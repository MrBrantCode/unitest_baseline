{
  "task_id": "taco_10799",
  "entry_point": "calculate_expected_value",
  "mutant_count": 219,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "ASR",
      "lineno": 31,
      "original_line": "r /= f(M + 1, M, N)",
      "mutated_line": "r *= f(M + 1, M, N)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r *= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if n - k < k:",
      "mutated_line": "if n - k <= k:",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k <= k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if n - k < k:",
      "mutated_line": "if n - k >= k:",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k >= k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if n - k < k:",
      "mutated_line": "if n - k != k:",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k != k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if k < 0:",
      "mutated_line": "if k <= 0:",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k <= 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if k < 0:",
      "mutated_line": "if k >= 0:",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k >= 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if k < 0:",
      "mutated_line": "if k != 0:",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k != 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)",
      "mutated_line": "return reduce(mul, range(n - k + 1, n + 1), 1) / reduce(mul, range(1, k + 1), 1)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) / reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)",
      "mutated_line": "return reduce(mul, range(n - k + 1, n + 1), 1) * reduce(mul, range(1, k + 1), 1)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) * reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if x == 0:",
      "mutated_line": "if x != 0:",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x != 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "ASR",
      "lineno": 40,
      "original_line": "q *= Decimal(-(N - k)) / Decimal(k + 1)",
      "mutated_line": "q /= Decimal(-(N - k)) / Decimal(k + 1)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q /= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "ASR",
      "lineno": 43,
      "original_line": "s += q",
      "mutated_line": "s -= q",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s -= q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "bot = 0",
      "mutated_line": "bot = 1",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 1\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "bot = 0",
      "mutated_line": "bot = -1",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = -1\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "bot = 0",
      "mutated_line": "bot = 1",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 1\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "r = 0",
      "mutated_line": "r = 1",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 1\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "r = 0",
      "mutated_line": "r = -1",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = -1\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "r = 0",
      "mutated_line": "r = 1",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 1\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "ASR",
      "lineno": 51,
      "original_line": "r += x * (top - bot)",
      "mutated_line": "r -= x * (top - bot)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r -= x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if n - k < k:",
      "mutated_line": "if n + k < k:",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n + k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if n - k < k:",
      "mutated_line": "if n * k < k:",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n * k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "k = n - k",
      "mutated_line": "k = n + k",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n + k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "k = n - k",
      "mutated_line": "k = n * k",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n * k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if k < 0:",
      "mutated_line": "if k < 1:",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 1:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if k < 0:",
      "mutated_line": "if k < -1:",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < -1:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if k < 0:",
      "mutated_line": "if k < 1:",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 1:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 1\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return -1\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 1\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "@lru_cache(maxsize=10 ** 5)",
      "mutated_line": "@lru_cache(maxsize=10 * 5)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 * 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "@lru_cache(maxsize=10 ** 5)",
      "mutated_line": "@lru_cache(maxsize=10 + 5)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 + 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "@lru_cache(maxsize=10 ** 5)",
      "mutated_line": "@lru_cache(maxsize=10 * 5)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 * 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "@lru_cache(maxsize=10 ** 5)",
      "mutated_line": "@lru_cache(maxsize=10 + 5)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 + 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "r /= f(M + 1, M, N)",
      "mutated_line": "r /= f(M - 1, M, N)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M - 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "r /= f(M + 1, M, N)",
      "mutated_line": "r /= f(M * 1, M, N)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M * 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if x == 0:",
      "mutated_line": "if x == 1:",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 1:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if x == 0:",
      "mutated_line": "if x == -1:",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == -1:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if x == 0:",
      "mutated_line": "if x == 1:",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 1:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 1\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return -1\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 1\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "s = Decimal(1)",
      "mutated_line": "s = Decimal(2)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(2)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "s = Decimal(1)",
      "mutated_line": "s = Decimal(0)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(0)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "s = Decimal(1)",
      "mutated_line": "s = Decimal(0)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(0)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "s = Decimal(1)",
      "mutated_line": "s = Decimal(-1)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(-1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "q = Decimal(1)",
      "mutated_line": "q = Decimal(2)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(2)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "q = Decimal(1)",
      "mutated_line": "q = Decimal(0)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(0)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "q = Decimal(1)",
      "mutated_line": "q = Decimal(0)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(0)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "q = Decimal(1)",
      "mutated_line": "q = Decimal(-1)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(-1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "q *= Decimal(-(N - k)) / Decimal(k + 1)",
      "mutated_line": "q *= Decimal(-(N - k)) * Decimal(k + 1)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) * Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "q *= Decimal(-(N - k)) / Decimal(k + 1)",
      "mutated_line": "q *= Decimal(-(N - k)) // Decimal(k + 1)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) // Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "ASR",
      "lineno": 42,
      "original_line": "q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)",
      "mutated_line": "q /= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q /= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "for x in range(1, M + 1):",
      "mutated_line": "for x in range(2, M + 1):",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(2, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "for x in range(1, M + 1):",
      "mutated_line": "for x in range(0, M + 1):",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(0, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "for x in range(1, M + 1):",
      "mutated_line": "for x in range(0, M + 1):",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(0, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "for x in range(1, M + 1):",
      "mutated_line": "for x in range(-1, M + 1):",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(-1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "for x in range(1, M + 1):",
      "mutated_line": "for x in range(1, M - 1):",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M - 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "for x in range(1, M + 1):",
      "mutated_line": "for x in range(1, M * 1):",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M * 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "r += x * (top - bot)",
      "mutated_line": "r += x / (top - bot)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x / (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "r += x * (top - bot)",
      "mutated_line": "r += x + (top - bot)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x + (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "r += x * (top - bot)",
      "mutated_line": "r += x ** (top - bot)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x ** (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)",
      "mutated_line": "return reduce(mul, range(n - k + 1, n + 1), 2) // reduce(mul, range(1, k + 1), 1)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 2) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)",
      "mutated_line": "return reduce(mul, range(n - k + 1, n + 1), 0) // reduce(mul, range(1, k + 1), 1)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 0) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)",
      "mutated_line": "return reduce(mul, range(n - k + 1, n + 1), 0) // reduce(mul, range(1, k + 1), 1)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 0) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)",
      "mutated_line": "return reduce(mul, range(n - k + 1, n + 1), -1) // reduce(mul, range(1, k + 1), 1)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), -1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)",
      "mutated_line": "return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 2)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 2)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)",
      "mutated_line": "return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 0)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 0)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)",
      "mutated_line": "return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 0)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 0)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)",
      "mutated_line": "return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), -1)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), -1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "@lru_cache(maxsize=10 ** 5)",
      "mutated_line": "@lru_cache(maxsize=11 ** 5)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=11 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "@lru_cache(maxsize=10 ** 5)",
      "mutated_line": "@lru_cache(maxsize=9 ** 5)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=9 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "@lru_cache(maxsize=10 ** 5)",
      "mutated_line": "@lru_cache(maxsize=0 ** 5)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=0 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "@lru_cache(maxsize=10 ** 5)",
      "mutated_line": "@lru_cache(maxsize=1 ** 5)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=1 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "@lru_cache(maxsize=10 ** 5)",
      "mutated_line": "@lru_cache(maxsize=-10 ** 5)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=-10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "@lru_cache(maxsize=10 ** 5)",
      "mutated_line": "@lru_cache(maxsize=10 ** 6)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 6)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "@lru_cache(maxsize=10 ** 5)",
      "mutated_line": "@lru_cache(maxsize=10 ** 4)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 4)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "@lru_cache(maxsize=10 ** 5)",
      "mutated_line": "@lru_cache(maxsize=10 ** 0)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 0)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "@lru_cache(maxsize=10 ** 5)",
      "mutated_line": "@lru_cache(maxsize=10 ** 1)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 1)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "@lru_cache(maxsize=10 ** 5)",
      "mutated_line": "@lru_cache(maxsize=10 ** -5)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** -5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))",
      "mutated_line": "return sum((binom(N, k) * (-1) ** k / binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k / binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))",
      "mutated_line": "return sum((binom(N, k) * (-1) ** k + binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k + binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))",
      "mutated_line": "return sum(((binom(N, k) * (-1) ** k) ** binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum(((binom(N, k) * (-1) ** k) ** binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "@lru_cache(maxsize=10 ** 5)",
      "mutated_line": "@lru_cache(maxsize=11 ** 5)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=11 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "@lru_cache(maxsize=10 ** 5)",
      "mutated_line": "@lru_cache(maxsize=9 ** 5)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=9 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "@lru_cache(maxsize=10 ** 5)",
      "mutated_line": "@lru_cache(maxsize=0 ** 5)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=0 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "@lru_cache(maxsize=10 ** 5)",
      "mutated_line": "@lru_cache(maxsize=1 ** 5)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=1 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "@lru_cache(maxsize=10 ** 5)",
      "mutated_line": "@lru_cache(maxsize=-10 ** 5)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=-10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "@lru_cache(maxsize=10 ** 5)",
      "mutated_line": "@lru_cache(maxsize=10 ** 6)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 6)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "@lru_cache(maxsize=10 ** 5)",
      "mutated_line": "@lru_cache(maxsize=10 ** 4)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 4)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "@lru_cache(maxsize=10 ** 5)",
      "mutated_line": "@lru_cache(maxsize=10 ** 0)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 0)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "@lru_cache(maxsize=10 ** 5)",
      "mutated_line": "@lru_cache(maxsize=10 ** 1)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 1)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "@lru_cache(maxsize=10 ** 5)",
      "mutated_line": "@lru_cache(maxsize=10 ** -5)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** -5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))",
      "mutated_line": "r = sum((x / (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x / (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))",
      "mutated_line": "r = sum((x + (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x + (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))",
      "mutated_line": "r = sum((x ** (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x ** (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "r /= f(M + 1, M, N)",
      "mutated_line": "r /= f(M + 2, M, N)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 2, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "r /= f(M + 1, M, N)",
      "mutated_line": "r /= f(M + 0, M, N)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 0, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "r /= f(M + 1, M, N)",
      "mutated_line": "r /= f(M + 0, M, N)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 0, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "r /= f(M + 1, M, N)",
      "mutated_line": "r /= f(M + -1, M, N)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + -1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "for k in range(min(M // x, N)):",
      "mutated_line": "for k in range(min(M / x, N)):",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M / x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "for k in range(min(M // x, N)):",
      "mutated_line": "for k in range(min(M * x, N)):",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M * x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)",
      "mutated_line": "q *= Decimal(M - k * x - j) * Decimal(N + M - k * x - 1 - j)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) * Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)",
      "mutated_line": "q *= Decimal(M - k * x - j) // Decimal(N + M - k * x - 1 - j)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) // Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "for x in range(1, M + 1):",
      "mutated_line": "for x in range(1, M + 2):",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 2):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "for x in range(1, M + 1):",
      "mutated_line": "for x in range(1, M + 0):",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 0):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "for x in range(1, M + 1):",
      "mutated_line": "for x in range(1, M + 0):",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 0):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "for x in range(1, M + 1):",
      "mutated_line": "for x in range(1, M + -1):",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + -1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "top = f2(x + 1, M, N)",
      "mutated_line": "top = f2(x - 1, M, N)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x - 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "top = f2(x + 1, M, N)",
      "mutated_line": "top = f2(x * 1, M, N)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x * 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "r += x * (top - bot)",
      "mutated_line": "r += x * (top + bot)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top + bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "r += x * (top - bot)",
      "mutated_line": "r += x * (top * bot)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top * bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)",
      "mutated_line": "return reduce(mul, range(n - k - 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k - 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)",
      "mutated_line": "return reduce(mul, range((n - k) * 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range((n - k) * 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)",
      "mutated_line": "return reduce(mul, range(n - k + 1, n - 1), 1) // reduce(mul, range(1, k + 1), 1)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n - 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)",
      "mutated_line": "return reduce(mul, range(n - k + 1, n * 1), 1) // reduce(mul, range(1, k + 1), 1)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n * 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)",
      "mutated_line": "return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(2, k + 1), 1)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(2, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)",
      "mutated_line": "return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(0, k + 1), 1)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(0, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)",
      "mutated_line": "return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(0, k + 1), 1)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(0, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)",
      "mutated_line": "return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(-1, k + 1), 1)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(-1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)",
      "mutated_line": "return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k - 1), 1)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k - 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)",
      "mutated_line": "return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k * 1), 1)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k * 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))",
      "mutated_line": "return sum((binom(N, k) / (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) / (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))",
      "mutated_line": "return sum(((binom(N, k) + (-1) ** k) * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum(((binom(N, k) + (-1) ** k) * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))",
      "mutated_line": "return sum((binom(N, k) ** (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) ** (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))",
      "mutated_line": "r = sum((x * (f(x + 1, M, N) + f(x, M, N)) for x in range(M + 1)))",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) + f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))",
      "mutated_line": "r = sum((x * (f(x + 1, M, N) * f(x, M, N)) for x in range(M + 1)))",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) * f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "UOI",
      "lineno": 40,
      "original_line": "q *= Decimal(-(N - k)) / Decimal(k + 1)",
      "mutated_line": "q *= Decimal(+(N - k)) / Decimal(k + 1)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(+(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "q *= Decimal(-(N - k)) / Decimal(k + 1)",
      "mutated_line": "q *= Decimal(-(N - k)) / Decimal(k - 1)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k - 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "q *= Decimal(-(N - k)) / Decimal(k + 1)",
      "mutated_line": "q *= Decimal(-(N - k)) / Decimal(k * 1)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k * 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "top = f2(x + 1, M, N)",
      "mutated_line": "top = f2(x + 2, M, N)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 2, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "top = f2(x + 1, M, N)",
      "mutated_line": "top = f2(x + 0, M, N)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 0, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "top = f2(x + 1, M, N)",
      "mutated_line": "top = f2(x + 0, M, N)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 0, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "top = f2(x + 1, M, N)",
      "mutated_line": "top = f2(x + -1, M, N)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + -1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)",
      "mutated_line": "return reduce(mul, range(n + k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n + k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)",
      "mutated_line": "return reduce(mul, range(n * k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n * k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)",
      "mutated_line": "return reduce(mul, range(n - k + 2, n + 1), 1) // reduce(mul, range(1, k + 1), 1)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 2, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)",
      "mutated_line": "return reduce(mul, range(n - k + 0, n + 1), 1) // reduce(mul, range(1, k + 1), 1)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 0, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)",
      "mutated_line": "return reduce(mul, range(n - k + 0, n + 1), 1) // reduce(mul, range(1, k + 1), 1)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 0, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)",
      "mutated_line": "return reduce(mul, range(n - k + -1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + -1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)",
      "mutated_line": "return reduce(mul, range(n - k + 1, n + 2), 1) // reduce(mul, range(1, k + 1), 1)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 2), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)",
      "mutated_line": "return reduce(mul, range(n - k + 1, n + 0), 1) // reduce(mul, range(1, k + 1), 1)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 0), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)",
      "mutated_line": "return reduce(mul, range(n - k + 1, n + 0), 1) // reduce(mul, range(1, k + 1), 1)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 0), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)",
      "mutated_line": "return reduce(mul, range(n - k + 1, n + -1), 1) // reduce(mul, range(1, k + 1), 1)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + -1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)",
      "mutated_line": "return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 2), 1)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 2), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)",
      "mutated_line": "return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 0), 1)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 0), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)",
      "mutated_line": "return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 0), 1)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 0), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)",
      "mutated_line": "return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + -1), 1)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + -1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))",
      "mutated_line": "return sum((binom(N, k) * (-1 * k) * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1 * k) * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))",
      "mutated_line": "return sum((binom(N, k) * (-1 + k) * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1 + k) * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))",
      "mutated_line": "return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x + 1, M - k * x) for k in range(M + 1)))",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x + 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))",
      "mutated_line": "return sum((binom(N, k) * (-1) ** k * binom((N + M - k * x) * 1, M - k * x) for k in range(M + 1)))",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom((N + M - k * x) * 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))",
      "mutated_line": "return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M + k * x) for k in range(M + 1)))",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M + k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))",
      "mutated_line": "return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M * (k * x)) for k in range(M + 1)))",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M * (k * x)) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))",
      "mutated_line": "return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M - 1)))",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M - 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))",
      "mutated_line": "return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M * 1)))",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M * 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))",
      "mutated_line": "r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M - 1)))",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M - 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))",
      "mutated_line": "r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M * 1)))",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M * 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "q *= Decimal(-(N - k)) / Decimal(k + 1)",
      "mutated_line": "q *= Decimal(-(N + k)) / Decimal(k + 1)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N + k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "q *= Decimal(-(N - k)) / Decimal(k + 1)",
      "mutated_line": "q *= Decimal(-(N * k)) / Decimal(k + 1)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N * k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "q *= Decimal(-(N - k)) / Decimal(k + 1)",
      "mutated_line": "q *= Decimal(-(N - k)) / Decimal(k + 2)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 2)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "q *= Decimal(-(N - k)) / Decimal(k + 1)",
      "mutated_line": "q *= Decimal(-(N - k)) / Decimal(k + 0)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 0)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "q *= Decimal(-(N - k)) / Decimal(k + 1)",
      "mutated_line": "q *= Decimal(-(N - k)) / Decimal(k + 0)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 0)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "q *= Decimal(-(N - k)) / Decimal(k + 1)",
      "mutated_line": "q *= Decimal(-(N - k)) / Decimal(k + -1)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + -1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)",
      "mutated_line": "q *= Decimal(M - k * x + j) / Decimal(N + M - k * x - 1 - j)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x + j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)",
      "mutated_line": "q *= Decimal((M - k * x) * j) / Decimal(N + M - k * x - 1 - j)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal((M - k * x) * j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)",
      "mutated_line": "q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 + j)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 + j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)",
      "mutated_line": "q *= Decimal(M - k * x - j) / Decimal((N + M - k * x - 1) * j)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal((N + M - k * x - 1) * j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "UOI",
      "lineno": 27,
      "original_line": "return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))",
      "mutated_line": "return sum((binom(N, k) * (+1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (+1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))",
      "mutated_line": "return sum((binom(N, k) * (-1) ** k * binom(N + M + k * x - 1, M - k * x) for k in range(M + 1)))",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M + k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))",
      "mutated_line": "return sum((binom(N, k) * (-1) ** k * binom((N + M) * (k * x) - 1, M - k * x) for k in range(M + 1)))",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom((N + M) * (k * x) - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))",
      "mutated_line": "return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 2, M - k * x) for k in range(M + 1)))",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 2, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))",
      "mutated_line": "return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 0, M - k * x) for k in range(M + 1)))",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 0, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))",
      "mutated_line": "return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 0, M - k * x) for k in range(M + 1)))",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 0, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))",
      "mutated_line": "return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - -1, M - k * x) for k in range(M + 1)))",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - -1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))",
      "mutated_line": "return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k / x) for k in range(M + 1)))",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k / x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))",
      "mutated_line": "return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - (k + x)) for k in range(M + 1)))",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - (k + x)) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))",
      "mutated_line": "return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k ** x) for k in range(M + 1)))",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k ** x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))",
      "mutated_line": "return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 2)))",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 2)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))",
      "mutated_line": "return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 0)))",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 0)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))",
      "mutated_line": "return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 0)))",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 0)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))",
      "mutated_line": "return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + -1)))",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + -1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))",
      "mutated_line": "r = sum((x * (f(x - 1, M, N) - f(x, M, N)) for x in range(M + 1)))",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x - 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))",
      "mutated_line": "r = sum((x * (f(x * 1, M, N) - f(x, M, N)) for x in range(M + 1)))",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x * 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))",
      "mutated_line": "r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 2)))",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 2)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))",
      "mutated_line": "r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 0)))",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 0)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))",
      "mutated_line": "r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 0)))",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 0)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))",
      "mutated_line": "r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + -1)))",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + -1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)",
      "mutated_line": "q *= Decimal(M + k * x - j) / Decimal(N + M - k * x - 1 - j)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M + k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)",
      "mutated_line": "q *= Decimal(M * (k * x) - j) / Decimal(N + M - k * x - 1 - j)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M * (k * x) - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)",
      "mutated_line": "q *= Decimal(M - k * x - j) / Decimal(N + M - k * x + 1 - j)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x + 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)",
      "mutated_line": "q *= Decimal(M - k * x - j) / Decimal((N + M - k * x) * 1 - j)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal((N + M - k * x) * 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))",
      "mutated_line": "return sum((binom(N, k) * (-2) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-2) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))",
      "mutated_line": "return sum((binom(N, k) * (-0) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-0) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))",
      "mutated_line": "return sum((binom(N, k) * (-0) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-0) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))",
      "mutated_line": "return sum((binom(N, k) * (--1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (--1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))",
      "mutated_line": "return sum((binom(N, k) * (-1) ** k * binom(N - M - k * x - 1, M - k * x) for k in range(M + 1)))",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N - M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))",
      "mutated_line": "return sum((binom(N, k) * (-1) ** k * binom(N * M - k * x - 1, M - k * x) for k in range(M + 1)))",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N * M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))",
      "mutated_line": "return sum((binom(N, k) * (-1) ** k * binom(N + M - k / x - 1, M - k * x) for k in range(M + 1)))",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k / x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))",
      "mutated_line": "return sum((binom(N, k) * (-1) ** k * binom(N + M - (k + x) - 1, M - k * x) for k in range(M + 1)))",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - (k + x) - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))",
      "mutated_line": "return sum((binom(N, k) * (-1) ** k * binom(N + M - k ** x - 1, M - k * x) for k in range(M + 1)))",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k ** x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))",
      "mutated_line": "r = sum((x * (f(x + 2, M, N) - f(x, M, N)) for x in range(M + 1)))",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 2, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))",
      "mutated_line": "r = sum((x * (f(x + 0, M, N) - f(x, M, N)) for x in range(M + 1)))",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 0, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))",
      "mutated_line": "r = sum((x * (f(x + 0, M, N) - f(x, M, N)) for x in range(M + 1)))",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 0, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))",
      "mutated_line": "r = sum((x * (f(x + -1, M, N) - f(x, M, N)) for x in range(M + 1)))",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + -1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)",
      "mutated_line": "q *= Decimal(M - k / x - j) / Decimal(N + M - k * x - 1 - j)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k / x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)",
      "mutated_line": "q *= Decimal(M - (k + x) - j) / Decimal(N + M - k * x - 1 - j)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - (k + x) - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)",
      "mutated_line": "q *= Decimal(M - k ** x - j) / Decimal(N + M - k * x - 1 - j)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k ** x - j) / Decimal(N + M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)",
      "mutated_line": "q *= Decimal(M - k * x - j) / Decimal(N + M + k * x - 1 - j)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M + k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)",
      "mutated_line": "q *= Decimal(M - k * x - j) / Decimal((N + M) * (k * x) - 1 - j)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal((N + M) * (k * x) - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)",
      "mutated_line": "q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 2 - j)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 2 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)",
      "mutated_line": "q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 0 - j)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 0 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)",
      "mutated_line": "q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 0 - j)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 0 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)",
      "mutated_line": "q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - -1 - j)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - -1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)",
      "mutated_line": "q *= Decimal(M - k * x - j) / Decimal(N - M - k * x - 1 - j)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N - M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)",
      "mutated_line": "q *= Decimal(M - k * x - j) / Decimal(N * M - k * x - 1 - j)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N * M - k * x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)",
      "mutated_line": "q *= Decimal(M - k * x - j) / Decimal(N + M - k / x - 1 - j)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k / x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)",
      "mutated_line": "q *= Decimal(M - k * x - j) / Decimal(N + M - (k + x) - 1 - j)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - (k + x) - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "q *= Decimal(M - k * x - j) / Decimal(N + M - k * x - 1 - j)",
      "mutated_line": "q *= Decimal(M - k * x - j) / Decimal(N + M - k ** x - 1 - j)",
      "code": "def calculate_expected_value(M: int, N: int) -> float:\n    \"\"\"\n    Calculate the expected value of x for a given M and N.\n\n    Parameters:\n    M (int): The length of the non-decreasing sequence.\n    N (int): The maximum value in the sequence (values range from 1 to N).\n\n    Returns:\n    float: The expected value of x, with an error tolerance of up to 10^-3.\n    \"\"\"\n    from decimal import Decimal\n    from functools import lru_cache\n    from operator import mul\n    from functools import reduce\n\n    @lru_cache(maxsize=10 ** 5)\n    def binom(n, k):\n        if n - k < k:\n            k = n - k\n        if k < 0:\n            return 0\n        return reduce(mul, range(n - k + 1, n + 1), 1) // reduce(mul, range(1, k + 1), 1)\n\n    @lru_cache(maxsize=10 ** 5)\n    def f(x, M, N):\n        return sum((binom(N, k) * (-1) ** k * binom(N + M - k * x - 1, M - k * x) for k in range(M + 1)))\n\n    def solve(M, N):\n        r = sum((x * (f(x + 1, M, N) - f(x, M, N)) for x in range(M + 1)))\n        r /= f(M + 1, M, N)\n        return r\n\n    def f2(x, M, N):\n        if x == 0:\n            return 0\n        s = Decimal(1)\n        q = Decimal(1)\n        for k in range(min(M // x, N)):\n            q *= Decimal(-(N - k)) / Decimal(k + 1)\n            for j in range(x):\n                q *= Decimal(M - k * x - j) / Decimal(N + M - k ** x - 1 - j)\n            s += q\n        return float(s)\n\n    def solve2(M, N):\n        bot = 0\n        r = 0\n        for x in range(1, M + 1):\n            top = f2(x + 1, M, N)\n            r += x * (top - bot)\n            bot = top\n        return r\n    return solve2(M, N)"
    }
  ]
}