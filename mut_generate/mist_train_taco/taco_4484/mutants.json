{
  "task_id": "taco_4484",
  "entry_point": "comb",
  "mutant_count": 121,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOD_NUM = 998244353",
      "mutated_line": "MOD_NUM = 998244354",
      "code": "import functools\nMOD_NUM = 998244354\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOD_NUM = 998244353",
      "mutated_line": "MOD_NUM = 998244352",
      "code": "import functools\nMOD_NUM = 998244352\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOD_NUM = 998244353",
      "mutated_line": "MOD_NUM = 0",
      "code": "import functools\nMOD_NUM = 0\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOD_NUM = 998244353",
      "mutated_line": "MOD_NUM = 1",
      "code": "import functools\nMOD_NUM = 1\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOD_NUM = 998244353",
      "mutated_line": "MOD_NUM = -998244353",
      "code": "import functools\nMOD_NUM = -998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "COMB = [[0] * 510 for _ in range(510)]",
      "mutated_line": "COMB = [[0] / 510 for _ in range(510)]",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] / 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "COMB = [[0] * 510 for _ in range(510)]",
      "mutated_line": "COMB = [[0] + 510 for _ in range(510)]",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] + 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "COMB = [[0] * 510 for _ in range(510)]",
      "mutated_line": "COMB = [[0] ** 510 for _ in range(510)]",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] ** 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for n in range(510):",
      "mutated_line": "for n in range(511):",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(511):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for n in range(510):",
      "mutated_line": "for n in range(509):",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(509):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for n in range(510):",
      "mutated_line": "for n in range(0):",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(0):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for n in range(510):",
      "mutated_line": "for n in range(1):",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(1):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for n in range(510):",
      "mutated_line": "for n in range(-510):",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(-510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if x <= n - 1:",
      "mutated_line": "if x < n - 1:",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x < n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if x <= n - 1:",
      "mutated_line": "if x > n - 1:",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x > n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if x <= n - 1:",
      "mutated_line": "if x == n - 1:",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x == n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "ASR",
      "lineno": 27,
      "original_line": "ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)",
      "mutated_line": "ans -= comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans -= comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "COMB = [[0] * 510 for _ in range(510)]",
      "mutated_line": "COMB = [[0] * 511 for _ in range(510)]",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 511 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "COMB = [[0] * 510 for _ in range(510)]",
      "mutated_line": "COMB = [[0] * 509 for _ in range(510)]",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 509 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "COMB = [[0] * 510 for _ in range(510)]",
      "mutated_line": "COMB = [[0] * 0 for _ in range(510)]",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 0 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "COMB = [[0] * 510 for _ in range(510)]",
      "mutated_line": "COMB = [[0] * 1 for _ in range(510)]",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 1 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "COMB = [[0] * 510 for _ in range(510)]",
      "mutated_line": "COMB = [[0] * -510 for _ in range(510)]",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * -510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "for k in range(1 + n):",
      "mutated_line": "for k in range(1 - n):",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 - n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "for k in range(1 + n):",
      "mutated_line": "for k in range(1 * n):",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 * n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "LCR",
      "lineno": 9,
      "original_line": "if n == k or k == 0:",
      "mutated_line": "if n == k and k == 0:",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k and k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]",
      "mutated_line": "COMB[n][k] = COMB[n - 1][k] - COMB[n - 1][k - 1]",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] - COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]",
      "mutated_line": "COMB[n][k] = COMB[n - 1][k] * COMB[n - 1][k - 1]",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] * COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if x <= n - 1:",
      "mutated_line": "if x <= n + 1:",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n + 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if x <= n - 1:",
      "mutated_line": "if x <= n * 1:",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n * 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if n > 1:",
      "mutated_line": "if n >= 1:",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n >= 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if n > 1:",
      "mutated_line": "if n <= 1:",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n <= 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if n > 1:",
      "mutated_line": "if n != 1:",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n != 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "ans = pow(n - 1, n, MOD_NUM)",
      "mutated_line": "ans = pow(n + 1, n, MOD_NUM)",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n + 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "ans = pow(n - 1, n, MOD_NUM)",
      "mutated_line": "ans = pow(n * 1, n, MOD_NUM)",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n * 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for k in range(2, n + 1):",
      "mutated_line": "for k in range(3, n + 1):",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(3, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for k in range(2, n + 1):",
      "mutated_line": "for k in range(1, n + 1):",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(1, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for k in range(2, n + 1):",
      "mutated_line": "for k in range(0, n + 1):",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(0, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for k in range(2, n + 1):",
      "mutated_line": "for k in range(1, n + 1):",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(1, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for k in range(2, n + 1):",
      "mutated_line": "for k in range(-2, n + 1):",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(-2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "for k in range(2, n + 1):",
      "mutated_line": "for k in range(2, n - 1):",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n - 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "for k in range(2, n + 1):",
      "mutated_line": "for k in range(2, n * 1):",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n * 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)",
      "mutated_line": "ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) / dp(k, x - n + 1)",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) / dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)",
      "mutated_line": "ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) + dp(k, x - n + 1)",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) + dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)",
      "mutated_line": "ans += (comb(n, k) * pow(n - 1, n - k, MOD_NUM)) ** dp(k, x - n + 1)",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += (comb(n, k) * pow(n - 1, n - k, MOD_NUM)) ** dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "COMB = [[0] * 510 for _ in range(510)]",
      "mutated_line": "COMB = [[1] * 510 for _ in range(510)]",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[1] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "COMB = [[0] * 510 for _ in range(510)]",
      "mutated_line": "COMB = [[-1] * 510 for _ in range(510)]",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[-1] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "COMB = [[0] * 510 for _ in range(510)]",
      "mutated_line": "COMB = [[1] * 510 for _ in range(510)]",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[1] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "COMB = [[0] * 510 for _ in range(510)]",
      "mutated_line": "COMB = [[0] * 510 for _ in range(511)]",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(511)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "COMB = [[0] * 510 for _ in range(510)]",
      "mutated_line": "COMB = [[0] * 510 for _ in range(509)]",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(509)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "COMB = [[0] * 510 for _ in range(510)]",
      "mutated_line": "COMB = [[0] * 510 for _ in range(0)]",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(0)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "COMB = [[0] * 510 for _ in range(510)]",
      "mutated_line": "COMB = [[0] * 510 for _ in range(1)]",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(1)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "COMB = [[0] * 510 for _ in range(510)]",
      "mutated_line": "COMB = [[0] * 510 for _ in range(-510)]",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(-510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for k in range(1 + n):",
      "mutated_line": "for k in range(2 + n):",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(2 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for k in range(1 + n):",
      "mutated_line": "for k in range(0 + n):",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(0 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for k in range(1 + n):",
      "mutated_line": "for k in range(0 + n):",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(0 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for k in range(1 + n):",
      "mutated_line": "for k in range(-1 + n):",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(-1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if n == k or k == 0:",
      "mutated_line": "if n != k or k == 0:",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n != k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if n == k or k == 0:",
      "mutated_line": "if n == k or k != 0:",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k != 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "COMB[n][k] = 1",
      "mutated_line": "COMB[n][k] = 2",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 2\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "COMB[n][k] = 1",
      "mutated_line": "COMB[n][k] = 0",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 0\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "COMB[n][k] = 1",
      "mutated_line": "COMB[n][k] = 0",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 0\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "COMB[n][k] = 1",
      "mutated_line": "COMB[n][k] = -1",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = -1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if x <= n - 1:",
      "mutated_line": "if x <= n - 2:",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 2:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if x <= n - 1:",
      "mutated_line": "if x <= n - 0:",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 0:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if x <= n - 1:",
      "mutated_line": "if x <= n - 0:",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 0:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if x <= n - 1:",
      "mutated_line": "if x <= n - -1:",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - -1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if n > 1:",
      "mutated_line": "if n > 2:",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 2:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if n > 1:",
      "mutated_line": "if n > 0:",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 0:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if n > 1:",
      "mutated_line": "if n > 0:",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 0:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if n > 1:",
      "mutated_line": "if n > -1:",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > -1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 1\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return -1\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 1\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ans = pow(n - 1, n, MOD_NUM)",
      "mutated_line": "ans = pow(n - 2, n, MOD_NUM)",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 2, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ans = pow(n - 1, n, MOD_NUM)",
      "mutated_line": "ans = pow(n - 0, n, MOD_NUM)",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 0, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ans = pow(n - 1, n, MOD_NUM)",
      "mutated_line": "ans = pow(n - 0, n, MOD_NUM)",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 0, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ans = pow(n - 1, n, MOD_NUM)",
      "mutated_line": "ans = pow(n - -1, n, MOD_NUM)",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - -1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for k in range(2, n + 1):",
      "mutated_line": "for k in range(2, n + 2):",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 2):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for k in range(2, n + 1):",
      "mutated_line": "for k in range(2, n + 0):",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 0):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for k in range(2, n + 1):",
      "mutated_line": "for k in range(2, n + 0):",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 0):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for k in range(2, n + 1):",
      "mutated_line": "for k in range(2, n + -1):",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + -1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)",
      "mutated_line": "ans += comb(n, k) / pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) / pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)",
      "mutated_line": "ans += (comb(n, k) + pow(n - 1, n - k, MOD_NUM)) * dp(k, x - n + 1)",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += (comb(n, k) + pow(n - 1, n - k, MOD_NUM)) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)",
      "mutated_line": "ans += comb(n, k) ** pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) ** pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if n == k or k == 0:",
      "mutated_line": "if n == k or k == 1:",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 1:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if n == k or k == 0:",
      "mutated_line": "if n == k or k == -1:",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == -1:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if n == k or k == 0:",
      "mutated_line": "if n == k or k == 1:",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 1:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]",
      "mutated_line": "COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k + 1]",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k + 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]",
      "mutated_line": "COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k * 1]",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k * 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)",
      "mutated_line": "ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n - 1)",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n - 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)",
      "mutated_line": "ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, (x - n) * 1)",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, (x - n) * 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]",
      "mutated_line": "COMB[n][k] = COMB[n + 1][k] + COMB[n - 1][k - 1]",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n + 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]",
      "mutated_line": "COMB[n][k] = COMB[n * 1][k] + COMB[n - 1][k - 1]",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n * 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]",
      "mutated_line": "COMB[n][k] = COMB[n - 1][k] + COMB[n + 1][k - 1]",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n + 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]",
      "mutated_line": "COMB[n][k] = COMB[n - 1][k] + COMB[n * 1][k - 1]",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n * 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]",
      "mutated_line": "COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 2]",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 2]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]",
      "mutated_line": "COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 0]",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 0]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]",
      "mutated_line": "COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 0]",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 0]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]",
      "mutated_line": "COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - -1]",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - -1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)",
      "mutated_line": "ans += comb(n, k) * pow(n + 1, n - k, MOD_NUM) * dp(k, x - n + 1)",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n + 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)",
      "mutated_line": "ans += comb(n, k) * pow(n * 1, n - k, MOD_NUM) * dp(k, x - n + 1)",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n * 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)",
      "mutated_line": "ans += comb(n, k) * pow(n - 1, n + k, MOD_NUM) * dp(k, x - n + 1)",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n + k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)",
      "mutated_line": "ans += comb(n, k) * pow(n - 1, n * k, MOD_NUM) * dp(k, x - n + 1)",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n * k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)",
      "mutated_line": "ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x + n + 1)",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x + n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)",
      "mutated_line": "ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x * n + 1)",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x * n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)",
      "mutated_line": "ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 2)",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 2)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)",
      "mutated_line": "ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 0)",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 0)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)",
      "mutated_line": "ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 0)",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 0)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)",
      "mutated_line": "ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + -1)",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + -1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]",
      "mutated_line": "COMB[n][k] = COMB[n - 2][k] + COMB[n - 1][k - 1]",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 2][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]",
      "mutated_line": "COMB[n][k] = COMB[n - 0][k] + COMB[n - 1][k - 1]",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 0][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]",
      "mutated_line": "COMB[n][k] = COMB[n - 0][k] + COMB[n - 1][k - 1]",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 0][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]",
      "mutated_line": "COMB[n][k] = COMB[n - -1][k] + COMB[n - 1][k - 1]",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - -1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]",
      "mutated_line": "COMB[n][k] = COMB[n - 1][k] + COMB[n - 2][k - 1]",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 2][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]",
      "mutated_line": "COMB[n][k] = COMB[n - 1][k] + COMB[n - 0][k - 1]",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 0][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]",
      "mutated_line": "COMB[n][k] = COMB[n - 1][k] + COMB[n - 0][k - 1]",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 0][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]",
      "mutated_line": "COMB[n][k] = COMB[n - 1][k] + COMB[n - -1][k - 1]",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - -1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)",
      "mutated_line": "ans += comb(n, k) * pow(n - 2, n - k, MOD_NUM) * dp(k, x - n + 1)",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 2, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)",
      "mutated_line": "ans += comb(n, k) * pow(n - 0, n - k, MOD_NUM) * dp(k, x - n + 1)",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 0, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)",
      "mutated_line": "ans += comb(n, k) * pow(n - 0, n - k, MOD_NUM) * dp(k, x - n + 1)",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - 0, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "ans += comb(n, k) * pow(n - 1, n - k, MOD_NUM) * dp(k, x - n + 1)",
      "mutated_line": "ans += comb(n, k) * pow(n - -1, n - k, MOD_NUM) * dp(k, x - n + 1)",
      "code": "import functools\nMOD_NUM = 998244353\nCOMB = [[0] * 510 for _ in range(510)]\nfor n in range(510):\n    for k in range(1 + n):\n        if n == k or k == 0:\n            COMB[n][k] = 1\n            continue\n        COMB[n][k] = COMB[n - 1][k] + COMB[n - 1][k - 1]\n        COMB[n][k] %= MOD_NUM\n\ndef comb(n, k):\n    return COMB[n][k]\n\n@functools.lru_cache(None)\ndef dp(n, x):\n    if x <= n - 1:\n        if n > 1:\n            return pow(x, n, MOD_NUM)\n        else:\n            return 0\n    ans = pow(n - 1, n, MOD_NUM)\n    for k in range(2, n + 1):\n        ans += comb(n, k) * pow(n - -1, n - k, MOD_NUM) * dp(k, x - n + 1)\n        ans %= MOD_NUM\n    return ans\n\ndef calculate_no_winner_ways(n, x):\n    return dp(n, x)"
    }
  ]
}