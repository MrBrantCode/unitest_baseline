{
  "task_id": "taco_8045",
  "entry_point": "find_minimum_balance_value",
  "mutant_count": 63,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "minimum = 10 ** 19 * 3",
      "mutated_line": "minimum = 10 ** 19 / 3",
      "code": "import bisect\n\ndef find_minimum_balance_value(reds, greens, blues):\n\n    def nearest_with_leader(leader_list, other_list1, other_list2):\n        minimum = 10 ** 19 / 3\n        for leader in leader_list:\n            idx1 = bisect.bisect_left(other_list1, leader)\n            idx2 = bisect.bisect_right(other_list2, leader)\n            if idx1 == len(other_list1) or idx2 == 0:\n                continue\n            val1 = other_list1[idx1]\n            val2 = other_list2[idx2 - 1]\n            minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** 2)\n        return minimum\n    reds.sort()\n    greens.sort()\n    blues.sort()\n    return min(nearest_with_leader(reds, greens, blues), nearest_with_leader(blues, greens, reds), nearest_with_leader(greens, blues, reds), nearest_with_leader(reds, blues, greens), nearest_with_leader(blues, reds, greens), nearest_with_leader(greens, reds, blues))"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "minimum = 10 ** 19 * 3",
      "mutated_line": "minimum = 10 ** 19 + 3",
      "code": "import bisect\n\ndef find_minimum_balance_value(reds, greens, blues):\n\n    def nearest_with_leader(leader_list, other_list1, other_list2):\n        minimum = 10 ** 19 + 3\n        for leader in leader_list:\n            idx1 = bisect.bisect_left(other_list1, leader)\n            idx2 = bisect.bisect_right(other_list2, leader)\n            if idx1 == len(other_list1) or idx2 == 0:\n                continue\n            val1 = other_list1[idx1]\n            val2 = other_list2[idx2 - 1]\n            minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** 2)\n        return minimum\n    reds.sort()\n    greens.sort()\n    blues.sort()\n    return min(nearest_with_leader(reds, greens, blues), nearest_with_leader(blues, greens, reds), nearest_with_leader(greens, blues, reds), nearest_with_leader(reds, blues, greens), nearest_with_leader(blues, reds, greens), nearest_with_leader(greens, reds, blues))"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "minimum = 10 ** 19 * 3",
      "mutated_line": "minimum = (10 ** 19) ** 3",
      "code": "import bisect\n\ndef find_minimum_balance_value(reds, greens, blues):\n\n    def nearest_with_leader(leader_list, other_list1, other_list2):\n        minimum = (10 ** 19) ** 3\n        for leader in leader_list:\n            idx1 = bisect.bisect_left(other_list1, leader)\n            idx2 = bisect.bisect_right(other_list2, leader)\n            if idx1 == len(other_list1) or idx2 == 0:\n                continue\n            val1 = other_list1[idx1]\n            val2 = other_list2[idx2 - 1]\n            minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** 2)\n        return minimum\n    reds.sort()\n    greens.sort()\n    blues.sort()\n    return min(nearest_with_leader(reds, greens, blues), nearest_with_leader(blues, greens, reds), nearest_with_leader(greens, blues, reds), nearest_with_leader(reds, blues, greens), nearest_with_leader(blues, reds, greens), nearest_with_leader(greens, reds, blues))"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "minimum = 10 ** 19 * 3",
      "mutated_line": "minimum = 10 * 19 * 3",
      "code": "import bisect\n\ndef find_minimum_balance_value(reds, greens, blues):\n\n    def nearest_with_leader(leader_list, other_list1, other_list2):\n        minimum = 10 * 19 * 3\n        for leader in leader_list:\n            idx1 = bisect.bisect_left(other_list1, leader)\n            idx2 = bisect.bisect_right(other_list2, leader)\n            if idx1 == len(other_list1) or idx2 == 0:\n                continue\n            val1 = other_list1[idx1]\n            val2 = other_list2[idx2 - 1]\n            minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** 2)\n        return minimum\n    reds.sort()\n    greens.sort()\n    blues.sort()\n    return min(nearest_with_leader(reds, greens, blues), nearest_with_leader(blues, greens, reds), nearest_with_leader(greens, blues, reds), nearest_with_leader(reds, blues, greens), nearest_with_leader(blues, reds, greens), nearest_with_leader(greens, reds, blues))"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "minimum = 10 ** 19 * 3",
      "mutated_line": "minimum = (10 + 19) * 3",
      "code": "import bisect\n\ndef find_minimum_balance_value(reds, greens, blues):\n\n    def nearest_with_leader(leader_list, other_list1, other_list2):\n        minimum = (10 + 19) * 3\n        for leader in leader_list:\n            idx1 = bisect.bisect_left(other_list1, leader)\n            idx2 = bisect.bisect_right(other_list2, leader)\n            if idx1 == len(other_list1) or idx2 == 0:\n                continue\n            val1 = other_list1[idx1]\n            val2 = other_list2[idx2 - 1]\n            minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** 2)\n        return minimum\n    reds.sort()\n    greens.sort()\n    blues.sort()\n    return min(nearest_with_leader(reds, greens, blues), nearest_with_leader(blues, greens, reds), nearest_with_leader(greens, blues, reds), nearest_with_leader(reds, blues, greens), nearest_with_leader(blues, reds, greens), nearest_with_leader(greens, reds, blues))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "minimum = 10 ** 19 * 3",
      "mutated_line": "minimum = 10 ** 19 * 4",
      "code": "import bisect\n\ndef find_minimum_balance_value(reds, greens, blues):\n\n    def nearest_with_leader(leader_list, other_list1, other_list2):\n        minimum = 10 ** 19 * 4\n        for leader in leader_list:\n            idx1 = bisect.bisect_left(other_list1, leader)\n            idx2 = bisect.bisect_right(other_list2, leader)\n            if idx1 == len(other_list1) or idx2 == 0:\n                continue\n            val1 = other_list1[idx1]\n            val2 = other_list2[idx2 - 1]\n            minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** 2)\n        return minimum\n    reds.sort()\n    greens.sort()\n    blues.sort()\n    return min(nearest_with_leader(reds, greens, blues), nearest_with_leader(blues, greens, reds), nearest_with_leader(greens, blues, reds), nearest_with_leader(reds, blues, greens), nearest_with_leader(blues, reds, greens), nearest_with_leader(greens, reds, blues))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "minimum = 10 ** 19 * 3",
      "mutated_line": "minimum = 10 ** 19 * 2",
      "code": "import bisect\n\ndef find_minimum_balance_value(reds, greens, blues):\n\n    def nearest_with_leader(leader_list, other_list1, other_list2):\n        minimum = 10 ** 19 * 2\n        for leader in leader_list:\n            idx1 = bisect.bisect_left(other_list1, leader)\n            idx2 = bisect.bisect_right(other_list2, leader)\n            if idx1 == len(other_list1) or idx2 == 0:\n                continue\n            val1 = other_list1[idx1]\n            val2 = other_list2[idx2 - 1]\n            minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** 2)\n        return minimum\n    reds.sort()\n    greens.sort()\n    blues.sort()\n    return min(nearest_with_leader(reds, greens, blues), nearest_with_leader(blues, greens, reds), nearest_with_leader(greens, blues, reds), nearest_with_leader(reds, blues, greens), nearest_with_leader(blues, reds, greens), nearest_with_leader(greens, reds, blues))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "minimum = 10 ** 19 * 3",
      "mutated_line": "minimum = 10 ** 19 * 0",
      "code": "import bisect\n\ndef find_minimum_balance_value(reds, greens, blues):\n\n    def nearest_with_leader(leader_list, other_list1, other_list2):\n        minimum = 10 ** 19 * 0\n        for leader in leader_list:\n            idx1 = bisect.bisect_left(other_list1, leader)\n            idx2 = bisect.bisect_right(other_list2, leader)\n            if idx1 == len(other_list1) or idx2 == 0:\n                continue\n            val1 = other_list1[idx1]\n            val2 = other_list2[idx2 - 1]\n            minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** 2)\n        return minimum\n    reds.sort()\n    greens.sort()\n    blues.sort()\n    return min(nearest_with_leader(reds, greens, blues), nearest_with_leader(blues, greens, reds), nearest_with_leader(greens, blues, reds), nearest_with_leader(reds, blues, greens), nearest_with_leader(blues, reds, greens), nearest_with_leader(greens, reds, blues))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "minimum = 10 ** 19 * 3",
      "mutated_line": "minimum = 10 ** 19 * 1",
      "code": "import bisect\n\ndef find_minimum_balance_value(reds, greens, blues):\n\n    def nearest_with_leader(leader_list, other_list1, other_list2):\n        minimum = 10 ** 19 * 1\n        for leader in leader_list:\n            idx1 = bisect.bisect_left(other_list1, leader)\n            idx2 = bisect.bisect_right(other_list2, leader)\n            if idx1 == len(other_list1) or idx2 == 0:\n                continue\n            val1 = other_list1[idx1]\n            val2 = other_list2[idx2 - 1]\n            minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** 2)\n        return minimum\n    reds.sort()\n    greens.sort()\n    blues.sort()\n    return min(nearest_with_leader(reds, greens, blues), nearest_with_leader(blues, greens, reds), nearest_with_leader(greens, blues, reds), nearest_with_leader(reds, blues, greens), nearest_with_leader(blues, reds, greens), nearest_with_leader(greens, reds, blues))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "minimum = 10 ** 19 * 3",
      "mutated_line": "minimum = 10 ** 19 * -3",
      "code": "import bisect\n\ndef find_minimum_balance_value(reds, greens, blues):\n\n    def nearest_with_leader(leader_list, other_list1, other_list2):\n        minimum = 10 ** 19 * -3\n        for leader in leader_list:\n            idx1 = bisect.bisect_left(other_list1, leader)\n            idx2 = bisect.bisect_right(other_list2, leader)\n            if idx1 == len(other_list1) or idx2 == 0:\n                continue\n            val1 = other_list1[idx1]\n            val2 = other_list2[idx2 - 1]\n            minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** 2)\n        return minimum\n    reds.sort()\n    greens.sort()\n    blues.sort()\n    return min(nearest_with_leader(reds, greens, blues), nearest_with_leader(blues, greens, reds), nearest_with_leader(greens, blues, reds), nearest_with_leader(reds, blues, greens), nearest_with_leader(blues, reds, greens), nearest_with_leader(greens, reds, blues))"
    },
    {
      "operator": "LCR",
      "lineno": 9,
      "original_line": "if idx1 == len(other_list1) or idx2 == 0:",
      "mutated_line": "if idx1 == len(other_list1) and idx2 == 0:",
      "code": "import bisect\n\ndef find_minimum_balance_value(reds, greens, blues):\n\n    def nearest_with_leader(leader_list, other_list1, other_list2):\n        minimum = 10 ** 19 * 3\n        for leader in leader_list:\n            idx1 = bisect.bisect_left(other_list1, leader)\n            idx2 = bisect.bisect_right(other_list2, leader)\n            if idx1 == len(other_list1) and idx2 == 0:\n                continue\n            val1 = other_list1[idx1]\n            val2 = other_list2[idx2 - 1]\n            minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** 2)\n        return minimum\n    reds.sort()\n    greens.sort()\n    blues.sort()\n    return min(nearest_with_leader(reds, greens, blues), nearest_with_leader(blues, greens, reds), nearest_with_leader(greens, blues, reds), nearest_with_leader(reds, blues, greens), nearest_with_leader(blues, reds, greens), nearest_with_leader(greens, reds, blues))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "minimum = 10 ** 19 * 3",
      "mutated_line": "minimum = 11 ** 19 * 3",
      "code": "import bisect\n\ndef find_minimum_balance_value(reds, greens, blues):\n\n    def nearest_with_leader(leader_list, other_list1, other_list2):\n        minimum = 11 ** 19 * 3\n        for leader in leader_list:\n            idx1 = bisect.bisect_left(other_list1, leader)\n            idx2 = bisect.bisect_right(other_list2, leader)\n            if idx1 == len(other_list1) or idx2 == 0:\n                continue\n            val1 = other_list1[idx1]\n            val2 = other_list2[idx2 - 1]\n            minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** 2)\n        return minimum\n    reds.sort()\n    greens.sort()\n    blues.sort()\n    return min(nearest_with_leader(reds, greens, blues), nearest_with_leader(blues, greens, reds), nearest_with_leader(greens, blues, reds), nearest_with_leader(reds, blues, greens), nearest_with_leader(blues, reds, greens), nearest_with_leader(greens, reds, blues))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "minimum = 10 ** 19 * 3",
      "mutated_line": "minimum = 9 ** 19 * 3",
      "code": "import bisect\n\ndef find_minimum_balance_value(reds, greens, blues):\n\n    def nearest_with_leader(leader_list, other_list1, other_list2):\n        minimum = 9 ** 19 * 3\n        for leader in leader_list:\n            idx1 = bisect.bisect_left(other_list1, leader)\n            idx2 = bisect.bisect_right(other_list2, leader)\n            if idx1 == len(other_list1) or idx2 == 0:\n                continue\n            val1 = other_list1[idx1]\n            val2 = other_list2[idx2 - 1]\n            minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** 2)\n        return minimum\n    reds.sort()\n    greens.sort()\n    blues.sort()\n    return min(nearest_with_leader(reds, greens, blues), nearest_with_leader(blues, greens, reds), nearest_with_leader(greens, blues, reds), nearest_with_leader(reds, blues, greens), nearest_with_leader(blues, reds, greens), nearest_with_leader(greens, reds, blues))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "minimum = 10 ** 19 * 3",
      "mutated_line": "minimum = 0 ** 19 * 3",
      "code": "import bisect\n\ndef find_minimum_balance_value(reds, greens, blues):\n\n    def nearest_with_leader(leader_list, other_list1, other_list2):\n        minimum = 0 ** 19 * 3\n        for leader in leader_list:\n            idx1 = bisect.bisect_left(other_list1, leader)\n            idx2 = bisect.bisect_right(other_list2, leader)\n            if idx1 == len(other_list1) or idx2 == 0:\n                continue\n            val1 = other_list1[idx1]\n            val2 = other_list2[idx2 - 1]\n            minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** 2)\n        return minimum\n    reds.sort()\n    greens.sort()\n    blues.sort()\n    return min(nearest_with_leader(reds, greens, blues), nearest_with_leader(blues, greens, reds), nearest_with_leader(greens, blues, reds), nearest_with_leader(reds, blues, greens), nearest_with_leader(blues, reds, greens), nearest_with_leader(greens, reds, blues))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "minimum = 10 ** 19 * 3",
      "mutated_line": "minimum = 1 ** 19 * 3",
      "code": "import bisect\n\ndef find_minimum_balance_value(reds, greens, blues):\n\n    def nearest_with_leader(leader_list, other_list1, other_list2):\n        minimum = 1 ** 19 * 3\n        for leader in leader_list:\n            idx1 = bisect.bisect_left(other_list1, leader)\n            idx2 = bisect.bisect_right(other_list2, leader)\n            if idx1 == len(other_list1) or idx2 == 0:\n                continue\n            val1 = other_list1[idx1]\n            val2 = other_list2[idx2 - 1]\n            minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** 2)\n        return minimum\n    reds.sort()\n    greens.sort()\n    blues.sort()\n    return min(nearest_with_leader(reds, greens, blues), nearest_with_leader(blues, greens, reds), nearest_with_leader(greens, blues, reds), nearest_with_leader(reds, blues, greens), nearest_with_leader(blues, reds, greens), nearest_with_leader(greens, reds, blues))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "minimum = 10 ** 19 * 3",
      "mutated_line": "minimum = -10 ** 19 * 3",
      "code": "import bisect\n\ndef find_minimum_balance_value(reds, greens, blues):\n\n    def nearest_with_leader(leader_list, other_list1, other_list2):\n        minimum = -10 ** 19 * 3\n        for leader in leader_list:\n            idx1 = bisect.bisect_left(other_list1, leader)\n            idx2 = bisect.bisect_right(other_list2, leader)\n            if idx1 == len(other_list1) or idx2 == 0:\n                continue\n            val1 = other_list1[idx1]\n            val2 = other_list2[idx2 - 1]\n            minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** 2)\n        return minimum\n    reds.sort()\n    greens.sort()\n    blues.sort()\n    return min(nearest_with_leader(reds, greens, blues), nearest_with_leader(blues, greens, reds), nearest_with_leader(greens, blues, reds), nearest_with_leader(reds, blues, greens), nearest_with_leader(blues, reds, greens), nearest_with_leader(greens, reds, blues))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "minimum = 10 ** 19 * 3",
      "mutated_line": "minimum = 10 ** 20 * 3",
      "code": "import bisect\n\ndef find_minimum_balance_value(reds, greens, blues):\n\n    def nearest_with_leader(leader_list, other_list1, other_list2):\n        minimum = 10 ** 20 * 3\n        for leader in leader_list:\n            idx1 = bisect.bisect_left(other_list1, leader)\n            idx2 = bisect.bisect_right(other_list2, leader)\n            if idx1 == len(other_list1) or idx2 == 0:\n                continue\n            val1 = other_list1[idx1]\n            val2 = other_list2[idx2 - 1]\n            minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** 2)\n        return minimum\n    reds.sort()\n    greens.sort()\n    blues.sort()\n    return min(nearest_with_leader(reds, greens, blues), nearest_with_leader(blues, greens, reds), nearest_with_leader(greens, blues, reds), nearest_with_leader(reds, blues, greens), nearest_with_leader(blues, reds, greens), nearest_with_leader(greens, reds, blues))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "minimum = 10 ** 19 * 3",
      "mutated_line": "minimum = 10 ** 18 * 3",
      "code": "import bisect\n\ndef find_minimum_balance_value(reds, greens, blues):\n\n    def nearest_with_leader(leader_list, other_list1, other_list2):\n        minimum = 10 ** 18 * 3\n        for leader in leader_list:\n            idx1 = bisect.bisect_left(other_list1, leader)\n            idx2 = bisect.bisect_right(other_list2, leader)\n            if idx1 == len(other_list1) or idx2 == 0:\n                continue\n            val1 = other_list1[idx1]\n            val2 = other_list2[idx2 - 1]\n            minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** 2)\n        return minimum\n    reds.sort()\n    greens.sort()\n    blues.sort()\n    return min(nearest_with_leader(reds, greens, blues), nearest_with_leader(blues, greens, reds), nearest_with_leader(greens, blues, reds), nearest_with_leader(reds, blues, greens), nearest_with_leader(blues, reds, greens), nearest_with_leader(greens, reds, blues))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "minimum = 10 ** 19 * 3",
      "mutated_line": "minimum = 10 ** 0 * 3",
      "code": "import bisect\n\ndef find_minimum_balance_value(reds, greens, blues):\n\n    def nearest_with_leader(leader_list, other_list1, other_list2):\n        minimum = 10 ** 0 * 3\n        for leader in leader_list:\n            idx1 = bisect.bisect_left(other_list1, leader)\n            idx2 = bisect.bisect_right(other_list2, leader)\n            if idx1 == len(other_list1) or idx2 == 0:\n                continue\n            val1 = other_list1[idx1]\n            val2 = other_list2[idx2 - 1]\n            minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** 2)\n        return minimum\n    reds.sort()\n    greens.sort()\n    blues.sort()\n    return min(nearest_with_leader(reds, greens, blues), nearest_with_leader(blues, greens, reds), nearest_with_leader(greens, blues, reds), nearest_with_leader(reds, blues, greens), nearest_with_leader(blues, reds, greens), nearest_with_leader(greens, reds, blues))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "minimum = 10 ** 19 * 3",
      "mutated_line": "minimum = 10 ** 1 * 3",
      "code": "import bisect\n\ndef find_minimum_balance_value(reds, greens, blues):\n\n    def nearest_with_leader(leader_list, other_list1, other_list2):\n        minimum = 10 ** 1 * 3\n        for leader in leader_list:\n            idx1 = bisect.bisect_left(other_list1, leader)\n            idx2 = bisect.bisect_right(other_list2, leader)\n            if idx1 == len(other_list1) or idx2 == 0:\n                continue\n            val1 = other_list1[idx1]\n            val2 = other_list2[idx2 - 1]\n            minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** 2)\n        return minimum\n    reds.sort()\n    greens.sort()\n    blues.sort()\n    return min(nearest_with_leader(reds, greens, blues), nearest_with_leader(blues, greens, reds), nearest_with_leader(greens, blues, reds), nearest_with_leader(reds, blues, greens), nearest_with_leader(blues, reds, greens), nearest_with_leader(greens, reds, blues))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "minimum = 10 ** 19 * 3",
      "mutated_line": "minimum = 10 ** -19 * 3",
      "code": "import bisect\n\ndef find_minimum_balance_value(reds, greens, blues):\n\n    def nearest_with_leader(leader_list, other_list1, other_list2):\n        minimum = 10 ** -19 * 3\n        for leader in leader_list:\n            idx1 = bisect.bisect_left(other_list1, leader)\n            idx2 = bisect.bisect_right(other_list2, leader)\n            if idx1 == len(other_list1) or idx2 == 0:\n                continue\n            val1 = other_list1[idx1]\n            val2 = other_list2[idx2 - 1]\n            minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** 2)\n        return minimum\n    reds.sort()\n    greens.sort()\n    blues.sort()\n    return min(nearest_with_leader(reds, greens, blues), nearest_with_leader(blues, greens, reds), nearest_with_leader(greens, blues, reds), nearest_with_leader(reds, blues, greens), nearest_with_leader(blues, reds, greens), nearest_with_leader(greens, reds, blues))"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if idx1 == len(other_list1) or idx2 == 0:",
      "mutated_line": "if idx1 != len(other_list1) or idx2 == 0:",
      "code": "import bisect\n\ndef find_minimum_balance_value(reds, greens, blues):\n\n    def nearest_with_leader(leader_list, other_list1, other_list2):\n        minimum = 10 ** 19 * 3\n        for leader in leader_list:\n            idx1 = bisect.bisect_left(other_list1, leader)\n            idx2 = bisect.bisect_right(other_list2, leader)\n            if idx1 != len(other_list1) or idx2 == 0:\n                continue\n            val1 = other_list1[idx1]\n            val2 = other_list2[idx2 - 1]\n            minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** 2)\n        return minimum\n    reds.sort()\n    greens.sort()\n    blues.sort()\n    return min(nearest_with_leader(reds, greens, blues), nearest_with_leader(blues, greens, reds), nearest_with_leader(greens, blues, reds), nearest_with_leader(reds, blues, greens), nearest_with_leader(blues, reds, greens), nearest_with_leader(greens, reds, blues))"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if idx1 == len(other_list1) or idx2 == 0:",
      "mutated_line": "if idx1 == len(other_list1) or idx2 != 0:",
      "code": "import bisect\n\ndef find_minimum_balance_value(reds, greens, blues):\n\n    def nearest_with_leader(leader_list, other_list1, other_list2):\n        minimum = 10 ** 19 * 3\n        for leader in leader_list:\n            idx1 = bisect.bisect_left(other_list1, leader)\n            idx2 = bisect.bisect_right(other_list2, leader)\n            if idx1 == len(other_list1) or idx2 != 0:\n                continue\n            val1 = other_list1[idx1]\n            val2 = other_list2[idx2 - 1]\n            minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** 2)\n        return minimum\n    reds.sort()\n    greens.sort()\n    blues.sort()\n    return min(nearest_with_leader(reds, greens, blues), nearest_with_leader(blues, greens, reds), nearest_with_leader(greens, blues, reds), nearest_with_leader(reds, blues, greens), nearest_with_leader(blues, reds, greens), nearest_with_leader(greens, reds, blues))"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "val2 = other_list2[idx2 - 1]",
      "mutated_line": "val2 = other_list2[idx2 + 1]",
      "code": "import bisect\n\ndef find_minimum_balance_value(reds, greens, blues):\n\n    def nearest_with_leader(leader_list, other_list1, other_list2):\n        minimum = 10 ** 19 * 3\n        for leader in leader_list:\n            idx1 = bisect.bisect_left(other_list1, leader)\n            idx2 = bisect.bisect_right(other_list2, leader)\n            if idx1 == len(other_list1) or idx2 == 0:\n                continue\n            val1 = other_list1[idx1]\n            val2 = other_list2[idx2 + 1]\n            minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** 2)\n        return minimum\n    reds.sort()\n    greens.sort()\n    blues.sort()\n    return min(nearest_with_leader(reds, greens, blues), nearest_with_leader(blues, greens, reds), nearest_with_leader(greens, blues, reds), nearest_with_leader(reds, blues, greens), nearest_with_leader(blues, reds, greens), nearest_with_leader(greens, reds, blues))"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "val2 = other_list2[idx2 - 1]",
      "mutated_line": "val2 = other_list2[idx2 * 1]",
      "code": "import bisect\n\ndef find_minimum_balance_value(reds, greens, blues):\n\n    def nearest_with_leader(leader_list, other_list1, other_list2):\n        minimum = 10 ** 19 * 3\n        for leader in leader_list:\n            idx1 = bisect.bisect_left(other_list1, leader)\n            idx2 = bisect.bisect_right(other_list2, leader)\n            if idx1 == len(other_list1) or idx2 == 0:\n                continue\n            val1 = other_list1[idx1]\n            val2 = other_list2[idx2 * 1]\n            minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** 2)\n        return minimum\n    reds.sort()\n    greens.sort()\n    blues.sort()\n    return min(nearest_with_leader(reds, greens, blues), nearest_with_leader(blues, greens, reds), nearest_with_leader(greens, blues, reds), nearest_with_leader(reds, blues, greens), nearest_with_leader(blues, reds, greens), nearest_with_leader(greens, reds, blues))"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** 2)",
      "mutated_line": "minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 - (leader - val2) ** 2)",
      "code": "import bisect\n\ndef find_minimum_balance_value(reds, greens, blues):\n\n    def nearest_with_leader(leader_list, other_list1, other_list2):\n        minimum = 10 ** 19 * 3\n        for leader in leader_list:\n            idx1 = bisect.bisect_left(other_list1, leader)\n            idx2 = bisect.bisect_right(other_list2, leader)\n            if idx1 == len(other_list1) or idx2 == 0:\n                continue\n            val1 = other_list1[idx1]\n            val2 = other_list2[idx2 - 1]\n            minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 - (leader - val2) ** 2)\n        return minimum\n    reds.sort()\n    greens.sort()\n    blues.sort()\n    return min(nearest_with_leader(reds, greens, blues), nearest_with_leader(blues, greens, reds), nearest_with_leader(greens, blues, reds), nearest_with_leader(reds, blues, greens), nearest_with_leader(blues, reds, greens), nearest_with_leader(greens, reds, blues))"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** 2)",
      "mutated_line": "minimum = min(minimum, ((leader - val1) ** 2 + (val1 - val2) ** 2) * (leader - val2) ** 2)",
      "code": "import bisect\n\ndef find_minimum_balance_value(reds, greens, blues):\n\n    def nearest_with_leader(leader_list, other_list1, other_list2):\n        minimum = 10 ** 19 * 3\n        for leader in leader_list:\n            idx1 = bisect.bisect_left(other_list1, leader)\n            idx2 = bisect.bisect_right(other_list2, leader)\n            if idx1 == len(other_list1) or idx2 == 0:\n                continue\n            val1 = other_list1[idx1]\n            val2 = other_list2[idx2 - 1]\n            minimum = min(minimum, ((leader - val1) ** 2 + (val1 - val2) ** 2) * (leader - val2) ** 2)\n        return minimum\n    reds.sort()\n    greens.sort()\n    blues.sort()\n    return min(nearest_with_leader(reds, greens, blues), nearest_with_leader(blues, greens, reds), nearest_with_leader(greens, blues, reds), nearest_with_leader(reds, blues, greens), nearest_with_leader(blues, reds, greens), nearest_with_leader(greens, reds, blues))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if idx1 == len(other_list1) or idx2 == 0:",
      "mutated_line": "if idx1 == len(other_list1) or idx2 == 1:",
      "code": "import bisect\n\ndef find_minimum_balance_value(reds, greens, blues):\n\n    def nearest_with_leader(leader_list, other_list1, other_list2):\n        minimum = 10 ** 19 * 3\n        for leader in leader_list:\n            idx1 = bisect.bisect_left(other_list1, leader)\n            idx2 = bisect.bisect_right(other_list2, leader)\n            if idx1 == len(other_list1) or idx2 == 1:\n                continue\n            val1 = other_list1[idx1]\n            val2 = other_list2[idx2 - 1]\n            minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** 2)\n        return minimum\n    reds.sort()\n    greens.sort()\n    blues.sort()\n    return min(nearest_with_leader(reds, greens, blues), nearest_with_leader(blues, greens, reds), nearest_with_leader(greens, blues, reds), nearest_with_leader(reds, blues, greens), nearest_with_leader(blues, reds, greens), nearest_with_leader(greens, reds, blues))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if idx1 == len(other_list1) or idx2 == 0:",
      "mutated_line": "if idx1 == len(other_list1) or idx2 == -1:",
      "code": "import bisect\n\ndef find_minimum_balance_value(reds, greens, blues):\n\n    def nearest_with_leader(leader_list, other_list1, other_list2):\n        minimum = 10 ** 19 * 3\n        for leader in leader_list:\n            idx1 = bisect.bisect_left(other_list1, leader)\n            idx2 = bisect.bisect_right(other_list2, leader)\n            if idx1 == len(other_list1) or idx2 == -1:\n                continue\n            val1 = other_list1[idx1]\n            val2 = other_list2[idx2 - 1]\n            minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** 2)\n        return minimum\n    reds.sort()\n    greens.sort()\n    blues.sort()\n    return min(nearest_with_leader(reds, greens, blues), nearest_with_leader(blues, greens, reds), nearest_with_leader(greens, blues, reds), nearest_with_leader(reds, blues, greens), nearest_with_leader(blues, reds, greens), nearest_with_leader(greens, reds, blues))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if idx1 == len(other_list1) or idx2 == 0:",
      "mutated_line": "if idx1 == len(other_list1) or idx2 == 1:",
      "code": "import bisect\n\ndef find_minimum_balance_value(reds, greens, blues):\n\n    def nearest_with_leader(leader_list, other_list1, other_list2):\n        minimum = 10 ** 19 * 3\n        for leader in leader_list:\n            idx1 = bisect.bisect_left(other_list1, leader)\n            idx2 = bisect.bisect_right(other_list2, leader)\n            if idx1 == len(other_list1) or idx2 == 1:\n                continue\n            val1 = other_list1[idx1]\n            val2 = other_list2[idx2 - 1]\n            minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** 2)\n        return minimum\n    reds.sort()\n    greens.sort()\n    blues.sort()\n    return min(nearest_with_leader(reds, greens, blues), nearest_with_leader(blues, greens, reds), nearest_with_leader(greens, blues, reds), nearest_with_leader(reds, blues, greens), nearest_with_leader(blues, reds, greens), nearest_with_leader(greens, reds, blues))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "val2 = other_list2[idx2 - 1]",
      "mutated_line": "val2 = other_list2[idx2 - 2]",
      "code": "import bisect\n\ndef find_minimum_balance_value(reds, greens, blues):\n\n    def nearest_with_leader(leader_list, other_list1, other_list2):\n        minimum = 10 ** 19 * 3\n        for leader in leader_list:\n            idx1 = bisect.bisect_left(other_list1, leader)\n            idx2 = bisect.bisect_right(other_list2, leader)\n            if idx1 == len(other_list1) or idx2 == 0:\n                continue\n            val1 = other_list1[idx1]\n            val2 = other_list2[idx2 - 2]\n            minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** 2)\n        return minimum\n    reds.sort()\n    greens.sort()\n    blues.sort()\n    return min(nearest_with_leader(reds, greens, blues), nearest_with_leader(blues, greens, reds), nearest_with_leader(greens, blues, reds), nearest_with_leader(reds, blues, greens), nearest_with_leader(blues, reds, greens), nearest_with_leader(greens, reds, blues))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "val2 = other_list2[idx2 - 1]",
      "mutated_line": "val2 = other_list2[idx2 - 0]",
      "code": "import bisect\n\ndef find_minimum_balance_value(reds, greens, blues):\n\n    def nearest_with_leader(leader_list, other_list1, other_list2):\n        minimum = 10 ** 19 * 3\n        for leader in leader_list:\n            idx1 = bisect.bisect_left(other_list1, leader)\n            idx2 = bisect.bisect_right(other_list2, leader)\n            if idx1 == len(other_list1) or idx2 == 0:\n                continue\n            val1 = other_list1[idx1]\n            val2 = other_list2[idx2 - 0]\n            minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** 2)\n        return minimum\n    reds.sort()\n    greens.sort()\n    blues.sort()\n    return min(nearest_with_leader(reds, greens, blues), nearest_with_leader(blues, greens, reds), nearest_with_leader(greens, blues, reds), nearest_with_leader(reds, blues, greens), nearest_with_leader(blues, reds, greens), nearest_with_leader(greens, reds, blues))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "val2 = other_list2[idx2 - 1]",
      "mutated_line": "val2 = other_list2[idx2 - 0]",
      "code": "import bisect\n\ndef find_minimum_balance_value(reds, greens, blues):\n\n    def nearest_with_leader(leader_list, other_list1, other_list2):\n        minimum = 10 ** 19 * 3\n        for leader in leader_list:\n            idx1 = bisect.bisect_left(other_list1, leader)\n            idx2 = bisect.bisect_right(other_list2, leader)\n            if idx1 == len(other_list1) or idx2 == 0:\n                continue\n            val1 = other_list1[idx1]\n            val2 = other_list2[idx2 - 0]\n            minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** 2)\n        return minimum\n    reds.sort()\n    greens.sort()\n    blues.sort()\n    return min(nearest_with_leader(reds, greens, blues), nearest_with_leader(blues, greens, reds), nearest_with_leader(greens, blues, reds), nearest_with_leader(reds, blues, greens), nearest_with_leader(blues, reds, greens), nearest_with_leader(greens, reds, blues))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "val2 = other_list2[idx2 - 1]",
      "mutated_line": "val2 = other_list2[idx2 - -1]",
      "code": "import bisect\n\ndef find_minimum_balance_value(reds, greens, blues):\n\n    def nearest_with_leader(leader_list, other_list1, other_list2):\n        minimum = 10 ** 19 * 3\n        for leader in leader_list:\n            idx1 = bisect.bisect_left(other_list1, leader)\n            idx2 = bisect.bisect_right(other_list2, leader)\n            if idx1 == len(other_list1) or idx2 == 0:\n                continue\n            val1 = other_list1[idx1]\n            val2 = other_list2[idx2 - -1]\n            minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** 2)\n        return minimum\n    reds.sort()\n    greens.sort()\n    blues.sort()\n    return min(nearest_with_leader(reds, greens, blues), nearest_with_leader(blues, greens, reds), nearest_with_leader(greens, blues, reds), nearest_with_leader(reds, blues, greens), nearest_with_leader(blues, reds, greens), nearest_with_leader(greens, reds, blues))"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** 2)",
      "mutated_line": "minimum = min(minimum, (leader - val1) ** 2 - (val1 - val2) ** 2 + (leader - val2) ** 2)",
      "code": "import bisect\n\ndef find_minimum_balance_value(reds, greens, blues):\n\n    def nearest_with_leader(leader_list, other_list1, other_list2):\n        minimum = 10 ** 19 * 3\n        for leader in leader_list:\n            idx1 = bisect.bisect_left(other_list1, leader)\n            idx2 = bisect.bisect_right(other_list2, leader)\n            if idx1 == len(other_list1) or idx2 == 0:\n                continue\n            val1 = other_list1[idx1]\n            val2 = other_list2[idx2 - 1]\n            minimum = min(minimum, (leader - val1) ** 2 - (val1 - val2) ** 2 + (leader - val2) ** 2)\n        return minimum\n    reds.sort()\n    greens.sort()\n    blues.sort()\n    return min(nearest_with_leader(reds, greens, blues), nearest_with_leader(blues, greens, reds), nearest_with_leader(greens, blues, reds), nearest_with_leader(reds, blues, greens), nearest_with_leader(blues, reds, greens), nearest_with_leader(greens, reds, blues))"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** 2)",
      "mutated_line": "minimum = min(minimum, (leader - val1) ** 2 * (val1 - val2) ** 2 + (leader - val2) ** 2)",
      "code": "import bisect\n\ndef find_minimum_balance_value(reds, greens, blues):\n\n    def nearest_with_leader(leader_list, other_list1, other_list2):\n        minimum = 10 ** 19 * 3\n        for leader in leader_list:\n            idx1 = bisect.bisect_left(other_list1, leader)\n            idx2 = bisect.bisect_right(other_list2, leader)\n            if idx1 == len(other_list1) or idx2 == 0:\n                continue\n            val1 = other_list1[idx1]\n            val2 = other_list2[idx2 - 1]\n            minimum = min(minimum, (leader - val1) ** 2 * (val1 - val2) ** 2 + (leader - val2) ** 2)\n        return minimum\n    reds.sort()\n    greens.sort()\n    blues.sort()\n    return min(nearest_with_leader(reds, greens, blues), nearest_with_leader(blues, greens, reds), nearest_with_leader(greens, blues, reds), nearest_with_leader(reds, blues, greens), nearest_with_leader(blues, reds, greens), nearest_with_leader(greens, reds, blues))"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** 2)",
      "mutated_line": "minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) * 2)",
      "code": "import bisect\n\ndef find_minimum_balance_value(reds, greens, blues):\n\n    def nearest_with_leader(leader_list, other_list1, other_list2):\n        minimum = 10 ** 19 * 3\n        for leader in leader_list:\n            idx1 = bisect.bisect_left(other_list1, leader)\n            idx2 = bisect.bisect_right(other_list2, leader)\n            if idx1 == len(other_list1) or idx2 == 0:\n                continue\n            val1 = other_list1[idx1]\n            val2 = other_list2[idx2 - 1]\n            minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) * 2)\n        return minimum\n    reds.sort()\n    greens.sort()\n    blues.sort()\n    return min(nearest_with_leader(reds, greens, blues), nearest_with_leader(blues, greens, reds), nearest_with_leader(greens, blues, reds), nearest_with_leader(reds, blues, greens), nearest_with_leader(blues, reds, greens), nearest_with_leader(greens, reds, blues))"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** 2)",
      "mutated_line": "minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2 + 2))",
      "code": "import bisect\n\ndef find_minimum_balance_value(reds, greens, blues):\n\n    def nearest_with_leader(leader_list, other_list1, other_list2):\n        minimum = 10 ** 19 * 3\n        for leader in leader_list:\n            idx1 = bisect.bisect_left(other_list1, leader)\n            idx2 = bisect.bisect_right(other_list2, leader)\n            if idx1 == len(other_list1) or idx2 == 0:\n                continue\n            val1 = other_list1[idx1]\n            val2 = other_list2[idx2 - 1]\n            minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2 + 2))\n        return minimum\n    reds.sort()\n    greens.sort()\n    blues.sort()\n    return min(nearest_with_leader(reds, greens, blues), nearest_with_leader(blues, greens, reds), nearest_with_leader(greens, blues, reds), nearest_with_leader(reds, blues, greens), nearest_with_leader(blues, reds, greens), nearest_with_leader(greens, reds, blues))"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** 2)",
      "mutated_line": "minimum = min(minimum, (leader - val1) * 2 + (val1 - val2) ** 2 + (leader - val2) ** 2)",
      "code": "import bisect\n\ndef find_minimum_balance_value(reds, greens, blues):\n\n    def nearest_with_leader(leader_list, other_list1, other_list2):\n        minimum = 10 ** 19 * 3\n        for leader in leader_list:\n            idx1 = bisect.bisect_left(other_list1, leader)\n            idx2 = bisect.bisect_right(other_list2, leader)\n            if idx1 == len(other_list1) or idx2 == 0:\n                continue\n            val1 = other_list1[idx1]\n            val2 = other_list2[idx2 - 1]\n            minimum = min(minimum, (leader - val1) * 2 + (val1 - val2) ** 2 + (leader - val2) ** 2)\n        return minimum\n    reds.sort()\n    greens.sort()\n    blues.sort()\n    return min(nearest_with_leader(reds, greens, blues), nearest_with_leader(blues, greens, reds), nearest_with_leader(greens, blues, reds), nearest_with_leader(reds, blues, greens), nearest_with_leader(blues, reds, greens), nearest_with_leader(greens, reds, blues))"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** 2)",
      "mutated_line": "minimum = min(minimum, leader - val1 + 2 + (val1 - val2) ** 2 + (leader - val2) ** 2)",
      "code": "import bisect\n\ndef find_minimum_balance_value(reds, greens, blues):\n\n    def nearest_with_leader(leader_list, other_list1, other_list2):\n        minimum = 10 ** 19 * 3\n        for leader in leader_list:\n            idx1 = bisect.bisect_left(other_list1, leader)\n            idx2 = bisect.bisect_right(other_list2, leader)\n            if idx1 == len(other_list1) or idx2 == 0:\n                continue\n            val1 = other_list1[idx1]\n            val2 = other_list2[idx2 - 1]\n            minimum = min(minimum, leader - val1 + 2 + (val1 - val2) ** 2 + (leader - val2) ** 2)\n        return minimum\n    reds.sort()\n    greens.sort()\n    blues.sort()\n    return min(nearest_with_leader(reds, greens, blues), nearest_with_leader(blues, greens, reds), nearest_with_leader(greens, blues, reds), nearest_with_leader(reds, blues, greens), nearest_with_leader(blues, reds, greens), nearest_with_leader(greens, reds, blues))"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** 2)",
      "mutated_line": "minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) * 2 + (leader - val2) ** 2)",
      "code": "import bisect\n\ndef find_minimum_balance_value(reds, greens, blues):\n\n    def nearest_with_leader(leader_list, other_list1, other_list2):\n        minimum = 10 ** 19 * 3\n        for leader in leader_list:\n            idx1 = bisect.bisect_left(other_list1, leader)\n            idx2 = bisect.bisect_right(other_list2, leader)\n            if idx1 == len(other_list1) or idx2 == 0:\n                continue\n            val1 = other_list1[idx1]\n            val2 = other_list2[idx2 - 1]\n            minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) * 2 + (leader - val2) ** 2)\n        return minimum\n    reds.sort()\n    greens.sort()\n    blues.sort()\n    return min(nearest_with_leader(reds, greens, blues), nearest_with_leader(blues, greens, reds), nearest_with_leader(greens, blues, reds), nearest_with_leader(reds, blues, greens), nearest_with_leader(blues, reds, greens), nearest_with_leader(greens, reds, blues))"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** 2)",
      "mutated_line": "minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2 + 2) + (leader - val2) ** 2)",
      "code": "import bisect\n\ndef find_minimum_balance_value(reds, greens, blues):\n\n    def nearest_with_leader(leader_list, other_list1, other_list2):\n        minimum = 10 ** 19 * 3\n        for leader in leader_list:\n            idx1 = bisect.bisect_left(other_list1, leader)\n            idx2 = bisect.bisect_right(other_list2, leader)\n            if idx1 == len(other_list1) or idx2 == 0:\n                continue\n            val1 = other_list1[idx1]\n            val2 = other_list2[idx2 - 1]\n            minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2 + 2) + (leader - val2) ** 2)\n        return minimum\n    reds.sort()\n    greens.sort()\n    blues.sort()\n    return min(nearest_with_leader(reds, greens, blues), nearest_with_leader(blues, greens, reds), nearest_with_leader(greens, blues, reds), nearest_with_leader(reds, blues, greens), nearest_with_leader(blues, reds, greens), nearest_with_leader(greens, reds, blues))"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** 2)",
      "mutated_line": "minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader + val2) ** 2)",
      "code": "import bisect\n\ndef find_minimum_balance_value(reds, greens, blues):\n\n    def nearest_with_leader(leader_list, other_list1, other_list2):\n        minimum = 10 ** 19 * 3\n        for leader in leader_list:\n            idx1 = bisect.bisect_left(other_list1, leader)\n            idx2 = bisect.bisect_right(other_list2, leader)\n            if idx1 == len(other_list1) or idx2 == 0:\n                continue\n            val1 = other_list1[idx1]\n            val2 = other_list2[idx2 - 1]\n            minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader + val2) ** 2)\n        return minimum\n    reds.sort()\n    greens.sort()\n    blues.sort()\n    return min(nearest_with_leader(reds, greens, blues), nearest_with_leader(blues, greens, reds), nearest_with_leader(greens, blues, reds), nearest_with_leader(reds, blues, greens), nearest_with_leader(blues, reds, greens), nearest_with_leader(greens, reds, blues))"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** 2)",
      "mutated_line": "minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader * val2) ** 2)",
      "code": "import bisect\n\ndef find_minimum_balance_value(reds, greens, blues):\n\n    def nearest_with_leader(leader_list, other_list1, other_list2):\n        minimum = 10 ** 19 * 3\n        for leader in leader_list:\n            idx1 = bisect.bisect_left(other_list1, leader)\n            idx2 = bisect.bisect_right(other_list2, leader)\n            if idx1 == len(other_list1) or idx2 == 0:\n                continue\n            val1 = other_list1[idx1]\n            val2 = other_list2[idx2 - 1]\n            minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader * val2) ** 2)\n        return minimum\n    reds.sort()\n    greens.sort()\n    blues.sort()\n    return min(nearest_with_leader(reds, greens, blues), nearest_with_leader(blues, greens, reds), nearest_with_leader(greens, blues, reds), nearest_with_leader(reds, blues, greens), nearest_with_leader(blues, reds, greens), nearest_with_leader(greens, reds, blues))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** 2)",
      "mutated_line": "minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** 3)",
      "code": "import bisect\n\ndef find_minimum_balance_value(reds, greens, blues):\n\n    def nearest_with_leader(leader_list, other_list1, other_list2):\n        minimum = 10 ** 19 * 3\n        for leader in leader_list:\n            idx1 = bisect.bisect_left(other_list1, leader)\n            idx2 = bisect.bisect_right(other_list2, leader)\n            if idx1 == len(other_list1) or idx2 == 0:\n                continue\n            val1 = other_list1[idx1]\n            val2 = other_list2[idx2 - 1]\n            minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** 3)\n        return minimum\n    reds.sort()\n    greens.sort()\n    blues.sort()\n    return min(nearest_with_leader(reds, greens, blues), nearest_with_leader(blues, greens, reds), nearest_with_leader(greens, blues, reds), nearest_with_leader(reds, blues, greens), nearest_with_leader(blues, reds, greens), nearest_with_leader(greens, reds, blues))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** 2)",
      "mutated_line": "minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** 1)",
      "code": "import bisect\n\ndef find_minimum_balance_value(reds, greens, blues):\n\n    def nearest_with_leader(leader_list, other_list1, other_list2):\n        minimum = 10 ** 19 * 3\n        for leader in leader_list:\n            idx1 = bisect.bisect_left(other_list1, leader)\n            idx2 = bisect.bisect_right(other_list2, leader)\n            if idx1 == len(other_list1) or idx2 == 0:\n                continue\n            val1 = other_list1[idx1]\n            val2 = other_list2[idx2 - 1]\n            minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** 1)\n        return minimum\n    reds.sort()\n    greens.sort()\n    blues.sort()\n    return min(nearest_with_leader(reds, greens, blues), nearest_with_leader(blues, greens, reds), nearest_with_leader(greens, blues, reds), nearest_with_leader(reds, blues, greens), nearest_with_leader(blues, reds, greens), nearest_with_leader(greens, reds, blues))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** 2)",
      "mutated_line": "minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** 0)",
      "code": "import bisect\n\ndef find_minimum_balance_value(reds, greens, blues):\n\n    def nearest_with_leader(leader_list, other_list1, other_list2):\n        minimum = 10 ** 19 * 3\n        for leader in leader_list:\n            idx1 = bisect.bisect_left(other_list1, leader)\n            idx2 = bisect.bisect_right(other_list2, leader)\n            if idx1 == len(other_list1) or idx2 == 0:\n                continue\n            val1 = other_list1[idx1]\n            val2 = other_list2[idx2 - 1]\n            minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** 0)\n        return minimum\n    reds.sort()\n    greens.sort()\n    blues.sort()\n    return min(nearest_with_leader(reds, greens, blues), nearest_with_leader(blues, greens, reds), nearest_with_leader(greens, blues, reds), nearest_with_leader(reds, blues, greens), nearest_with_leader(blues, reds, greens), nearest_with_leader(greens, reds, blues))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** 2)",
      "mutated_line": "minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** 1)",
      "code": "import bisect\n\ndef find_minimum_balance_value(reds, greens, blues):\n\n    def nearest_with_leader(leader_list, other_list1, other_list2):\n        minimum = 10 ** 19 * 3\n        for leader in leader_list:\n            idx1 = bisect.bisect_left(other_list1, leader)\n            idx2 = bisect.bisect_right(other_list2, leader)\n            if idx1 == len(other_list1) or idx2 == 0:\n                continue\n            val1 = other_list1[idx1]\n            val2 = other_list2[idx2 - 1]\n            minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** 1)\n        return minimum\n    reds.sort()\n    greens.sort()\n    blues.sort()\n    return min(nearest_with_leader(reds, greens, blues), nearest_with_leader(blues, greens, reds), nearest_with_leader(greens, blues, reds), nearest_with_leader(reds, blues, greens), nearest_with_leader(blues, reds, greens), nearest_with_leader(greens, reds, blues))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** 2)",
      "mutated_line": "minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** -2)",
      "code": "import bisect\n\ndef find_minimum_balance_value(reds, greens, blues):\n\n    def nearest_with_leader(leader_list, other_list1, other_list2):\n        minimum = 10 ** 19 * 3\n        for leader in leader_list:\n            idx1 = bisect.bisect_left(other_list1, leader)\n            idx2 = bisect.bisect_right(other_list2, leader)\n            if idx1 == len(other_list1) or idx2 == 0:\n                continue\n            val1 = other_list1[idx1]\n            val2 = other_list2[idx2 - 1]\n            minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** -2)\n        return minimum\n    reds.sort()\n    greens.sort()\n    blues.sort()\n    return min(nearest_with_leader(reds, greens, blues), nearest_with_leader(blues, greens, reds), nearest_with_leader(greens, blues, reds), nearest_with_leader(reds, blues, greens), nearest_with_leader(blues, reds, greens), nearest_with_leader(greens, reds, blues))"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** 2)",
      "mutated_line": "minimum = min(minimum, (leader + val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** 2)",
      "code": "import bisect\n\ndef find_minimum_balance_value(reds, greens, blues):\n\n    def nearest_with_leader(leader_list, other_list1, other_list2):\n        minimum = 10 ** 19 * 3\n        for leader in leader_list:\n            idx1 = bisect.bisect_left(other_list1, leader)\n            idx2 = bisect.bisect_right(other_list2, leader)\n            if idx1 == len(other_list1) or idx2 == 0:\n                continue\n            val1 = other_list1[idx1]\n            val2 = other_list2[idx2 - 1]\n            minimum = min(minimum, (leader + val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** 2)\n        return minimum\n    reds.sort()\n    greens.sort()\n    blues.sort()\n    return min(nearest_with_leader(reds, greens, blues), nearest_with_leader(blues, greens, reds), nearest_with_leader(greens, blues, reds), nearest_with_leader(reds, blues, greens), nearest_with_leader(blues, reds, greens), nearest_with_leader(greens, reds, blues))"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** 2)",
      "mutated_line": "minimum = min(minimum, (leader * val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** 2)",
      "code": "import bisect\n\ndef find_minimum_balance_value(reds, greens, blues):\n\n    def nearest_with_leader(leader_list, other_list1, other_list2):\n        minimum = 10 ** 19 * 3\n        for leader in leader_list:\n            idx1 = bisect.bisect_left(other_list1, leader)\n            idx2 = bisect.bisect_right(other_list2, leader)\n            if idx1 == len(other_list1) or idx2 == 0:\n                continue\n            val1 = other_list1[idx1]\n            val2 = other_list2[idx2 - 1]\n            minimum = min(minimum, (leader * val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** 2)\n        return minimum\n    reds.sort()\n    greens.sort()\n    blues.sort()\n    return min(nearest_with_leader(reds, greens, blues), nearest_with_leader(blues, greens, reds), nearest_with_leader(greens, blues, reds), nearest_with_leader(reds, blues, greens), nearest_with_leader(blues, reds, greens), nearest_with_leader(greens, reds, blues))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** 2)",
      "mutated_line": "minimum = min(minimum, (leader - val1) ** 3 + (val1 - val2) ** 2 + (leader - val2) ** 2)",
      "code": "import bisect\n\ndef find_minimum_balance_value(reds, greens, blues):\n\n    def nearest_with_leader(leader_list, other_list1, other_list2):\n        minimum = 10 ** 19 * 3\n        for leader in leader_list:\n            idx1 = bisect.bisect_left(other_list1, leader)\n            idx2 = bisect.bisect_right(other_list2, leader)\n            if idx1 == len(other_list1) or idx2 == 0:\n                continue\n            val1 = other_list1[idx1]\n            val2 = other_list2[idx2 - 1]\n            minimum = min(minimum, (leader - val1) ** 3 + (val1 - val2) ** 2 + (leader - val2) ** 2)\n        return minimum\n    reds.sort()\n    greens.sort()\n    blues.sort()\n    return min(nearest_with_leader(reds, greens, blues), nearest_with_leader(blues, greens, reds), nearest_with_leader(greens, blues, reds), nearest_with_leader(reds, blues, greens), nearest_with_leader(blues, reds, greens), nearest_with_leader(greens, reds, blues))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** 2)",
      "mutated_line": "minimum = min(minimum, (leader - val1) ** 1 + (val1 - val2) ** 2 + (leader - val2) ** 2)",
      "code": "import bisect\n\ndef find_minimum_balance_value(reds, greens, blues):\n\n    def nearest_with_leader(leader_list, other_list1, other_list2):\n        minimum = 10 ** 19 * 3\n        for leader in leader_list:\n            idx1 = bisect.bisect_left(other_list1, leader)\n            idx2 = bisect.bisect_right(other_list2, leader)\n            if idx1 == len(other_list1) or idx2 == 0:\n                continue\n            val1 = other_list1[idx1]\n            val2 = other_list2[idx2 - 1]\n            minimum = min(minimum, (leader - val1) ** 1 + (val1 - val2) ** 2 + (leader - val2) ** 2)\n        return minimum\n    reds.sort()\n    greens.sort()\n    blues.sort()\n    return min(nearest_with_leader(reds, greens, blues), nearest_with_leader(blues, greens, reds), nearest_with_leader(greens, blues, reds), nearest_with_leader(reds, blues, greens), nearest_with_leader(blues, reds, greens), nearest_with_leader(greens, reds, blues))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** 2)",
      "mutated_line": "minimum = min(minimum, (leader - val1) ** 0 + (val1 - val2) ** 2 + (leader - val2) ** 2)",
      "code": "import bisect\n\ndef find_minimum_balance_value(reds, greens, blues):\n\n    def nearest_with_leader(leader_list, other_list1, other_list2):\n        minimum = 10 ** 19 * 3\n        for leader in leader_list:\n            idx1 = bisect.bisect_left(other_list1, leader)\n            idx2 = bisect.bisect_right(other_list2, leader)\n            if idx1 == len(other_list1) or idx2 == 0:\n                continue\n            val1 = other_list1[idx1]\n            val2 = other_list2[idx2 - 1]\n            minimum = min(minimum, (leader - val1) ** 0 + (val1 - val2) ** 2 + (leader - val2) ** 2)\n        return minimum\n    reds.sort()\n    greens.sort()\n    blues.sort()\n    return min(nearest_with_leader(reds, greens, blues), nearest_with_leader(blues, greens, reds), nearest_with_leader(greens, blues, reds), nearest_with_leader(reds, blues, greens), nearest_with_leader(blues, reds, greens), nearest_with_leader(greens, reds, blues))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** 2)",
      "mutated_line": "minimum = min(minimum, (leader - val1) ** 1 + (val1 - val2) ** 2 + (leader - val2) ** 2)",
      "code": "import bisect\n\ndef find_minimum_balance_value(reds, greens, blues):\n\n    def nearest_with_leader(leader_list, other_list1, other_list2):\n        minimum = 10 ** 19 * 3\n        for leader in leader_list:\n            idx1 = bisect.bisect_left(other_list1, leader)\n            idx2 = bisect.bisect_right(other_list2, leader)\n            if idx1 == len(other_list1) or idx2 == 0:\n                continue\n            val1 = other_list1[idx1]\n            val2 = other_list2[idx2 - 1]\n            minimum = min(minimum, (leader - val1) ** 1 + (val1 - val2) ** 2 + (leader - val2) ** 2)\n        return minimum\n    reds.sort()\n    greens.sort()\n    blues.sort()\n    return min(nearest_with_leader(reds, greens, blues), nearest_with_leader(blues, greens, reds), nearest_with_leader(greens, blues, reds), nearest_with_leader(reds, blues, greens), nearest_with_leader(blues, reds, greens), nearest_with_leader(greens, reds, blues))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** 2)",
      "mutated_line": "minimum = min(minimum, (leader - val1) ** -2 + (val1 - val2) ** 2 + (leader - val2) ** 2)",
      "code": "import bisect\n\ndef find_minimum_balance_value(reds, greens, blues):\n\n    def nearest_with_leader(leader_list, other_list1, other_list2):\n        minimum = 10 ** 19 * 3\n        for leader in leader_list:\n            idx1 = bisect.bisect_left(other_list1, leader)\n            idx2 = bisect.bisect_right(other_list2, leader)\n            if idx1 == len(other_list1) or idx2 == 0:\n                continue\n            val1 = other_list1[idx1]\n            val2 = other_list2[idx2 - 1]\n            minimum = min(minimum, (leader - val1) ** -2 + (val1 - val2) ** 2 + (leader - val2) ** 2)\n        return minimum\n    reds.sort()\n    greens.sort()\n    blues.sort()\n    return min(nearest_with_leader(reds, greens, blues), nearest_with_leader(blues, greens, reds), nearest_with_leader(greens, blues, reds), nearest_with_leader(reds, blues, greens), nearest_with_leader(blues, reds, greens), nearest_with_leader(greens, reds, blues))"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** 2)",
      "mutated_line": "minimum = min(minimum, (leader - val1) ** 2 + (val1 + val2) ** 2 + (leader - val2) ** 2)",
      "code": "import bisect\n\ndef find_minimum_balance_value(reds, greens, blues):\n\n    def nearest_with_leader(leader_list, other_list1, other_list2):\n        minimum = 10 ** 19 * 3\n        for leader in leader_list:\n            idx1 = bisect.bisect_left(other_list1, leader)\n            idx2 = bisect.bisect_right(other_list2, leader)\n            if idx1 == len(other_list1) or idx2 == 0:\n                continue\n            val1 = other_list1[idx1]\n            val2 = other_list2[idx2 - 1]\n            minimum = min(minimum, (leader - val1) ** 2 + (val1 + val2) ** 2 + (leader - val2) ** 2)\n        return minimum\n    reds.sort()\n    greens.sort()\n    blues.sort()\n    return min(nearest_with_leader(reds, greens, blues), nearest_with_leader(blues, greens, reds), nearest_with_leader(greens, blues, reds), nearest_with_leader(reds, blues, greens), nearest_with_leader(blues, reds, greens), nearest_with_leader(greens, reds, blues))"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** 2)",
      "mutated_line": "minimum = min(minimum, (leader - val1) ** 2 + (val1 * val2) ** 2 + (leader - val2) ** 2)",
      "code": "import bisect\n\ndef find_minimum_balance_value(reds, greens, blues):\n\n    def nearest_with_leader(leader_list, other_list1, other_list2):\n        minimum = 10 ** 19 * 3\n        for leader in leader_list:\n            idx1 = bisect.bisect_left(other_list1, leader)\n            idx2 = bisect.bisect_right(other_list2, leader)\n            if idx1 == len(other_list1) or idx2 == 0:\n                continue\n            val1 = other_list1[idx1]\n            val2 = other_list2[idx2 - 1]\n            minimum = min(minimum, (leader - val1) ** 2 + (val1 * val2) ** 2 + (leader - val2) ** 2)\n        return minimum\n    reds.sort()\n    greens.sort()\n    blues.sort()\n    return min(nearest_with_leader(reds, greens, blues), nearest_with_leader(blues, greens, reds), nearest_with_leader(greens, blues, reds), nearest_with_leader(reds, blues, greens), nearest_with_leader(blues, reds, greens), nearest_with_leader(greens, reds, blues))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** 2)",
      "mutated_line": "minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 3 + (leader - val2) ** 2)",
      "code": "import bisect\n\ndef find_minimum_balance_value(reds, greens, blues):\n\n    def nearest_with_leader(leader_list, other_list1, other_list2):\n        minimum = 10 ** 19 * 3\n        for leader in leader_list:\n            idx1 = bisect.bisect_left(other_list1, leader)\n            idx2 = bisect.bisect_right(other_list2, leader)\n            if idx1 == len(other_list1) or idx2 == 0:\n                continue\n            val1 = other_list1[idx1]\n            val2 = other_list2[idx2 - 1]\n            minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 3 + (leader - val2) ** 2)\n        return minimum\n    reds.sort()\n    greens.sort()\n    blues.sort()\n    return min(nearest_with_leader(reds, greens, blues), nearest_with_leader(blues, greens, reds), nearest_with_leader(greens, blues, reds), nearest_with_leader(reds, blues, greens), nearest_with_leader(blues, reds, greens), nearest_with_leader(greens, reds, blues))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** 2)",
      "mutated_line": "minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 1 + (leader - val2) ** 2)",
      "code": "import bisect\n\ndef find_minimum_balance_value(reds, greens, blues):\n\n    def nearest_with_leader(leader_list, other_list1, other_list2):\n        minimum = 10 ** 19 * 3\n        for leader in leader_list:\n            idx1 = bisect.bisect_left(other_list1, leader)\n            idx2 = bisect.bisect_right(other_list2, leader)\n            if idx1 == len(other_list1) or idx2 == 0:\n                continue\n            val1 = other_list1[idx1]\n            val2 = other_list2[idx2 - 1]\n            minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 1 + (leader - val2) ** 2)\n        return minimum\n    reds.sort()\n    greens.sort()\n    blues.sort()\n    return min(nearest_with_leader(reds, greens, blues), nearest_with_leader(blues, greens, reds), nearest_with_leader(greens, blues, reds), nearest_with_leader(reds, blues, greens), nearest_with_leader(blues, reds, greens), nearest_with_leader(greens, reds, blues))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** 2)",
      "mutated_line": "minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 0 + (leader - val2) ** 2)",
      "code": "import bisect\n\ndef find_minimum_balance_value(reds, greens, blues):\n\n    def nearest_with_leader(leader_list, other_list1, other_list2):\n        minimum = 10 ** 19 * 3\n        for leader in leader_list:\n            idx1 = bisect.bisect_left(other_list1, leader)\n            idx2 = bisect.bisect_right(other_list2, leader)\n            if idx1 == len(other_list1) or idx2 == 0:\n                continue\n            val1 = other_list1[idx1]\n            val2 = other_list2[idx2 - 1]\n            minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 0 + (leader - val2) ** 2)\n        return minimum\n    reds.sort()\n    greens.sort()\n    blues.sort()\n    return min(nearest_with_leader(reds, greens, blues), nearest_with_leader(blues, greens, reds), nearest_with_leader(greens, blues, reds), nearest_with_leader(reds, blues, greens), nearest_with_leader(blues, reds, greens), nearest_with_leader(greens, reds, blues))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** 2)",
      "mutated_line": "minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 1 + (leader - val2) ** 2)",
      "code": "import bisect\n\ndef find_minimum_balance_value(reds, greens, blues):\n\n    def nearest_with_leader(leader_list, other_list1, other_list2):\n        minimum = 10 ** 19 * 3\n        for leader in leader_list:\n            idx1 = bisect.bisect_left(other_list1, leader)\n            idx2 = bisect.bisect_right(other_list2, leader)\n            if idx1 == len(other_list1) or idx2 == 0:\n                continue\n            val1 = other_list1[idx1]\n            val2 = other_list2[idx2 - 1]\n            minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 1 + (leader - val2) ** 2)\n        return minimum\n    reds.sort()\n    greens.sort()\n    blues.sort()\n    return min(nearest_with_leader(reds, greens, blues), nearest_with_leader(blues, greens, reds), nearest_with_leader(greens, blues, reds), nearest_with_leader(reds, blues, greens), nearest_with_leader(blues, reds, greens), nearest_with_leader(greens, reds, blues))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** 2 + (leader - val2) ** 2)",
      "mutated_line": "minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** -2 + (leader - val2) ** 2)",
      "code": "import bisect\n\ndef find_minimum_balance_value(reds, greens, blues):\n\n    def nearest_with_leader(leader_list, other_list1, other_list2):\n        minimum = 10 ** 19 * 3\n        for leader in leader_list:\n            idx1 = bisect.bisect_left(other_list1, leader)\n            idx2 = bisect.bisect_right(other_list2, leader)\n            if idx1 == len(other_list1) or idx2 == 0:\n                continue\n            val1 = other_list1[idx1]\n            val2 = other_list2[idx2 - 1]\n            minimum = min(minimum, (leader - val1) ** 2 + (val1 - val2) ** -2 + (leader - val2) ** 2)\n        return minimum\n    reds.sort()\n    greens.sort()\n    blues.sort()\n    return min(nearest_with_leader(reds, greens, blues), nearest_with_leader(blues, greens, reds), nearest_with_leader(greens, blues, reds), nearest_with_leader(reds, blues, greens), nearest_with_leader(blues, reds, greens), nearest_with_leader(greens, reds, blues))"
    }
  ]
}