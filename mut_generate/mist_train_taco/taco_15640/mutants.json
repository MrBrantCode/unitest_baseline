{
  "task_id": "taco_15640",
  "entry_point": "restore_permutation",
  "mutant_count": 84,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == 0:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 1) == 0:\n                min_real = i // (val + 1) + 1\n            else:\n                min_real = i // (val + 1) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "res = [0] * n",
      "mutated_line": "res = [0] / n",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == 0:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 1) == 0:\n                min_real = i // (val + 1) + 1\n            else:\n                min_real = i // (val + 1) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] / n\n    my_heap = []\n    for val in range(n, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "res = [0] * n",
      "mutated_line": "res = [0] + n",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == 0:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 1) == 0:\n                min_real = i // (val + 1) + 1\n            else:\n                min_real = i // (val + 1) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] + n\n    my_heap = []\n    for val in range(n, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "res = [0] * n",
      "mutated_line": "res = [0] ** n",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == 0:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 1) == 0:\n                min_real = i // (val + 1) + 1\n            else:\n                min_real = i // (val + 1) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] ** n\n    my_heap = []\n    for val in range(n, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "i = j + 1",
      "mutated_line": "i = j - 1",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j - 1\n        if val == 0:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 1) == 0:\n                min_real = i // (val + 1) + 1\n            else:\n                min_real = i // (val + 1) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "i = j + 1",
      "mutated_line": "i = j * 1",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j * 1\n        if val == 0:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 1) == 0:\n                min_real = i // (val + 1) + 1\n            else:\n                min_real = i // (val + 1) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if val == 0:",
      "mutated_line": "if val != 0:",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val != 0:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 1) == 0:\n                min_real = i // (val + 1) + 1\n            else:\n                min_real = i // (val + 1) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for val in range(n, 0, -1):",
      "mutated_line": "for val in range(n, 1, -1):",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == 0:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 1) == 0:\n                min_real = i // (val + 1) + 1\n            else:\n                min_real = i // (val + 1) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 1, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for val in range(n, 0, -1):",
      "mutated_line": "for val in range(n, -1, -1):",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == 0:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 1) == 0:\n                min_real = i // (val + 1) + 1\n            else:\n                min_real = i // (val + 1) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, -1, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for val in range(n, 0, -1):",
      "mutated_line": "for val in range(n, 1, -1):",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == 0:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 1) == 0:\n                min_real = i // (val + 1) + 1\n            else:\n                min_real = i // (val + 1) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 1, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "UOI",
      "lineno": 31,
      "original_line": "for val in range(n, 0, -1):",
      "mutated_line": "for val in range(n, 0, +1):",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == 0:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 1) == 0:\n                min_real = i // (val + 1) + 1\n            else:\n                min_real = i // (val + 1) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 0, +1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "i = j + 1",
      "mutated_line": "i = j + 2",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 2\n        if val == 0:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 1) == 0:\n                min_real = i // (val + 1) + 1\n            else:\n                min_real = i // (val + 1) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "i = j + 1",
      "mutated_line": "i = j + 0",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 0\n        if val == 0:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 1) == 0:\n                min_real = i // (val + 1) + 1\n            else:\n                min_real = i // (val + 1) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "i = j + 1",
      "mutated_line": "i = j + 0",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 0\n        if val == 0:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 1) == 0:\n                min_real = i // (val + 1) + 1\n            else:\n                min_real = i // (val + 1) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "i = j + 1",
      "mutated_line": "i = j + -1",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + -1\n        if val == 0:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 1) == 0:\n                min_real = i // (val + 1) + 1\n            else:\n                min_real = i // (val + 1) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if val == 0:",
      "mutated_line": "if val == 1:",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == 1:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 1) == 0:\n                min_real = i // (val + 1) + 1\n            else:\n                min_real = i // (val + 1) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if val == 0:",
      "mutated_line": "if val == -1:",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == -1:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 1) == 0:\n                min_real = i // (val + 1) + 1\n            else:\n                min_real = i // (val + 1) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if val == 0:",
      "mutated_line": "if val == 1:",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == 1:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 1) == 0:\n                min_real = i // (val + 1) + 1\n            else:\n                min_real = i // (val + 1) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "min_real = i + 1",
      "mutated_line": "min_real = i - 1",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == 0:\n            min_real = i - 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 1) == 0:\n                min_real = i // (val + 1) + 1\n            else:\n                min_real = i // (val + 1) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "min_real = i + 1",
      "mutated_line": "min_real = i * 1",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == 0:\n            min_real = i * 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 1) == 0:\n                min_real = i // (val + 1) + 1\n            else:\n                min_real = i // (val + 1) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "max_real = i // val",
      "mutated_line": "max_real = i / val",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == 0:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i / val\n            if i % (val + 1) == 0:\n                min_real = i // (val + 1) + 1\n            else:\n                min_real = i // (val + 1) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "max_real = i // val",
      "mutated_line": "max_real = i * val",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == 0:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i * val\n            if i % (val + 1) == 0:\n                min_real = i // (val + 1) + 1\n            else:\n                min_real = i // (val + 1) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if i % (val + 1) == 0:",
      "mutated_line": "if i % (val + 1) != 0:",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == 0:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 1) != 0:\n                min_real = i // (val + 1) + 1\n            else:\n                min_real = i // (val + 1) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "res = [0] * n",
      "mutated_line": "res = [1] * n",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == 0:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 1) == 0:\n                min_real = i // (val + 1) + 1\n            else:\n                min_real = i // (val + 1) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [1] * n\n    my_heap = []\n    for val in range(n, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "res = [0] * n",
      "mutated_line": "res = [-1] * n",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == 0:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 1) == 0:\n                min_real = i // (val + 1) + 1\n            else:\n                min_real = i // (val + 1) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [-1] * n\n    my_heap = []\n    for val in range(n, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "res = [0] * n",
      "mutated_line": "res = [1] * n",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == 0:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 1) == 0:\n                min_real = i // (val + 1) + 1\n            else:\n                min_real = i // (val + 1) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [1] * n\n    my_heap = []\n    for val in range(n, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for val in range(n, 0, -1):",
      "mutated_line": "for val in range(n, 0, -2):",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == 0:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 1) == 0:\n                min_real = i // (val + 1) + 1\n            else:\n                min_real = i // (val + 1) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 0, -2):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for val in range(n, 0, -1):",
      "mutated_line": "for val in range(n, 0, -0):",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == 0:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 1) == 0:\n                min_real = i // (val + 1) + 1\n            else:\n                min_real = i // (val + 1) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 0, -0):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for val in range(n, 0, -1):",
      "mutated_line": "for val in range(n, 0, -0):",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == 0:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 1) == 0:\n                min_real = i // (val + 1) + 1\n            else:\n                min_real = i // (val + 1) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 0, -0):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for val in range(n, 0, -1):",
      "mutated_line": "for val in range(n, 0, --1):",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == 0:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 1) == 0:\n                min_real = i // (val + 1) + 1\n            else:\n                min_real = i // (val + 1) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 0, --1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "ranges_begin = [[] for _ in range(n + 1)]",
      "mutated_line": "ranges_begin = [[] for _ in range(n - 1)]",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n - 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == 0:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 1) == 0:\n                min_real = i // (val + 1) + 1\n            else:\n                min_real = i // (val + 1) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "ranges_begin = [[] for _ in range(n + 1)]",
      "mutated_line": "ranges_begin = [[] for _ in range(n * 1)]",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n * 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == 0:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 1) == 0:\n                min_real = i // (val + 1) + 1\n            else:\n                min_real = i // (val + 1) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "min_real = i + 1",
      "mutated_line": "min_real = i + 2",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == 0:\n            min_real = i + 2\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 1) == 0:\n                min_real = i // (val + 1) + 1\n            else:\n                min_real = i // (val + 1) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "min_real = i + 1",
      "mutated_line": "min_real = i + 0",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == 0:\n            min_real = i + 0\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 1) == 0:\n                min_real = i // (val + 1) + 1\n            else:\n                min_real = i // (val + 1) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "min_real = i + 1",
      "mutated_line": "min_real = i + 0",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == 0:\n            min_real = i + 0\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 1) == 0:\n                min_real = i // (val + 1) + 1\n            else:\n                min_real = i // (val + 1) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "min_real = i + 1",
      "mutated_line": "min_real = i + -1",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == 0:\n            min_real = i + -1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 1) == 0:\n                min_real = i // (val + 1) + 1\n            else:\n                min_real = i // (val + 1) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if i % (val + 1) == 0:",
      "mutated_line": "if i * (val + 1) == 0:",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == 0:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i * (val + 1) == 0:\n                min_real = i // (val + 1) + 1\n            else:\n                min_real = i // (val + 1) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if i % (val + 1) == 0:",
      "mutated_line": "if i + (val + 1) == 0:",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == 0:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i + (val + 1) == 0:\n                min_real = i // (val + 1) + 1\n            else:\n                min_real = i // (val + 1) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if i % (val + 1) == 0:",
      "mutated_line": "if i % (val + 1) == 1:",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == 0:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 1) == 1:\n                min_real = i // (val + 1) + 1\n            else:\n                min_real = i // (val + 1) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if i % (val + 1) == 0:",
      "mutated_line": "if i % (val + 1) == -1:",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == 0:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 1) == -1:\n                min_real = i // (val + 1) + 1\n            else:\n                min_real = i // (val + 1) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if i % (val + 1) == 0:",
      "mutated_line": "if i % (val + 1) == 1:",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == 0:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 1) == 1:\n                min_real = i // (val + 1) + 1\n            else:\n                min_real = i // (val + 1) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "min_real = i // (val + 1) + 1",
      "mutated_line": "min_real = i // (val + 1) - 1",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == 0:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 1) == 0:\n                min_real = i // (val + 1) - 1\n            else:\n                min_real = i // (val + 1) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "min_real = i // (val + 1) + 1",
      "mutated_line": "min_real = i // (val + 1) * 1",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == 0:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 1) == 0:\n                min_real = i // (val + 1) * 1\n            else:\n                min_real = i // (val + 1) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "min_real = i // (val + 1) + 1",
      "mutated_line": "min_real = i // (val + 1) - 1",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == 0:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 1) == 0:\n                min_real = i // (val + 1) + 1\n            else:\n                min_real = i // (val + 1) - 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "min_real = i // (val + 1) + 1",
      "mutated_line": "min_real = i // (val + 1) * 1",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == 0:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 1) == 0:\n                min_real = i // (val + 1) + 1\n            else:\n                min_real = i // (val + 1) * 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "UOI",
      "lineno": 26,
      "original_line": "ranges_begin[max_real].append((-min_real, j))",
      "mutated_line": "ranges_begin[max_real].append((+min_real, j))",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == 0:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 1) == 0:\n                min_real = i // (val + 1) + 1\n            else:\n                min_real = i // (val + 1) + 1\n        ranges_begin[max_real].append((+min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "res[mini_of_heap[1]] = val",
      "mutated_line": "res[mini_of_heap[2]] = val",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == 0:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 1) == 0:\n                min_real = i // (val + 1) + 1\n            else:\n                min_real = i // (val + 1) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[2]] = val\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "res[mini_of_heap[1]] = val",
      "mutated_line": "res[mini_of_heap[0]] = val",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == 0:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 1) == 0:\n                min_real = i // (val + 1) + 1\n            else:\n                min_real = i // (val + 1) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[0]] = val\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "res[mini_of_heap[1]] = val",
      "mutated_line": "res[mini_of_heap[0]] = val",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == 0:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 1) == 0:\n                min_real = i // (val + 1) + 1\n            else:\n                min_real = i // (val + 1) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[0]] = val\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "res[mini_of_heap[1]] = val",
      "mutated_line": "res[mini_of_heap[-1]] = val",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == 0:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 1) == 0:\n                min_real = i // (val + 1) + 1\n            else:\n                min_real = i // (val + 1) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[-1]] = val\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "ranges_begin = [[] for _ in range(n + 1)]",
      "mutated_line": "ranges_begin = [[] for _ in range(n + 2)]",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 2)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == 0:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 1) == 0:\n                min_real = i // (val + 1) + 1\n            else:\n                min_real = i // (val + 1) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "ranges_begin = [[] for _ in range(n + 1)]",
      "mutated_line": "ranges_begin = [[] for _ in range(n + 0)]",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 0)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == 0:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 1) == 0:\n                min_real = i // (val + 1) + 1\n            else:\n                min_real = i // (val + 1) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "ranges_begin = [[] for _ in range(n + 1)]",
      "mutated_line": "ranges_begin = [[] for _ in range(n + 0)]",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 0)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == 0:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 1) == 0:\n                min_real = i // (val + 1) + 1\n            else:\n                min_real = i // (val + 1) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "ranges_begin = [[] for _ in range(n + 1)]",
      "mutated_line": "ranges_begin = [[] for _ in range(n + -1)]",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + -1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == 0:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 1) == 0:\n                min_real = i // (val + 1) + 1\n            else:\n                min_real = i // (val + 1) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if i % (val + 1) == 0:",
      "mutated_line": "if i % (val - 1) == 0:",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == 0:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val - 1) == 0:\n                min_real = i // (val + 1) + 1\n            else:\n                min_real = i // (val + 1) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if i % (val + 1) == 0:",
      "mutated_line": "if i % (val * 1) == 0:",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == 0:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val * 1) == 0:\n                min_real = i // (val + 1) + 1\n            else:\n                min_real = i // (val + 1) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "min_real = i // (val + 1) + 1",
      "mutated_line": "min_real = i / (val + 1) + 1",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == 0:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 1) == 0:\n                min_real = i / (val + 1) + 1\n            else:\n                min_real = i // (val + 1) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "min_real = i // (val + 1) + 1",
      "mutated_line": "min_real = i * (val + 1) + 1",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == 0:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 1) == 0:\n                min_real = i * (val + 1) + 1\n            else:\n                min_real = i // (val + 1) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "min_real = i // (val + 1) + 1",
      "mutated_line": "min_real = i // (val + 1) + 2",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == 0:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 1) == 0:\n                min_real = i // (val + 1) + 2\n            else:\n                min_real = i // (val + 1) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "min_real = i // (val + 1) + 1",
      "mutated_line": "min_real = i // (val + 1) + 0",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == 0:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 1) == 0:\n                min_real = i // (val + 1) + 0\n            else:\n                min_real = i // (val + 1) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "min_real = i // (val + 1) + 1",
      "mutated_line": "min_real = i // (val + 1) + 0",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == 0:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 1) == 0:\n                min_real = i // (val + 1) + 0\n            else:\n                min_real = i // (val + 1) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "min_real = i // (val + 1) + 1",
      "mutated_line": "min_real = i // (val + 1) + -1",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == 0:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 1) == 0:\n                min_real = i // (val + 1) + -1\n            else:\n                min_real = i // (val + 1) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "min_real = i // (val + 1) + 1",
      "mutated_line": "min_real = i / (val + 1) + 1",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == 0:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 1) == 0:\n                min_real = i // (val + 1) + 1\n            else:\n                min_real = i / (val + 1) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "min_real = i // (val + 1) + 1",
      "mutated_line": "min_real = i * (val + 1) + 1",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == 0:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 1) == 0:\n                min_real = i // (val + 1) + 1\n            else:\n                min_real = i * (val + 1) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "min_real = i // (val + 1) + 1",
      "mutated_line": "min_real = i // (val + 1) + 2",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == 0:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 1) == 0:\n                min_real = i // (val + 1) + 1\n            else:\n                min_real = i // (val + 1) + 2\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "min_real = i // (val + 1) + 1",
      "mutated_line": "min_real = i // (val + 1) + 0",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == 0:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 1) == 0:\n                min_real = i // (val + 1) + 1\n            else:\n                min_real = i // (val + 1) + 0\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "min_real = i // (val + 1) + 1",
      "mutated_line": "min_real = i // (val + 1) + 0",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == 0:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 1) == 0:\n                min_real = i // (val + 1) + 1\n            else:\n                min_real = i // (val + 1) + 0\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "min_real = i // (val + 1) + 1",
      "mutated_line": "min_real = i // (val + 1) + -1",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == 0:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 1) == 0:\n                min_real = i // (val + 1) + 1\n            else:\n                min_real = i // (val + 1) + -1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if i % (val + 1) == 0:",
      "mutated_line": "if i % (val + 2) == 0:",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == 0:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 2) == 0:\n                min_real = i // (val + 1) + 1\n            else:\n                min_real = i // (val + 1) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if i % (val + 1) == 0:",
      "mutated_line": "if i % (val + 0) == 0:",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == 0:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 0) == 0:\n                min_real = i // (val + 1) + 1\n            else:\n                min_real = i // (val + 1) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if i % (val + 1) == 0:",
      "mutated_line": "if i % (val + 0) == 0:",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == 0:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 0) == 0:\n                min_real = i // (val + 1) + 1\n            else:\n                min_real = i // (val + 1) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if i % (val + 1) == 0:",
      "mutated_line": "if i % (val + -1) == 0:",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == 0:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + -1) == 0:\n                min_real = i // (val + 1) + 1\n            else:\n                min_real = i // (val + 1) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "min_real = i // (val + 1) + 1",
      "mutated_line": "min_real = i // (val - 1) + 1",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == 0:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 1) == 0:\n                min_real = i // (val - 1) + 1\n            else:\n                min_real = i // (val + 1) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "min_real = i // (val + 1) + 1",
      "mutated_line": "min_real = i // (val * 1) + 1",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == 0:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 1) == 0:\n                min_real = i // (val * 1) + 1\n            else:\n                min_real = i // (val + 1) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "min_real = i // (val + 1) + 1",
      "mutated_line": "min_real = i // (val - 1) + 1",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == 0:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 1) == 0:\n                min_real = i // (val + 1) + 1\n            else:\n                min_real = i // (val - 1) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "min_real = i // (val + 1) + 1",
      "mutated_line": "min_real = i // (val * 1) + 1",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == 0:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 1) == 0:\n                min_real = i // (val + 1) + 1\n            else:\n                min_real = i // (val * 1) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "min_real = i // (val + 1) + 1",
      "mutated_line": "min_real = i // (val + 2) + 1",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == 0:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 1) == 0:\n                min_real = i // (val + 2) + 1\n            else:\n                min_real = i // (val + 1) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "min_real = i // (val + 1) + 1",
      "mutated_line": "min_real = i // (val + 0) + 1",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == 0:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 1) == 0:\n                min_real = i // (val + 0) + 1\n            else:\n                min_real = i // (val + 1) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "min_real = i // (val + 1) + 1",
      "mutated_line": "min_real = i // (val + 0) + 1",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == 0:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 1) == 0:\n                min_real = i // (val + 0) + 1\n            else:\n                min_real = i // (val + 1) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "min_real = i // (val + 1) + 1",
      "mutated_line": "min_real = i // (val + -1) + 1",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == 0:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 1) == 0:\n                min_real = i // (val + -1) + 1\n            else:\n                min_real = i // (val + 1) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "min_real = i // (val + 1) + 1",
      "mutated_line": "min_real = i // (val + 2) + 1",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == 0:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 1) == 0:\n                min_real = i // (val + 1) + 1\n            else:\n                min_real = i // (val + 2) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "min_real = i // (val + 1) + 1",
      "mutated_line": "min_real = i // (val + 0) + 1",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == 0:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 1) == 0:\n                min_real = i // (val + 1) + 1\n            else:\n                min_real = i // (val + 0) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "min_real = i // (val + 1) + 1",
      "mutated_line": "min_real = i // (val + 0) + 1",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == 0:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 1) == 0:\n                min_real = i // (val + 1) + 1\n            else:\n                min_real = i // (val + 0) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "min_real = i // (val + 1) + 1",
      "mutated_line": "min_real = i // (val + -1) + 1",
      "code": "def restore_permutation(b: list[int]) -> list[int]:\n    \"\"\"\n    Restores the permutation `a` from the given array `b` where `b_i = floor(i / a_i)`.\n\n    Parameters:\n    b (list[int]): The array derived from the permutation `a`.\n\n    Returns:\n    list[int]: The restored permutation `a`.\n    \"\"\"\n    n = len(b)\n    ranges_begin = [[] for _ in range(n + 1)]\n    for j in range(n):\n        val = b[j]\n        i = j + 1\n        if val == 0:\n            min_real = i + 1\n            max_real = n\n        else:\n            max_real = i // val\n            if i % (val + 1) == 0:\n                min_real = i // (val + 1) + 1\n            else:\n                min_real = i // (val + -1) + 1\n        ranges_begin[max_real].append((-min_real, j))\n    res = [0] * n\n    my_heap = []\n    for val in range(n, 0, -1):\n        for r in ranges_begin[val]:\n            heapq.heappush(my_heap, r)\n        mini_of_heap = heapq.heappop(my_heap)\n        res[mini_of_heap[1]] = val\n    return res"
    }
  ]
}