{
  "task_id": "taco_5336",
  "entry_point": "construct_non_adjacent_matrix",
  "mutant_count": 180,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if n == 1:",
      "mutated_line": "if n != 1:",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n != 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if n == 1:",
      "mutated_line": "if n == 2:",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 2:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if n == 1:",
      "mutated_line": "if n == 0:",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 0:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if n == 1:",
      "mutated_line": "if n == 0:",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 0:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if n == 1:",
      "mutated_line": "if n == -1:",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == -1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "elif n == 2:",
      "mutated_line": "elif n != 2:",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n != 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "elif n == 2:",
      "mutated_line": "elif n == 3:",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 3:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "elif n == 2:",
      "mutated_line": "elif n == 1:",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 1:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "elif n == 2:",
      "mutated_line": "elif n == 0:",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 0:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "elif n == 2:",
      "mutated_line": "elif n == 1:",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 1:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "elif n == 2:",
      "mutated_line": "elif n == -2:",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == -2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "UOI",
      "lineno": 16,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return +1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "elif n == 3:",
      "mutated_line": "elif n != 3:",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n != 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return [[1]]",
      "mutated_line": "return [[2]]",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[2]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return [[1]]",
      "mutated_line": "return [[0]]",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[0]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return [[1]]",
      "mutated_line": "return [[0]]",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[0]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return [[1]]",
      "mutated_line": "return [[-1]]",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[-1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -2\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -0\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -0\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return --1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "elif n == 3:",
      "mutated_line": "elif n == 4:",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 4:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "elif n == 3:",
      "mutated_line": "elif n == 2:",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 2:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "elif n == 3:",
      "mutated_line": "elif n == 0:",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 0:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "elif n == 3:",
      "mutated_line": "elif n == 1:",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 1:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "elif n == 3:",
      "mutated_line": "elif n == -3:",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == -3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 2 != 1:",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 != 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "for i in range(n ** 2 // 2 * 2):",
      "mutated_line": "for i in range(n ** 2 // 2 / 2):",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 / 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "for i in range(n ** 2 // 2 * 2):",
      "mutated_line": "for i in range(n ** 2 // 2 + 2):",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 + 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "for i in range(n ** 2 // 2 * 2):",
      "mutated_line": "for i in range((n ** 2 // 2) ** 2):",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range((n ** 2 // 2) ** 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 2 != 1:",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 != 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n * 2 == 1:",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n * 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n + 2 == 1:",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n + 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 2 == 2:",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 2:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 2 == 0:",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 0:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 2 == 0:",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 0:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 2 == -1:",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == -1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "[2, 9, 7],",
      "mutated_line": "return [[3, 9, 7], [4, 6, 3], [1, 8, 5]]",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[3, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "[2, 9, 7],",
      "mutated_line": "return [[1, 9, 7], [4, 6, 3], [1, 8, 5]]",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[1, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "[2, 9, 7],",
      "mutated_line": "return [[0, 9, 7], [4, 6, 3], [1, 8, 5]]",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[0, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "[2, 9, 7],",
      "mutated_line": "return [[1, 9, 7], [4, 6, 3], [1, 8, 5]]",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[1, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "[2, 9, 7],",
      "mutated_line": "return [[-2, 9, 7], [4, 6, 3], [1, 8, 5]]",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[-2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "[2, 9, 7],",
      "mutated_line": "return [[2, 10, 7], [4, 6, 3], [1, 8, 5]]",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 10, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "[2, 9, 7],",
      "mutated_line": "return [[2, 8, 7], [4, 6, 3], [1, 8, 5]]",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 8, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "[2, 9, 7],",
      "mutated_line": "return [[2, 0, 7], [4, 6, 3], [1, 8, 5]]",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 0, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "[2, 9, 7],",
      "mutated_line": "return [[2, 1, 7], [4, 6, 3], [1, 8, 5]]",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 1, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "[2, 9, 7],",
      "mutated_line": "return [[2, -9, 7], [4, 6, 3], [1, 8, 5]]",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, -9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "[2, 9, 7],",
      "mutated_line": "return [[2, 9, 8], [4, 6, 3], [1, 8, 5]]",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 8], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "[2, 9, 7],",
      "mutated_line": "return [[2, 9, 6], [4, 6, 3], [1, 8, 5]]",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 6], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "[2, 9, 7],",
      "mutated_line": "return [[2, 9, 0], [4, 6, 3], [1, 8, 5]]",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 0], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "[2, 9, 7],",
      "mutated_line": "return [[2, 9, 1], [4, 6, 3], [1, 8, 5]]",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 1], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "[2, 9, 7],",
      "mutated_line": "return [[2, 9, -7], [4, 6, 3], [1, 8, 5]]",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, -7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "[4, 6, 3],",
      "mutated_line": "return [[2, 9, 7], [5, 6, 3], [1, 8, 5]]",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [5, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "[4, 6, 3],",
      "mutated_line": "return [[2, 9, 7], [3, 6, 3], [1, 8, 5]]",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [3, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "[4, 6, 3],",
      "mutated_line": "return [[2, 9, 7], [0, 6, 3], [1, 8, 5]]",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [0, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "[4, 6, 3],",
      "mutated_line": "return [[2, 9, 7], [1, 6, 3], [1, 8, 5]]",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [1, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "[4, 6, 3],",
      "mutated_line": "return [[2, 9, 7], [-4, 6, 3], [1, 8, 5]]",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [-4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "[4, 6, 3],",
      "mutated_line": "return [[2, 9, 7], [4, 7, 3], [1, 8, 5]]",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 7, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "[4, 6, 3],",
      "mutated_line": "return [[2, 9, 7], [4, 5, 3], [1, 8, 5]]",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 5, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "[4, 6, 3],",
      "mutated_line": "return [[2, 9, 7], [4, 0, 3], [1, 8, 5]]",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 0, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "[4, 6, 3],",
      "mutated_line": "return [[2, 9, 7], [4, 1, 3], [1, 8, 5]]",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 1, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "[4, 6, 3],",
      "mutated_line": "return [[2, 9, 7], [4, -6, 3], [1, 8, 5]]",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, -6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "[4, 6, 3],",
      "mutated_line": "return [[2, 9, 7], [4, 6, 4], [1, 8, 5]]",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 4], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "[4, 6, 3],",
      "mutated_line": "return [[2, 9, 7], [4, 6, 2], [1, 8, 5]]",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 2], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "[4, 6, 3],",
      "mutated_line": "return [[2, 9, 7], [4, 6, 0], [1, 8, 5]]",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 0], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "[4, 6, 3],",
      "mutated_line": "return [[2, 9, 7], [4, 6, 1], [1, 8, 5]]",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 1], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "[4, 6, 3],",
      "mutated_line": "return [[2, 9, 7], [4, 6, -3], [1, 8, 5]]",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, -3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "[1, 8, 5]",
      "mutated_line": "return [[2, 9, 7], [4, 6, 3], [2, 8, 5]]",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [2, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "[1, 8, 5]",
      "mutated_line": "return [[2, 9, 7], [4, 6, 3], [0, 8, 5]]",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [0, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "[1, 8, 5]",
      "mutated_line": "return [[2, 9, 7], [4, 6, 3], [0, 8, 5]]",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [0, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "[1, 8, 5]",
      "mutated_line": "return [[2, 9, 7], [4, 6, 3], [-1, 8, 5]]",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [-1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "[1, 8, 5]",
      "mutated_line": "return [[2, 9, 7], [4, 6, 3], [1, 9, 5]]",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 9, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "[1, 8, 5]",
      "mutated_line": "return [[2, 9, 7], [4, 6, 3], [1, 7, 5]]",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 7, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "[1, 8, 5]",
      "mutated_line": "return [[2, 9, 7], [4, 6, 3], [1, 0, 5]]",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 0, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "[1, 8, 5]",
      "mutated_line": "return [[2, 9, 7], [4, 6, 3], [1, 1, 5]]",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 1, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "[1, 8, 5]",
      "mutated_line": "return [[2, 9, 7], [4, 6, 3], [1, -8, 5]]",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, -8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "[1, 8, 5]",
      "mutated_line": "return [[2, 9, 7], [4, 6, 3], [1, 8, 6]]",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 6]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "[1, 8, 5]",
      "mutated_line": "return [[2, 9, 7], [4, 6, 3], [1, 8, 4]]",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 4]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "[1, 8, 5]",
      "mutated_line": "return [[2, 9, 7], [4, 6, 3], [1, 8, 0]]",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 0]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "[1, 8, 5]",
      "mutated_line": "return [[2, 9, 7], [4, 6, 3], [1, 8, 1]]",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 1]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "[1, 8, 5]",
      "mutated_line": "return [[2, 9, 7], [4, 6, 3], [1, 8, -5]]",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, -5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "for i in range(n ** 2 // 2 * 2):",
      "mutated_line": "for i in range(n ** 2 / 2 * 2):",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 / 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "for i in range(n ** 2 // 2 * 2):",
      "mutated_line": "for i in range(n ** 2 * 2 * 2):",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 * 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(n ** 2 // 2 * 2):",
      "mutated_line": "for i in range(n ** 2 // 2 * 3):",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 3):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(n ** 2 // 2 * 2):",
      "mutated_line": "for i in range(n ** 2 // 2 * 1):",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 1):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(n ** 2 // 2 * 2):",
      "mutated_line": "for i in range(n ** 2 // 2 * 0):",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 0):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(n ** 2 // 2 * 2):",
      "mutated_line": "for i in range(n ** 2 // 2 * 1):",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 1):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(n ** 2 // 2 * 2):",
      "mutated_line": "for i in range(n ** 2 // 2 * -2):",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * -2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "l.append(i + 1)",
      "mutated_line": "l.append(i - 1)",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i - 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "l.append(i + 1)",
      "mutated_line": "l.append(i * 1)",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i * 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n * 2 == 1:",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n * 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n + 2 == 1:",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n + 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 2 == 2:",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 2:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 2 == 0:",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 0:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 2 == 0:",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 0:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 2 == -1:",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == -1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 3 == 1:",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 3 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 1 == 1:",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 1 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 0 == 1:",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 0 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 1 == 1:",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 1 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % -2 == 1:",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % -2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "l.append(n ** 2)",
      "mutated_line": "l.append(n * 2)",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n * 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "l.append(n ** 2)",
      "mutated_line": "l.append(n + 2)",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n + 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "for i in range(n ** 2 // 2 * 2):",
      "mutated_line": "for i in range(n * 2 // 2 * 2):",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n * 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "for i in range(n ** 2 // 2 * 2):",
      "mutated_line": "for i in range((n + 2) // 2 * 2):",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range((n + 2) // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(n ** 2 // 2 * 2):",
      "mutated_line": "for i in range(n ** 2 // 3 * 2):",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 3 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(n ** 2 // 2 * 2):",
      "mutated_line": "for i in range(n ** 2 // 1 * 2):",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 1 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(n ** 2 // 2 * 2):",
      "mutated_line": "for i in range(n ** 2 // 0 * 2):",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 0 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(n ** 2 // 2 * 2):",
      "mutated_line": "for i in range(n ** 2 // 1 * 2):",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 1 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(n ** 2 // 2 * 2):",
      "mutated_line": "for i in range(n ** 2 // -2 * 2):",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // -2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "l.append(i + 1)",
      "mutated_line": "l.append(i + 2)",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 2)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "l.append(i + 1)",
      "mutated_line": "l.append(i + 0)",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 0)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "l.append(i + 1)",
      "mutated_line": "l.append(i + 0)",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 0)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "l.append(i + 1)",
      "mutated_line": "l.append(i + -1)",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + -1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 3 == 1:",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 3 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 1 == 1:",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 1 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 0 == 1:",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 0 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 1 == 1:",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 1 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % -2 == 1:",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % -2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "l.append(n ** 2 // 2 + 2 + i)",
      "mutated_line": "l.append(n ** 2 // 2 + 2 - i)",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 - i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "l.append(n ** 2 // 2 + 2 + i)",
      "mutated_line": "l.append((n ** 2 // 2 + 2) * i)",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append((n ** 2 // 2 + 2) * i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "l.append(n ** 2)",
      "mutated_line": "l.append(n ** 3)",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 3)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "l.append(n ** 2)",
      "mutated_line": "l.append(n ** 1)",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 1)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "l.append(n ** 2)",
      "mutated_line": "l.append(n ** 0)",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 0)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "l.append(n ** 2)",
      "mutated_line": "l.append(n ** 1)",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 1)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "l.append(n ** 2)",
      "mutated_line": "l.append(n ** -2)",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** -2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(n ** 2 // 2 * 2):",
      "mutated_line": "for i in range(n ** 3 // 2 * 2):",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 3 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(n ** 2 // 2 * 2):",
      "mutated_line": "for i in range(n ** 1 // 2 * 2):",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 1 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(n ** 2 // 2 * 2):",
      "mutated_line": "for i in range(n ** 0 // 2 * 2):",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 0 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(n ** 2 // 2 * 2):",
      "mutated_line": "for i in range(n ** 1 // 2 * 2):",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 1 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(n ** 2 // 2 * 2):",
      "mutated_line": "for i in range(n ** -2 // 2 * 2):",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** -2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "l.append(n ** 2 // 2 + 2 + i)",
      "mutated_line": "l.append(n ** 2 // 2 - 2 + i)",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 - 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "l.append(n ** 2 // 2 + 2 + i)",
      "mutated_line": "l.append(n ** 2 // 2 * 2 + i)",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 * 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "l.append(int(n ** 2 / 2 + 1 + i))",
      "mutated_line": "l.append(int(n ** 2 / 2 + 1 - i))",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 - i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "l.append(int(n ** 2 / 2 + 1 + i))",
      "mutated_line": "l.append(int((n ** 2 / 2 + 1) * i))",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int((n ** 2 / 2 + 1) * i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "a.append(l[n * i + j])",
      "mutated_line": "a.append(l[n * i - j])",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i - j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "a.append(l[n * i + j])",
      "mutated_line": "a.append(l[n * i * j])",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i * j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "l.append(n ** 2 // 2 + 2 + i)",
      "mutated_line": "l.append(n ** 2 / 2 + 2 + i)",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 / 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "l.append(n ** 2 // 2 + 2 + i)",
      "mutated_line": "l.append(n ** 2 * 2 + 2 + i)",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 * 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "l.append(n ** 2 // 2 + 2 + i)",
      "mutated_line": "l.append(n ** 2 // 2 + 3 + i)",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 3 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "l.append(n ** 2 // 2 + 2 + i)",
      "mutated_line": "l.append(n ** 2 // 2 + 1 + i)",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 1 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "l.append(n ** 2 // 2 + 2 + i)",
      "mutated_line": "l.append(n ** 2 // 2 + 0 + i)",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 0 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "l.append(n ** 2 // 2 + 2 + i)",
      "mutated_line": "l.append(n ** 2 // 2 + 1 + i)",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 1 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "l.append(n ** 2 // 2 + 2 + i)",
      "mutated_line": "l.append(n ** 2 // 2 + -2 + i)",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + -2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "l.append(int(n ** 2 / 2 + 1 + i))",
      "mutated_line": "l.append(int(n ** 2 / 2 - 1 + i))",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 - 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "l.append(int(n ** 2 / 2 + 1 + i))",
      "mutated_line": "l.append(int(n ** 2 / 2 * 1 + i))",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 * 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "a.append(l[n * i + j])",
      "mutated_line": "a.append(l[n / i + j])",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n / i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "a.append(l[n * i + j])",
      "mutated_line": "a.append(l[n + i + j])",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n + i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "a.append(l[n * i + j])",
      "mutated_line": "a.append(l[n ** i + j])",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n ** i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "l.append(n ** 2 // 2 + 2 + i)",
      "mutated_line": "l.append(n * 2 // 2 + 2 + i)",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n * 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "l.append(n ** 2 // 2 + 2 + i)",
      "mutated_line": "l.append((n + 2) // 2 + 2 + i)",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append((n + 2) // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "l.append(n ** 2 // 2 + 2 + i)",
      "mutated_line": "l.append(n ** 2 // 3 + 2 + i)",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 3 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "l.append(n ** 2 // 2 + 2 + i)",
      "mutated_line": "l.append(n ** 2 // 1 + 2 + i)",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 1 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "l.append(n ** 2 // 2 + 2 + i)",
      "mutated_line": "l.append(n ** 2 // 0 + 2 + i)",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 0 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "l.append(n ** 2 // 2 + 2 + i)",
      "mutated_line": "l.append(n ** 2 // 1 + 2 + i)",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 1 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "l.append(n ** 2 // 2 + 2 + i)",
      "mutated_line": "l.append(n ** 2 // -2 + 2 + i)",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // -2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "l.append(int(n ** 2 / 2 + 1 + i))",
      "mutated_line": "l.append(int(n ** 2 * 2 + 1 + i))",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 * 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "l.append(int(n ** 2 / 2 + 1 + i))",
      "mutated_line": "l.append(int(n ** 2 // 2 + 1 + i))",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 // 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "l.append(int(n ** 2 / 2 + 1 + i))",
      "mutated_line": "l.append(int(n ** 2 / 2 + 2 + i))",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 2 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "l.append(int(n ** 2 / 2 + 1 + i))",
      "mutated_line": "l.append(int(n ** 2 / 2 + 0 + i))",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 0 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "l.append(int(n ** 2 / 2 + 1 + i))",
      "mutated_line": "l.append(int(n ** 2 / 2 + 0 + i))",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 0 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "l.append(int(n ** 2 / 2 + 1 + i))",
      "mutated_line": "l.append(int(n ** 2 / 2 + -1 + i))",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + -1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "l.append(n ** 2 // 2 + 2 + i)",
      "mutated_line": "l.append(n ** 3 // 2 + 2 + i)",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 3 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "l.append(n ** 2 // 2 + 2 + i)",
      "mutated_line": "l.append(n ** 1 // 2 + 2 + i)",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 1 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "l.append(n ** 2 // 2 + 2 + i)",
      "mutated_line": "l.append(n ** 0 // 2 + 2 + i)",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 0 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "l.append(n ** 2 // 2 + 2 + i)",
      "mutated_line": "l.append(n ** 1 // 2 + 2 + i)",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 1 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "l.append(n ** 2 // 2 + 2 + i)",
      "mutated_line": "l.append(n ** -2 // 2 + 2 + i)",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** -2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "l.append(int(n ** 2 / 2 + 1 + i))",
      "mutated_line": "l.append(int(n * 2 / 2 + 1 + i))",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n * 2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "l.append(int(n ** 2 / 2 + 1 + i))",
      "mutated_line": "l.append(int((n + 2) / 2 + 1 + i))",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int((n + 2) / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "l.append(int(n ** 2 / 2 + 1 + i))",
      "mutated_line": "l.append(int(n ** 2 / 3 + 1 + i))",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 3 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "l.append(int(n ** 2 / 2 + 1 + i))",
      "mutated_line": "l.append(int(n ** 2 / 1 + 1 + i))",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 1 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "l.append(int(n ** 2 / 2 + 1 + i))",
      "mutated_line": "l.append(int(n ** 2 / 0 + 1 + i))",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 0 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "l.append(int(n ** 2 / 2 + 1 + i))",
      "mutated_line": "l.append(int(n ** 2 / 1 + 1 + i))",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / 1 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "l.append(int(n ** 2 / 2 + 1 + i))",
      "mutated_line": "l.append(int(n ** 2 / -2 + 1 + i))",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 2 / -2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "l.append(int(n ** 2 / 2 + 1 + i))",
      "mutated_line": "l.append(int(n ** 3 / 2 + 1 + i))",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 3 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "l.append(int(n ** 2 / 2 + 1 + i))",
      "mutated_line": "l.append(int(n ** 1 / 2 + 1 + i))",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 1 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "l.append(int(n ** 2 / 2 + 1 + i))",
      "mutated_line": "l.append(int(n ** 0 / 2 + 1 + i))",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 0 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "l.append(int(n ** 2 / 2 + 1 + i))",
      "mutated_line": "l.append(int(n ** 1 / 2 + 1 + i))",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** 1 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "l.append(int(n ** 2 / 2 + 1 + i))",
      "mutated_line": "l.append(int(n ** -2 / 2 + 1 + i))",
      "code": "def construct_non_adjacent_matrix(n):\n    \"\"\"\n    Constructs a square matrix of size n x n such that:\n    - Each integer from 1 to n^2 occurs exactly once.\n    - If two cells are adjacent, the numbers in them are not adjacent.\n\n    Parameters:\n    n (int): The size of the square matrix.\n\n    Returns:\n    list of lists: The constructed matrix if possible, otherwise returns -1.\n    \"\"\"\n    if n == 1:\n        return [[1]]\n    elif n == 2:\n        return -1\n    elif n == 3:\n        return [[2, 9, 7], [4, 6, 3], [1, 8, 5]]\n    else:\n        l = []\n        for i in range(n ** 2 // 2 * 2):\n            l.append(i + 1)\n            if n % 2 == 1:\n                l.append(n ** 2 // 2 + 2 + i)\n            else:\n                l.append(int(n ** -2 / 2 + 1 + i))\n        if n % 2 == 1:\n            l.append(n ** 2)\n        g = []\n        a = []\n        for i in range(n):\n            for j in range(n):\n                a.append(l[n * i + j])\n            g.append(a)\n            a = []\n        return g"
    }
  ]
}