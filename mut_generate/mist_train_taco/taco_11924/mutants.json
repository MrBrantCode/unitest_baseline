{
  "task_id": "taco_11924",
  "entry_point": "calculate_beauty",
  "mutant_count": 85,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 4,
      "original_line": "s -= 1",
      "mutated_line": "s += 1",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s += 1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 20\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 1:\n                    dist[to] = score + 1\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 5,
      "original_line": "t -= 1",
      "mutated_line": "t += 1",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t += 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 20\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 1:\n                    dist[to] = score + 1\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "s -= 1",
      "mutated_line": "s -= 2",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 2\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 20\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 1:\n                    dist[to] = score + 1\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "s -= 1",
      "mutated_line": "s -= 0",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 0\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 20\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 1:\n                    dist[to] = score + 1\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "s -= 1",
      "mutated_line": "s -= 0",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 0\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 20\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 1:\n                    dist[to] = score + 1\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "s -= 1",
      "mutated_line": "s -= -1",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= -1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 20\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 1:\n                    dist[to] = score + 1\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "t -= 1",
      "mutated_line": "t -= 2",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 2\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 20\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 1:\n                    dist[to] = score + 1\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "t -= 1",
      "mutated_line": "t -= 0",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 0\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 20\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 1:\n                    dist[to] = score + 1\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "t -= 1",
      "mutated_line": "t -= 0",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 0\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 20\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 1:\n                    dist[to] = score + 1\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "t -= 1",
      "mutated_line": "t -= -1",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= -1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 20\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 1:\n                    dist[to] = score + 1\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 8,
      "original_line": "x -= 1",
      "mutated_line": "x += 1",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x += 1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 20\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 1:\n                    dist[to] = score + 1\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 9,
      "original_line": "y -= 1",
      "mutated_line": "y += 1",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y += 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 20\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 1:\n                    dist[to] = score + 1\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 20\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 1:\n                    dist[to] = score + 1\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 1\n    for key in dic1:\n        another_key = st_dist - key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 20\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 1:\n                    dist[to] = score + 1\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = -1\n    for key in dic1:\n        another_key = st_dist - key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 20\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 1:\n                    dist[to] = score + 1\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 1\n    for key in dic1:\n        another_key = st_dist - key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "x -= 1",
      "mutated_line": "x -= 2",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 2\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 20\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 1:\n                    dist[to] = score + 1\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "x -= 1",
      "mutated_line": "x -= 0",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 0\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 20\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 1:\n                    dist[to] = score + 1\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "x -= 1",
      "mutated_line": "x -= 0",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 0\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 20\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 1:\n                    dist[to] = score + 1\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "x -= 1",
      "mutated_line": "x -= -1",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= -1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 20\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 1:\n                    dist[to] = score + 1\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "y -= 1",
      "mutated_line": "y -= 2",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 2\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 20\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 1:\n                    dist[to] = score + 1\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "y -= 1",
      "mutated_line": "y -= 0",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 0\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 20\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 1:\n                    dist[to] = score + 1\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "y -= 1",
      "mutated_line": "y -= 0",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 0\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 20\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 1:\n                    dist[to] = score + 1\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "y -= 1",
      "mutated_line": "y -= -1",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= -1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 20\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 1:\n                    dist[to] = score + 1\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 10 * 20",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 * 20\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 1:\n                    dist[to] = score + 1\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 10 + 20",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 + 20\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 1:\n                    dist[to] = score + 1\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "dist = [INF] * n",
      "mutated_line": "dist = [INF] / n",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 20\n        dist = [INF] / n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 1:\n                    dist[to] = score + 1\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "dist = [INF] * n",
      "mutated_line": "dist = [INF] + n",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 20\n        dist = [INF] + n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 1:\n                    dist[to] = score + 1\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "dist = [INF] * n",
      "mutated_line": "dist = [INF] ** n",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 20\n        dist = [INF] ** n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 1:\n                    dist[to] = score + 1\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dist[start] = 0",
      "mutated_line": "dist[start] = 1",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 20\n        dist = [INF] * n\n        dist[start] = 1\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 1:\n                    dist[to] = score + 1\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dist[start] = 0",
      "mutated_line": "dist[start] = -1",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 20\n        dist = [INF] * n\n        dist[start] = -1\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 1:\n                    dist[to] = score + 1\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dist[start] = 0",
      "mutated_line": "dist[start] = 1",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 20\n        dist = [INF] * n\n        dist[start] = 1\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 1:\n                    dist[to] = score + 1\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "another_key = st_dist - key - 2",
      "mutated_line": "another_key = st_dist - key + 2",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 20\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 1:\n                    dist[to] = score + 1\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key + 2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "another_key = st_dist - key - 2",
      "mutated_line": "another_key = (st_dist - key) * 2",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 20\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 1:\n                    dist[to] = score + 1\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = (st_dist - key) * 2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if another_key in dic2:",
      "mutated_line": "if another_key not in dic2:",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 20\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 1:\n                    dist[to] = score + 1\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 2\n        if another_key not in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 47,
      "original_line": "ans += add",
      "mutated_line": "ans -= add",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 20\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 1:\n                    dist[to] = score + 1\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans -= add\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 11 ** 20",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 11 ** 20\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 1:\n                    dist[to] = score + 1\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 9 ** 20",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 9 ** 20\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 1:\n                    dist[to] = score + 1\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 0 ** 20",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 0 ** 20\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 1:\n                    dist[to] = score + 1\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 1 ** 20",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 1 ** 20\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 1:\n                    dist[to] = score + 1\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = -10 ** 20",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = -10 ** 20\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 1:\n                    dist[to] = score + 1\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 10 ** 21",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 21\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 1:\n                    dist[to] = score + 1\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 10 ** 19",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 19\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 1:\n                    dist[to] = score + 1\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 10 ** 0",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 0\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 1:\n                    dist[to] = score + 1\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 10 ** 1",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 1\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 1:\n                    dist[to] = score + 1\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 10 ** -20",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** -20\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 1:\n                    dist[to] = score + 1\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "another_key = st_dist - key - 2",
      "mutated_line": "another_key = st_dist + key - 2",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 20\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 1:\n                    dist[to] = score + 1\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist + key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "another_key = st_dist - key - 2",
      "mutated_line": "another_key = st_dist * key - 2",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 20\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 1:\n                    dist[to] = score + 1\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist * key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "another_key = st_dist - key - 2",
      "mutated_line": "another_key = st_dist - key - 3",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 20\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 1:\n                    dist[to] = score + 1\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 3\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "another_key = st_dist - key - 2",
      "mutated_line": "another_key = st_dist - key - 1",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 20\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 1:\n                    dist[to] = score + 1\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 1\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "another_key = st_dist - key - 2",
      "mutated_line": "another_key = st_dist - key - 0",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 20\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 1:\n                    dist[to] = score + 1\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 0\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "another_key = st_dist - key - 2",
      "mutated_line": "another_key = st_dist - key - 1",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 20\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 1:\n                    dist[to] = score + 1\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 1\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "another_key = st_dist - key - 2",
      "mutated_line": "another_key = st_dist - key - -2",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 20\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 1:\n                    dist[to] = score + 1\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - -2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "add = len(dic1[key]) * len(dic2[another_key])",
      "mutated_line": "add = len(dic1[key]) / len(dic2[another_key])",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 20\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 1:\n                    dist[to] = score + 1\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) / len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "add = len(dic1[key]) * len(dic2[another_key])",
      "mutated_line": "add = len(dic1[key]) + len(dic2[another_key])",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 20\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 1:\n                    dist[to] = score + 1\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) + len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "add = len(dic1[key]) * len(dic2[another_key])",
      "mutated_line": "add = len(dic1[key]) ** len(dic2[another_key])",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 20\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 1:\n                    dist[to] = score + 1\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) ** len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "que.append((0, start))",
      "mutated_line": "que.append((1, start))",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 20\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((1, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 1:\n                    dist[to] = score + 1\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "que.append((0, start))",
      "mutated_line": "que.append((-1, start))",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 20\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((-1, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 1:\n                    dist[to] = score + 1\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "que.append((0, start))",
      "mutated_line": "que.append((1, start))",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 20\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((1, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 1:\n                    dist[to] = score + 1\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if dist[to] > score + 1:",
      "mutated_line": "if dist[to] >= score + 1:",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 20\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] >= score + 1:\n                    dist[to] = score + 1\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if dist[to] > score + 1:",
      "mutated_line": "if dist[to] <= score + 1:",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 20\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] <= score + 1:\n                    dist[to] = score + 1\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if dist[to] > score + 1:",
      "mutated_line": "if dist[to] != score + 1:",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 20\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] != score + 1:\n                    dist[to] = score + 1\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if dist[to] > score + 1:",
      "mutated_line": "if dist[to] > score - 1:",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 20\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score - 1:\n                    dist[to] = score + 1\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if dist[to] > score + 1:",
      "mutated_line": "if dist[to] > score * 1:",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 20\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score * 1:\n                    dist[to] = score + 1\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "dist[to] = score + 1",
      "mutated_line": "dist[to] = score - 1",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 20\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 1:\n                    dist[to] = score - 1\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "dist[to] = score + 1",
      "mutated_line": "dist[to] = score * 1",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 20\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 1:\n                    dist[to] = score * 1\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if to in dic2[another_key]:",
      "mutated_line": "if to not in dic2[another_key]:",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 20\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 1:\n                    dist[to] = score + 1\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to not in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 46,
      "original_line": "add -= 1",
      "mutated_line": "add += 1",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 20\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 1:\n                    dist[to] = score + 1\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add += 1\n            ans += add\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if dist[to] > score + 1:",
      "mutated_line": "if dist[to] > score + 2:",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 20\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 2:\n                    dist[to] = score + 1\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if dist[to] > score + 1:",
      "mutated_line": "if dist[to] > score + 0:",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 20\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 0:\n                    dist[to] = score + 1\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if dist[to] > score + 1:",
      "mutated_line": "if dist[to] > score + 0:",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 20\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 0:\n                    dist[to] = score + 1\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if dist[to] > score + 1:",
      "mutated_line": "if dist[to] > score + -1:",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 20\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + -1:\n                    dist[to] = score + 1\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dist[to] = score + 1",
      "mutated_line": "dist[to] = score + 2",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 20\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 1:\n                    dist[to] = score + 2\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dist[to] = score + 1",
      "mutated_line": "dist[to] = score + 0",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 20\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 1:\n                    dist[to] = score + 0\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dist[to] = score + 1",
      "mutated_line": "dist[to] = score + 0",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 20\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 1:\n                    dist[to] = score + 0\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dist[to] = score + 1",
      "mutated_line": "dist[to] = score + -1",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 20\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 1:\n                    dist[to] = score + -1\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "add -= 1",
      "mutated_line": "add -= 2",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 20\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 1:\n                    dist[to] = score + 1\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 2\n            ans += add\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "add -= 1",
      "mutated_line": "add -= 0",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 20\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 1:\n                    dist[to] = score + 1\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 0\n            ans += add\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "add -= 1",
      "mutated_line": "add -= 0",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 20\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 1:\n                    dist[to] = score + 1\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 0\n            ans += add\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "add -= 1",
      "mutated_line": "add -= -1",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 20\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 1:\n                    dist[to] = score + 1\n                    que.append((score + 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= -1\n            ans += add\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "que.append((score + 1, to))",
      "mutated_line": "que.append((score - 1, to))",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 20\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 1:\n                    dist[to] = score + 1\n                    que.append((score - 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "que.append((score + 1, to))",
      "mutated_line": "que.append((score * 1, to))",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 20\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 1:\n                    dist[to] = score + 1\n                    que.append((score * 1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "que.append((score + 1, to))",
      "mutated_line": "que.append((score + 2, to))",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 20\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 1:\n                    dist[to] = score + 1\n                    que.append((score + 2, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "que.append((score + 1, to))",
      "mutated_line": "que.append((score + 0, to))",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 20\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 1:\n                    dist[to] = score + 1\n                    que.append((score + 0, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "que.append((score + 1, to))",
      "mutated_line": "que.append((score + 0, to))",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 20\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 1:\n                    dist[to] = score + 1\n                    que.append((score + 0, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "que.append((score + 1, to))",
      "mutated_line": "que.append((score + -1, to))",
      "code": "from collections import deque, defaultdict\n\ndef calculate_beauty(n, m, s, t, edges):\n    s -= 1\n    t -= 1\n    adjacency_list = [[] for _ in range(n)]\n    for (x, y) in edges:\n        x -= 1\n        y -= 1\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n\n    def dist_from(start):\n        INF = 10 ** 20\n        dist = [INF] * n\n        dist[start] = 0\n        que = deque()\n        que.append((0, start))\n        while que:\n            (score, node) = que.popleft()\n            for to in adjacency_list[node]:\n                if dist[to] > score + 1:\n                    dist[to] = score + 1\n                    que.append((score + -1, to))\n        return dist\n    dist_from_s = dist_from(s)\n    dic1 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_s):\n        dic1[d].add(i)\n    dist_from_t = dist_from(t)\n    dic2 = defaultdict(set)\n    for (i, d) in enumerate(dist_from_t):\n        dic2[d].add(i)\n    st_dist = dist_from_s[t]\n    ans = 0\n    for key in dic1:\n        another_key = st_dist - key - 2\n        if another_key in dic2:\n            add = len(dic1[key]) * len(dic2[another_key])\n            for u in dic1[key]:\n                for to in adjacency_list[u]:\n                    if to in dic2[another_key]:\n                        add -= 1\n            ans += add\n    return ans"
    }
  ]
}