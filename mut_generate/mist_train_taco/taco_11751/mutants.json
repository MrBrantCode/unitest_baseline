{
  "task_id": "taco_11751",
  "entry_point": "can_reach_exit",
  "mutant_count": 70,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "return matrix[length - 1][length - 1] == 'x'",
      "mutated_line": "return matrix[length - 1][length - 1] != 'x'",
      "code": "def can_reach_exit(maze):\n    matrix = list(map(list, maze.splitlines()))\n    stack = [[0, 0]]\n    length = len(matrix)\n    while stack:\n        (x, y) = stack.pop()\n        if matrix[x][y] == '.':\n            matrix[x][y] = 'x'\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < length and 0 <= ny < length:\n                    stack.append([nx, ny])\n    return matrix[length - 1][length - 1] != 'x'"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if matrix[x][y] == '.':",
      "mutated_line": "if matrix[x][y] != '.':",
      "code": "def can_reach_exit(maze):\n    matrix = list(map(list, maze.splitlines()))\n    stack = [[0, 0]]\n    length = len(matrix)\n    while stack:\n        (x, y) = stack.pop()\n        if matrix[x][y] != '.':\n            matrix[x][y] = 'x'\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < length and 0 <= ny < length:\n                    stack.append([nx, ny])\n    return matrix[length - 1][length - 1] == 'x'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return matrix[length - 1][length - 1] == 'x'",
      "mutated_line": "return matrix[length - 1][length - 1] == ''",
      "code": "def can_reach_exit(maze):\n    matrix = list(map(list, maze.splitlines()))\n    stack = [[0, 0]]\n    length = len(matrix)\n    while stack:\n        (x, y) = stack.pop()\n        if matrix[x][y] == '.':\n            matrix[x][y] = 'x'\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < length and 0 <= ny < length:\n                    stack.append([nx, ny])\n    return matrix[length - 1][length - 1] == ''"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "stack = [[0, 0]]",
      "mutated_line": "stack = [[1, 0]]",
      "code": "def can_reach_exit(maze):\n    matrix = list(map(list, maze.splitlines()))\n    stack = [[1, 0]]\n    length = len(matrix)\n    while stack:\n        (x, y) = stack.pop()\n        if matrix[x][y] == '.':\n            matrix[x][y] = 'x'\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < length and 0 <= ny < length:\n                    stack.append([nx, ny])\n    return matrix[length - 1][length - 1] == 'x'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "stack = [[0, 0]]",
      "mutated_line": "stack = [[-1, 0]]",
      "code": "def can_reach_exit(maze):\n    matrix = list(map(list, maze.splitlines()))\n    stack = [[-1, 0]]\n    length = len(matrix)\n    while stack:\n        (x, y) = stack.pop()\n        if matrix[x][y] == '.':\n            matrix[x][y] = 'x'\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < length and 0 <= ny < length:\n                    stack.append([nx, ny])\n    return matrix[length - 1][length - 1] == 'x'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "stack = [[0, 0]]",
      "mutated_line": "stack = [[1, 0]]",
      "code": "def can_reach_exit(maze):\n    matrix = list(map(list, maze.splitlines()))\n    stack = [[1, 0]]\n    length = len(matrix)\n    while stack:\n        (x, y) = stack.pop()\n        if matrix[x][y] == '.':\n            matrix[x][y] = 'x'\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < length and 0 <= ny < length:\n                    stack.append([nx, ny])\n    return matrix[length - 1][length - 1] == 'x'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "stack = [[0, 0]]",
      "mutated_line": "stack = [[0, 1]]",
      "code": "def can_reach_exit(maze):\n    matrix = list(map(list, maze.splitlines()))\n    stack = [[0, 1]]\n    length = len(matrix)\n    while stack:\n        (x, y) = stack.pop()\n        if matrix[x][y] == '.':\n            matrix[x][y] = 'x'\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < length and 0 <= ny < length:\n                    stack.append([nx, ny])\n    return matrix[length - 1][length - 1] == 'x'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "stack = [[0, 0]]",
      "mutated_line": "stack = [[0, -1]]",
      "code": "def can_reach_exit(maze):\n    matrix = list(map(list, maze.splitlines()))\n    stack = [[0, -1]]\n    length = len(matrix)\n    while stack:\n        (x, y) = stack.pop()\n        if matrix[x][y] == '.':\n            matrix[x][y] = 'x'\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < length and 0 <= ny < length:\n                    stack.append([nx, ny])\n    return matrix[length - 1][length - 1] == 'x'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "stack = [[0, 0]]",
      "mutated_line": "stack = [[0, 1]]",
      "code": "def can_reach_exit(maze):\n    matrix = list(map(list, maze.splitlines()))\n    stack = [[0, 1]]\n    length = len(matrix)\n    while stack:\n        (x, y) = stack.pop()\n        if matrix[x][y] == '.':\n            matrix[x][y] = 'x'\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < length and 0 <= ny < length:\n                    stack.append([nx, ny])\n    return matrix[length - 1][length - 1] == 'x'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if matrix[x][y] == '.':",
      "mutated_line": "if matrix[x][y] == '':",
      "code": "def can_reach_exit(maze):\n    matrix = list(map(list, maze.splitlines()))\n    stack = [[0, 0]]\n    length = len(matrix)\n    while stack:\n        (x, y) = stack.pop()\n        if matrix[x][y] == '':\n            matrix[x][y] = 'x'\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < length and 0 <= ny < length:\n                    stack.append([nx, ny])\n    return matrix[length - 1][length - 1] == 'x'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "matrix[x][y] = 'x'",
      "mutated_line": "matrix[x][y] = ''",
      "code": "def can_reach_exit(maze):\n    matrix = list(map(list, maze.splitlines()))\n    stack = [[0, 0]]\n    length = len(matrix)\n    while stack:\n        (x, y) = stack.pop()\n        if matrix[x][y] == '.':\n            matrix[x][y] = ''\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < length and 0 <= ny < length:\n                    stack.append([nx, ny])\n    return matrix[length - 1][length - 1] == 'x'"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return matrix[length - 1][length - 1] == 'x'",
      "mutated_line": "return matrix[length - 1][length + 1] == 'x'",
      "code": "def can_reach_exit(maze):\n    matrix = list(map(list, maze.splitlines()))\n    stack = [[0, 0]]\n    length = len(matrix)\n    while stack:\n        (x, y) = stack.pop()\n        if matrix[x][y] == '.':\n            matrix[x][y] = 'x'\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < length and 0 <= ny < length:\n                    stack.append([nx, ny])\n    return matrix[length - 1][length + 1] == 'x'"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return matrix[length - 1][length - 1] == 'x'",
      "mutated_line": "return matrix[length - 1][length * 1] == 'x'",
      "code": "def can_reach_exit(maze):\n    matrix = list(map(list, maze.splitlines()))\n    stack = [[0, 0]]\n    length = len(matrix)\n    while stack:\n        (x, y) = stack.pop()\n        if matrix[x][y] == '.':\n            matrix[x][y] = 'x'\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < length and 0 <= ny < length:\n                    stack.append([nx, ny])\n    return matrix[length - 1][length * 1] == 'x'"
    },
    {
      "operator": "LCR",
      "lineno": 12,
      "original_line": "if 0 <= nx < length and 0 <= ny < length:",
      "mutated_line": "if 0 <= nx < length or 0 <= ny < length:",
      "code": "def can_reach_exit(maze):\n    matrix = list(map(list, maze.splitlines()))\n    stack = [[0, 0]]\n    length = len(matrix)\n    while stack:\n        (x, y) = stack.pop()\n        if matrix[x][y] == '.':\n            matrix[x][y] = 'x'\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < length or 0 <= ny < length:\n                    stack.append([nx, ny])\n    return matrix[length - 1][length - 1] == 'x'"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return matrix[length - 1][length - 1] == 'x'",
      "mutated_line": "return matrix[length + 1][length - 1] == 'x'",
      "code": "def can_reach_exit(maze):\n    matrix = list(map(list, maze.splitlines()))\n    stack = [[0, 0]]\n    length = len(matrix)\n    while stack:\n        (x, y) = stack.pop()\n        if matrix[x][y] == '.':\n            matrix[x][y] = 'x'\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < length and 0 <= ny < length:\n                    stack.append([nx, ny])\n    return matrix[length + 1][length - 1] == 'x'"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return matrix[length - 1][length - 1] == 'x'",
      "mutated_line": "return matrix[length * 1][length - 1] == 'x'",
      "code": "def can_reach_exit(maze):\n    matrix = list(map(list, maze.splitlines()))\n    stack = [[0, 0]]\n    length = len(matrix)\n    while stack:\n        (x, y) = stack.pop()\n        if matrix[x][y] == '.':\n            matrix[x][y] = 'x'\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < length and 0 <= ny < length:\n                    stack.append([nx, ny])\n    return matrix[length * 1][length - 1] == 'x'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return matrix[length - 1][length - 1] == 'x'",
      "mutated_line": "return matrix[length - 1][length - 2] == 'x'",
      "code": "def can_reach_exit(maze):\n    matrix = list(map(list, maze.splitlines()))\n    stack = [[0, 0]]\n    length = len(matrix)\n    while stack:\n        (x, y) = stack.pop()\n        if matrix[x][y] == '.':\n            matrix[x][y] = 'x'\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < length and 0 <= ny < length:\n                    stack.append([nx, ny])\n    return matrix[length - 1][length - 2] == 'x'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return matrix[length - 1][length - 1] == 'x'",
      "mutated_line": "return matrix[length - 1][length - 0] == 'x'",
      "code": "def can_reach_exit(maze):\n    matrix = list(map(list, maze.splitlines()))\n    stack = [[0, 0]]\n    length = len(matrix)\n    while stack:\n        (x, y) = stack.pop()\n        if matrix[x][y] == '.':\n            matrix[x][y] = 'x'\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < length and 0 <= ny < length:\n                    stack.append([nx, ny])\n    return matrix[length - 1][length - 0] == 'x'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return matrix[length - 1][length - 1] == 'x'",
      "mutated_line": "return matrix[length - 1][length - 0] == 'x'",
      "code": "def can_reach_exit(maze):\n    matrix = list(map(list, maze.splitlines()))\n    stack = [[0, 0]]\n    length = len(matrix)\n    while stack:\n        (x, y) = stack.pop()\n        if matrix[x][y] == '.':\n            matrix[x][y] = 'x'\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < length and 0 <= ny < length:\n                    stack.append([nx, ny])\n    return matrix[length - 1][length - 0] == 'x'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return matrix[length - 1][length - 1] == 'x'",
      "mutated_line": "return matrix[length - 1][length - -1] == 'x'",
      "code": "def can_reach_exit(maze):\n    matrix = list(map(list, maze.splitlines()))\n    stack = [[0, 0]]\n    length = len(matrix)\n    while stack:\n        (x, y) = stack.pop()\n        if matrix[x][y] == '.':\n            matrix[x][y] = 'x'\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < length and 0 <= ny < length:\n                    stack.append([nx, ny])\n    return matrix[length - 1][length - -1] == 'x'"
    },
    {
      "operator": "UOI",
      "lineno": 10,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(+1, 0), (1, 0), (0, -1), (0, 1)]:",
      "code": "def can_reach_exit(maze):\n    matrix = list(map(list, maze.splitlines()))\n    stack = [[0, 0]]\n    length = len(matrix)\n    while stack:\n        (x, y) = stack.pop()\n        if matrix[x][y] == '.':\n            matrix[x][y] = 'x'\n            for (dx, dy) in [(+1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < length and 0 <= ny < length:\n                    stack.append([nx, ny])\n    return matrix[length - 1][length - 1] == 'x'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 1), (1, 0), (0, -1), (0, 1)]:",
      "code": "def can_reach_exit(maze):\n    matrix = list(map(list, maze.splitlines()))\n    stack = [[0, 0]]\n    length = len(matrix)\n    while stack:\n        (x, y) = stack.pop()\n        if matrix[x][y] == '.':\n            matrix[x][y] = 'x'\n            for (dx, dy) in [(-1, 1), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < length and 0 <= ny < length:\n                    stack.append([nx, ny])\n    return matrix[length - 1][length - 1] == 'x'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, -1), (1, 0), (0, -1), (0, 1)]:",
      "code": "def can_reach_exit(maze):\n    matrix = list(map(list, maze.splitlines()))\n    stack = [[0, 0]]\n    length = len(matrix)\n    while stack:\n        (x, y) = stack.pop()\n        if matrix[x][y] == '.':\n            matrix[x][y] = 'x'\n            for (dx, dy) in [(-1, -1), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < length and 0 <= ny < length:\n                    stack.append([nx, ny])\n    return matrix[length - 1][length - 1] == 'x'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 1), (1, 0), (0, -1), (0, 1)]:",
      "code": "def can_reach_exit(maze):\n    matrix = list(map(list, maze.splitlines()))\n    stack = [[0, 0]]\n    length = len(matrix)\n    while stack:\n        (x, y) = stack.pop()\n        if matrix[x][y] == '.':\n            matrix[x][y] = 'x'\n            for (dx, dy) in [(-1, 1), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < length and 0 <= ny < length:\n                    stack.append([nx, ny])\n    return matrix[length - 1][length - 1] == 'x'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (2, 0), (0, -1), (0, 1)]:",
      "code": "def can_reach_exit(maze):\n    matrix = list(map(list, maze.splitlines()))\n    stack = [[0, 0]]\n    length = len(matrix)\n    while stack:\n        (x, y) = stack.pop()\n        if matrix[x][y] == '.':\n            matrix[x][y] = 'x'\n            for (dx, dy) in [(-1, 0), (2, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < length and 0 <= ny < length:\n                    stack.append([nx, ny])\n    return matrix[length - 1][length - 1] == 'x'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (0, 0), (0, -1), (0, 1)]:",
      "code": "def can_reach_exit(maze):\n    matrix = list(map(list, maze.splitlines()))\n    stack = [[0, 0]]\n    length = len(matrix)\n    while stack:\n        (x, y) = stack.pop()\n        if matrix[x][y] == '.':\n            matrix[x][y] = 'x'\n            for (dx, dy) in [(-1, 0), (0, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < length and 0 <= ny < length:\n                    stack.append([nx, ny])\n    return matrix[length - 1][length - 1] == 'x'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (0, 0), (0, -1), (0, 1)]:",
      "code": "def can_reach_exit(maze):\n    matrix = list(map(list, maze.splitlines()))\n    stack = [[0, 0]]\n    length = len(matrix)\n    while stack:\n        (x, y) = stack.pop()\n        if matrix[x][y] == '.':\n            matrix[x][y] = 'x'\n            for (dx, dy) in [(-1, 0), (0, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < length and 0 <= ny < length:\n                    stack.append([nx, ny])\n    return matrix[length - 1][length - 1] == 'x'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (-1, 0), (0, -1), (0, 1)]:",
      "code": "def can_reach_exit(maze):\n    matrix = list(map(list, maze.splitlines()))\n    stack = [[0, 0]]\n    length = len(matrix)\n    while stack:\n        (x, y) = stack.pop()\n        if matrix[x][y] == '.':\n            matrix[x][y] = 'x'\n            for (dx, dy) in [(-1, 0), (-1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < length and 0 <= ny < length:\n                    stack.append([nx, ny])\n    return matrix[length - 1][length - 1] == 'x'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (1, 1), (0, -1), (0, 1)]:",
      "code": "def can_reach_exit(maze):\n    matrix = list(map(list, maze.splitlines()))\n    stack = [[0, 0]]\n    length = len(matrix)\n    while stack:\n        (x, y) = stack.pop()\n        if matrix[x][y] == '.':\n            matrix[x][y] = 'x'\n            for (dx, dy) in [(-1, 0), (1, 1), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < length and 0 <= ny < length:\n                    stack.append([nx, ny])\n    return matrix[length - 1][length - 1] == 'x'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (1, -1), (0, -1), (0, 1)]:",
      "code": "def can_reach_exit(maze):\n    matrix = list(map(list, maze.splitlines()))\n    stack = [[0, 0]]\n    length = len(matrix)\n    while stack:\n        (x, y) = stack.pop()\n        if matrix[x][y] == '.':\n            matrix[x][y] = 'x'\n            for (dx, dy) in [(-1, 0), (1, -1), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < length and 0 <= ny < length:\n                    stack.append([nx, ny])\n    return matrix[length - 1][length - 1] == 'x'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (1, 1), (0, -1), (0, 1)]:",
      "code": "def can_reach_exit(maze):\n    matrix = list(map(list, maze.splitlines()))\n    stack = [[0, 0]]\n    length = len(matrix)\n    while stack:\n        (x, y) = stack.pop()\n        if matrix[x][y] == '.':\n            matrix[x][y] = 'x'\n            for (dx, dy) in [(-1, 0), (1, 1), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < length and 0 <= ny < length:\n                    stack.append([nx, ny])\n    return matrix[length - 1][length - 1] == 'x'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (1, 0), (1, -1), (0, 1)]:",
      "code": "def can_reach_exit(maze):\n    matrix = list(map(list, maze.splitlines()))\n    stack = [[0, 0]]\n    length = len(matrix)\n    while stack:\n        (x, y) = stack.pop()\n        if matrix[x][y] == '.':\n            matrix[x][y] = 'x'\n            for (dx, dy) in [(-1, 0), (1, 0), (1, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < length and 0 <= ny < length:\n                    stack.append([nx, ny])\n    return matrix[length - 1][length - 1] == 'x'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (1, 0), (-1, -1), (0, 1)]:",
      "code": "def can_reach_exit(maze):\n    matrix = list(map(list, maze.splitlines()))\n    stack = [[0, 0]]\n    length = len(matrix)\n    while stack:\n        (x, y) = stack.pop()\n        if matrix[x][y] == '.':\n            matrix[x][y] = 'x'\n            for (dx, dy) in [(-1, 0), (1, 0), (-1, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < length and 0 <= ny < length:\n                    stack.append([nx, ny])\n    return matrix[length - 1][length - 1] == 'x'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (1, 0), (1, -1), (0, 1)]:",
      "code": "def can_reach_exit(maze):\n    matrix = list(map(list, maze.splitlines()))\n    stack = [[0, 0]]\n    length = len(matrix)\n    while stack:\n        (x, y) = stack.pop()\n        if matrix[x][y] == '.':\n            matrix[x][y] = 'x'\n            for (dx, dy) in [(-1, 0), (1, 0), (1, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < length and 0 <= ny < length:\n                    stack.append([nx, ny])\n    return matrix[length - 1][length - 1] == 'x'"
    },
    {
      "operator": "UOI",
      "lineno": 10,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (1, 0), (0, +1), (0, 1)]:",
      "code": "def can_reach_exit(maze):\n    matrix = list(map(list, maze.splitlines()))\n    stack = [[0, 0]]\n    length = len(matrix)\n    while stack:\n        (x, y) = stack.pop()\n        if matrix[x][y] == '.':\n            matrix[x][y] = 'x'\n            for (dx, dy) in [(-1, 0), (1, 0), (0, +1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < length and 0 <= ny < length:\n                    stack.append([nx, ny])\n    return matrix[length - 1][length - 1] == 'x'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (1, 1)]:",
      "code": "def can_reach_exit(maze):\n    matrix = list(map(list, maze.splitlines()))\n    stack = [[0, 0]]\n    length = len(matrix)\n    while stack:\n        (x, y) = stack.pop()\n        if matrix[x][y] == '.':\n            matrix[x][y] = 'x'\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (1, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < length and 0 <= ny < length:\n                    stack.append([nx, ny])\n    return matrix[length - 1][length - 1] == 'x'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (-1, 1)]:",
      "code": "def can_reach_exit(maze):\n    matrix = list(map(list, maze.splitlines()))\n    stack = [[0, 0]]\n    length = len(matrix)\n    while stack:\n        (x, y) = stack.pop()\n        if matrix[x][y] == '.':\n            matrix[x][y] = 'x'\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (-1, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < length and 0 <= ny < length:\n                    stack.append([nx, ny])\n    return matrix[length - 1][length - 1] == 'x'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (1, 1)]:",
      "code": "def can_reach_exit(maze):\n    matrix = list(map(list, maze.splitlines()))\n    stack = [[0, 0]]\n    length = len(matrix)\n    while stack:\n        (x, y) = stack.pop()\n        if matrix[x][y] == '.':\n            matrix[x][y] = 'x'\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (1, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < length and 0 <= ny < length:\n                    stack.append([nx, ny])\n    return matrix[length - 1][length - 1] == 'x'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 2)]:",
      "code": "def can_reach_exit(maze):\n    matrix = list(map(list, maze.splitlines()))\n    stack = [[0, 0]]\n    length = len(matrix)\n    while stack:\n        (x, y) = stack.pop()\n        if matrix[x][y] == '.':\n            matrix[x][y] = 'x'\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 2)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < length and 0 <= ny < length:\n                    stack.append([nx, ny])\n    return matrix[length - 1][length - 1] == 'x'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 0)]:",
      "code": "def can_reach_exit(maze):\n    matrix = list(map(list, maze.splitlines()))\n    stack = [[0, 0]]\n    length = len(matrix)\n    while stack:\n        (x, y) = stack.pop()\n        if matrix[x][y] == '.':\n            matrix[x][y] = 'x'\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 0)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < length and 0 <= ny < length:\n                    stack.append([nx, ny])\n    return matrix[length - 1][length - 1] == 'x'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 0)]:",
      "code": "def can_reach_exit(maze):\n    matrix = list(map(list, maze.splitlines()))\n    stack = [[0, 0]]\n    length = len(matrix)\n    while stack:\n        (x, y) = stack.pop()\n        if matrix[x][y] == '.':\n            matrix[x][y] = 'x'\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 0)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < length and 0 <= ny < length:\n                    stack.append([nx, ny])\n    return matrix[length - 1][length - 1] == 'x'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, -1)]:",
      "code": "def can_reach_exit(maze):\n    matrix = list(map(list, maze.splitlines()))\n    stack = [[0, 0]]\n    length = len(matrix)\n    while stack:\n        (x, y) = stack.pop()\n        if matrix[x][y] == '.':\n            matrix[x][y] = 'x'\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, -1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < length and 0 <= ny < length:\n                    stack.append([nx, ny])\n    return matrix[length - 1][length - 1] == 'x'"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "(nx, ny) = (x - dx, y + dy)",
      "code": "def can_reach_exit(maze):\n    matrix = list(map(list, maze.splitlines()))\n    stack = [[0, 0]]\n    length = len(matrix)\n    while stack:\n        (x, y) = stack.pop()\n        if matrix[x][y] == '.':\n            matrix[x][y] = 'x'\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x - dx, y + dy)\n                if 0 <= nx < length and 0 <= ny < length:\n                    stack.append([nx, ny])\n    return matrix[length - 1][length - 1] == 'x'"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "(nx, ny) = (x * dx, y + dy)",
      "code": "def can_reach_exit(maze):\n    matrix = list(map(list, maze.splitlines()))\n    stack = [[0, 0]]\n    length = len(matrix)\n    while stack:\n        (x, y) = stack.pop()\n        if matrix[x][y] == '.':\n            matrix[x][y] = 'x'\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x * dx, y + dy)\n                if 0 <= nx < length and 0 <= ny < length:\n                    stack.append([nx, ny])\n    return matrix[length - 1][length - 1] == 'x'"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "(nx, ny) = (x + dx, y - dy)",
      "code": "def can_reach_exit(maze):\n    matrix = list(map(list, maze.splitlines()))\n    stack = [[0, 0]]\n    length = len(matrix)\n    while stack:\n        (x, y) = stack.pop()\n        if matrix[x][y] == '.':\n            matrix[x][y] = 'x'\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y - dy)\n                if 0 <= nx < length and 0 <= ny < length:\n                    stack.append([nx, ny])\n    return matrix[length - 1][length - 1] == 'x'"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "(nx, ny) = (x + dx, y * dy)",
      "code": "def can_reach_exit(maze):\n    matrix = list(map(list, maze.splitlines()))\n    stack = [[0, 0]]\n    length = len(matrix)\n    while stack:\n        (x, y) = stack.pop()\n        if matrix[x][y] == '.':\n            matrix[x][y] = 'x'\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y * dy)\n                if 0 <= nx < length and 0 <= ny < length:\n                    stack.append([nx, ny])\n    return matrix[length - 1][length - 1] == 'x'"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if 0 <= nx < length and 0 <= ny < length:",
      "mutated_line": "if 0 < nx < length and 0 <= ny < length:",
      "code": "def can_reach_exit(maze):\n    matrix = list(map(list, maze.splitlines()))\n    stack = [[0, 0]]\n    length = len(matrix)\n    while stack:\n        (x, y) = stack.pop()\n        if matrix[x][y] == '.':\n            matrix[x][y] = 'x'\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 < nx < length and 0 <= ny < length:\n                    stack.append([nx, ny])\n    return matrix[length - 1][length - 1] == 'x'"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if 0 <= nx < length and 0 <= ny < length:",
      "mutated_line": "if 0 > nx < length and 0 <= ny < length:",
      "code": "def can_reach_exit(maze):\n    matrix = list(map(list, maze.splitlines()))\n    stack = [[0, 0]]\n    length = len(matrix)\n    while stack:\n        (x, y) = stack.pop()\n        if matrix[x][y] == '.':\n            matrix[x][y] = 'x'\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 > nx < length and 0 <= ny < length:\n                    stack.append([nx, ny])\n    return matrix[length - 1][length - 1] == 'x'"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if 0 <= nx < length and 0 <= ny < length:",
      "mutated_line": "if 0 == nx < length and 0 <= ny < length:",
      "code": "def can_reach_exit(maze):\n    matrix = list(map(list, maze.splitlines()))\n    stack = [[0, 0]]\n    length = len(matrix)\n    while stack:\n        (x, y) = stack.pop()\n        if matrix[x][y] == '.':\n            matrix[x][y] = 'x'\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 == nx < length and 0 <= ny < length:\n                    stack.append([nx, ny])\n    return matrix[length - 1][length - 1] == 'x'"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if 0 <= nx < length and 0 <= ny < length:",
      "mutated_line": "if 0 <= nx < length and 0 < ny < length:",
      "code": "def can_reach_exit(maze):\n    matrix = list(map(list, maze.splitlines()))\n    stack = [[0, 0]]\n    length = len(matrix)\n    while stack:\n        (x, y) = stack.pop()\n        if matrix[x][y] == '.':\n            matrix[x][y] = 'x'\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < length and 0 < ny < length:\n                    stack.append([nx, ny])\n    return matrix[length - 1][length - 1] == 'x'"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if 0 <= nx < length and 0 <= ny < length:",
      "mutated_line": "if 0 <= nx < length and 0 > ny < length:",
      "code": "def can_reach_exit(maze):\n    matrix = list(map(list, maze.splitlines()))\n    stack = [[0, 0]]\n    length = len(matrix)\n    while stack:\n        (x, y) = stack.pop()\n        if matrix[x][y] == '.':\n            matrix[x][y] = 'x'\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < length and 0 > ny < length:\n                    stack.append([nx, ny])\n    return matrix[length - 1][length - 1] == 'x'"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if 0 <= nx < length and 0 <= ny < length:",
      "mutated_line": "if 0 <= nx < length and 0 == ny < length:",
      "code": "def can_reach_exit(maze):\n    matrix = list(map(list, maze.splitlines()))\n    stack = [[0, 0]]\n    length = len(matrix)\n    while stack:\n        (x, y) = stack.pop()\n        if matrix[x][y] == '.':\n            matrix[x][y] = 'x'\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < length and 0 == ny < length:\n                    stack.append([nx, ny])\n    return matrix[length - 1][length - 1] == 'x'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return matrix[length - 1][length - 1] == 'x'",
      "mutated_line": "return matrix[length - 2][length - 1] == 'x'",
      "code": "def can_reach_exit(maze):\n    matrix = list(map(list, maze.splitlines()))\n    stack = [[0, 0]]\n    length = len(matrix)\n    while stack:\n        (x, y) = stack.pop()\n        if matrix[x][y] == '.':\n            matrix[x][y] = 'x'\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < length and 0 <= ny < length:\n                    stack.append([nx, ny])\n    return matrix[length - 2][length - 1] == 'x'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return matrix[length - 1][length - 1] == 'x'",
      "mutated_line": "return matrix[length - 0][length - 1] == 'x'",
      "code": "def can_reach_exit(maze):\n    matrix = list(map(list, maze.splitlines()))\n    stack = [[0, 0]]\n    length = len(matrix)\n    while stack:\n        (x, y) = stack.pop()\n        if matrix[x][y] == '.':\n            matrix[x][y] = 'x'\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < length and 0 <= ny < length:\n                    stack.append([nx, ny])\n    return matrix[length - 0][length - 1] == 'x'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return matrix[length - 1][length - 1] == 'x'",
      "mutated_line": "return matrix[length - 0][length - 1] == 'x'",
      "code": "def can_reach_exit(maze):\n    matrix = list(map(list, maze.splitlines()))\n    stack = [[0, 0]]\n    length = len(matrix)\n    while stack:\n        (x, y) = stack.pop()\n        if matrix[x][y] == '.':\n            matrix[x][y] = 'x'\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < length and 0 <= ny < length:\n                    stack.append([nx, ny])\n    return matrix[length - 0][length - 1] == 'x'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return matrix[length - 1][length - 1] == 'x'",
      "mutated_line": "return matrix[length - -1][length - 1] == 'x'",
      "code": "def can_reach_exit(maze):\n    matrix = list(map(list, maze.splitlines()))\n    stack = [[0, 0]]\n    length = len(matrix)\n    while stack:\n        (x, y) = stack.pop()\n        if matrix[x][y] == '.':\n            matrix[x][y] = 'x'\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < length and 0 <= ny < length:\n                    stack.append([nx, ny])\n    return matrix[length - -1][length - 1] == 'x'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-2, 0), (1, 0), (0, -1), (0, 1)]:",
      "code": "def can_reach_exit(maze):\n    matrix = list(map(list, maze.splitlines()))\n    stack = [[0, 0]]\n    length = len(matrix)\n    while stack:\n        (x, y) = stack.pop()\n        if matrix[x][y] == '.':\n            matrix[x][y] = 'x'\n            for (dx, dy) in [(-2, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < length and 0 <= ny < length:\n                    stack.append([nx, ny])\n    return matrix[length - 1][length - 1] == 'x'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-0, 0), (1, 0), (0, -1), (0, 1)]:",
      "code": "def can_reach_exit(maze):\n    matrix = list(map(list, maze.splitlines()))\n    stack = [[0, 0]]\n    length = len(matrix)\n    while stack:\n        (x, y) = stack.pop()\n        if matrix[x][y] == '.':\n            matrix[x][y] = 'x'\n            for (dx, dy) in [(-0, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < length and 0 <= ny < length:\n                    stack.append([nx, ny])\n    return matrix[length - 1][length - 1] == 'x'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-0, 0), (1, 0), (0, -1), (0, 1)]:",
      "code": "def can_reach_exit(maze):\n    matrix = list(map(list, maze.splitlines()))\n    stack = [[0, 0]]\n    length = len(matrix)\n    while stack:\n        (x, y) = stack.pop()\n        if matrix[x][y] == '.':\n            matrix[x][y] = 'x'\n            for (dx, dy) in [(-0, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < length and 0 <= ny < length:\n                    stack.append([nx, ny])\n    return matrix[length - 1][length - 1] == 'x'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(--1, 0), (1, 0), (0, -1), (0, 1)]:",
      "code": "def can_reach_exit(maze):\n    matrix = list(map(list, maze.splitlines()))\n    stack = [[0, 0]]\n    length = len(matrix)\n    while stack:\n        (x, y) = stack.pop()\n        if matrix[x][y] == '.':\n            matrix[x][y] = 'x'\n            for (dx, dy) in [(--1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < length and 0 <= ny < length:\n                    stack.append([nx, ny])\n    return matrix[length - 1][length - 1] == 'x'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (1, 0), (0, -2), (0, 1)]:",
      "code": "def can_reach_exit(maze):\n    matrix = list(map(list, maze.splitlines()))\n    stack = [[0, 0]]\n    length = len(matrix)\n    while stack:\n        (x, y) = stack.pop()\n        if matrix[x][y] == '.':\n            matrix[x][y] = 'x'\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -2), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < length and 0 <= ny < length:\n                    stack.append([nx, ny])\n    return matrix[length - 1][length - 1] == 'x'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (1, 0), (0, -0), (0, 1)]:",
      "code": "def can_reach_exit(maze):\n    matrix = list(map(list, maze.splitlines()))\n    stack = [[0, 0]]\n    length = len(matrix)\n    while stack:\n        (x, y) = stack.pop()\n        if matrix[x][y] == '.':\n            matrix[x][y] = 'x'\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -0), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < length and 0 <= ny < length:\n                    stack.append([nx, ny])\n    return matrix[length - 1][length - 1] == 'x'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (1, 0), (0, -0), (0, 1)]:",
      "code": "def can_reach_exit(maze):\n    matrix = list(map(list, maze.splitlines()))\n    stack = [[0, 0]]\n    length = len(matrix)\n    while stack:\n        (x, y) = stack.pop()\n        if matrix[x][y] == '.':\n            matrix[x][y] = 'x'\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -0), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < length and 0 <= ny < length:\n                    stack.append([nx, ny])\n    return matrix[length - 1][length - 1] == 'x'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (1, 0), (0, --1), (0, 1)]:",
      "code": "def can_reach_exit(maze):\n    matrix = list(map(list, maze.splitlines()))\n    stack = [[0, 0]]\n    length = len(matrix)\n    while stack:\n        (x, y) = stack.pop()\n        if matrix[x][y] == '.':\n            matrix[x][y] = 'x'\n            for (dx, dy) in [(-1, 0), (1, 0), (0, --1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < length and 0 <= ny < length:\n                    stack.append([nx, ny])\n    return matrix[length - 1][length - 1] == 'x'"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if 0 <= nx < length and 0 <= ny < length:",
      "mutated_line": "if 1 <= nx < length and 0 <= ny < length:",
      "code": "def can_reach_exit(maze):\n    matrix = list(map(list, maze.splitlines()))\n    stack = [[0, 0]]\n    length = len(matrix)\n    while stack:\n        (x, y) = stack.pop()\n        if matrix[x][y] == '.':\n            matrix[x][y] = 'x'\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 1 <= nx < length and 0 <= ny < length:\n                    stack.append([nx, ny])\n    return matrix[length - 1][length - 1] == 'x'"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if 0 <= nx < length and 0 <= ny < length:",
      "mutated_line": "if -1 <= nx < length and 0 <= ny < length:",
      "code": "def can_reach_exit(maze):\n    matrix = list(map(list, maze.splitlines()))\n    stack = [[0, 0]]\n    length = len(matrix)\n    while stack:\n        (x, y) = stack.pop()\n        if matrix[x][y] == '.':\n            matrix[x][y] = 'x'\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if -1 <= nx < length and 0 <= ny < length:\n                    stack.append([nx, ny])\n    return matrix[length - 1][length - 1] == 'x'"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if 0 <= nx < length and 0 <= ny < length:",
      "mutated_line": "if 1 <= nx < length and 0 <= ny < length:",
      "code": "def can_reach_exit(maze):\n    matrix = list(map(list, maze.splitlines()))\n    stack = [[0, 0]]\n    length = len(matrix)\n    while stack:\n        (x, y) = stack.pop()\n        if matrix[x][y] == '.':\n            matrix[x][y] = 'x'\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 1 <= nx < length and 0 <= ny < length:\n                    stack.append([nx, ny])\n    return matrix[length - 1][length - 1] == 'x'"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if 0 <= nx < length and 0 <= ny < length:",
      "mutated_line": "if 0 <= nx < length and 1 <= ny < length:",
      "code": "def can_reach_exit(maze):\n    matrix = list(map(list, maze.splitlines()))\n    stack = [[0, 0]]\n    length = len(matrix)\n    while stack:\n        (x, y) = stack.pop()\n        if matrix[x][y] == '.':\n            matrix[x][y] = 'x'\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < length and 1 <= ny < length:\n                    stack.append([nx, ny])\n    return matrix[length - 1][length - 1] == 'x'"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if 0 <= nx < length and 0 <= ny < length:",
      "mutated_line": "if 0 <= nx < length and -1 <= ny < length:",
      "code": "def can_reach_exit(maze):\n    matrix = list(map(list, maze.splitlines()))\n    stack = [[0, 0]]\n    length = len(matrix)\n    while stack:\n        (x, y) = stack.pop()\n        if matrix[x][y] == '.':\n            matrix[x][y] = 'x'\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < length and -1 <= ny < length:\n                    stack.append([nx, ny])\n    return matrix[length - 1][length - 1] == 'x'"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if 0 <= nx < length and 0 <= ny < length:",
      "mutated_line": "if 0 <= nx < length and 1 <= ny < length:",
      "code": "def can_reach_exit(maze):\n    matrix = list(map(list, maze.splitlines()))\n    stack = [[0, 0]]\n    length = len(matrix)\n    while stack:\n        (x, y) = stack.pop()\n        if matrix[x][y] == '.':\n            matrix[x][y] = 'x'\n            for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                (nx, ny) = (x + dx, y + dy)\n                if 0 <= nx < length and 1 <= ny < length:\n                    stack.append([nx, ny])\n    return matrix[length - 1][length - 1] == 'x'"
    }
  ]
}