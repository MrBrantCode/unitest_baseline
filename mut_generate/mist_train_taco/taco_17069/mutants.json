{
  "task_id": "taco_17069",
  "entry_point": "find_largest_jumping_number",
  "mutant_count": 67,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "from collections import deque\n\ndef find_largest_jumping_number(X: int) -> int:\n\n    def generate_all_jumping_nums(X, i):\n        J = deque()\n        J.append(i)\n        while J:\n            num = J.popleft()\n            if num <= X:\n                nonlocal ans\n                ans = max(ans, num)\n                last_dig = num % 10\n                if last_dig != 9:\n                    J.append(num * 10 + last_dig + 1)\n                if last_dig != 0:\n                    J.append(num * 10 + last_dig - 1)\n    ans = 1\n    for i in range(1, 10):\n        if i <= X:\n            generate_all_jumping_nums(X, i)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "from collections import deque\n\ndef find_largest_jumping_number(X: int) -> int:\n\n    def generate_all_jumping_nums(X, i):\n        J = deque()\n        J.append(i)\n        while J:\n            num = J.popleft()\n            if num <= X:\n                nonlocal ans\n                ans = max(ans, num)\n                last_dig = num % 10\n                if last_dig != 9:\n                    J.append(num * 10 + last_dig + 1)\n                if last_dig != 0:\n                    J.append(num * 10 + last_dig - 1)\n    ans = -1\n    for i in range(1, 10):\n        if i <= X:\n            generate_all_jumping_nums(X, i)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "from collections import deque\n\ndef find_largest_jumping_number(X: int) -> int:\n\n    def generate_all_jumping_nums(X, i):\n        J = deque()\n        J.append(i)\n        while J:\n            num = J.popleft()\n            if num <= X:\n                nonlocal ans\n                ans = max(ans, num)\n                last_dig = num % 10\n                if last_dig != 9:\n                    J.append(num * 10 + last_dig + 1)\n                if last_dig != 0:\n                    J.append(num * 10 + last_dig - 1)\n    ans = 1\n    for i in range(1, 10):\n        if i <= X:\n            generate_all_jumping_nums(X, i)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(1, 10):",
      "mutated_line": "for i in range(2, 10):",
      "code": "from collections import deque\n\ndef find_largest_jumping_number(X: int) -> int:\n\n    def generate_all_jumping_nums(X, i):\n        J = deque()\n        J.append(i)\n        while J:\n            num = J.popleft()\n            if num <= X:\n                nonlocal ans\n                ans = max(ans, num)\n                last_dig = num % 10\n                if last_dig != 9:\n                    J.append(num * 10 + last_dig + 1)\n                if last_dig != 0:\n                    J.append(num * 10 + last_dig - 1)\n    ans = 0\n    for i in range(2, 10):\n        if i <= X:\n            generate_all_jumping_nums(X, i)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(1, 10):",
      "mutated_line": "for i in range(0, 10):",
      "code": "from collections import deque\n\ndef find_largest_jumping_number(X: int) -> int:\n\n    def generate_all_jumping_nums(X, i):\n        J = deque()\n        J.append(i)\n        while J:\n            num = J.popleft()\n            if num <= X:\n                nonlocal ans\n                ans = max(ans, num)\n                last_dig = num % 10\n                if last_dig != 9:\n                    J.append(num * 10 + last_dig + 1)\n                if last_dig != 0:\n                    J.append(num * 10 + last_dig - 1)\n    ans = 0\n    for i in range(0, 10):\n        if i <= X:\n            generate_all_jumping_nums(X, i)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(1, 10):",
      "mutated_line": "for i in range(0, 10):",
      "code": "from collections import deque\n\ndef find_largest_jumping_number(X: int) -> int:\n\n    def generate_all_jumping_nums(X, i):\n        J = deque()\n        J.append(i)\n        while J:\n            num = J.popleft()\n            if num <= X:\n                nonlocal ans\n                ans = max(ans, num)\n                last_dig = num % 10\n                if last_dig != 9:\n                    J.append(num * 10 + last_dig + 1)\n                if last_dig != 0:\n                    J.append(num * 10 + last_dig - 1)\n    ans = 0\n    for i in range(0, 10):\n        if i <= X:\n            generate_all_jumping_nums(X, i)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(1, 10):",
      "mutated_line": "for i in range(-1, 10):",
      "code": "from collections import deque\n\ndef find_largest_jumping_number(X: int) -> int:\n\n    def generate_all_jumping_nums(X, i):\n        J = deque()\n        J.append(i)\n        while J:\n            num = J.popleft()\n            if num <= X:\n                nonlocal ans\n                ans = max(ans, num)\n                last_dig = num % 10\n                if last_dig != 9:\n                    J.append(num * 10 + last_dig + 1)\n                if last_dig != 0:\n                    J.append(num * 10 + last_dig - 1)\n    ans = 0\n    for i in range(-1, 10):\n        if i <= X:\n            generate_all_jumping_nums(X, i)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(1, 10):",
      "mutated_line": "for i in range(1, 11):",
      "code": "from collections import deque\n\ndef find_largest_jumping_number(X: int) -> int:\n\n    def generate_all_jumping_nums(X, i):\n        J = deque()\n        J.append(i)\n        while J:\n            num = J.popleft()\n            if num <= X:\n                nonlocal ans\n                ans = max(ans, num)\n                last_dig = num % 10\n                if last_dig != 9:\n                    J.append(num * 10 + last_dig + 1)\n                if last_dig != 0:\n                    J.append(num * 10 + last_dig - 1)\n    ans = 0\n    for i in range(1, 11):\n        if i <= X:\n            generate_all_jumping_nums(X, i)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(1, 10):",
      "mutated_line": "for i in range(1, 9):",
      "code": "from collections import deque\n\ndef find_largest_jumping_number(X: int) -> int:\n\n    def generate_all_jumping_nums(X, i):\n        J = deque()\n        J.append(i)\n        while J:\n            num = J.popleft()\n            if num <= X:\n                nonlocal ans\n                ans = max(ans, num)\n                last_dig = num % 10\n                if last_dig != 9:\n                    J.append(num * 10 + last_dig + 1)\n                if last_dig != 0:\n                    J.append(num * 10 + last_dig - 1)\n    ans = 0\n    for i in range(1, 9):\n        if i <= X:\n            generate_all_jumping_nums(X, i)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(1, 10):",
      "mutated_line": "for i in range(1, 0):",
      "code": "from collections import deque\n\ndef find_largest_jumping_number(X: int) -> int:\n\n    def generate_all_jumping_nums(X, i):\n        J = deque()\n        J.append(i)\n        while J:\n            num = J.popleft()\n            if num <= X:\n                nonlocal ans\n                ans = max(ans, num)\n                last_dig = num % 10\n                if last_dig != 9:\n                    J.append(num * 10 + last_dig + 1)\n                if last_dig != 0:\n                    J.append(num * 10 + last_dig - 1)\n    ans = 0\n    for i in range(1, 0):\n        if i <= X:\n            generate_all_jumping_nums(X, i)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(1, 10):",
      "mutated_line": "for i in range(1, 1):",
      "code": "from collections import deque\n\ndef find_largest_jumping_number(X: int) -> int:\n\n    def generate_all_jumping_nums(X, i):\n        J = deque()\n        J.append(i)\n        while J:\n            num = J.popleft()\n            if num <= X:\n                nonlocal ans\n                ans = max(ans, num)\n                last_dig = num % 10\n                if last_dig != 9:\n                    J.append(num * 10 + last_dig + 1)\n                if last_dig != 0:\n                    J.append(num * 10 + last_dig - 1)\n    ans = 0\n    for i in range(1, 1):\n        if i <= X:\n            generate_all_jumping_nums(X, i)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(1, 10):",
      "mutated_line": "for i in range(1, -10):",
      "code": "from collections import deque\n\ndef find_largest_jumping_number(X: int) -> int:\n\n    def generate_all_jumping_nums(X, i):\n        J = deque()\n        J.append(i)\n        while J:\n            num = J.popleft()\n            if num <= X:\n                nonlocal ans\n                ans = max(ans, num)\n                last_dig = num % 10\n                if last_dig != 9:\n                    J.append(num * 10 + last_dig + 1)\n                if last_dig != 0:\n                    J.append(num * 10 + last_dig - 1)\n    ans = 0\n    for i in range(1, -10):\n        if i <= X:\n            generate_all_jumping_nums(X, i)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if i <= X:",
      "mutated_line": "if i < X:",
      "code": "from collections import deque\n\ndef find_largest_jumping_number(X: int) -> int:\n\n    def generate_all_jumping_nums(X, i):\n        J = deque()\n        J.append(i)\n        while J:\n            num = J.popleft()\n            if num <= X:\n                nonlocal ans\n                ans = max(ans, num)\n                last_dig = num % 10\n                if last_dig != 9:\n                    J.append(num * 10 + last_dig + 1)\n                if last_dig != 0:\n                    J.append(num * 10 + last_dig - 1)\n    ans = 0\n    for i in range(1, 10):\n        if i < X:\n            generate_all_jumping_nums(X, i)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if i <= X:",
      "mutated_line": "if i > X:",
      "code": "from collections import deque\n\ndef find_largest_jumping_number(X: int) -> int:\n\n    def generate_all_jumping_nums(X, i):\n        J = deque()\n        J.append(i)\n        while J:\n            num = J.popleft()\n            if num <= X:\n                nonlocal ans\n                ans = max(ans, num)\n                last_dig = num % 10\n                if last_dig != 9:\n                    J.append(num * 10 + last_dig + 1)\n                if last_dig != 0:\n                    J.append(num * 10 + last_dig - 1)\n    ans = 0\n    for i in range(1, 10):\n        if i > X:\n            generate_all_jumping_nums(X, i)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if i <= X:",
      "mutated_line": "if i == X:",
      "code": "from collections import deque\n\ndef find_largest_jumping_number(X: int) -> int:\n\n    def generate_all_jumping_nums(X, i):\n        J = deque()\n        J.append(i)\n        while J:\n            num = J.popleft()\n            if num <= X:\n                nonlocal ans\n                ans = max(ans, num)\n                last_dig = num % 10\n                if last_dig != 9:\n                    J.append(num * 10 + last_dig + 1)\n                if last_dig != 0:\n                    J.append(num * 10 + last_dig - 1)\n    ans = 0\n    for i in range(1, 10):\n        if i == X:\n            generate_all_jumping_nums(X, i)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if num <= X:",
      "mutated_line": "if num < X:",
      "code": "from collections import deque\n\ndef find_largest_jumping_number(X: int) -> int:\n\n    def generate_all_jumping_nums(X, i):\n        J = deque()\n        J.append(i)\n        while J:\n            num = J.popleft()\n            if num < X:\n                nonlocal ans\n                ans = max(ans, num)\n                last_dig = num % 10\n                if last_dig != 9:\n                    J.append(num * 10 + last_dig + 1)\n                if last_dig != 0:\n                    J.append(num * 10 + last_dig - 1)\n    ans = 0\n    for i in range(1, 10):\n        if i <= X:\n            generate_all_jumping_nums(X, i)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if num <= X:",
      "mutated_line": "if num > X:",
      "code": "from collections import deque\n\ndef find_largest_jumping_number(X: int) -> int:\n\n    def generate_all_jumping_nums(X, i):\n        J = deque()\n        J.append(i)\n        while J:\n            num = J.popleft()\n            if num > X:\n                nonlocal ans\n                ans = max(ans, num)\n                last_dig = num % 10\n                if last_dig != 9:\n                    J.append(num * 10 + last_dig + 1)\n                if last_dig != 0:\n                    J.append(num * 10 + last_dig - 1)\n    ans = 0\n    for i in range(1, 10):\n        if i <= X:\n            generate_all_jumping_nums(X, i)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if num <= X:",
      "mutated_line": "if num == X:",
      "code": "from collections import deque\n\ndef find_largest_jumping_number(X: int) -> int:\n\n    def generate_all_jumping_nums(X, i):\n        J = deque()\n        J.append(i)\n        while J:\n            num = J.popleft()\n            if num == X:\n                nonlocal ans\n                ans = max(ans, num)\n                last_dig = num % 10\n                if last_dig != 9:\n                    J.append(num * 10 + last_dig + 1)\n                if last_dig != 0:\n                    J.append(num * 10 + last_dig - 1)\n    ans = 0\n    for i in range(1, 10):\n        if i <= X:\n            generate_all_jumping_nums(X, i)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "last_dig = num % 10",
      "mutated_line": "last_dig = num * 10",
      "code": "from collections import deque\n\ndef find_largest_jumping_number(X: int) -> int:\n\n    def generate_all_jumping_nums(X, i):\n        J = deque()\n        J.append(i)\n        while J:\n            num = J.popleft()\n            if num <= X:\n                nonlocal ans\n                ans = max(ans, num)\n                last_dig = num * 10\n                if last_dig != 9:\n                    J.append(num * 10 + last_dig + 1)\n                if last_dig != 0:\n                    J.append(num * 10 + last_dig - 1)\n    ans = 0\n    for i in range(1, 10):\n        if i <= X:\n            generate_all_jumping_nums(X, i)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "last_dig = num % 10",
      "mutated_line": "last_dig = num + 10",
      "code": "from collections import deque\n\ndef find_largest_jumping_number(X: int) -> int:\n\n    def generate_all_jumping_nums(X, i):\n        J = deque()\n        J.append(i)\n        while J:\n            num = J.popleft()\n            if num <= X:\n                nonlocal ans\n                ans = max(ans, num)\n                last_dig = num + 10\n                if last_dig != 9:\n                    J.append(num * 10 + last_dig + 1)\n                if last_dig != 0:\n                    J.append(num * 10 + last_dig - 1)\n    ans = 0\n    for i in range(1, 10):\n        if i <= X:\n            generate_all_jumping_nums(X, i)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if last_dig != 9:",
      "mutated_line": "if last_dig == 9:",
      "code": "from collections import deque\n\ndef find_largest_jumping_number(X: int) -> int:\n\n    def generate_all_jumping_nums(X, i):\n        J = deque()\n        J.append(i)\n        while J:\n            num = J.popleft()\n            if num <= X:\n                nonlocal ans\n                ans = max(ans, num)\n                last_dig = num % 10\n                if last_dig == 9:\n                    J.append(num * 10 + last_dig + 1)\n                if last_dig != 0:\n                    J.append(num * 10 + last_dig - 1)\n    ans = 0\n    for i in range(1, 10):\n        if i <= X:\n            generate_all_jumping_nums(X, i)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if last_dig != 0:",
      "mutated_line": "if last_dig == 0:",
      "code": "from collections import deque\n\ndef find_largest_jumping_number(X: int) -> int:\n\n    def generate_all_jumping_nums(X, i):\n        J = deque()\n        J.append(i)\n        while J:\n            num = J.popleft()\n            if num <= X:\n                nonlocal ans\n                ans = max(ans, num)\n                last_dig = num % 10\n                if last_dig != 9:\n                    J.append(num * 10 + last_dig + 1)\n                if last_dig == 0:\n                    J.append(num * 10 + last_dig - 1)\n    ans = 0\n    for i in range(1, 10):\n        if i <= X:\n            generate_all_jumping_nums(X, i)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "last_dig = num % 10",
      "mutated_line": "last_dig = num % 11",
      "code": "from collections import deque\n\ndef find_largest_jumping_number(X: int) -> int:\n\n    def generate_all_jumping_nums(X, i):\n        J = deque()\n        J.append(i)\n        while J:\n            num = J.popleft()\n            if num <= X:\n                nonlocal ans\n                ans = max(ans, num)\n                last_dig = num % 11\n                if last_dig != 9:\n                    J.append(num * 10 + last_dig + 1)\n                if last_dig != 0:\n                    J.append(num * 10 + last_dig - 1)\n    ans = 0\n    for i in range(1, 10):\n        if i <= X:\n            generate_all_jumping_nums(X, i)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "last_dig = num % 10",
      "mutated_line": "last_dig = num % 9",
      "code": "from collections import deque\n\ndef find_largest_jumping_number(X: int) -> int:\n\n    def generate_all_jumping_nums(X, i):\n        J = deque()\n        J.append(i)\n        while J:\n            num = J.popleft()\n            if num <= X:\n                nonlocal ans\n                ans = max(ans, num)\n                last_dig = num % 9\n                if last_dig != 9:\n                    J.append(num * 10 + last_dig + 1)\n                if last_dig != 0:\n                    J.append(num * 10 + last_dig - 1)\n    ans = 0\n    for i in range(1, 10):\n        if i <= X:\n            generate_all_jumping_nums(X, i)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "last_dig = num % 10",
      "mutated_line": "last_dig = num % 0",
      "code": "from collections import deque\n\ndef find_largest_jumping_number(X: int) -> int:\n\n    def generate_all_jumping_nums(X, i):\n        J = deque()\n        J.append(i)\n        while J:\n            num = J.popleft()\n            if num <= X:\n                nonlocal ans\n                ans = max(ans, num)\n                last_dig = num % 0\n                if last_dig != 9:\n                    J.append(num * 10 + last_dig + 1)\n                if last_dig != 0:\n                    J.append(num * 10 + last_dig - 1)\n    ans = 0\n    for i in range(1, 10):\n        if i <= X:\n            generate_all_jumping_nums(X, i)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "last_dig = num % 10",
      "mutated_line": "last_dig = num % 1",
      "code": "from collections import deque\n\ndef find_largest_jumping_number(X: int) -> int:\n\n    def generate_all_jumping_nums(X, i):\n        J = deque()\n        J.append(i)\n        while J:\n            num = J.popleft()\n            if num <= X:\n                nonlocal ans\n                ans = max(ans, num)\n                last_dig = num % 1\n                if last_dig != 9:\n                    J.append(num * 10 + last_dig + 1)\n                if last_dig != 0:\n                    J.append(num * 10 + last_dig - 1)\n    ans = 0\n    for i in range(1, 10):\n        if i <= X:\n            generate_all_jumping_nums(X, i)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "last_dig = num % 10",
      "mutated_line": "last_dig = num % -10",
      "code": "from collections import deque\n\ndef find_largest_jumping_number(X: int) -> int:\n\n    def generate_all_jumping_nums(X, i):\n        J = deque()\n        J.append(i)\n        while J:\n            num = J.popleft()\n            if num <= X:\n                nonlocal ans\n                ans = max(ans, num)\n                last_dig = num % -10\n                if last_dig != 9:\n                    J.append(num * 10 + last_dig + 1)\n                if last_dig != 0:\n                    J.append(num * 10 + last_dig - 1)\n    ans = 0\n    for i in range(1, 10):\n        if i <= X:\n            generate_all_jumping_nums(X, i)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if last_dig != 9:",
      "mutated_line": "if last_dig != 10:",
      "code": "from collections import deque\n\ndef find_largest_jumping_number(X: int) -> int:\n\n    def generate_all_jumping_nums(X, i):\n        J = deque()\n        J.append(i)\n        while J:\n            num = J.popleft()\n            if num <= X:\n                nonlocal ans\n                ans = max(ans, num)\n                last_dig = num % 10\n                if last_dig != 10:\n                    J.append(num * 10 + last_dig + 1)\n                if last_dig != 0:\n                    J.append(num * 10 + last_dig - 1)\n    ans = 0\n    for i in range(1, 10):\n        if i <= X:\n            generate_all_jumping_nums(X, i)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if last_dig != 9:",
      "mutated_line": "if last_dig != 8:",
      "code": "from collections import deque\n\ndef find_largest_jumping_number(X: int) -> int:\n\n    def generate_all_jumping_nums(X, i):\n        J = deque()\n        J.append(i)\n        while J:\n            num = J.popleft()\n            if num <= X:\n                nonlocal ans\n                ans = max(ans, num)\n                last_dig = num % 10\n                if last_dig != 8:\n                    J.append(num * 10 + last_dig + 1)\n                if last_dig != 0:\n                    J.append(num * 10 + last_dig - 1)\n    ans = 0\n    for i in range(1, 10):\n        if i <= X:\n            generate_all_jumping_nums(X, i)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if last_dig != 9:",
      "mutated_line": "if last_dig != 0:",
      "code": "from collections import deque\n\ndef find_largest_jumping_number(X: int) -> int:\n\n    def generate_all_jumping_nums(X, i):\n        J = deque()\n        J.append(i)\n        while J:\n            num = J.popleft()\n            if num <= X:\n                nonlocal ans\n                ans = max(ans, num)\n                last_dig = num % 10\n                if last_dig != 0:\n                    J.append(num * 10 + last_dig + 1)\n                if last_dig != 0:\n                    J.append(num * 10 + last_dig - 1)\n    ans = 0\n    for i in range(1, 10):\n        if i <= X:\n            generate_all_jumping_nums(X, i)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if last_dig != 9:",
      "mutated_line": "if last_dig != 1:",
      "code": "from collections import deque\n\ndef find_largest_jumping_number(X: int) -> int:\n\n    def generate_all_jumping_nums(X, i):\n        J = deque()\n        J.append(i)\n        while J:\n            num = J.popleft()\n            if num <= X:\n                nonlocal ans\n                ans = max(ans, num)\n                last_dig = num % 10\n                if last_dig != 1:\n                    J.append(num * 10 + last_dig + 1)\n                if last_dig != 0:\n                    J.append(num * 10 + last_dig - 1)\n    ans = 0\n    for i in range(1, 10):\n        if i <= X:\n            generate_all_jumping_nums(X, i)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if last_dig != 9:",
      "mutated_line": "if last_dig != -9:",
      "code": "from collections import deque\n\ndef find_largest_jumping_number(X: int) -> int:\n\n    def generate_all_jumping_nums(X, i):\n        J = deque()\n        J.append(i)\n        while J:\n            num = J.popleft()\n            if num <= X:\n                nonlocal ans\n                ans = max(ans, num)\n                last_dig = num % 10\n                if last_dig != -9:\n                    J.append(num * 10 + last_dig + 1)\n                if last_dig != 0:\n                    J.append(num * 10 + last_dig - 1)\n    ans = 0\n    for i in range(1, 10):\n        if i <= X:\n            generate_all_jumping_nums(X, i)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if last_dig != 0:",
      "mutated_line": "if last_dig != 1:",
      "code": "from collections import deque\n\ndef find_largest_jumping_number(X: int) -> int:\n\n    def generate_all_jumping_nums(X, i):\n        J = deque()\n        J.append(i)\n        while J:\n            num = J.popleft()\n            if num <= X:\n                nonlocal ans\n                ans = max(ans, num)\n                last_dig = num % 10\n                if last_dig != 9:\n                    J.append(num * 10 + last_dig + 1)\n                if last_dig != 1:\n                    J.append(num * 10 + last_dig - 1)\n    ans = 0\n    for i in range(1, 10):\n        if i <= X:\n            generate_all_jumping_nums(X, i)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if last_dig != 0:",
      "mutated_line": "if last_dig != -1:",
      "code": "from collections import deque\n\ndef find_largest_jumping_number(X: int) -> int:\n\n    def generate_all_jumping_nums(X, i):\n        J = deque()\n        J.append(i)\n        while J:\n            num = J.popleft()\n            if num <= X:\n                nonlocal ans\n                ans = max(ans, num)\n                last_dig = num % 10\n                if last_dig != 9:\n                    J.append(num * 10 + last_dig + 1)\n                if last_dig != -1:\n                    J.append(num * 10 + last_dig - 1)\n    ans = 0\n    for i in range(1, 10):\n        if i <= X:\n            generate_all_jumping_nums(X, i)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if last_dig != 0:",
      "mutated_line": "if last_dig != 1:",
      "code": "from collections import deque\n\ndef find_largest_jumping_number(X: int) -> int:\n\n    def generate_all_jumping_nums(X, i):\n        J = deque()\n        J.append(i)\n        while J:\n            num = J.popleft()\n            if num <= X:\n                nonlocal ans\n                ans = max(ans, num)\n                last_dig = num % 10\n                if last_dig != 9:\n                    J.append(num * 10 + last_dig + 1)\n                if last_dig != 1:\n                    J.append(num * 10 + last_dig - 1)\n    ans = 0\n    for i in range(1, 10):\n        if i <= X:\n            generate_all_jumping_nums(X, i)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "J.append(num * 10 + last_dig + 1)",
      "mutated_line": "J.append(num * 10 + last_dig - 1)",
      "code": "from collections import deque\n\ndef find_largest_jumping_number(X: int) -> int:\n\n    def generate_all_jumping_nums(X, i):\n        J = deque()\n        J.append(i)\n        while J:\n            num = J.popleft()\n            if num <= X:\n                nonlocal ans\n                ans = max(ans, num)\n                last_dig = num % 10\n                if last_dig != 9:\n                    J.append(num * 10 + last_dig - 1)\n                if last_dig != 0:\n                    J.append(num * 10 + last_dig - 1)\n    ans = 0\n    for i in range(1, 10):\n        if i <= X:\n            generate_all_jumping_nums(X, i)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "J.append(num * 10 + last_dig + 1)",
      "mutated_line": "J.append((num * 10 + last_dig) * 1)",
      "code": "from collections import deque\n\ndef find_largest_jumping_number(X: int) -> int:\n\n    def generate_all_jumping_nums(X, i):\n        J = deque()\n        J.append(i)\n        while J:\n            num = J.popleft()\n            if num <= X:\n                nonlocal ans\n                ans = max(ans, num)\n                last_dig = num % 10\n                if last_dig != 9:\n                    J.append((num * 10 + last_dig) * 1)\n                if last_dig != 0:\n                    J.append(num * 10 + last_dig - 1)\n    ans = 0\n    for i in range(1, 10):\n        if i <= X:\n            generate_all_jumping_nums(X, i)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "J.append(num * 10 + last_dig - 1)",
      "mutated_line": "J.append(num * 10 + last_dig + 1)",
      "code": "from collections import deque\n\ndef find_largest_jumping_number(X: int) -> int:\n\n    def generate_all_jumping_nums(X, i):\n        J = deque()\n        J.append(i)\n        while J:\n            num = J.popleft()\n            if num <= X:\n                nonlocal ans\n                ans = max(ans, num)\n                last_dig = num % 10\n                if last_dig != 9:\n                    J.append(num * 10 + last_dig + 1)\n                if last_dig != 0:\n                    J.append(num * 10 + last_dig + 1)\n    ans = 0\n    for i in range(1, 10):\n        if i <= X:\n            generate_all_jumping_nums(X, i)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "J.append(num * 10 + last_dig - 1)",
      "mutated_line": "J.append((num * 10 + last_dig) * 1)",
      "code": "from collections import deque\n\ndef find_largest_jumping_number(X: int) -> int:\n\n    def generate_all_jumping_nums(X, i):\n        J = deque()\n        J.append(i)\n        while J:\n            num = J.popleft()\n            if num <= X:\n                nonlocal ans\n                ans = max(ans, num)\n                last_dig = num % 10\n                if last_dig != 9:\n                    J.append(num * 10 + last_dig + 1)\n                if last_dig != 0:\n                    J.append((num * 10 + last_dig) * 1)\n    ans = 0\n    for i in range(1, 10):\n        if i <= X:\n            generate_all_jumping_nums(X, i)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "J.append(num * 10 + last_dig + 1)",
      "mutated_line": "J.append(num * 10 - last_dig + 1)",
      "code": "from collections import deque\n\ndef find_largest_jumping_number(X: int) -> int:\n\n    def generate_all_jumping_nums(X, i):\n        J = deque()\n        J.append(i)\n        while J:\n            num = J.popleft()\n            if num <= X:\n                nonlocal ans\n                ans = max(ans, num)\n                last_dig = num % 10\n                if last_dig != 9:\n                    J.append(num * 10 - last_dig + 1)\n                if last_dig != 0:\n                    J.append(num * 10 + last_dig - 1)\n    ans = 0\n    for i in range(1, 10):\n        if i <= X:\n            generate_all_jumping_nums(X, i)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "J.append(num * 10 + last_dig + 1)",
      "mutated_line": "J.append(num * 10 * last_dig + 1)",
      "code": "from collections import deque\n\ndef find_largest_jumping_number(X: int) -> int:\n\n    def generate_all_jumping_nums(X, i):\n        J = deque()\n        J.append(i)\n        while J:\n            num = J.popleft()\n            if num <= X:\n                nonlocal ans\n                ans = max(ans, num)\n                last_dig = num % 10\n                if last_dig != 9:\n                    J.append(num * 10 * last_dig + 1)\n                if last_dig != 0:\n                    J.append(num * 10 + last_dig - 1)\n    ans = 0\n    for i in range(1, 10):\n        if i <= X:\n            generate_all_jumping_nums(X, i)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "J.append(num * 10 + last_dig + 1)",
      "mutated_line": "J.append(num * 10 + last_dig + 2)",
      "code": "from collections import deque\n\ndef find_largest_jumping_number(X: int) -> int:\n\n    def generate_all_jumping_nums(X, i):\n        J = deque()\n        J.append(i)\n        while J:\n            num = J.popleft()\n            if num <= X:\n                nonlocal ans\n                ans = max(ans, num)\n                last_dig = num % 10\n                if last_dig != 9:\n                    J.append(num * 10 + last_dig + 2)\n                if last_dig != 0:\n                    J.append(num * 10 + last_dig - 1)\n    ans = 0\n    for i in range(1, 10):\n        if i <= X:\n            generate_all_jumping_nums(X, i)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "J.append(num * 10 + last_dig + 1)",
      "mutated_line": "J.append(num * 10 + last_dig + 0)",
      "code": "from collections import deque\n\ndef find_largest_jumping_number(X: int) -> int:\n\n    def generate_all_jumping_nums(X, i):\n        J = deque()\n        J.append(i)\n        while J:\n            num = J.popleft()\n            if num <= X:\n                nonlocal ans\n                ans = max(ans, num)\n                last_dig = num % 10\n                if last_dig != 9:\n                    J.append(num * 10 + last_dig + 0)\n                if last_dig != 0:\n                    J.append(num * 10 + last_dig - 1)\n    ans = 0\n    for i in range(1, 10):\n        if i <= X:\n            generate_all_jumping_nums(X, i)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "J.append(num * 10 + last_dig + 1)",
      "mutated_line": "J.append(num * 10 + last_dig + 0)",
      "code": "from collections import deque\n\ndef find_largest_jumping_number(X: int) -> int:\n\n    def generate_all_jumping_nums(X, i):\n        J = deque()\n        J.append(i)\n        while J:\n            num = J.popleft()\n            if num <= X:\n                nonlocal ans\n                ans = max(ans, num)\n                last_dig = num % 10\n                if last_dig != 9:\n                    J.append(num * 10 + last_dig + 0)\n                if last_dig != 0:\n                    J.append(num * 10 + last_dig - 1)\n    ans = 0\n    for i in range(1, 10):\n        if i <= X:\n            generate_all_jumping_nums(X, i)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "J.append(num * 10 + last_dig + 1)",
      "mutated_line": "J.append(num * 10 + last_dig + -1)",
      "code": "from collections import deque\n\ndef find_largest_jumping_number(X: int) -> int:\n\n    def generate_all_jumping_nums(X, i):\n        J = deque()\n        J.append(i)\n        while J:\n            num = J.popleft()\n            if num <= X:\n                nonlocal ans\n                ans = max(ans, num)\n                last_dig = num % 10\n                if last_dig != 9:\n                    J.append(num * 10 + last_dig + -1)\n                if last_dig != 0:\n                    J.append(num * 10 + last_dig - 1)\n    ans = 0\n    for i in range(1, 10):\n        if i <= X:\n            generate_all_jumping_nums(X, i)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "J.append(num * 10 + last_dig - 1)",
      "mutated_line": "J.append(num * 10 - last_dig - 1)",
      "code": "from collections import deque\n\ndef find_largest_jumping_number(X: int) -> int:\n\n    def generate_all_jumping_nums(X, i):\n        J = deque()\n        J.append(i)\n        while J:\n            num = J.popleft()\n            if num <= X:\n                nonlocal ans\n                ans = max(ans, num)\n                last_dig = num % 10\n                if last_dig != 9:\n                    J.append(num * 10 + last_dig + 1)\n                if last_dig != 0:\n                    J.append(num * 10 - last_dig - 1)\n    ans = 0\n    for i in range(1, 10):\n        if i <= X:\n            generate_all_jumping_nums(X, i)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "J.append(num * 10 + last_dig - 1)",
      "mutated_line": "J.append(num * 10 * last_dig - 1)",
      "code": "from collections import deque\n\ndef find_largest_jumping_number(X: int) -> int:\n\n    def generate_all_jumping_nums(X, i):\n        J = deque()\n        J.append(i)\n        while J:\n            num = J.popleft()\n            if num <= X:\n                nonlocal ans\n                ans = max(ans, num)\n                last_dig = num % 10\n                if last_dig != 9:\n                    J.append(num * 10 + last_dig + 1)\n                if last_dig != 0:\n                    J.append(num * 10 * last_dig - 1)\n    ans = 0\n    for i in range(1, 10):\n        if i <= X:\n            generate_all_jumping_nums(X, i)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "J.append(num * 10 + last_dig - 1)",
      "mutated_line": "J.append(num * 10 + last_dig - 2)",
      "code": "from collections import deque\n\ndef find_largest_jumping_number(X: int) -> int:\n\n    def generate_all_jumping_nums(X, i):\n        J = deque()\n        J.append(i)\n        while J:\n            num = J.popleft()\n            if num <= X:\n                nonlocal ans\n                ans = max(ans, num)\n                last_dig = num % 10\n                if last_dig != 9:\n                    J.append(num * 10 + last_dig + 1)\n                if last_dig != 0:\n                    J.append(num * 10 + last_dig - 2)\n    ans = 0\n    for i in range(1, 10):\n        if i <= X:\n            generate_all_jumping_nums(X, i)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "J.append(num * 10 + last_dig - 1)",
      "mutated_line": "J.append(num * 10 + last_dig - 0)",
      "code": "from collections import deque\n\ndef find_largest_jumping_number(X: int) -> int:\n\n    def generate_all_jumping_nums(X, i):\n        J = deque()\n        J.append(i)\n        while J:\n            num = J.popleft()\n            if num <= X:\n                nonlocal ans\n                ans = max(ans, num)\n                last_dig = num % 10\n                if last_dig != 9:\n                    J.append(num * 10 + last_dig + 1)\n                if last_dig != 0:\n                    J.append(num * 10 + last_dig - 0)\n    ans = 0\n    for i in range(1, 10):\n        if i <= X:\n            generate_all_jumping_nums(X, i)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "J.append(num * 10 + last_dig - 1)",
      "mutated_line": "J.append(num * 10 + last_dig - 0)",
      "code": "from collections import deque\n\ndef find_largest_jumping_number(X: int) -> int:\n\n    def generate_all_jumping_nums(X, i):\n        J = deque()\n        J.append(i)\n        while J:\n            num = J.popleft()\n            if num <= X:\n                nonlocal ans\n                ans = max(ans, num)\n                last_dig = num % 10\n                if last_dig != 9:\n                    J.append(num * 10 + last_dig + 1)\n                if last_dig != 0:\n                    J.append(num * 10 + last_dig - 0)\n    ans = 0\n    for i in range(1, 10):\n        if i <= X:\n            generate_all_jumping_nums(X, i)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "J.append(num * 10 + last_dig - 1)",
      "mutated_line": "J.append(num * 10 + last_dig - -1)",
      "code": "from collections import deque\n\ndef find_largest_jumping_number(X: int) -> int:\n\n    def generate_all_jumping_nums(X, i):\n        J = deque()\n        J.append(i)\n        while J:\n            num = J.popleft()\n            if num <= X:\n                nonlocal ans\n                ans = max(ans, num)\n                last_dig = num % 10\n                if last_dig != 9:\n                    J.append(num * 10 + last_dig + 1)\n                if last_dig != 0:\n                    J.append(num * 10 + last_dig - -1)\n    ans = 0\n    for i in range(1, 10):\n        if i <= X:\n            generate_all_jumping_nums(X, i)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "J.append(num * 10 + last_dig + 1)",
      "mutated_line": "J.append(num / 10 + last_dig + 1)",
      "code": "from collections import deque\n\ndef find_largest_jumping_number(X: int) -> int:\n\n    def generate_all_jumping_nums(X, i):\n        J = deque()\n        J.append(i)\n        while J:\n            num = J.popleft()\n            if num <= X:\n                nonlocal ans\n                ans = max(ans, num)\n                last_dig = num % 10\n                if last_dig != 9:\n                    J.append(num / 10 + last_dig + 1)\n                if last_dig != 0:\n                    J.append(num * 10 + last_dig - 1)\n    ans = 0\n    for i in range(1, 10):\n        if i <= X:\n            generate_all_jumping_nums(X, i)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "J.append(num * 10 + last_dig + 1)",
      "mutated_line": "J.append(num + 10 + last_dig + 1)",
      "code": "from collections import deque\n\ndef find_largest_jumping_number(X: int) -> int:\n\n    def generate_all_jumping_nums(X, i):\n        J = deque()\n        J.append(i)\n        while J:\n            num = J.popleft()\n            if num <= X:\n                nonlocal ans\n                ans = max(ans, num)\n                last_dig = num % 10\n                if last_dig != 9:\n                    J.append(num + 10 + last_dig + 1)\n                if last_dig != 0:\n                    J.append(num * 10 + last_dig - 1)\n    ans = 0\n    for i in range(1, 10):\n        if i <= X:\n            generate_all_jumping_nums(X, i)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "J.append(num * 10 + last_dig + 1)",
      "mutated_line": "J.append(num ** 10 + last_dig + 1)",
      "code": "from collections import deque\n\ndef find_largest_jumping_number(X: int) -> int:\n\n    def generate_all_jumping_nums(X, i):\n        J = deque()\n        J.append(i)\n        while J:\n            num = J.popleft()\n            if num <= X:\n                nonlocal ans\n                ans = max(ans, num)\n                last_dig = num % 10\n                if last_dig != 9:\n                    J.append(num ** 10 + last_dig + 1)\n                if last_dig != 0:\n                    J.append(num * 10 + last_dig - 1)\n    ans = 0\n    for i in range(1, 10):\n        if i <= X:\n            generate_all_jumping_nums(X, i)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "J.append(num * 10 + last_dig - 1)",
      "mutated_line": "J.append(num / 10 + last_dig - 1)",
      "code": "from collections import deque\n\ndef find_largest_jumping_number(X: int) -> int:\n\n    def generate_all_jumping_nums(X, i):\n        J = deque()\n        J.append(i)\n        while J:\n            num = J.popleft()\n            if num <= X:\n                nonlocal ans\n                ans = max(ans, num)\n                last_dig = num % 10\n                if last_dig != 9:\n                    J.append(num * 10 + last_dig + 1)\n                if last_dig != 0:\n                    J.append(num / 10 + last_dig - 1)\n    ans = 0\n    for i in range(1, 10):\n        if i <= X:\n            generate_all_jumping_nums(X, i)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "J.append(num * 10 + last_dig - 1)",
      "mutated_line": "J.append(num + 10 + last_dig - 1)",
      "code": "from collections import deque\n\ndef find_largest_jumping_number(X: int) -> int:\n\n    def generate_all_jumping_nums(X, i):\n        J = deque()\n        J.append(i)\n        while J:\n            num = J.popleft()\n            if num <= X:\n                nonlocal ans\n                ans = max(ans, num)\n                last_dig = num % 10\n                if last_dig != 9:\n                    J.append(num * 10 + last_dig + 1)\n                if last_dig != 0:\n                    J.append(num + 10 + last_dig - 1)\n    ans = 0\n    for i in range(1, 10):\n        if i <= X:\n            generate_all_jumping_nums(X, i)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "J.append(num * 10 + last_dig - 1)",
      "mutated_line": "J.append(num ** 10 + last_dig - 1)",
      "code": "from collections import deque\n\ndef find_largest_jumping_number(X: int) -> int:\n\n    def generate_all_jumping_nums(X, i):\n        J = deque()\n        J.append(i)\n        while J:\n            num = J.popleft()\n            if num <= X:\n                nonlocal ans\n                ans = max(ans, num)\n                last_dig = num % 10\n                if last_dig != 9:\n                    J.append(num * 10 + last_dig + 1)\n                if last_dig != 0:\n                    J.append(num ** 10 + last_dig - 1)\n    ans = 0\n    for i in range(1, 10):\n        if i <= X:\n            generate_all_jumping_nums(X, i)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "J.append(num * 10 + last_dig + 1)",
      "mutated_line": "J.append(num * 11 + last_dig + 1)",
      "code": "from collections import deque\n\ndef find_largest_jumping_number(X: int) -> int:\n\n    def generate_all_jumping_nums(X, i):\n        J = deque()\n        J.append(i)\n        while J:\n            num = J.popleft()\n            if num <= X:\n                nonlocal ans\n                ans = max(ans, num)\n                last_dig = num % 10\n                if last_dig != 9:\n                    J.append(num * 11 + last_dig + 1)\n                if last_dig != 0:\n                    J.append(num * 10 + last_dig - 1)\n    ans = 0\n    for i in range(1, 10):\n        if i <= X:\n            generate_all_jumping_nums(X, i)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "J.append(num * 10 + last_dig + 1)",
      "mutated_line": "J.append(num * 9 + last_dig + 1)",
      "code": "from collections import deque\n\ndef find_largest_jumping_number(X: int) -> int:\n\n    def generate_all_jumping_nums(X, i):\n        J = deque()\n        J.append(i)\n        while J:\n            num = J.popleft()\n            if num <= X:\n                nonlocal ans\n                ans = max(ans, num)\n                last_dig = num % 10\n                if last_dig != 9:\n                    J.append(num * 9 + last_dig + 1)\n                if last_dig != 0:\n                    J.append(num * 10 + last_dig - 1)\n    ans = 0\n    for i in range(1, 10):\n        if i <= X:\n            generate_all_jumping_nums(X, i)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "J.append(num * 10 + last_dig + 1)",
      "mutated_line": "J.append(num * 0 + last_dig + 1)",
      "code": "from collections import deque\n\ndef find_largest_jumping_number(X: int) -> int:\n\n    def generate_all_jumping_nums(X, i):\n        J = deque()\n        J.append(i)\n        while J:\n            num = J.popleft()\n            if num <= X:\n                nonlocal ans\n                ans = max(ans, num)\n                last_dig = num % 10\n                if last_dig != 9:\n                    J.append(num * 0 + last_dig + 1)\n                if last_dig != 0:\n                    J.append(num * 10 + last_dig - 1)\n    ans = 0\n    for i in range(1, 10):\n        if i <= X:\n            generate_all_jumping_nums(X, i)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "J.append(num * 10 + last_dig + 1)",
      "mutated_line": "J.append(num * 1 + last_dig + 1)",
      "code": "from collections import deque\n\ndef find_largest_jumping_number(X: int) -> int:\n\n    def generate_all_jumping_nums(X, i):\n        J = deque()\n        J.append(i)\n        while J:\n            num = J.popleft()\n            if num <= X:\n                nonlocal ans\n                ans = max(ans, num)\n                last_dig = num % 10\n                if last_dig != 9:\n                    J.append(num * 1 + last_dig + 1)\n                if last_dig != 0:\n                    J.append(num * 10 + last_dig - 1)\n    ans = 0\n    for i in range(1, 10):\n        if i <= X:\n            generate_all_jumping_nums(X, i)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "J.append(num * 10 + last_dig + 1)",
      "mutated_line": "J.append(num * -10 + last_dig + 1)",
      "code": "from collections import deque\n\ndef find_largest_jumping_number(X: int) -> int:\n\n    def generate_all_jumping_nums(X, i):\n        J = deque()\n        J.append(i)\n        while J:\n            num = J.popleft()\n            if num <= X:\n                nonlocal ans\n                ans = max(ans, num)\n                last_dig = num % 10\n                if last_dig != 9:\n                    J.append(num * -10 + last_dig + 1)\n                if last_dig != 0:\n                    J.append(num * 10 + last_dig - 1)\n    ans = 0\n    for i in range(1, 10):\n        if i <= X:\n            generate_all_jumping_nums(X, i)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "J.append(num * 10 + last_dig - 1)",
      "mutated_line": "J.append(num * 11 + last_dig - 1)",
      "code": "from collections import deque\n\ndef find_largest_jumping_number(X: int) -> int:\n\n    def generate_all_jumping_nums(X, i):\n        J = deque()\n        J.append(i)\n        while J:\n            num = J.popleft()\n            if num <= X:\n                nonlocal ans\n                ans = max(ans, num)\n                last_dig = num % 10\n                if last_dig != 9:\n                    J.append(num * 10 + last_dig + 1)\n                if last_dig != 0:\n                    J.append(num * 11 + last_dig - 1)\n    ans = 0\n    for i in range(1, 10):\n        if i <= X:\n            generate_all_jumping_nums(X, i)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "J.append(num * 10 + last_dig - 1)",
      "mutated_line": "J.append(num * 9 + last_dig - 1)",
      "code": "from collections import deque\n\ndef find_largest_jumping_number(X: int) -> int:\n\n    def generate_all_jumping_nums(X, i):\n        J = deque()\n        J.append(i)\n        while J:\n            num = J.popleft()\n            if num <= X:\n                nonlocal ans\n                ans = max(ans, num)\n                last_dig = num % 10\n                if last_dig != 9:\n                    J.append(num * 10 + last_dig + 1)\n                if last_dig != 0:\n                    J.append(num * 9 + last_dig - 1)\n    ans = 0\n    for i in range(1, 10):\n        if i <= X:\n            generate_all_jumping_nums(X, i)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "J.append(num * 10 + last_dig - 1)",
      "mutated_line": "J.append(num * 0 + last_dig - 1)",
      "code": "from collections import deque\n\ndef find_largest_jumping_number(X: int) -> int:\n\n    def generate_all_jumping_nums(X, i):\n        J = deque()\n        J.append(i)\n        while J:\n            num = J.popleft()\n            if num <= X:\n                nonlocal ans\n                ans = max(ans, num)\n                last_dig = num % 10\n                if last_dig != 9:\n                    J.append(num * 10 + last_dig + 1)\n                if last_dig != 0:\n                    J.append(num * 0 + last_dig - 1)\n    ans = 0\n    for i in range(1, 10):\n        if i <= X:\n            generate_all_jumping_nums(X, i)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "J.append(num * 10 + last_dig - 1)",
      "mutated_line": "J.append(num * 1 + last_dig - 1)",
      "code": "from collections import deque\n\ndef find_largest_jumping_number(X: int) -> int:\n\n    def generate_all_jumping_nums(X, i):\n        J = deque()\n        J.append(i)\n        while J:\n            num = J.popleft()\n            if num <= X:\n                nonlocal ans\n                ans = max(ans, num)\n                last_dig = num % 10\n                if last_dig != 9:\n                    J.append(num * 10 + last_dig + 1)\n                if last_dig != 0:\n                    J.append(num * 1 + last_dig - 1)\n    ans = 0\n    for i in range(1, 10):\n        if i <= X:\n            generate_all_jumping_nums(X, i)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "J.append(num * 10 + last_dig - 1)",
      "mutated_line": "J.append(num * -10 + last_dig - 1)",
      "code": "from collections import deque\n\ndef find_largest_jumping_number(X: int) -> int:\n\n    def generate_all_jumping_nums(X, i):\n        J = deque()\n        J.append(i)\n        while J:\n            num = J.popleft()\n            if num <= X:\n                nonlocal ans\n                ans = max(ans, num)\n                last_dig = num % 10\n                if last_dig != 9:\n                    J.append(num * 10 + last_dig + 1)\n                if last_dig != 0:\n                    J.append(num * -10 + last_dig - 1)\n    ans = 0\n    for i in range(1, 10):\n        if i <= X:\n            generate_all_jumping_nums(X, i)\n    return ans"
    }
  ]
}