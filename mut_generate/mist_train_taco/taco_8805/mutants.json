{
  "task_id": "taco_8805",
  "entry_point": "generate_spanning_tree",
  "mutant_count": 19,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if x == y:",
      "mutated_line": "if x != y:",
      "code": "from operator import itemgetter\nfrom numpy import delete\n\ndef generate_spanning_tree(edges, tree_type):\n    memo = []\n    result = []\n    for v in sorted(edges, key=itemgetter(1), reverse=tree_type == 'max'):\n        (edge, weight) = v\n        (x, y) = edge\n        if x != y:\n            continue\n        i = next((i for (i, s) in enumerate(memo) if x in s), None)\n        j = next((j for (j, s) in enumerate(memo) if y in s), None)\n        if i == j and i is not None:\n            continue\n        result.append(v)\n        if i is None and j is None:\n            memo.append({x, y})\n        elif i is None:\n            memo[j].add(x)\n        elif j is None:\n            memo[i].add(y)\n        else:\n            memo.append(memo[i] | memo[j])\n            memo = delete(memo, [i, j]).tolist()\n    return result"
    },
    {
      "operator": "LCR",
      "lineno": 18,
      "original_line": "if i == j and i is not None:",
      "mutated_line": "if i == j or i is not None:",
      "code": "from operator import itemgetter\nfrom numpy import delete\n\ndef generate_spanning_tree(edges, tree_type):\n    memo = []\n    result = []\n    for v in sorted(edges, key=itemgetter(1), reverse=tree_type == 'max'):\n        (edge, weight) = v\n        (x, y) = edge\n        if x == y:\n            continue\n        i = next((i for (i, s) in enumerate(memo) if x in s), None)\n        j = next((j for (j, s) in enumerate(memo) if y in s), None)\n        if i == j or i is not None:\n            continue\n        result.append(v)\n        if i is None and j is None:\n            memo.append({x, y})\n        elif i is None:\n            memo[j].add(x)\n        elif j is None:\n            memo[i].add(y)\n        else:\n            memo.append(memo[i] | memo[j])\n            memo = delete(memo, [i, j]).tolist()\n    return result"
    },
    {
      "operator": "LCR",
      "lineno": 23,
      "original_line": "if i is None and j is None:",
      "mutated_line": "if i is None or j is None:",
      "code": "from operator import itemgetter\nfrom numpy import delete\n\ndef generate_spanning_tree(edges, tree_type):\n    memo = []\n    result = []\n    for v in sorted(edges, key=itemgetter(1), reverse=tree_type == 'max'):\n        (edge, weight) = v\n        (x, y) = edge\n        if x == y:\n            continue\n        i = next((i for (i, s) in enumerate(memo) if x in s), None)\n        j = next((j for (j, s) in enumerate(memo) if y in s), None)\n        if i == j and i is not None:\n            continue\n        result.append(v)\n        if i is None or j is None:\n            memo.append({x, y})\n        elif i is None:\n            memo[j].add(x)\n        elif j is None:\n            memo[i].add(y)\n        else:\n            memo.append(memo[i] | memo[j])\n            memo = delete(memo, [i, j]).tolist()\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "for v in sorted(edges, key=itemgetter(1), reverse=(tree_type == 'max')):",
      "mutated_line": "for v in sorted(edges, key=itemgetter(1), reverse=tree_type != 'max'):",
      "code": "from operator import itemgetter\nfrom numpy import delete\n\ndef generate_spanning_tree(edges, tree_type):\n    memo = []\n    result = []\n    for v in sorted(edges, key=itemgetter(1), reverse=tree_type != 'max'):\n        (edge, weight) = v\n        (x, y) = edge\n        if x == y:\n            continue\n        i = next((i for (i, s) in enumerate(memo) if x in s), None)\n        j = next((j for (j, s) in enumerate(memo) if y in s), None)\n        if i == j and i is not None:\n            continue\n        result.append(v)\n        if i is None and j is None:\n            memo.append({x, y})\n        elif i is None:\n            memo[j].add(x)\n        elif j is None:\n            memo[i].add(y)\n        else:\n            memo.append(memo[i] | memo[j])\n            memo = delete(memo, [i, j]).tolist()\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if i == j and i is not None:",
      "mutated_line": "if i != j and i is not None:",
      "code": "from operator import itemgetter\nfrom numpy import delete\n\ndef generate_spanning_tree(edges, tree_type):\n    memo = []\n    result = []\n    for v in sorted(edges, key=itemgetter(1), reverse=tree_type == 'max'):\n        (edge, weight) = v\n        (x, y) = edge\n        if x == y:\n            continue\n        i = next((i for (i, s) in enumerate(memo) if x in s), None)\n        j = next((j for (j, s) in enumerate(memo) if y in s), None)\n        if i != j and i is not None:\n            continue\n        result.append(v)\n        if i is None and j is None:\n            memo.append({x, y})\n        elif i is None:\n            memo[j].add(x)\n        elif j is None:\n            memo[i].add(y)\n        else:\n            memo.append(memo[i] | memo[j])\n            memo = delete(memo, [i, j]).tolist()\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if i == j and i is not None:",
      "mutated_line": "if i == j and i is None:",
      "code": "from operator import itemgetter\nfrom numpy import delete\n\ndef generate_spanning_tree(edges, tree_type):\n    memo = []\n    result = []\n    for v in sorted(edges, key=itemgetter(1), reverse=tree_type == 'max'):\n        (edge, weight) = v\n        (x, y) = edge\n        if x == y:\n            continue\n        i = next((i for (i, s) in enumerate(memo) if x in s), None)\n        j = next((j for (j, s) in enumerate(memo) if y in s), None)\n        if i == j and i is None:\n            continue\n        result.append(v)\n        if i is None and j is None:\n            memo.append({x, y})\n        elif i is None:\n            memo[j].add(x)\n        elif j is None:\n            memo[i].add(y)\n        else:\n            memo.append(memo[i] | memo[j])\n            memo = delete(memo, [i, j]).tolist()\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if i is None and j is None:",
      "mutated_line": "if i is not None and j is None:",
      "code": "from operator import itemgetter\nfrom numpy import delete\n\ndef generate_spanning_tree(edges, tree_type):\n    memo = []\n    result = []\n    for v in sorted(edges, key=itemgetter(1), reverse=tree_type == 'max'):\n        (edge, weight) = v\n        (x, y) = edge\n        if x == y:\n            continue\n        i = next((i for (i, s) in enumerate(memo) if x in s), None)\n        j = next((j for (j, s) in enumerate(memo) if y in s), None)\n        if i == j and i is not None:\n            continue\n        result.append(v)\n        if i is not None and j is None:\n            memo.append({x, y})\n        elif i is None:\n            memo[j].add(x)\n        elif j is None:\n            memo[i].add(y)\n        else:\n            memo.append(memo[i] | memo[j])\n            memo = delete(memo, [i, j]).tolist()\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if i is None and j is None:",
      "mutated_line": "if i is None and j is not None:",
      "code": "from operator import itemgetter\nfrom numpy import delete\n\ndef generate_spanning_tree(edges, tree_type):\n    memo = []\n    result = []\n    for v in sorted(edges, key=itemgetter(1), reverse=tree_type == 'max'):\n        (edge, weight) = v\n        (x, y) = edge\n        if x == y:\n            continue\n        i = next((i for (i, s) in enumerate(memo) if x in s), None)\n        j = next((j for (j, s) in enumerate(memo) if y in s), None)\n        if i == j and i is not None:\n            continue\n        result.append(v)\n        if i is None and j is not None:\n            memo.append({x, y})\n        elif i is None:\n            memo[j].add(x)\n        elif j is None:\n            memo[i].add(y)\n        else:\n            memo.append(memo[i] | memo[j])\n            memo = delete(memo, [i, j]).tolist()\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "elif i is None:",
      "mutated_line": "elif i is not None:",
      "code": "from operator import itemgetter\nfrom numpy import delete\n\ndef generate_spanning_tree(edges, tree_type):\n    memo = []\n    result = []\n    for v in sorted(edges, key=itemgetter(1), reverse=tree_type == 'max'):\n        (edge, weight) = v\n        (x, y) = edge\n        if x == y:\n            continue\n        i = next((i for (i, s) in enumerate(memo) if x in s), None)\n        j = next((j for (j, s) in enumerate(memo) if y in s), None)\n        if i == j and i is not None:\n            continue\n        result.append(v)\n        if i is None and j is None:\n            memo.append({x, y})\n        elif i is not None:\n            memo[j].add(x)\n        elif j is None:\n            memo[i].add(y)\n        else:\n            memo.append(memo[i] | memo[j])\n            memo = delete(memo, [i, j]).tolist()\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for v in sorted(edges, key=itemgetter(1), reverse=(tree_type == 'max')):",
      "mutated_line": "for v in sorted(edges, key=itemgetter(2), reverse=tree_type == 'max'):",
      "code": "from operator import itemgetter\nfrom numpy import delete\n\ndef generate_spanning_tree(edges, tree_type):\n    memo = []\n    result = []\n    for v in sorted(edges, key=itemgetter(2), reverse=tree_type == 'max'):\n        (edge, weight) = v\n        (x, y) = edge\n        if x == y:\n            continue\n        i = next((i for (i, s) in enumerate(memo) if x in s), None)\n        j = next((j for (j, s) in enumerate(memo) if y in s), None)\n        if i == j and i is not None:\n            continue\n        result.append(v)\n        if i is None and j is None:\n            memo.append({x, y})\n        elif i is None:\n            memo[j].add(x)\n        elif j is None:\n            memo[i].add(y)\n        else:\n            memo.append(memo[i] | memo[j])\n            memo = delete(memo, [i, j]).tolist()\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for v in sorted(edges, key=itemgetter(1), reverse=(tree_type == 'max')):",
      "mutated_line": "for v in sorted(edges, key=itemgetter(0), reverse=tree_type == 'max'):",
      "code": "from operator import itemgetter\nfrom numpy import delete\n\ndef generate_spanning_tree(edges, tree_type):\n    memo = []\n    result = []\n    for v in sorted(edges, key=itemgetter(0), reverse=tree_type == 'max'):\n        (edge, weight) = v\n        (x, y) = edge\n        if x == y:\n            continue\n        i = next((i for (i, s) in enumerate(memo) if x in s), None)\n        j = next((j for (j, s) in enumerate(memo) if y in s), None)\n        if i == j and i is not None:\n            continue\n        result.append(v)\n        if i is None and j is None:\n            memo.append({x, y})\n        elif i is None:\n            memo[j].add(x)\n        elif j is None:\n            memo[i].add(y)\n        else:\n            memo.append(memo[i] | memo[j])\n            memo = delete(memo, [i, j]).tolist()\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for v in sorted(edges, key=itemgetter(1), reverse=(tree_type == 'max')):",
      "mutated_line": "for v in sorted(edges, key=itemgetter(0), reverse=tree_type == 'max'):",
      "code": "from operator import itemgetter\nfrom numpy import delete\n\ndef generate_spanning_tree(edges, tree_type):\n    memo = []\n    result = []\n    for v in sorted(edges, key=itemgetter(0), reverse=tree_type == 'max'):\n        (edge, weight) = v\n        (x, y) = edge\n        if x == y:\n            continue\n        i = next((i for (i, s) in enumerate(memo) if x in s), None)\n        j = next((j for (j, s) in enumerate(memo) if y in s), None)\n        if i == j and i is not None:\n            continue\n        result.append(v)\n        if i is None and j is None:\n            memo.append({x, y})\n        elif i is None:\n            memo[j].add(x)\n        elif j is None:\n            memo[i].add(y)\n        else:\n            memo.append(memo[i] | memo[j])\n            memo = delete(memo, [i, j]).tolist()\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for v in sorted(edges, key=itemgetter(1), reverse=(tree_type == 'max')):",
      "mutated_line": "for v in sorted(edges, key=itemgetter(-1), reverse=tree_type == 'max'):",
      "code": "from operator import itemgetter\nfrom numpy import delete\n\ndef generate_spanning_tree(edges, tree_type):\n    memo = []\n    result = []\n    for v in sorted(edges, key=itemgetter(-1), reverse=tree_type == 'max'):\n        (edge, weight) = v\n        (x, y) = edge\n        if x == y:\n            continue\n        i = next((i for (i, s) in enumerate(memo) if x in s), None)\n        j = next((j for (j, s) in enumerate(memo) if y in s), None)\n        if i == j and i is not None:\n            continue\n        result.append(v)\n        if i is None and j is None:\n            memo.append({x, y})\n        elif i is None:\n            memo[j].add(x)\n        elif j is None:\n            memo[i].add(y)\n        else:\n            memo.append(memo[i] | memo[j])\n            memo = delete(memo, [i, j]).tolist()\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for v in sorted(edges, key=itemgetter(1), reverse=(tree_type == 'max')):",
      "mutated_line": "for v in sorted(edges, key=itemgetter(1), reverse=tree_type == ''):",
      "code": "from operator import itemgetter\nfrom numpy import delete\n\ndef generate_spanning_tree(edges, tree_type):\n    memo = []\n    result = []\n    for v in sorted(edges, key=itemgetter(1), reverse=tree_type == ''):\n        (edge, weight) = v\n        (x, y) = edge\n        if x == y:\n            continue\n        i = next((i for (i, s) in enumerate(memo) if x in s), None)\n        j = next((j for (j, s) in enumerate(memo) if y in s), None)\n        if i == j and i is not None:\n            continue\n        result.append(v)\n        if i is None and j is None:\n            memo.append({x, y})\n        elif i is None:\n            memo[j].add(x)\n        elif j is None:\n            memo[i].add(y)\n        else:\n            memo.append(memo[i] | memo[j])\n            memo = delete(memo, [i, j]).tolist()\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "elif j is None:",
      "mutated_line": "elif j is not None:",
      "code": "from operator import itemgetter\nfrom numpy import delete\n\ndef generate_spanning_tree(edges, tree_type):\n    memo = []\n    result = []\n    for v in sorted(edges, key=itemgetter(1), reverse=tree_type == 'max'):\n        (edge, weight) = v\n        (x, y) = edge\n        if x == y:\n            continue\n        i = next((i for (i, s) in enumerate(memo) if x in s), None)\n        j = next((j for (j, s) in enumerate(memo) if y in s), None)\n        if i == j and i is not None:\n            continue\n        result.append(v)\n        if i is None and j is None:\n            memo.append({x, y})\n        elif i is None:\n            memo[j].add(x)\n        elif j is not None:\n            memo[i].add(y)\n        else:\n            memo.append(memo[i] | memo[j])\n            memo = delete(memo, [i, j]).tolist()\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "i = next((i for (i, s) in enumerate(memo) if x in s), None)",
      "mutated_line": "i = next((i for (i, s) in enumerate(memo) if x not in s), None)",
      "code": "from operator import itemgetter\nfrom numpy import delete\n\ndef generate_spanning_tree(edges, tree_type):\n    memo = []\n    result = []\n    for v in sorted(edges, key=itemgetter(1), reverse=tree_type == 'max'):\n        (edge, weight) = v\n        (x, y) = edge\n        if x == y:\n            continue\n        i = next((i for (i, s) in enumerate(memo) if x not in s), None)\n        j = next((j for (j, s) in enumerate(memo) if y in s), None)\n        if i == j and i is not None:\n            continue\n        result.append(v)\n        if i is None and j is None:\n            memo.append({x, y})\n        elif i is None:\n            memo[j].add(x)\n        elif j is None:\n            memo[i].add(y)\n        else:\n            memo.append(memo[i] | memo[j])\n            memo = delete(memo, [i, j]).tolist()\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "j = next((j for (j, s) in enumerate(memo) if y in s), None)",
      "mutated_line": "j = next((j for (j, s) in enumerate(memo) if y not in s), None)",
      "code": "from operator import itemgetter\nfrom numpy import delete\n\ndef generate_spanning_tree(edges, tree_type):\n    memo = []\n    result = []\n    for v in sorted(edges, key=itemgetter(1), reverse=tree_type == 'max'):\n        (edge, weight) = v\n        (x, y) = edge\n        if x == y:\n            continue\n        i = next((i for (i, s) in enumerate(memo) if x in s), None)\n        j = next((j for (j, s) in enumerate(memo) if y not in s), None)\n        if i == j and i is not None:\n            continue\n        result.append(v)\n        if i is None and j is None:\n            memo.append({x, y})\n        elif i is None:\n            memo[j].add(x)\n        elif j is None:\n            memo[i].add(y)\n        else:\n            memo.append(memo[i] | memo[j])\n            memo = delete(memo, [i, j]).tolist()\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "memo.append(memo[i] | memo[j])",
      "mutated_line": "memo.append(memo[i] & memo[j])",
      "code": "from operator import itemgetter\nfrom numpy import delete\n\ndef generate_spanning_tree(edges, tree_type):\n    memo = []\n    result = []\n    for v in sorted(edges, key=itemgetter(1), reverse=tree_type == 'max'):\n        (edge, weight) = v\n        (x, y) = edge\n        if x == y:\n            continue\n        i = next((i for (i, s) in enumerate(memo) if x in s), None)\n        j = next((j for (j, s) in enumerate(memo) if y in s), None)\n        if i == j and i is not None:\n            continue\n        result.append(v)\n        if i is None and j is None:\n            memo.append({x, y})\n        elif i is None:\n            memo[j].add(x)\n        elif j is None:\n            memo[i].add(y)\n        else:\n            memo.append(memo[i] & memo[j])\n            memo = delete(memo, [i, j]).tolist()\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "memo.append(memo[i] | memo[j])",
      "mutated_line": "memo.append(memo[i] ^ memo[j])",
      "code": "from operator import itemgetter\nfrom numpy import delete\n\ndef generate_spanning_tree(edges, tree_type):\n    memo = []\n    result = []\n    for v in sorted(edges, key=itemgetter(1), reverse=tree_type == 'max'):\n        (edge, weight) = v\n        (x, y) = edge\n        if x == y:\n            continue\n        i = next((i for (i, s) in enumerate(memo) if x in s), None)\n        j = next((j for (j, s) in enumerate(memo) if y in s), None)\n        if i == j and i is not None:\n            continue\n        result.append(v)\n        if i is None and j is None:\n            memo.append({x, y})\n        elif i is None:\n            memo[j].add(x)\n        elif j is None:\n            memo[i].add(y)\n        else:\n            memo.append(memo[i] ^ memo[j])\n            memo = delete(memo, [i, j]).tolist()\n    return result"
    }
  ]
}