{
  "task_id": "taco_14181",
  "entry_point": "determine_chord_type",
  "mutant_count": 55,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "NOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2",
      "mutated_line": "NOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] / 2",
      "code": "from itertools import product\nNOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] / 2\nconfig = [('Major', 4), ('Minor', 3)]\nDCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 2) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 7])}\n\ndef determine_chord_type(chord: str) -> str:\n    chord = tuple(chord.split()) if isinstance(chord, str) else ''\n    return DCT_CHORDS.get(chord, 'Not a chord')"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "NOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2",
      "mutated_line": "NOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] + 2",
      "code": "from itertools import product\nNOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] + 2\nconfig = [('Major', 4), ('Minor', 3)]\nDCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 2) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 7])}\n\ndef determine_chord_type(chord: str) -> str:\n    chord = tuple(chord.split()) if isinstance(chord, str) else ''\n    return DCT_CHORDS.get(chord, 'Not a chord')"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "NOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2",
      "mutated_line": "NOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] ** 2",
      "code": "from itertools import product\nNOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] ** 2\nconfig = [('Major', 4), ('Minor', 3)]\nDCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 2) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 7])}\n\ndef determine_chord_type(chord: str) -> str:\n    chord = tuple(chord.split()) if isinstance(chord, str) else ''\n    return DCT_CHORDS.get(chord, 'Not a chord')"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "NOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2",
      "mutated_line": "NOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 3",
      "code": "from itertools import product\nNOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 3\nconfig = [('Major', 4), ('Minor', 3)]\nDCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 2) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 7])}\n\ndef determine_chord_type(chord: str) -> str:\n    chord = tuple(chord.split()) if isinstance(chord, str) else ''\n    return DCT_CHORDS.get(chord, 'Not a chord')"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "NOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2",
      "mutated_line": "NOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 1",
      "code": "from itertools import product\nNOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 1\nconfig = [('Major', 4), ('Minor', 3)]\nDCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 2) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 7])}\n\ndef determine_chord_type(chord: str) -> str:\n    chord = tuple(chord.split()) if isinstance(chord, str) else ''\n    return DCT_CHORDS.get(chord, 'Not a chord')"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "NOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2",
      "mutated_line": "NOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 0",
      "code": "from itertools import product\nNOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 0\nconfig = [('Major', 4), ('Minor', 3)]\nDCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 2) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 7])}\n\ndef determine_chord_type(chord: str) -> str:\n    chord = tuple(chord.split()) if isinstance(chord, str) else ''\n    return DCT_CHORDS.get(chord, 'Not a chord')"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "NOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2",
      "mutated_line": "NOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 1",
      "code": "from itertools import product\nNOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 1\nconfig = [('Major', 4), ('Minor', 3)]\nDCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 2) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 7])}\n\ndef determine_chord_type(chord: str) -> str:\n    chord = tuple(chord.split()) if isinstance(chord, str) else ''\n    return DCT_CHORDS.get(chord, 'Not a chord')"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "NOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2",
      "mutated_line": "NOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * -2",
      "code": "from itertools import product\nNOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * -2\nconfig = [('Major', 4), ('Minor', 3)]\nDCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 2) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 7])}\n\ndef determine_chord_type(chord: str) -> str:\n    chord = tuple(chord.split()) if isinstance(chord, str) else ''\n    return DCT_CHORDS.get(chord, 'Not a chord')"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "config = [('Major', 4), ('Minor', 3)]",
      "mutated_line": "config = [('', 4), ('Minor', 3)]",
      "code": "from itertools import product\nNOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2\nconfig = [('', 4), ('Minor', 3)]\nDCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 2) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 7])}\n\ndef determine_chord_type(chord: str) -> str:\n    chord = tuple(chord.split()) if isinstance(chord, str) else ''\n    return DCT_CHORDS.get(chord, 'Not a chord')"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "config = [('Major', 4), ('Minor', 3)]",
      "mutated_line": "config = [('Major', 5), ('Minor', 3)]",
      "code": "from itertools import product\nNOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2\nconfig = [('Major', 5), ('Minor', 3)]\nDCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 2) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 7])}\n\ndef determine_chord_type(chord: str) -> str:\n    chord = tuple(chord.split()) if isinstance(chord, str) else ''\n    return DCT_CHORDS.get(chord, 'Not a chord')"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "config = [('Major', 4), ('Minor', 3)]",
      "mutated_line": "config = [('Major', 3), ('Minor', 3)]",
      "code": "from itertools import product\nNOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2\nconfig = [('Major', 3), ('Minor', 3)]\nDCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 2) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 7])}\n\ndef determine_chord_type(chord: str) -> str:\n    chord = tuple(chord.split()) if isinstance(chord, str) else ''\n    return DCT_CHORDS.get(chord, 'Not a chord')"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "config = [('Major', 4), ('Minor', 3)]",
      "mutated_line": "config = [('Major', 0), ('Minor', 3)]",
      "code": "from itertools import product\nNOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2\nconfig = [('Major', 0), ('Minor', 3)]\nDCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 2) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 7])}\n\ndef determine_chord_type(chord: str) -> str:\n    chord = tuple(chord.split()) if isinstance(chord, str) else ''\n    return DCT_CHORDS.get(chord, 'Not a chord')"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "config = [('Major', 4), ('Minor', 3)]",
      "mutated_line": "config = [('Major', 1), ('Minor', 3)]",
      "code": "from itertools import product\nNOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2\nconfig = [('Major', 1), ('Minor', 3)]\nDCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 2) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 7])}\n\ndef determine_chord_type(chord: str) -> str:\n    chord = tuple(chord.split()) if isinstance(chord, str) else ''\n    return DCT_CHORDS.get(chord, 'Not a chord')"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "config = [('Major', 4), ('Minor', 3)]",
      "mutated_line": "config = [('Major', -4), ('Minor', 3)]",
      "code": "from itertools import product\nNOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2\nconfig = [('Major', -4), ('Minor', 3)]\nDCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 2) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 7])}\n\ndef determine_chord_type(chord: str) -> str:\n    chord = tuple(chord.split()) if isinstance(chord, str) else ''\n    return DCT_CHORDS.get(chord, 'Not a chord')"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "config = [('Major', 4), ('Minor', 3)]",
      "mutated_line": "config = [('Major', 4), ('', 3)]",
      "code": "from itertools import product\nNOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2\nconfig = [('Major', 4), ('', 3)]\nDCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 2) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 7])}\n\ndef determine_chord_type(chord: str) -> str:\n    chord = tuple(chord.split()) if isinstance(chord, str) else ''\n    return DCT_CHORDS.get(chord, 'Not a chord')"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "config = [('Major', 4), ('Minor', 3)]",
      "mutated_line": "config = [('Major', 4), ('Minor', 4)]",
      "code": "from itertools import product\nNOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2\nconfig = [('Major', 4), ('Minor', 4)]\nDCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 2) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 7])}\n\ndef determine_chord_type(chord: str) -> str:\n    chord = tuple(chord.split()) if isinstance(chord, str) else ''\n    return DCT_CHORDS.get(chord, 'Not a chord')"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "config = [('Major', 4), ('Minor', 3)]",
      "mutated_line": "config = [('Major', 4), ('Minor', 2)]",
      "code": "from itertools import product\nNOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2\nconfig = [('Major', 4), ('Minor', 2)]\nDCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 2) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 7])}\n\ndef determine_chord_type(chord: str) -> str:\n    chord = tuple(chord.split()) if isinstance(chord, str) else ''\n    return DCT_CHORDS.get(chord, 'Not a chord')"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "config = [('Major', 4), ('Minor', 3)]",
      "mutated_line": "config = [('Major', 4), ('Minor', 0)]",
      "code": "from itertools import product\nNOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2\nconfig = [('Major', 4), ('Minor', 0)]\nDCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 2) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 7])}\n\ndef determine_chord_type(chord: str) -> str:\n    chord = tuple(chord.split()) if isinstance(chord, str) else ''\n    return DCT_CHORDS.get(chord, 'Not a chord')"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "config = [('Major', 4), ('Minor', 3)]",
      "mutated_line": "config = [('Major', 4), ('Minor', 1)]",
      "code": "from itertools import product\nNOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2\nconfig = [('Major', 4), ('Minor', 1)]\nDCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 2) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 7])}\n\ndef determine_chord_type(chord: str) -> str:\n    chord = tuple(chord.split()) if isinstance(chord, str) else ''\n    return DCT_CHORDS.get(chord, 'Not a chord')"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "config = [('Major', 4), ('Minor', 3)]",
      "mutated_line": "config = [('Major', 4), ('Minor', -3)]",
      "code": "from itertools import product\nNOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2\nconfig = [('Major', 4), ('Minor', -3)]\nDCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 2) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 7])}\n\ndef determine_chord_type(chord: str) -> str:\n    chord = tuple(chord.split()) if isinstance(chord, str) else ''\n    return DCT_CHORDS.get(chord, 'Not a chord')"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "chord = tuple(chord.split()) if isinstance(chord, str) else ''",
      "mutated_line": "chord = tuple(chord.split()) if isinstance(chord, str) else 'MUTATED'",
      "code": "from itertools import product\nNOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2\nconfig = [('Major', 4), ('Minor', 3)]\nDCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 2) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 7])}\n\ndef determine_chord_type(chord: str) -> str:\n    chord = tuple(chord.split()) if isinstance(chord, str) else 'MUTATED'\n    return DCT_CHORDS.get(chord, 'Not a chord')"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return DCT_CHORDS.get(chord, 'Not a chord')",
      "mutated_line": "return DCT_CHORDS.get(chord, '')",
      "code": "from itertools import product\nNOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2\nconfig = [('Major', 4), ('Minor', 3)]\nDCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 2) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 7])}\n\ndef determine_chord_type(chord: str) -> str:\n    chord = tuple(chord.split()) if isinstance(chord, str) else ''\n    return DCT_CHORDS.get(chord, '')"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "NOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2",
      "mutated_line": "NOTES = [[''], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2",
      "code": "from itertools import product\nNOTES = [[''], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2\nconfig = [('Major', 4), ('Minor', 3)]\nDCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 2) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 7])}\n\ndef determine_chord_type(chord: str) -> str:\n    chord = tuple(chord.split()) if isinstance(chord, str) else ''\n    return DCT_CHORDS.get(chord, 'Not a chord')"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "NOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2",
      "mutated_line": "NOTES = [['C'], ['', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2",
      "code": "from itertools import product\nNOTES = [['C'], ['', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2\nconfig = [('Major', 4), ('Minor', 3)]\nDCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 2) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 7])}\n\ndef determine_chord_type(chord: str) -> str:\n    chord = tuple(chord.split()) if isinstance(chord, str) else ''\n    return DCT_CHORDS.get(chord, 'Not a chord')"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "NOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2",
      "mutated_line": "NOTES = [['C'], ['C#', ''], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2",
      "code": "from itertools import product\nNOTES = [['C'], ['C#', ''], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2\nconfig = [('Major', 4), ('Minor', 3)]\nDCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 2) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 7])}\n\ndef determine_chord_type(chord: str) -> str:\n    chord = tuple(chord.split()) if isinstance(chord, str) else ''\n    return DCT_CHORDS.get(chord, 'Not a chord')"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "NOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2",
      "mutated_line": "NOTES = [['C'], ['C#', 'Db'], [''], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2",
      "code": "from itertools import product\nNOTES = [['C'], ['C#', 'Db'], [''], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2\nconfig = [('Major', 4), ('Minor', 3)]\nDCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 2) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 7])}\n\ndef determine_chord_type(chord: str) -> str:\n    chord = tuple(chord.split()) if isinstance(chord, str) else ''\n    return DCT_CHORDS.get(chord, 'Not a chord')"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "NOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2",
      "mutated_line": "NOTES = [['C'], ['C#', 'Db'], ['D'], ['', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2",
      "code": "from itertools import product\nNOTES = [['C'], ['C#', 'Db'], ['D'], ['', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2\nconfig = [('Major', 4), ('Minor', 3)]\nDCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 2) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 7])}\n\ndef determine_chord_type(chord: str) -> str:\n    chord = tuple(chord.split()) if isinstance(chord, str) else ''\n    return DCT_CHORDS.get(chord, 'Not a chord')"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "NOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2",
      "mutated_line": "NOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', ''], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2",
      "code": "from itertools import product\nNOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', ''], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2\nconfig = [('Major', 4), ('Minor', 3)]\nDCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 2) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 7])}\n\ndef determine_chord_type(chord: str) -> str:\n    chord = tuple(chord.split()) if isinstance(chord, str) else ''\n    return DCT_CHORDS.get(chord, 'Not a chord')"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "NOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2",
      "mutated_line": "NOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], [''], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2",
      "code": "from itertools import product\nNOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], [''], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2\nconfig = [('Major', 4), ('Minor', 3)]\nDCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 2) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 7])}\n\ndef determine_chord_type(chord: str) -> str:\n    chord = tuple(chord.split()) if isinstance(chord, str) else ''\n    return DCT_CHORDS.get(chord, 'Not a chord')"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "NOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2",
      "mutated_line": "NOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], [''], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2",
      "code": "from itertools import product\nNOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], [''], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2\nconfig = [('Major', 4), ('Minor', 3)]\nDCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 2) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 7])}\n\ndef determine_chord_type(chord: str) -> str:\n    chord = tuple(chord.split()) if isinstance(chord, str) else ''\n    return DCT_CHORDS.get(chord, 'Not a chord')"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "NOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2",
      "mutated_line": "NOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2",
      "code": "from itertools import product\nNOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2\nconfig = [('Major', 4), ('Minor', 3)]\nDCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 2) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 7])}\n\ndef determine_chord_type(chord: str) -> str:\n    chord = tuple(chord.split()) if isinstance(chord, str) else ''\n    return DCT_CHORDS.get(chord, 'Not a chord')"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "NOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2",
      "mutated_line": "NOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', ''], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2",
      "code": "from itertools import product\nNOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', ''], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2\nconfig = [('Major', 4), ('Minor', 3)]\nDCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 2) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 7])}\n\ndef determine_chord_type(chord: str) -> str:\n    chord = tuple(chord.split()) if isinstance(chord, str) else ''\n    return DCT_CHORDS.get(chord, 'Not a chord')"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "NOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2",
      "mutated_line": "NOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], [''], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2",
      "code": "from itertools import product\nNOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], [''], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2\nconfig = [('Major', 4), ('Minor', 3)]\nDCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 2) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 7])}\n\ndef determine_chord_type(chord: str) -> str:\n    chord = tuple(chord.split()) if isinstance(chord, str) else ''\n    return DCT_CHORDS.get(chord, 'Not a chord')"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "NOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2",
      "mutated_line": "NOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2",
      "code": "from itertools import product\nNOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2\nconfig = [('Major', 4), ('Minor', 3)]\nDCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 2) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 7])}\n\ndef determine_chord_type(chord: str) -> str:\n    chord = tuple(chord.split()) if isinstance(chord, str) else ''\n    return DCT_CHORDS.get(chord, 'Not a chord')"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "NOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2",
      "mutated_line": "NOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', ''], ['A'], ['A#', 'Bb'], ['B']] * 2",
      "code": "from itertools import product\nNOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', ''], ['A'], ['A#', 'Bb'], ['B']] * 2\nconfig = [('Major', 4), ('Minor', 3)]\nDCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 2) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 7])}\n\ndef determine_chord_type(chord: str) -> str:\n    chord = tuple(chord.split()) if isinstance(chord, str) else ''\n    return DCT_CHORDS.get(chord, 'Not a chord')"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "NOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2",
      "mutated_line": "NOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], [''], ['A#', 'Bb'], ['B']] * 2",
      "code": "from itertools import product\nNOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], [''], ['A#', 'Bb'], ['B']] * 2\nconfig = [('Major', 4), ('Minor', 3)]\nDCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 2) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 7])}\n\ndef determine_chord_type(chord: str) -> str:\n    chord = tuple(chord.split()) if isinstance(chord, str) else ''\n    return DCT_CHORDS.get(chord, 'Not a chord')"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "NOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2",
      "mutated_line": "NOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['', 'Bb'], ['B']] * 2",
      "code": "from itertools import product\nNOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['', 'Bb'], ['B']] * 2\nconfig = [('Major', 4), ('Minor', 3)]\nDCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 2) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 7])}\n\ndef determine_chord_type(chord: str) -> str:\n    chord = tuple(chord.split()) if isinstance(chord, str) else ''\n    return DCT_CHORDS.get(chord, 'Not a chord')"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "NOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2",
      "mutated_line": "NOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', ''], ['B']] * 2",
      "code": "from itertools import product\nNOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', ''], ['B']] * 2\nconfig = [('Major', 4), ('Minor', 3)]\nDCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 2) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 7])}\n\ndef determine_chord_type(chord: str) -> str:\n    chord = tuple(chord.split()) if isinstance(chord, str) else ''\n    return DCT_CHORDS.get(chord, 'Not a chord')"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "NOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2",
      "mutated_line": "NOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['']] * 2",
      "code": "from itertools import product\nNOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['']] * 2\nconfig = [('Major', 4), ('Minor', 3)]\nDCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 2) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 7])}\n\ndef determine_chord_type(chord: str) -> str:\n    chord = tuple(chord.split()) if isinstance(chord, str) else ''\n    return DCT_CHORDS.get(chord, 'Not a chord')"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "DCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 2) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 7])}",
      "mutated_line": "DCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) / 2) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 7])}",
      "code": "from itertools import product\nNOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2\nconfig = [('Major', 4), ('Minor', 3)]\nDCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) / 2) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 7])}\n\ndef determine_chord_type(chord: str) -> str:\n    chord = tuple(chord.split()) if isinstance(chord, str) else ''\n    return DCT_CHORDS.get(chord, 'Not a chord')"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "DCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 2) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 7])}",
      "mutated_line": "DCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) * 2) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 7])}",
      "code": "from itertools import product\nNOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2\nconfig = [('Major', 4), ('Minor', 3)]\nDCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) * 2) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 7])}\n\ndef determine_chord_type(chord: str) -> str:\n    chord = tuple(chord.split()) if isinstance(chord, str) else ''\n    return DCT_CHORDS.get(chord, 'Not a chord')"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "DCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 2) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 7])}",
      "mutated_line": "DCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 3) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 7])}",
      "code": "from itertools import product\nNOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2\nconfig = [('Major', 4), ('Minor', 3)]\nDCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 3) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 7])}\n\ndef determine_chord_type(chord: str) -> str:\n    chord = tuple(chord.split()) if isinstance(chord, str) else ''\n    return DCT_CHORDS.get(chord, 'Not a chord')"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "DCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 2) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 7])}",
      "mutated_line": "DCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 1) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 7])}",
      "code": "from itertools import product\nNOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2\nconfig = [('Major', 4), ('Minor', 3)]\nDCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 1) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 7])}\n\ndef determine_chord_type(chord: str) -> str:\n    chord = tuple(chord.split()) if isinstance(chord, str) else ''\n    return DCT_CHORDS.get(chord, 'Not a chord')"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "DCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 2) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 7])}",
      "mutated_line": "DCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 0) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 7])}",
      "code": "from itertools import product\nNOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2\nconfig = [('Major', 4), ('Minor', 3)]\nDCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 0) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 7])}\n\ndef determine_chord_type(chord: str) -> str:\n    chord = tuple(chord.split()) if isinstance(chord, str) else ''\n    return DCT_CHORDS.get(chord, 'Not a chord')"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "DCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 2) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 7])}",
      "mutated_line": "DCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 1) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 7])}",
      "code": "from itertools import product\nNOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2\nconfig = [('Major', 4), ('Minor', 3)]\nDCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 1) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 7])}\n\ndef determine_chord_type(chord: str) -> str:\n    chord = tuple(chord.split()) if isinstance(chord, str) else ''\n    return DCT_CHORDS.get(chord, 'Not a chord')"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "DCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 2) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 7])}",
      "mutated_line": "DCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // -2) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 7])}",
      "code": "from itertools import product\nNOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2\nconfig = [('Major', 4), ('Minor', 3)]\nDCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // -2) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 7])}\n\ndef determine_chord_type(chord: str) -> str:\n    chord = tuple(chord.split()) if isinstance(chord, str) else ''\n    return DCT_CHORDS.get(chord, 'Not a chord')"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "DCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 2) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 7])}",
      "mutated_line": "DCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 2) for c in product(NOTES[i], NOTES[i - offset], NOTES[i + 7])}",
      "code": "from itertools import product\nNOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2\nconfig = [('Major', 4), ('Minor', 3)]\nDCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 2) for c in product(NOTES[i], NOTES[i - offset], NOTES[i + 7])}\n\ndef determine_chord_type(chord: str) -> str:\n    chord = tuple(chord.split()) if isinstance(chord, str) else ''\n    return DCT_CHORDS.get(chord, 'Not a chord')"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "DCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 2) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 7])}",
      "mutated_line": "DCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 2) for c in product(NOTES[i], NOTES[i * offset], NOTES[i + 7])}",
      "code": "from itertools import product\nNOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2\nconfig = [('Major', 4), ('Minor', 3)]\nDCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 2) for c in product(NOTES[i], NOTES[i * offset], NOTES[i + 7])}\n\ndef determine_chord_type(chord: str) -> str:\n    chord = tuple(chord.split()) if isinstance(chord, str) else ''\n    return DCT_CHORDS.get(chord, 'Not a chord')"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "DCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 2) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 7])}",
      "mutated_line": "DCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 2) for c in product(NOTES[i], NOTES[i + offset], NOTES[i - 7])}",
      "code": "from itertools import product\nNOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2\nconfig = [('Major', 4), ('Minor', 3)]\nDCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 2) for c in product(NOTES[i], NOTES[i + offset], NOTES[i - 7])}\n\ndef determine_chord_type(chord: str) -> str:\n    chord = tuple(chord.split()) if isinstance(chord, str) else ''\n    return DCT_CHORDS.get(chord, 'Not a chord')"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "DCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 2) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 7])}",
      "mutated_line": "DCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 2) for c in product(NOTES[i], NOTES[i + offset], NOTES[i * 7])}",
      "code": "from itertools import product\nNOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2\nconfig = [('Major', 4), ('Minor', 3)]\nDCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 2) for c in product(NOTES[i], NOTES[i + offset], NOTES[i * 7])}\n\ndef determine_chord_type(chord: str) -> str:\n    chord = tuple(chord.split()) if isinstance(chord, str) else ''\n    return DCT_CHORDS.get(chord, 'Not a chord')"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "DCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 2) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 7])}",
      "mutated_line": "DCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 2) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 8])}",
      "code": "from itertools import product\nNOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2\nconfig = [('Major', 4), ('Minor', 3)]\nDCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 2) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 8])}\n\ndef determine_chord_type(chord: str) -> str:\n    chord = tuple(chord.split()) if isinstance(chord, str) else ''\n    return DCT_CHORDS.get(chord, 'Not a chord')"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "DCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 2) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 7])}",
      "mutated_line": "DCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 2) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 6])}",
      "code": "from itertools import product\nNOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2\nconfig = [('Major', 4), ('Minor', 3)]\nDCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 2) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 6])}\n\ndef determine_chord_type(chord: str) -> str:\n    chord = tuple(chord.split()) if isinstance(chord, str) else ''\n    return DCT_CHORDS.get(chord, 'Not a chord')"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "DCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 2) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 7])}",
      "mutated_line": "DCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 2) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 0])}",
      "code": "from itertools import product\nNOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2\nconfig = [('Major', 4), ('Minor', 3)]\nDCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 2) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 0])}\n\ndef determine_chord_type(chord: str) -> str:\n    chord = tuple(chord.split()) if isinstance(chord, str) else ''\n    return DCT_CHORDS.get(chord, 'Not a chord')"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "DCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 2) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 7])}",
      "mutated_line": "DCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 2) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 1])}",
      "code": "from itertools import product\nNOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2\nconfig = [('Major', 4), ('Minor', 3)]\nDCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 2) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 1])}\n\ndef determine_chord_type(chord: str) -> str:\n    chord = tuple(chord.split()) if isinstance(chord, str) else ''\n    return DCT_CHORDS.get(chord, 'Not a chord')"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "DCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 2) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 7])}",
      "mutated_line": "DCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 2) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + -7])}",
      "code": "from itertools import product\nNOTES = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']] * 2\nconfig = [('Major', 4), ('Minor', 3)]\nDCT_CHORDS = {c: mode for (mode, offset) in config for i in range(len(NOTES) // 2) for c in product(NOTES[i], NOTES[i + offset], NOTES[i + -7])}\n\ndef determine_chord_type(chord: str) -> str:\n    chord = tuple(chord.split()) if isinstance(chord, str) else ''\n    return DCT_CHORDS.get(chord, 'Not a chord')"
    }
  ]
}