{
  "task_id": "taco_12490",
  "entry_point": "find_most_popular_friend",
  "mutant_count": 81,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "graph = [[]] + group  # Convert to 1-based index",
      "mutated_line": "graph = [[]] - group",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count + 1)]\n        p = [0 for _ in range(f_count + 1)]\n        color = [0 for _ in range(f_count + 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] + 1\n            color[top] = 2\n        return sum(d) / (f_count * 1.0)\n    graph = [[]] - group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -1\n    for f in range(1, no_of_friends + 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 6))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "graph = [[]] + group  # Convert to 1-based index",
      "mutated_line": "graph = [[]] * group",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count + 1)]\n        p = [0 for _ in range(f_count + 1)]\n        color = [0 for _ in range(f_count + 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] + 1\n            color[top] = 2\n        return sum(d) / (f_count * 1.0)\n    graph = [[]] * group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -1\n    for f in range(1, no_of_friends + 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 6))"
    },
    {
      "operator": "UOI",
      "lineno": 23,
      "original_line": "popular = -1",
      "mutated_line": "popular = +1",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count + 1)]\n        p = [0 for _ in range(f_count + 1)]\n        color = [0 for _ in range(f_count + 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] + 1\n            color[top] = 2\n        return sum(d) / (f_count * 1.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = +1\n    for f in range(1, no_of_friends + 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 6))"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "return sum(d) / (f_count * 1.0)",
      "mutated_line": "return sum(d) * (f_count * 1.0)",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count + 1)]\n        p = [0 for _ in range(f_count + 1)]\n        color = [0 for _ in range(f_count + 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] + 1\n            color[top] = 2\n        return sum(d) * (f_count * 1.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -1\n    for f in range(1, no_of_friends + 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 6))"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "return sum(d) / (f_count * 1.0)",
      "mutated_line": "return sum(d) // (f_count * 1.0)",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count + 1)]\n        p = [0 for _ in range(f_count + 1)]\n        color = [0 for _ in range(f_count + 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] + 1\n            color[top] = 2\n        return sum(d) // (f_count * 1.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -1\n    for f in range(1, no_of_friends + 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 6))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "min_notoriety = float('inf')",
      "mutated_line": "min_notoriety = float('')",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count + 1)]\n        p = [0 for _ in range(f_count + 1)]\n        color = [0 for _ in range(f_count + 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] + 1\n            color[top] = 2\n        return sum(d) / (f_count * 1.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('')\n    popular = -1\n    for f in range(1, no_of_friends + 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 6))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "popular = -1",
      "mutated_line": "popular = -2",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count + 1)]\n        p = [0 for _ in range(f_count + 1)]\n        color = [0 for _ in range(f_count + 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] + 1\n            color[top] = 2\n        return sum(d) / (f_count * 1.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -2\n    for f in range(1, no_of_friends + 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 6))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "popular = -1",
      "mutated_line": "popular = -0",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count + 1)]\n        p = [0 for _ in range(f_count + 1)]\n        color = [0 for _ in range(f_count + 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] + 1\n            color[top] = 2\n        return sum(d) / (f_count * 1.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -0\n    for f in range(1, no_of_friends + 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 6))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "popular = -1",
      "mutated_line": "popular = -0",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count + 1)]\n        p = [0 for _ in range(f_count + 1)]\n        color = [0 for _ in range(f_count + 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] + 1\n            color[top] = 2\n        return sum(d) / (f_count * 1.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -0\n    for f in range(1, no_of_friends + 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 6))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "popular = -1",
      "mutated_line": "popular = --1",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count + 1)]\n        p = [0 for _ in range(f_count + 1)]\n        color = [0 for _ in range(f_count + 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] + 1\n            color[top] = 2\n        return sum(d) / (f_count * 1.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = --1\n    for f in range(1, no_of_friends + 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 6))"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for f in range(1, no_of_friends + 1):",
      "mutated_line": "for f in range(2, no_of_friends + 1):",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count + 1)]\n        p = [0 for _ in range(f_count + 1)]\n        color = [0 for _ in range(f_count + 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] + 1\n            color[top] = 2\n        return sum(d) / (f_count * 1.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -1\n    for f in range(2, no_of_friends + 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 6))"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for f in range(1, no_of_friends + 1):",
      "mutated_line": "for f in range(0, no_of_friends + 1):",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count + 1)]\n        p = [0 for _ in range(f_count + 1)]\n        color = [0 for _ in range(f_count + 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] + 1\n            color[top] = 2\n        return sum(d) / (f_count * 1.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -1\n    for f in range(0, no_of_friends + 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 6))"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for f in range(1, no_of_friends + 1):",
      "mutated_line": "for f in range(0, no_of_friends + 1):",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count + 1)]\n        p = [0 for _ in range(f_count + 1)]\n        color = [0 for _ in range(f_count + 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] + 1\n            color[top] = 2\n        return sum(d) / (f_count * 1.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -1\n    for f in range(0, no_of_friends + 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 6))"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for f in range(1, no_of_friends + 1):",
      "mutated_line": "for f in range(-1, no_of_friends + 1):",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count + 1)]\n        p = [0 for _ in range(f_count + 1)]\n        color = [0 for _ in range(f_count + 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] + 1\n            color[top] = 2\n        return sum(d) / (f_count * 1.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -1\n    for f in range(-1, no_of_friends + 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 6))"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "for f in range(1, no_of_friends + 1):",
      "mutated_line": "for f in range(1, no_of_friends - 1):",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count + 1)]\n        p = [0 for _ in range(f_count + 1)]\n        color = [0 for _ in range(f_count + 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] + 1\n            color[top] = 2\n        return sum(d) / (f_count * 1.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -1\n    for f in range(1, no_of_friends - 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 6))"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "for f in range(1, no_of_friends + 1):",
      "mutated_line": "for f in range(1, no_of_friends * 1):",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count + 1)]\n        p = [0 for _ in range(f_count + 1)]\n        color = [0 for _ in range(f_count + 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] + 1\n            color[top] = 2\n        return sum(d) / (f_count * 1.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -1\n    for f in range(1, no_of_friends * 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 6))"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if curr_not < min_notoriety:",
      "mutated_line": "if curr_not <= min_notoriety:",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count + 1)]\n        p = [0 for _ in range(f_count + 1)]\n        color = [0 for _ in range(f_count + 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] + 1\n            color[top] = 2\n        return sum(d) / (f_count * 1.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -1\n    for f in range(1, no_of_friends + 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not <= min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 6))"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if curr_not < min_notoriety:",
      "mutated_line": "if curr_not >= min_notoriety:",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count + 1)]\n        p = [0 for _ in range(f_count + 1)]\n        color = [0 for _ in range(f_count + 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] + 1\n            color[top] = 2\n        return sum(d) / (f_count * 1.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -1\n    for f in range(1, no_of_friends + 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not >= min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 6))"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if curr_not < min_notoriety:",
      "mutated_line": "if curr_not != min_notoriety:",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count + 1)]\n        p = [0 for _ in range(f_count + 1)]\n        color = [0 for _ in range(f_count + 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] + 1\n            color[top] = 2\n        return sum(d) / (f_count * 1.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -1\n    for f in range(1, no_of_friends + 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not != min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 6))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d = [0 for _ in range(f_count + 1)]",
      "mutated_line": "d = [1 for _ in range(f_count + 1)]",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [1 for _ in range(f_count + 1)]\n        p = [0 for _ in range(f_count + 1)]\n        color = [0 for _ in range(f_count + 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] + 1\n            color[top] = 2\n        return sum(d) / (f_count * 1.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -1\n    for f in range(1, no_of_friends + 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 6))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d = [0 for _ in range(f_count + 1)]",
      "mutated_line": "d = [-1 for _ in range(f_count + 1)]",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [-1 for _ in range(f_count + 1)]\n        p = [0 for _ in range(f_count + 1)]\n        color = [0 for _ in range(f_count + 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] + 1\n            color[top] = 2\n        return sum(d) / (f_count * 1.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -1\n    for f in range(1, no_of_friends + 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 6))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d = [0 for _ in range(f_count + 1)]",
      "mutated_line": "d = [1 for _ in range(f_count + 1)]",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [1 for _ in range(f_count + 1)]\n        p = [0 for _ in range(f_count + 1)]\n        color = [0 for _ in range(f_count + 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] + 1\n            color[top] = 2\n        return sum(d) / (f_count * 1.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -1\n    for f in range(1, no_of_friends + 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 6))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "p = [0 for _ in range(f_count + 1)]",
      "mutated_line": "p = [1 for _ in range(f_count + 1)]",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count + 1)]\n        p = [1 for _ in range(f_count + 1)]\n        color = [0 for _ in range(f_count + 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] + 1\n            color[top] = 2\n        return sum(d) / (f_count * 1.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -1\n    for f in range(1, no_of_friends + 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 6))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "p = [0 for _ in range(f_count + 1)]",
      "mutated_line": "p = [-1 for _ in range(f_count + 1)]",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count + 1)]\n        p = [-1 for _ in range(f_count + 1)]\n        color = [0 for _ in range(f_count + 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] + 1\n            color[top] = 2\n        return sum(d) / (f_count * 1.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -1\n    for f in range(1, no_of_friends + 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 6))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "p = [0 for _ in range(f_count + 1)]",
      "mutated_line": "p = [1 for _ in range(f_count + 1)]",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count + 1)]\n        p = [1 for _ in range(f_count + 1)]\n        color = [0 for _ in range(f_count + 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] + 1\n            color[top] = 2\n        return sum(d) / (f_count * 1.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -1\n    for f in range(1, no_of_friends + 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 6))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "color = [0 for _ in range(f_count + 1)]  # 0: WHITE, 1: GRAY, 2: BLACK",
      "mutated_line": "color = [1 for _ in range(f_count + 1)]",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count + 1)]\n        p = [0 for _ in range(f_count + 1)]\n        color = [1 for _ in range(f_count + 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] + 1\n            color[top] = 2\n        return sum(d) / (f_count * 1.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -1\n    for f in range(1, no_of_friends + 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 6))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "color = [0 for _ in range(f_count + 1)]  # 0: WHITE, 1: GRAY, 2: BLACK",
      "mutated_line": "color = [-1 for _ in range(f_count + 1)]",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count + 1)]\n        p = [0 for _ in range(f_count + 1)]\n        color = [-1 for _ in range(f_count + 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] + 1\n            color[top] = 2\n        return sum(d) / (f_count * 1.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -1\n    for f in range(1, no_of_friends + 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 6))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "color = [0 for _ in range(f_count + 1)]  # 0: WHITE, 1: GRAY, 2: BLACK",
      "mutated_line": "color = [1 for _ in range(f_count + 1)]",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count + 1)]\n        p = [0 for _ in range(f_count + 1)]\n        color = [1 for _ in range(f_count + 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] + 1\n            color[top] = 2\n        return sum(d) / (f_count * 1.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -1\n    for f in range(1, no_of_friends + 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 6))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "color[top] = 2",
      "mutated_line": "color[top] = 3",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count + 1)]\n        p = [0 for _ in range(f_count + 1)]\n        color = [0 for _ in range(f_count + 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] + 1\n            color[top] = 3\n        return sum(d) / (f_count * 1.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -1\n    for f in range(1, no_of_friends + 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 6))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "color[top] = 2",
      "mutated_line": "color[top] = 1",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count + 1)]\n        p = [0 for _ in range(f_count + 1)]\n        color = [0 for _ in range(f_count + 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] + 1\n            color[top] = 1\n        return sum(d) / (f_count * 1.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -1\n    for f in range(1, no_of_friends + 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 6))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "color[top] = 2",
      "mutated_line": "color[top] = 0",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count + 1)]\n        p = [0 for _ in range(f_count + 1)]\n        color = [0 for _ in range(f_count + 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] + 1\n            color[top] = 0\n        return sum(d) / (f_count * 1.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -1\n    for f in range(1, no_of_friends + 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 6))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "color[top] = 2",
      "mutated_line": "color[top] = 1",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count + 1)]\n        p = [0 for _ in range(f_count + 1)]\n        color = [0 for _ in range(f_count + 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] + 1\n            color[top] = 1\n        return sum(d) / (f_count * 1.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -1\n    for f in range(1, no_of_friends + 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 6))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "color[top] = 2",
      "mutated_line": "color[top] = -2",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count + 1)]\n        p = [0 for _ in range(f_count + 1)]\n        color = [0 for _ in range(f_count + 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] + 1\n            color[top] = -2\n        return sum(d) / (f_count * 1.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -1\n    for f in range(1, no_of_friends + 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 6))"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "return sum(d) / (f_count * 1.0)",
      "mutated_line": "return sum(d) / (f_count / 1.0)",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count + 1)]\n        p = [0 for _ in range(f_count + 1)]\n        color = [0 for _ in range(f_count + 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] + 1\n            color[top] = 2\n        return sum(d) / (f_count / 1.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -1\n    for f in range(1, no_of_friends + 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 6))"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "return sum(d) / (f_count * 1.0)",
      "mutated_line": "return sum(d) / (f_count + 1.0)",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count + 1)]\n        p = [0 for _ in range(f_count + 1)]\n        color = [0 for _ in range(f_count + 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] + 1\n            color[top] = 2\n        return sum(d) / (f_count + 1.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -1\n    for f in range(1, no_of_friends + 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 6))"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "return sum(d) / (f_count * 1.0)",
      "mutated_line": "return sum(d) / f_count ** 1.0",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count + 1)]\n        p = [0 for _ in range(f_count + 1)]\n        color = [0 for _ in range(f_count + 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] + 1\n            color[top] = 2\n        return sum(d) / f_count ** 1.0\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -1\n    for f in range(1, no_of_friends + 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 6))"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for f in range(1, no_of_friends + 1):",
      "mutated_line": "for f in range(1, no_of_friends + 2):",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count + 1)]\n        p = [0 for _ in range(f_count + 1)]\n        color = [0 for _ in range(f_count + 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] + 1\n            color[top] = 2\n        return sum(d) / (f_count * 1.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -1\n    for f in range(1, no_of_friends + 2):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 6))"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for f in range(1, no_of_friends + 1):",
      "mutated_line": "for f in range(1, no_of_friends + 0):",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count + 1)]\n        p = [0 for _ in range(f_count + 1)]\n        color = [0 for _ in range(f_count + 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] + 1\n            color[top] = 2\n        return sum(d) / (f_count * 1.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -1\n    for f in range(1, no_of_friends + 0):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 6))"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for f in range(1, no_of_friends + 1):",
      "mutated_line": "for f in range(1, no_of_friends + 0):",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count + 1)]\n        p = [0 for _ in range(f_count + 1)]\n        color = [0 for _ in range(f_count + 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] + 1\n            color[top] = 2\n        return sum(d) / (f_count * 1.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -1\n    for f in range(1, no_of_friends + 0):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 6))"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for f in range(1, no_of_friends + 1):",
      "mutated_line": "for f in range(1, no_of_friends + -1):",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count + 1)]\n        p = [0 for _ in range(f_count + 1)]\n        color = [0 for _ in range(f_count + 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] + 1\n            color[top] = 2\n        return sum(d) / (f_count * 1.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -1\n    for f in range(1, no_of_friends + -1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 6))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return popular, round(min_notoriety, 6)",
      "mutated_line": "return (popular, round(min_notoriety, 7))",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count + 1)]\n        p = [0 for _ in range(f_count + 1)]\n        color = [0 for _ in range(f_count + 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] + 1\n            color[top] = 2\n        return sum(d) / (f_count * 1.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -1\n    for f in range(1, no_of_friends + 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 7))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return popular, round(min_notoriety, 6)",
      "mutated_line": "return (popular, round(min_notoriety, 5))",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count + 1)]\n        p = [0 for _ in range(f_count + 1)]\n        color = [0 for _ in range(f_count + 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] + 1\n            color[top] = 2\n        return sum(d) / (f_count * 1.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -1\n    for f in range(1, no_of_friends + 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 5))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return popular, round(min_notoriety, 6)",
      "mutated_line": "return (popular, round(min_notoriety, 0))",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count + 1)]\n        p = [0 for _ in range(f_count + 1)]\n        color = [0 for _ in range(f_count + 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] + 1\n            color[top] = 2\n        return sum(d) / (f_count * 1.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -1\n    for f in range(1, no_of_friends + 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 0))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return popular, round(min_notoriety, 6)",
      "mutated_line": "return (popular, round(min_notoriety, 1))",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count + 1)]\n        p = [0 for _ in range(f_count + 1)]\n        color = [0 for _ in range(f_count + 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] + 1\n            color[top] = 2\n        return sum(d) / (f_count * 1.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -1\n    for f in range(1, no_of_friends + 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 1))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return popular, round(min_notoriety, 6)",
      "mutated_line": "return (popular, round(min_notoriety, -6))",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count + 1)]\n        p = [0 for _ in range(f_count + 1)]\n        color = [0 for _ in range(f_count + 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] + 1\n            color[top] = 2\n        return sum(d) / (f_count * 1.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -1\n    for f in range(1, no_of_friends + 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, -6))"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if color[node] == 0:",
      "mutated_line": "if color[node] != 0:",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count + 1)]\n        p = [0 for _ in range(f_count + 1)]\n        color = [0 for _ in range(f_count + 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] != 0:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] + 1\n            color[top] = 2\n        return sum(d) / (f_count * 1.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -1\n    for f in range(1, no_of_friends + 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 6))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return sum(d) / (f_count * 1.0)",
      "mutated_line": "return sum(d) / (f_count * 2.0)",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count + 1)]\n        p = [0 for _ in range(f_count + 1)]\n        color = [0 for _ in range(f_count + 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] + 1\n            color[top] = 2\n        return sum(d) / (f_count * 2.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -1\n    for f in range(1, no_of_friends + 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 6))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return sum(d) / (f_count * 1.0)",
      "mutated_line": "return sum(d) / (f_count * 0.0)",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count + 1)]\n        p = [0 for _ in range(f_count + 1)]\n        color = [0 for _ in range(f_count + 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] + 1\n            color[top] = 2\n        return sum(d) / (f_count * 0.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -1\n    for f in range(1, no_of_friends + 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 6))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return sum(d) / (f_count * 1.0)",
      "mutated_line": "return sum(d) / (f_count * 0)",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count + 1)]\n        p = [0 for _ in range(f_count + 1)]\n        color = [0 for _ in range(f_count + 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] + 1\n            color[top] = 2\n        return sum(d) / (f_count * 0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -1\n    for f in range(1, no_of_friends + 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 6))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return sum(d) / (f_count * 1.0)",
      "mutated_line": "return sum(d) / (f_count * -1.0)",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count + 1)]\n        p = [0 for _ in range(f_count + 1)]\n        color = [0 for _ in range(f_count + 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] + 1\n            color[top] = 2\n        return sum(d) / (f_count * -1.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -1\n    for f in range(1, no_of_friends + 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 6))"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "d = [0 for _ in range(f_count + 1)]",
      "mutated_line": "d = [0 for _ in range(f_count - 1)]",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count - 1)]\n        p = [0 for _ in range(f_count + 1)]\n        color = [0 for _ in range(f_count + 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] + 1\n            color[top] = 2\n        return sum(d) / (f_count * 1.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -1\n    for f in range(1, no_of_friends + 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 6))"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "d = [0 for _ in range(f_count + 1)]",
      "mutated_line": "d = [0 for _ in range(f_count * 1)]",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count * 1)]\n        p = [0 for _ in range(f_count + 1)]\n        color = [0 for _ in range(f_count + 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] + 1\n            color[top] = 2\n        return sum(d) / (f_count * 1.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -1\n    for f in range(1, no_of_friends + 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 6))"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "p = [0 for _ in range(f_count + 1)]",
      "mutated_line": "p = [0 for _ in range(f_count - 1)]",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count + 1)]\n        p = [0 for _ in range(f_count - 1)]\n        color = [0 for _ in range(f_count + 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] + 1\n            color[top] = 2\n        return sum(d) / (f_count * 1.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -1\n    for f in range(1, no_of_friends + 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 6))"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "p = [0 for _ in range(f_count + 1)]",
      "mutated_line": "p = [0 for _ in range(f_count * 1)]",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count + 1)]\n        p = [0 for _ in range(f_count * 1)]\n        color = [0 for _ in range(f_count + 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] + 1\n            color[top] = 2\n        return sum(d) / (f_count * 1.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -1\n    for f in range(1, no_of_friends + 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 6))"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "color = [0 for _ in range(f_count + 1)]  # 0: WHITE, 1: GRAY, 2: BLACK",
      "mutated_line": "color = [0 for _ in range(f_count - 1)]",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count + 1)]\n        p = [0 for _ in range(f_count + 1)]\n        color = [0 for _ in range(f_count - 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] + 1\n            color[top] = 2\n        return sum(d) / (f_count * 1.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -1\n    for f in range(1, no_of_friends + 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 6))"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "color = [0 for _ in range(f_count + 1)]  # 0: WHITE, 1: GRAY, 2: BLACK",
      "mutated_line": "color = [0 for _ in range(f_count * 1)]",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count + 1)]\n        p = [0 for _ in range(f_count + 1)]\n        color = [0 for _ in range(f_count * 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] + 1\n            color[top] = 2\n        return sum(d) / (f_count * 1.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -1\n    for f in range(1, no_of_friends + 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 6))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if color[node] == 0:",
      "mutated_line": "if color[node] == 1:",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count + 1)]\n        p = [0 for _ in range(f_count + 1)]\n        color = [0 for _ in range(f_count + 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 1:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] + 1\n            color[top] = 2\n        return sum(d) / (f_count * 1.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -1\n    for f in range(1, no_of_friends + 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 6))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if color[node] == 0:",
      "mutated_line": "if color[node] == -1:",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count + 1)]\n        p = [0 for _ in range(f_count + 1)]\n        color = [0 for _ in range(f_count + 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == -1:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] + 1\n            color[top] = 2\n        return sum(d) / (f_count * 1.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -1\n    for f in range(1, no_of_friends + 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 6))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if color[node] == 0:",
      "mutated_line": "if color[node] == 1:",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count + 1)]\n        p = [0 for _ in range(f_count + 1)]\n        color = [0 for _ in range(f_count + 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 1:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] + 1\n            color[top] = 2\n        return sum(d) / (f_count * 1.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -1\n    for f in range(1, no_of_friends + 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 6))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "color[node] = 1",
      "mutated_line": "color[node] = 2",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count + 1)]\n        p = [0 for _ in range(f_count + 1)]\n        color = [0 for _ in range(f_count + 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = 2\n                    p[node] = top\n                    d[node] = d[top] + 1\n            color[top] = 2\n        return sum(d) / (f_count * 1.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -1\n    for f in range(1, no_of_friends + 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 6))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "color[node] = 1",
      "mutated_line": "color[node] = 0",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count + 1)]\n        p = [0 for _ in range(f_count + 1)]\n        color = [0 for _ in range(f_count + 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = 0\n                    p[node] = top\n                    d[node] = d[top] + 1\n            color[top] = 2\n        return sum(d) / (f_count * 1.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -1\n    for f in range(1, no_of_friends + 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 6))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "color[node] = 1",
      "mutated_line": "color[node] = 0",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count + 1)]\n        p = [0 for _ in range(f_count + 1)]\n        color = [0 for _ in range(f_count + 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = 0\n                    p[node] = top\n                    d[node] = d[top] + 1\n            color[top] = 2\n        return sum(d) / (f_count * 1.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -1\n    for f in range(1, no_of_friends + 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 6))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "color[node] = 1",
      "mutated_line": "color[node] = -1",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count + 1)]\n        p = [0 for _ in range(f_count + 1)]\n        color = [0 for _ in range(f_count + 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = -1\n                    p[node] = top\n                    d[node] = d[top] + 1\n            color[top] = 2\n        return sum(d) / (f_count * 1.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -1\n    for f in range(1, no_of_friends + 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 6))"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "d[node] = d[top] + 1",
      "mutated_line": "d[node] = d[top] - 1",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count + 1)]\n        p = [0 for _ in range(f_count + 1)]\n        color = [0 for _ in range(f_count + 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] - 1\n            color[top] = 2\n        return sum(d) / (f_count * 1.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -1\n    for f in range(1, no_of_friends + 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 6))"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "d[node] = d[top] + 1",
      "mutated_line": "d[node] = d[top] * 1",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count + 1)]\n        p = [0 for _ in range(f_count + 1)]\n        color = [0 for _ in range(f_count + 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] * 1\n            color[top] = 2\n        return sum(d) / (f_count * 1.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -1\n    for f in range(1, no_of_friends + 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 6))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d = [0 for _ in range(f_count + 1)]",
      "mutated_line": "d = [0 for _ in range(f_count + 2)]",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count + 2)]\n        p = [0 for _ in range(f_count + 1)]\n        color = [0 for _ in range(f_count + 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] + 1\n            color[top] = 2\n        return sum(d) / (f_count * 1.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -1\n    for f in range(1, no_of_friends + 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 6))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d = [0 for _ in range(f_count + 1)]",
      "mutated_line": "d = [0 for _ in range(f_count + 0)]",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count + 0)]\n        p = [0 for _ in range(f_count + 1)]\n        color = [0 for _ in range(f_count + 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] + 1\n            color[top] = 2\n        return sum(d) / (f_count * 1.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -1\n    for f in range(1, no_of_friends + 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 6))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d = [0 for _ in range(f_count + 1)]",
      "mutated_line": "d = [0 for _ in range(f_count + 0)]",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count + 0)]\n        p = [0 for _ in range(f_count + 1)]\n        color = [0 for _ in range(f_count + 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] + 1\n            color[top] = 2\n        return sum(d) / (f_count * 1.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -1\n    for f in range(1, no_of_friends + 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 6))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d = [0 for _ in range(f_count + 1)]",
      "mutated_line": "d = [0 for _ in range(f_count + -1)]",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count + -1)]\n        p = [0 for _ in range(f_count + 1)]\n        color = [0 for _ in range(f_count + 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] + 1\n            color[top] = 2\n        return sum(d) / (f_count * 1.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -1\n    for f in range(1, no_of_friends + 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 6))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "p = [0 for _ in range(f_count + 1)]",
      "mutated_line": "p = [0 for _ in range(f_count + 2)]",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count + 1)]\n        p = [0 for _ in range(f_count + 2)]\n        color = [0 for _ in range(f_count + 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] + 1\n            color[top] = 2\n        return sum(d) / (f_count * 1.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -1\n    for f in range(1, no_of_friends + 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 6))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "p = [0 for _ in range(f_count + 1)]",
      "mutated_line": "p = [0 for _ in range(f_count + 0)]",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count + 1)]\n        p = [0 for _ in range(f_count + 0)]\n        color = [0 for _ in range(f_count + 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] + 1\n            color[top] = 2\n        return sum(d) / (f_count * 1.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -1\n    for f in range(1, no_of_friends + 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 6))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "p = [0 for _ in range(f_count + 1)]",
      "mutated_line": "p = [0 for _ in range(f_count + 0)]",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count + 1)]\n        p = [0 for _ in range(f_count + 0)]\n        color = [0 for _ in range(f_count + 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] + 1\n            color[top] = 2\n        return sum(d) / (f_count * 1.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -1\n    for f in range(1, no_of_friends + 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 6))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "p = [0 for _ in range(f_count + 1)]",
      "mutated_line": "p = [0 for _ in range(f_count + -1)]",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count + 1)]\n        p = [0 for _ in range(f_count + -1)]\n        color = [0 for _ in range(f_count + 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] + 1\n            color[top] = 2\n        return sum(d) / (f_count * 1.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -1\n    for f in range(1, no_of_friends + 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 6))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "color = [0 for _ in range(f_count + 1)]  # 0: WHITE, 1: GRAY, 2: BLACK",
      "mutated_line": "color = [0 for _ in range(f_count + 2)]",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count + 1)]\n        p = [0 for _ in range(f_count + 1)]\n        color = [0 for _ in range(f_count + 2)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] + 1\n            color[top] = 2\n        return sum(d) / (f_count * 1.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -1\n    for f in range(1, no_of_friends + 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 6))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "color = [0 for _ in range(f_count + 1)]  # 0: WHITE, 1: GRAY, 2: BLACK",
      "mutated_line": "color = [0 for _ in range(f_count + 0)]",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count + 1)]\n        p = [0 for _ in range(f_count + 1)]\n        color = [0 for _ in range(f_count + 0)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] + 1\n            color[top] = 2\n        return sum(d) / (f_count * 1.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -1\n    for f in range(1, no_of_friends + 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 6))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "color = [0 for _ in range(f_count + 1)]  # 0: WHITE, 1: GRAY, 2: BLACK",
      "mutated_line": "color = [0 for _ in range(f_count + 0)]",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count + 1)]\n        p = [0 for _ in range(f_count + 1)]\n        color = [0 for _ in range(f_count + 0)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] + 1\n            color[top] = 2\n        return sum(d) / (f_count * 1.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -1\n    for f in range(1, no_of_friends + 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 6))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "color = [0 for _ in range(f_count + 1)]  # 0: WHITE, 1: GRAY, 2: BLACK",
      "mutated_line": "color = [0 for _ in range(f_count + -1)]",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count + 1)]\n        p = [0 for _ in range(f_count + 1)]\n        color = [0 for _ in range(f_count + -1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] + 1\n            color[top] = 2\n        return sum(d) / (f_count * 1.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -1\n    for f in range(1, no_of_friends + 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 6))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "d[node] = d[top] + 1",
      "mutated_line": "d[node] = d[top] + 2",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count + 1)]\n        p = [0 for _ in range(f_count + 1)]\n        color = [0 for _ in range(f_count + 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] + 2\n            color[top] = 2\n        return sum(d) / (f_count * 1.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -1\n    for f in range(1, no_of_friends + 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 6))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "d[node] = d[top] + 1",
      "mutated_line": "d[node] = d[top] + 0",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count + 1)]\n        p = [0 for _ in range(f_count + 1)]\n        color = [0 for _ in range(f_count + 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] + 0\n            color[top] = 2\n        return sum(d) / (f_count * 1.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -1\n    for f in range(1, no_of_friends + 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 6))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "d[node] = d[top] + 1",
      "mutated_line": "d[node] = d[top] + 0",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count + 1)]\n        p = [0 for _ in range(f_count + 1)]\n        color = [0 for _ in range(f_count + 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] + 0\n            color[top] = 2\n        return sum(d) / (f_count * 1.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -1\n    for f in range(1, no_of_friends + 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 6))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "d[node] = d[top] + 1",
      "mutated_line": "d[node] = d[top] + -1",
      "code": "from collections import deque\n\ndef find_most_popular_friend(group):\n\n    def notoriety(x, f_count):\n        queue = deque([x])\n        d = [0 for _ in range(f_count + 1)]\n        p = [0 for _ in range(f_count + 1)]\n        color = [0 for _ in range(f_count + 1)]\n        while queue:\n            top = queue.pop()\n            for node in graph[top]:\n                if color[node] == 0:\n                    queue.appendleft(node)\n                    color[node] = 1\n                    p[node] = top\n                    d[node] = d[top] + -1\n            color[top] = 2\n        return sum(d) / (f_count * 1.0)\n    graph = [[]] + group\n    no_of_friends = len(group)\n    min_notoriety = float('inf')\n    popular = -1\n    for f in range(1, no_of_friends + 1):\n        curr_not = notoriety(f, no_of_friends)\n        if curr_not < min_notoriety:\n            min_notoriety = curr_not\n            popular = f\n    return (popular, round(min_notoriety, 6))"
    }
  ]
}