{
  "task_id": "taco_7928",
  "entry_point": "rwh_primes2",
  "mutant_count": 415,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOD = 1000000007",
      "mutated_line": "MOD = 1000000008",
      "code": "import math\nMOD = 1000000008\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOD = 1000000007",
      "mutated_line": "MOD = 1000000006",
      "code": "import math\nMOD = 1000000006\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOD = 1000000007",
      "mutated_line": "MOD = 0",
      "code": "import math\nMOD = 0\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOD = 1000000007",
      "mutated_line": "MOD = 1",
      "code": "import math\nMOD = 1\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOD = 1000000007",
      "mutated_line": "MOD = -1000000007",
      "code": "import math\nMOD = -1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if n < 3:",
      "mutated_line": "if n <= 3:",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n <= 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if n < 3:",
      "mutated_line": "if n >= 3:",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n >= 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if n < 3:",
      "mutated_line": "if n != 3:",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n != 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "correction = n % 6 > 1",
      "mutated_line": "correction = n % 6 >= 1",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 >= 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "correction = n % 6 > 1",
      "mutated_line": "correction = n % 6 <= 1",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 <= 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "correction = n % 6 > 1",
      "mutated_line": "correction = n % 6 != 1",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 != 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "sieve = [True] * (n // 3)",
      "mutated_line": "sieve = [True] / (n // 3)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] / (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "sieve = [True] * (n // 3)",
      "mutated_line": "sieve = [True] + n // 3",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] + n // 3\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "sieve = [True] * (n // 3)",
      "mutated_line": "sieve = [True] ** (n // 3)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] ** (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "sieve[0] = False",
      "mutated_line": "sieve[0] = True",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = True\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]",
      "mutated_line": "return [2, 3] - [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] - [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]",
      "mutated_line": "return [2, 3] * [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] * [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "product = 1",
      "mutated_line": "product = 2",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 2\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "product = 1",
      "mutated_line": "product = 0",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 0\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "product = 1",
      "mutated_line": "product = 0",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 0\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "product = 1",
      "mutated_line": "product = -1",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = -1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "ASR",
      "lineno": 33,
      "original_line": "product *= pow(p, n, MOD)",
      "mutated_line": "product /= pow(p, n, MOD)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product /= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if n < 3:",
      "mutated_line": "if n < 4:",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 4:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if n < 3:",
      "mutated_line": "if n < 2:",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 2:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if n < 3:",
      "mutated_line": "if n < 0:",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 0:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if n < 3:",
      "mutated_line": "if n < 1:",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 1:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if n < 3:",
      "mutated_line": "if n < -3:",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < -3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "elif n == 3:",
      "mutated_line": "elif n != 3:",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n != 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "correction = n % 6 > 1",
      "mutated_line": "correction = n * 6 > 1",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n * 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "correction = n % 6 > 1",
      "mutated_line": "correction = n + 6 > 1",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n + 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "correction = n % 6 > 1",
      "mutated_line": "correction = n % 6 > 2",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 2\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "correction = n % 6 > 1",
      "mutated_line": "correction = n % 6 > 0",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 0\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "correction = n % 6 > 1",
      "mutated_line": "correction = n % 6 > 0",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 0\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "correction = n % 6 > 1",
      "mutated_line": "correction = n % 6 > -1",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > -1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "mutated_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n * 6]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n * 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "mutated_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n + 6]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n + 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "sieve = [True] * (n // 3)",
      "mutated_line": "sieve = [True] * (n / 3)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n / 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "sieve = [True] * (n // 3)",
      "mutated_line": "sieve = [True] * (n * 3)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n * 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "sieve[0] = False",
      "mutated_line": "sieve[1] = False",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[1] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "sieve[0] = False",
      "mutated_line": "sieve[-1] = False",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[-1] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "sieve[0] = False",
      "mutated_line": "sieve[1] = False",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[1] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "for i in range(int(n ** 0.5) // 3 + 1):",
      "mutated_line": "for i in range(int(n ** 0.5) // 3 - 1):",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 - 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "for i in range(int(n ** 0.5) // 3 + 1):",
      "mutated_line": "for i in range(int(n ** 0.5) // 3 * 1):",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 * 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "primes = rwh_primes2(M + 1)",
      "mutated_line": "primes = rwh_primes2(M - 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M - 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "primes = rwh_primes2(M + 1)",
      "mutated_line": "primes = rwh_primes2(M * 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M * 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "n = 0",
      "mutated_line": "n = 1",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 1\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "n = 0",
      "mutated_line": "n = -1",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = -1\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "n = 0",
      "mutated_line": "n = 1",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 1\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "while k <= N:",
      "mutated_line": "while k < N:",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k < N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "while k <= N:",
      "mutated_line": "while k > N:",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k > N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "while k <= N:",
      "mutated_line": "while k == N:",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k == N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "ASR",
      "lineno": 31,
      "original_line": "n += N // k * (M // k)",
      "mutated_line": "n -= N // k * (M // k)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n -= N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "ASR",
      "lineno": 32,
      "original_line": "k *= p",
      "mutated_line": "k /= p",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k /= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "elif n == 3:",
      "mutated_line": "elif n == 4:",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 4:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "elif n == 3:",
      "mutated_line": "elif n == 2:",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 2:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "elif n == 3:",
      "mutated_line": "elif n == 0:",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 0:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "elif n == 3:",
      "mutated_line": "elif n == 1:",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 1:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "elif n == 3:",
      "mutated_line": "elif n == -3:",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == -3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "elif n < 6:",
      "mutated_line": "elif n <= 6:",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n <= 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "elif n < 6:",
      "mutated_line": "elif n >= 6:",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n >= 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "elif n < 6:",
      "mutated_line": "elif n != 6:",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n != 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "correction = n % 6 > 1",
      "mutated_line": "correction = n % 7 > 1",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 7 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "correction = n % 6 > 1",
      "mutated_line": "correction = n % 5 > 1",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 5 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "correction = n % 6 > 1",
      "mutated_line": "correction = n % 0 > 1",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 0 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "correction = n % 6 > 1",
      "mutated_line": "correction = n % 1 > 1",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 1 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "correction = n % 6 > 1",
      "mutated_line": "correction = n % -6 > 1",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % -6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "mutated_line": "n = {1: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {1: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "mutated_line": "n = {-1: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {-1: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "mutated_line": "n = {1: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {1: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "mutated_line": "n = {0: n, 2: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 2: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "mutated_line": "n = {0: n, 0: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 0: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "mutated_line": "n = {0: n, 0: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 0: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "mutated_line": "n = {0: n, -1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, -1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "mutated_line": "n = {0: n, 1: n - 1, 3: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 3: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "mutated_line": "n = {0: n, 1: n - 1, 1: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 1: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "mutated_line": "n = {0: n, 1: n - 1, 0: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 0: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "mutated_line": "n = {0: n, 1: n - 1, 1: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 1: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "mutated_line": "n = {0: n, 1: n - 1, -2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, -2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "mutated_line": "n = {0: n, 1: n - 1, 2: n + 4, 4: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 4: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "mutated_line": "n = {0: n, 1: n - 1, 2: n + 4, 2: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 2: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "mutated_line": "n = {0: n, 1: n - 1, 2: n + 4, 0: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 0: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "mutated_line": "n = {0: n, 1: n - 1, 2: n + 4, 1: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 1: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "mutated_line": "n = {0: n, 1: n - 1, 2: n + 4, -3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, -3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "mutated_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 5: n + 2, 5: n + 1}[n % 6]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 5: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "mutated_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 3: n + 2, 5: n + 1}[n % 6]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 3: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "mutated_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 0: n + 2, 5: n + 1}[n % 6]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 0: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "mutated_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 1: n + 2, 5: n + 1}[n % 6]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 1: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "mutated_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, -4: n + 2, 5: n + 1}[n % 6]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, -4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "mutated_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 6: n + 1}[n % 6]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 6: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "mutated_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 4: n + 1}[n % 6]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 4: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "mutated_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 0: n + 1}[n % 6]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 0: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "mutated_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 1: n + 1}[n % 6]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 1: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "mutated_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, -5: n + 1}[n % 6]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, -5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "mutated_line": "n = {0: n, 1: n + 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n + 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "mutated_line": "n = {0: n, 1: n * 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n * 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "mutated_line": "n = {0: n, 1: n - 1, 2: n - 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n - 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "mutated_line": "n = {0: n, 1: n - 1, 2: n * 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n * 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "mutated_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n - 3, 4: n + 2, 5: n + 1}[n % 6]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n - 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "mutated_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n * 3, 4: n + 2, 5: n + 1}[n % 6]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n * 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "mutated_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n - 2, 5: n + 1}[n % 6]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n - 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "mutated_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n * 2, 5: n + 1}[n % 6]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n * 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "mutated_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n - 1}[n % 6]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n - 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "mutated_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n * 1}[n % 6]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n * 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "mutated_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 7]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 7]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "mutated_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 5]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 5]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "mutated_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 0]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 0]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "mutated_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 1]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 1]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "mutated_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % -6]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % -6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "sieve = [True] * (n // 3)",
      "mutated_line": "sieve = [False] * (n // 3)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [False] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "sieve = [True] * (n // 3)",
      "mutated_line": "sieve = [True] * (n // 4)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 4)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "sieve = [True] * (n // 3)",
      "mutated_line": "sieve = [True] * (n // 2)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 2)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "sieve = [True] * (n // 3)",
      "mutated_line": "sieve = [True] * (n // 0)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 0)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "sieve = [True] * (n // 3)",
      "mutated_line": "sieve = [True] * (n // 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 1)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "sieve = [True] * (n // 3)",
      "mutated_line": "sieve = [True] * (n // -3)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // -3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "for i in range(int(n ** 0.5) // 3 + 1):",
      "mutated_line": "for i in range(int(n ** 0.5) / 3 + 1):",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) / 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "for i in range(int(n ** 0.5) // 3 + 1):",
      "mutated_line": "for i in range(int(n ** 0.5) * 3 + 1):",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) * 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(int(n ** 0.5) // 3 + 1):",
      "mutated_line": "for i in range(int(n ** 0.5) // 3 + 2):",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 2):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(int(n ** 0.5) // 3 + 1):",
      "mutated_line": "for i in range(int(n ** 0.5) // 3 + 0):",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 0):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(int(n ** 0.5) // 3 + 1):",
      "mutated_line": "for i in range(int(n ** 0.5) // 3 + 0):",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 0):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(int(n ** 0.5) // 3 + 1):",
      "mutated_line": "for i in range(int(n ** 0.5) // 3 + -1):",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + -1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "k = 3 * i + 1 | 1",
      "mutated_line": "k = 3 * i + 1 & 1",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 & 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "k = 3 * i + 1 | 1",
      "mutated_line": "k = 3 * i + 1 ^ 1",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 ^ 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)",
      "mutated_line": "sieve[k * k // 3::2 * k] = [False] / ((n // 6 - k * k // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] / ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)",
      "mutated_line": "sieve[k * k // 3::2 * k] = [False] + ((n // 6 - k * k // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] + ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)",
      "mutated_line": "sieve[k * k // 3::2 * k] = [False] ** ((n // 6 - k * k // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] ** ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] / ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] / ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] + ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] + ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] ** ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] ** ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]",
      "mutated_line": "return [3, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [3, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]",
      "mutated_line": "return [1, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [1, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]",
      "mutated_line": "return [0, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [0, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]",
      "mutated_line": "return [1, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [1, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]",
      "mutated_line": "return [-2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [-2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]",
      "mutated_line": "return [2, 4] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 4] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]",
      "mutated_line": "return [2, 2] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 2] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]",
      "mutated_line": "return [2, 0] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 0] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]",
      "mutated_line": "return [2, 1] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 1] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]",
      "mutated_line": "return [2, -3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, -3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]",
      "mutated_line": "return [2, 3] + [3 * i + 1 & 1 for i in range(1, n // 3 - correction) if sieve[i]]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 & 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]",
      "mutated_line": "return [2, 3] + [3 * i + 1 ^ 1 for i in range(1, n // 3 - correction) if sieve[i]]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 ^ 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "primes = rwh_primes2(M + 1)",
      "mutated_line": "primes = rwh_primes2(M + 2)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 2)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "primes = rwh_primes2(M + 1)",
      "mutated_line": "primes = rwh_primes2(M + 0)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 0)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "primes = rwh_primes2(M + 1)",
      "mutated_line": "primes = rwh_primes2(M + 0)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 0)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "primes = rwh_primes2(M + 1)",
      "mutated_line": "primes = rwh_primes2(M + -1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + -1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "n += N // k * (M // k)",
      "mutated_line": "n += N // k / (M // k)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k / (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "n += N // k * (M // k)",
      "mutated_line": "n += N // k + M // k",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k + M // k\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "n += N // k * (M // k)",
      "mutated_line": "n += (N // k) ** (M // k)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += (N // k) ** (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return [2]",
      "mutated_line": "return [3]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [3]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return [2]",
      "mutated_line": "return [1]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [1]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return [2]",
      "mutated_line": "return [0]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [0]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return [2]",
      "mutated_line": "return [1]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [1]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return [2]",
      "mutated_line": "return [-2]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [-2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "elif n < 6:",
      "mutated_line": "elif n < 7:",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 7:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "elif n < 6:",
      "mutated_line": "elif n < 5:",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 5:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "elif n < 6:",
      "mutated_line": "elif n < 0:",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 0:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "elif n < 6:",
      "mutated_line": "elif n < 1:",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 1:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "elif n < 6:",
      "mutated_line": "elif n < -6:",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < -6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "mutated_line": "n = {0: n, 1: n - 2, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 2, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "mutated_line": "n = {0: n, 1: n - 0, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 0, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "mutated_line": "n = {0: n, 1: n - 0, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 0, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "mutated_line": "n = {0: n, 1: n - -1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - -1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "mutated_line": "n = {0: n, 1: n - 1, 2: n + 5, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 5, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "mutated_line": "n = {0: n, 1: n - 1, 2: n + 3, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 3, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "mutated_line": "n = {0: n, 1: n - 1, 2: n + 0, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 0, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "mutated_line": "n = {0: n, 1: n - 1, 2: n + 1, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 1, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "mutated_line": "n = {0: n, 1: n - 1, 2: n + -4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + -4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "mutated_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 4, 4: n + 2, 5: n + 1}[n % 6]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 4, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "mutated_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 2, 4: n + 2, 5: n + 1}[n % 6]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 2, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "mutated_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 0, 4: n + 2, 5: n + 1}[n % 6]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 0, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "mutated_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 1, 4: n + 2, 5: n + 1}[n % 6]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 1, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "mutated_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + -3, 4: n + 2, 5: n + 1}[n % 6]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + -3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "mutated_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 3, 5: n + 1}[n % 6]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 3, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "mutated_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 1, 5: n + 1}[n % 6]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 1, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "mutated_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 0, 5: n + 1}[n % 6]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 0, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "mutated_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 1, 5: n + 1}[n % 6]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 1, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "mutated_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + -2, 5: n + 1}[n % 6]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + -2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "mutated_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 2}[n % 6]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 2}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "mutated_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 0}[n % 6]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 0}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "mutated_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 0}[n % 6]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 0}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]",
      "mutated_line": "n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + -1}[n % 6]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + -1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(int(n ** 0.5) // 3 + 1):",
      "mutated_line": "for i in range(int(n ** 0.5) // 4 + 1):",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 4 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(int(n ** 0.5) // 3 + 1):",
      "mutated_line": "for i in range(int(n ** 0.5) // 2 + 1):",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 2 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(int(n ** 0.5) // 3 + 1):",
      "mutated_line": "for i in range(int(n ** 0.5) // 0 + 1):",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 0 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(int(n ** 0.5) // 3 + 1):",
      "mutated_line": "for i in range(int(n ** 0.5) // 1 + 1):",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 1 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(int(n ** 0.5) // 3 + 1):",
      "mutated_line": "for i in range(int(n ** 0.5) // -3 + 1):",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // -3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "k = 3 * i + 1 | 1",
      "mutated_line": "k = 3 * i - 1 | 1",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i - 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "k = 3 * i + 1 | 1",
      "mutated_line": "k = 3 * i * 1 | 1",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i * 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "k = 3 * i + 1 | 1",
      "mutated_line": "k = 3 * i + 1 | 2",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 2\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "k = 3 * i + 1 | 1",
      "mutated_line": "k = 3 * i + 1 | 0",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 0\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "k = 3 * i + 1 | 1",
      "mutated_line": "k = 3 * i + 1 | 0",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 0\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "k = 3 * i + 1 | 1",
      "mutated_line": "k = 3 * i + 1 | -1",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | -1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)",
      "mutated_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k - 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k - 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)",
      "mutated_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k * 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k * 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k - 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k - 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k * 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k * 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]",
      "mutated_line": "return [2, 3] + [3 * i - 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i - 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]",
      "mutated_line": "return [2, 3] + [3 * i * 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i * 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]",
      "mutated_line": "return [2, 3] + [3 * i + 1 | 2 for i in range(1, n // 3 - correction) if sieve[i]]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 2 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]",
      "mutated_line": "return [2, 3] + [3 * i + 1 | 0 for i in range(1, n // 3 - correction) if sieve[i]]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 0 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]",
      "mutated_line": "return [2, 3] + [3 * i + 1 | 0 for i in range(1, n // 3 - correction) if sieve[i]]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 0 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]",
      "mutated_line": "return [2, 3] + [3 * i + 1 | -1 for i in range(1, n // 3 - correction) if sieve[i]]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | -1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "n += N // k * (M // k)",
      "mutated_line": "n += N / k * (M // k)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N / k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "n += N // k * (M // k)",
      "mutated_line": "n += N * k * (M // k)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N * k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "n += N // k * (M // k)",
      "mutated_line": "n += N // k * (M / k)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M / k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "n += N // k * (M // k)",
      "mutated_line": "n += N // k * (M * k)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M * k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return [2, 3]",
      "mutated_line": "return [3, 3]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [3, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return [2, 3]",
      "mutated_line": "return [1, 3]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [1, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return [2, 3]",
      "mutated_line": "return [0, 3]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [0, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return [2, 3]",
      "mutated_line": "return [1, 3]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [1, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return [2, 3]",
      "mutated_line": "return [-2, 3]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [-2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return [2, 3]",
      "mutated_line": "return [2, 4]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 4]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return [2, 3]",
      "mutated_line": "return [2, 2]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 2]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return [2, 3]",
      "mutated_line": "return [2, 0]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 0]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return [2, 3]",
      "mutated_line": "return [2, 1]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 1]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return [2, 3]",
      "mutated_line": "return [2, -3]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, -3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "for i in range(int(n ** 0.5) // 3 + 1):",
      "mutated_line": "for i in range(int(n * 0.5) // 3 + 1):",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n * 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "for i in range(int(n ** 0.5) // 3 + 1):",
      "mutated_line": "for i in range(int(n + 0.5) // 3 + 1):",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n + 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "k = 3 * i + 1 | 1",
      "mutated_line": "k = 3 / i + 1 | 1",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 / i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "k = 3 * i + 1 | 1",
      "mutated_line": "k = 3 + i + 1 | 1",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 + i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "k = 3 * i + 1 | 1",
      "mutated_line": "k = 3 ** i + 1 | 1",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 ** i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "k = 3 * i + 1 | 1",
      "mutated_line": "k = 3 * i + 2 | 1",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 2 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "k = 3 * i + 1 | 1",
      "mutated_line": "k = 3 * i + 0 | 1",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 0 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "k = 3 * i + 1 | 1",
      "mutated_line": "k = 3 * i + 0 | 1",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 0 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "k = 3 * i + 1 | 1",
      "mutated_line": "k = 3 * i + -1 | 1",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + -1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)",
      "mutated_line": "sieve[k * k / 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k / 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)",
      "mutated_line": "sieve[k * k * 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k * 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)",
      "mutated_line": "sieve[k * k // 3::2 / k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 / k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)",
      "mutated_line": "sieve[k * k // 3::2 + k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 + k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)",
      "mutated_line": "sieve[k * k // 3::2 ** k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 ** k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)",
      "mutated_line": "sieve[k * k // 3::2 * k] = [True] * ((n // 6 - k * k // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [True] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)",
      "mutated_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) / k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) / k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)",
      "mutated_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) * k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) * k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)",
      "mutated_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 2)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 2)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)",
      "mutated_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 0)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 0)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)",
      "mutated_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 0)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 0)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)",
      "mutated_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + -1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + -1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) / 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) / 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) * 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) * 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 / k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 / k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 + k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 + k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 ** k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 ** k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [True] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [True] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) / k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) / k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) * k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) * k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 2)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 2)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 0)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 0)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 0)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 0)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + -1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + -1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]",
      "mutated_line": "return [2, 3] + [3 / i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 / i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]",
      "mutated_line": "return [2, 3] + [3 + i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 + i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]",
      "mutated_line": "return [2, 3] + [3 ** i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 ** i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]",
      "mutated_line": "return [2, 3] + [3 * i + 2 | 1 for i in range(1, n // 3 - correction) if sieve[i]]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 2 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]",
      "mutated_line": "return [2, 3] + [3 * i + 0 | 1 for i in range(1, n // 3 - correction) if sieve[i]]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 0 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]",
      "mutated_line": "return [2, 3] + [3 * i + 0 | 1 for i in range(1, n // 3 - correction) if sieve[i]]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 0 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]",
      "mutated_line": "return [2, 3] + [3 * i + -1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + -1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]",
      "mutated_line": "return [2, 3] + [3 * i + 1 | 1 for i in range(2, n // 3 - correction) if sieve[i]]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(2, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]",
      "mutated_line": "return [2, 3] + [3 * i + 1 | 1 for i in range(0, n // 3 - correction) if sieve[i]]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(0, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]",
      "mutated_line": "return [2, 3] + [3 * i + 1 | 1 for i in range(0, n // 3 - correction) if sieve[i]]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(0, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]",
      "mutated_line": "return [2, 3] + [3 * i + 1 | 1 for i in range(-1, n // 3 - correction) if sieve[i]]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(-1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]",
      "mutated_line": "return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 + correction) if sieve[i]]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 + correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]",
      "mutated_line": "return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 * correction) if sieve[i]]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 * correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(int(n ** 0.5) // 3 + 1):",
      "mutated_line": "for i in range(int(n ** 1.5) // 3 + 1):",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 1.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(int(n ** 0.5) // 3 + 1):",
      "mutated_line": "for i in range(int(n ** -0.5) // 3 + 1):",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** -0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(int(n ** 0.5) // 3 + 1):",
      "mutated_line": "for i in range(int(n ** 0) // 3 + 1):",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(int(n ** 0.5) // 3 + 1):",
      "mutated_line": "for i in range(int(n ** 1) // 3 + 1):",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 1) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(int(n ** 0.5) // 3 + 1):",
      "mutated_line": "for i in range(int(n ** -0.5) // 3 + 1):",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** -0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "k = 3 * i + 1 | 1",
      "mutated_line": "k = 4 * i + 1 | 1",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 4 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "k = 3 * i + 1 | 1",
      "mutated_line": "k = 2 * i + 1 | 1",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 2 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "k = 3 * i + 1 | 1",
      "mutated_line": "k = 0 * i + 1 | 1",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 0 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "k = 3 * i + 1 | 1",
      "mutated_line": "k = 1 * i + 1 | 1",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 1 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "k = 3 * i + 1 | 1",
      "mutated_line": "k = -3 * i + 1 | 1",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = -3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)",
      "mutated_line": "sieve[k / k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k / k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k + k) // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[(k + k) // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)",
      "mutated_line": "sieve[k ** k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k ** k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)",
      "mutated_line": "sieve[k * k // 4::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 4::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)",
      "mutated_line": "sieve[k * k // 2::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 2::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)",
      "mutated_line": "sieve[k * k // 0::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 0::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)",
      "mutated_line": "sieve[k * k // 1::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 1::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)",
      "mutated_line": "sieve[k * k // -3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // -3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)",
      "mutated_line": "sieve[k * k // 3::3 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::3 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)",
      "mutated_line": "sieve[k * k // 3::1 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::1 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)",
      "mutated_line": "sieve[k * k // 3::0 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::0 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)",
      "mutated_line": "sieve[k * k // 3::1 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::1 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)",
      "mutated_line": "sieve[k * k // 3::-2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::-2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)",
      "mutated_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 + 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 + 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)",
      "mutated_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6) * 1 // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6) * 1 // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k + 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k + 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k) * (2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k) * (2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 4::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 4::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 2::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 2::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 0::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 0::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 1::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 1::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // -3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // -3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::3 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::3 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::1 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::1 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::0 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::0 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::1 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::1 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::-2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::-2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 + 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 + 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6) * 1 // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6) * 1 // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]",
      "mutated_line": "return [2, 3] + [4 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [4 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]",
      "mutated_line": "return [2, 3] + [2 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [2 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]",
      "mutated_line": "return [2, 3] + [0 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [0 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]",
      "mutated_line": "return [2, 3] + [1 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [1 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]",
      "mutated_line": "return [2, 3] + [-3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [-3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]",
      "mutated_line": "return [2, 3] + [3 * i + 1 | 1 for i in range(1, n / 3 - correction) if sieve[i]]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n / 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]",
      "mutated_line": "return [2, 3] + [3 * i + 1 | 1 for i in range(1, n * 3 - correction) if sieve[i]]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n * 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)",
      "mutated_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 + k * k // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 + k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)",
      "mutated_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 * (k * k // 6) - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 * (k * k // 6) - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)",
      "mutated_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 2) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 2) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)",
      "mutated_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 0) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 0) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)",
      "mutated_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 0) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 0) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)",
      "mutated_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - -1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - -1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k - 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k - 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k * (4 * k) - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k * (4 * k) - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k / (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k / (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - (2 * k + (i & 1))) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - (2 * k + (i & 1))) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - (2 * k) ** (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - (2 * k) ** (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 + (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 + (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 * ((k * k + 4 * k - 2 * k * (i & 1)) // 6) - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 * ((k * k + 4 * k - 2 * k * (i & 1)) // 6) - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 2) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 2) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 0) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 0) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 0) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 0) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - -1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - -1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]",
      "mutated_line": "return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 4 - correction) if sieve[i]]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 4 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]",
      "mutated_line": "return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 2 - correction) if sieve[i]]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 2 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]",
      "mutated_line": "return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 0 - correction) if sieve[i]]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 0 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]",
      "mutated_line": "return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 1 - correction) if sieve[i]]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 1 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]",
      "mutated_line": "return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // -3 - correction) if sieve[i]]",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // -3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)",
      "mutated_line": "sieve[k * k // 3::2 * k] = [False] * ((n / 6 - k * k // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n / 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)",
      "mutated_line": "sieve[k * k // 3::2 * k] = [False] * ((n * 6 - k * k // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n * 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)",
      "mutated_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k / 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k / 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)",
      "mutated_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k * 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k * 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k / k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k / k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k + k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k + k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k ** k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k ** k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 / k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 / k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + (4 + k) - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + (4 + k) - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 ** k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 ** k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 / k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 / k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - (2 + k) * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - (2 + k) * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 ** k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 ** k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i | 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i | 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n / 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n / 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n * 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n * 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) / 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) / 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) * 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) * 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)",
      "mutated_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 7 - k * k // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 7 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)",
      "mutated_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 5 - k * k // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 5 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)",
      "mutated_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 0 - k * k // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 0 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)",
      "mutated_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 1 - k * k // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 1 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)",
      "mutated_line": "sieve[k * k // 3::2 * k] = [False] * ((n // -6 - k * k // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // -6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)",
      "mutated_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k / k // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k / k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)",
      "mutated_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - (k + k) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - (k + k) // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)",
      "mutated_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k ** k // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k ** k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)",
      "mutated_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 7 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 7 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)",
      "mutated_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 5 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 5 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)",
      "mutated_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 0 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 0 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)",
      "mutated_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 1 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 1 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)",
      "mutated_line": "sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // -6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // -6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 5 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 5 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 3 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 3 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 0 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 0 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 1 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 1 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + -4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + -4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 3 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 3 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 1 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 1 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 0 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 0 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 1 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 1 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - -2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - -2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 2)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 2)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 0)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 0)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 0)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 0)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & -1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & -1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 7 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 7 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 5 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 5 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 0 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 0 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 1 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 1 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // -6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // -6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k + 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k + 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k) * (2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k) * (2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 7 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 7 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 5 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 5 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 0 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 0 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 1 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 1 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // -6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // -6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k - 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k - 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k * (4 * k) - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k * (4 * k) - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k / (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k / (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - (2 * k + (i & 1))) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - (2 * k + (i & 1))) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - (2 * k) ** (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - (2 * k) ** (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k / k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k / k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k + k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k + k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k ** k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k ** k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 / k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 / k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + (4 + k) - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + (4 + k) - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 ** k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 ** k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 / k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 / k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - (2 + k) * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - (2 + k) * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 ** k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 ** k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i | 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i | 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 5 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 5 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 3 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 3 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 0 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 0 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 1 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 1 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + -4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + -4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 3 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 3 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 1 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 1 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 0 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 0 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 1 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 1 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - -2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - -2 * k * (i & 1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 2)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 2)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 0)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 0)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 0)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 0)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & 1)) // 6 - 1) // k + 1)",
      "mutated_line": "sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & -1)) // 6 - 1) // k + 1)",
      "code": "import math\nMOD = 1000000007\n\ndef rwh_primes2(n):\n    if n < 3:\n        return []\n    elif n == 3:\n        return [2]\n    elif n < 6:\n        return [2, 3]\n    correction = n % 6 > 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[k * k // 3::2 * k] = [False] * ((n // 6 - k * k // 6 - 1) // k + 1)\n            sieve[(k * k + 4 * k - 2 * k * (i & 1)) // 3::2 * k] = [False] * ((n // 6 - (k * k + 4 * k - 2 * k * (i & -1)) // 6 - 1) // k + 1)\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\ndef calculate_gcd_product(N, M):\n    (N, M) = (min(N, M), max(N, M))\n    primes = rwh_primes2(M + 1)\n    product = 1\n    for p in primes:\n        n = 0\n        k = p\n        while k <= N:\n            n += N // k * (M // k)\n            k *= p\n        product *= pow(p, n, MOD)\n        product %= MOD\n    return product"
    }
  ]
}