{
  "task_id": "taco_6242",
  "entry_point": "queue_battle",
  "mutant_count": 69,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "Army = namedtuple('Army', 'i,q')",
      "mutated_line": "Army = namedtuple('', 'i,q')",
      "code": "from heapq import heappush, heappop\nfrom collections import deque, namedtuple\nfrom itertools import starmap\nArmy = namedtuple('', 'i,q')\nSoldier = namedtuple('Soldier', 'i,speed')\n\ndef queue_battle(distance, *args):\n    armies = [Army(i, deque(starmap(Soldier, enumerate(q)))) for (i, q) in enumerate(args)]\n    bullets = [[] for _ in range(len(armies))]\n    t = 0\n    while len(armies) > 1:\n        t += 1\n        alives = [1] * len(armies)\n        for (i, q) in enumerate(bullets):\n            if q and q[0] <= t:\n                alives[(i + 1) % len(armies)] = 0\n            while q and q[0] <= t:\n                heappop(q)\n        emptyArmies = False\n        for (i, alive) in enumerate(alives):\n            if alive:\n                heappush(bullets[i], t + distance / armies[i].q[0].speed)\n                armies[i].q.rotate(-1)\n            else:\n                armies[i].q.popleft()\n                emptyArmies |= not armies[i].q\n        if emptyArmies:\n            armies = [army for army in armies if army.q]\n            bullets = [[] for _ in range(len(armies))]\n    if not armies:\n        return (-1, ())\n    win = armies.pop()\n    return (win.i, tuple((soldier.i for soldier in win.q)))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "Army = namedtuple('Army', 'i,q')",
      "mutated_line": "Army = namedtuple('Army', '')",
      "code": "from heapq import heappush, heappop\nfrom collections import deque, namedtuple\nfrom itertools import starmap\nArmy = namedtuple('Army', '')\nSoldier = namedtuple('Soldier', 'i,speed')\n\ndef queue_battle(distance, *args):\n    armies = [Army(i, deque(starmap(Soldier, enumerate(q)))) for (i, q) in enumerate(args)]\n    bullets = [[] for _ in range(len(armies))]\n    t = 0\n    while len(armies) > 1:\n        t += 1\n        alives = [1] * len(armies)\n        for (i, q) in enumerate(bullets):\n            if q and q[0] <= t:\n                alives[(i + 1) % len(armies)] = 0\n            while q and q[0] <= t:\n                heappop(q)\n        emptyArmies = False\n        for (i, alive) in enumerate(alives):\n            if alive:\n                heappush(bullets[i], t + distance / armies[i].q[0].speed)\n                armies[i].q.rotate(-1)\n            else:\n                armies[i].q.popleft()\n                emptyArmies |= not armies[i].q\n        if emptyArmies:\n            armies = [army for army in armies if army.q]\n            bullets = [[] for _ in range(len(armies))]\n    if not armies:\n        return (-1, ())\n    win = armies.pop()\n    return (win.i, tuple((soldier.i for soldier in win.q)))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "Soldier = namedtuple('Soldier', 'i,speed')",
      "mutated_line": "Soldier = namedtuple('', 'i,speed')",
      "code": "from heapq import heappush, heappop\nfrom collections import deque, namedtuple\nfrom itertools import starmap\nArmy = namedtuple('Army', 'i,q')\nSoldier = namedtuple('', 'i,speed')\n\ndef queue_battle(distance, *args):\n    armies = [Army(i, deque(starmap(Soldier, enumerate(q)))) for (i, q) in enumerate(args)]\n    bullets = [[] for _ in range(len(armies))]\n    t = 0\n    while len(armies) > 1:\n        t += 1\n        alives = [1] * len(armies)\n        for (i, q) in enumerate(bullets):\n            if q and q[0] <= t:\n                alives[(i + 1) % len(armies)] = 0\n            while q and q[0] <= t:\n                heappop(q)\n        emptyArmies = False\n        for (i, alive) in enumerate(alives):\n            if alive:\n                heappush(bullets[i], t + distance / armies[i].q[0].speed)\n                armies[i].q.rotate(-1)\n            else:\n                armies[i].q.popleft()\n                emptyArmies |= not armies[i].q\n        if emptyArmies:\n            armies = [army for army in armies if army.q]\n            bullets = [[] for _ in range(len(armies))]\n    if not armies:\n        return (-1, ())\n    win = armies.pop()\n    return (win.i, tuple((soldier.i for soldier in win.q)))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "Soldier = namedtuple('Soldier', 'i,speed')",
      "mutated_line": "Soldier = namedtuple('Soldier', '')",
      "code": "from heapq import heappush, heappop\nfrom collections import deque, namedtuple\nfrom itertools import starmap\nArmy = namedtuple('Army', 'i,q')\nSoldier = namedtuple('Soldier', '')\n\ndef queue_battle(distance, *args):\n    armies = [Army(i, deque(starmap(Soldier, enumerate(q)))) for (i, q) in enumerate(args)]\n    bullets = [[] for _ in range(len(armies))]\n    t = 0\n    while len(armies) > 1:\n        t += 1\n        alives = [1] * len(armies)\n        for (i, q) in enumerate(bullets):\n            if q and q[0] <= t:\n                alives[(i + 1) % len(armies)] = 0\n            while q and q[0] <= t:\n                heappop(q)\n        emptyArmies = False\n        for (i, alive) in enumerate(alives):\n            if alive:\n                heappush(bullets[i], t + distance / armies[i].q[0].speed)\n                armies[i].q.rotate(-1)\n            else:\n                armies[i].q.popleft()\n                emptyArmies |= not armies[i].q\n        if emptyArmies:\n            armies = [army for army in armies if army.q]\n            bullets = [[] for _ in range(len(armies))]\n    if not armies:\n        return (-1, ())\n    win = armies.pop()\n    return (win.i, tuple((soldier.i for soldier in win.q)))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "t = 0",
      "mutated_line": "t = 1",
      "code": "from heapq import heappush, heappop\nfrom collections import deque, namedtuple\nfrom itertools import starmap\nArmy = namedtuple('Army', 'i,q')\nSoldier = namedtuple('Soldier', 'i,speed')\n\ndef queue_battle(distance, *args):\n    armies = [Army(i, deque(starmap(Soldier, enumerate(q)))) for (i, q) in enumerate(args)]\n    bullets = [[] for _ in range(len(armies))]\n    t = 1\n    while len(armies) > 1:\n        t += 1\n        alives = [1] * len(armies)\n        for (i, q) in enumerate(bullets):\n            if q and q[0] <= t:\n                alives[(i + 1) % len(armies)] = 0\n            while q and q[0] <= t:\n                heappop(q)\n        emptyArmies = False\n        for (i, alive) in enumerate(alives):\n            if alive:\n                heappush(bullets[i], t + distance / armies[i].q[0].speed)\n                armies[i].q.rotate(-1)\n            else:\n                armies[i].q.popleft()\n                emptyArmies |= not armies[i].q\n        if emptyArmies:\n            armies = [army for army in armies if army.q]\n            bullets = [[] for _ in range(len(armies))]\n    if not armies:\n        return (-1, ())\n    win = armies.pop()\n    return (win.i, tuple((soldier.i for soldier in win.q)))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "t = 0",
      "mutated_line": "t = -1",
      "code": "from heapq import heappush, heappop\nfrom collections import deque, namedtuple\nfrom itertools import starmap\nArmy = namedtuple('Army', 'i,q')\nSoldier = namedtuple('Soldier', 'i,speed')\n\ndef queue_battle(distance, *args):\n    armies = [Army(i, deque(starmap(Soldier, enumerate(q)))) for (i, q) in enumerate(args)]\n    bullets = [[] for _ in range(len(armies))]\n    t = -1\n    while len(armies) > 1:\n        t += 1\n        alives = [1] * len(armies)\n        for (i, q) in enumerate(bullets):\n            if q and q[0] <= t:\n                alives[(i + 1) % len(armies)] = 0\n            while q and q[0] <= t:\n                heappop(q)\n        emptyArmies = False\n        for (i, alive) in enumerate(alives):\n            if alive:\n                heappush(bullets[i], t + distance / armies[i].q[0].speed)\n                armies[i].q.rotate(-1)\n            else:\n                armies[i].q.popleft()\n                emptyArmies |= not armies[i].q\n        if emptyArmies:\n            armies = [army for army in armies if army.q]\n            bullets = [[] for _ in range(len(armies))]\n    if not armies:\n        return (-1, ())\n    win = armies.pop()\n    return (win.i, tuple((soldier.i for soldier in win.q)))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "t = 0",
      "mutated_line": "t = 1",
      "code": "from heapq import heappush, heappop\nfrom collections import deque, namedtuple\nfrom itertools import starmap\nArmy = namedtuple('Army', 'i,q')\nSoldier = namedtuple('Soldier', 'i,speed')\n\ndef queue_battle(distance, *args):\n    armies = [Army(i, deque(starmap(Soldier, enumerate(q)))) for (i, q) in enumerate(args)]\n    bullets = [[] for _ in range(len(armies))]\n    t = 1\n    while len(armies) > 1:\n        t += 1\n        alives = [1] * len(armies)\n        for (i, q) in enumerate(bullets):\n            if q and q[0] <= t:\n                alives[(i + 1) % len(armies)] = 0\n            while q and q[0] <= t:\n                heappop(q)\n        emptyArmies = False\n        for (i, alive) in enumerate(alives):\n            if alive:\n                heappush(bullets[i], t + distance / armies[i].q[0].speed)\n                armies[i].q.rotate(-1)\n            else:\n                armies[i].q.popleft()\n                emptyArmies |= not armies[i].q\n        if emptyArmies:\n            armies = [army for army in armies if army.q]\n            bullets = [[] for _ in range(len(armies))]\n    if not armies:\n        return (-1, ())\n    win = armies.pop()\n    return (win.i, tuple((soldier.i for soldier in win.q)))"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "while len(armies) > 1:",
      "mutated_line": "while len(armies) >= 1:",
      "code": "from heapq import heappush, heappop\nfrom collections import deque, namedtuple\nfrom itertools import starmap\nArmy = namedtuple('Army', 'i,q')\nSoldier = namedtuple('Soldier', 'i,speed')\n\ndef queue_battle(distance, *args):\n    armies = [Army(i, deque(starmap(Soldier, enumerate(q)))) for (i, q) in enumerate(args)]\n    bullets = [[] for _ in range(len(armies))]\n    t = 0\n    while len(armies) >= 1:\n        t += 1\n        alives = [1] * len(armies)\n        for (i, q) in enumerate(bullets):\n            if q and q[0] <= t:\n                alives[(i + 1) % len(armies)] = 0\n            while q and q[0] <= t:\n                heappop(q)\n        emptyArmies = False\n        for (i, alive) in enumerate(alives):\n            if alive:\n                heappush(bullets[i], t + distance / armies[i].q[0].speed)\n                armies[i].q.rotate(-1)\n            else:\n                armies[i].q.popleft()\n                emptyArmies |= not armies[i].q\n        if emptyArmies:\n            armies = [army for army in armies if army.q]\n            bullets = [[] for _ in range(len(armies))]\n    if not armies:\n        return (-1, ())\n    win = armies.pop()\n    return (win.i, tuple((soldier.i for soldier in win.q)))"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "while len(armies) > 1:",
      "mutated_line": "while len(armies) <= 1:",
      "code": "from heapq import heappush, heappop\nfrom collections import deque, namedtuple\nfrom itertools import starmap\nArmy = namedtuple('Army', 'i,q')\nSoldier = namedtuple('Soldier', 'i,speed')\n\ndef queue_battle(distance, *args):\n    armies = [Army(i, deque(starmap(Soldier, enumerate(q)))) for (i, q) in enumerate(args)]\n    bullets = [[] for _ in range(len(armies))]\n    t = 0\n    while len(armies) <= 1:\n        t += 1\n        alives = [1] * len(armies)\n        for (i, q) in enumerate(bullets):\n            if q and q[0] <= t:\n                alives[(i + 1) % len(armies)] = 0\n            while q and q[0] <= t:\n                heappop(q)\n        emptyArmies = False\n        for (i, alive) in enumerate(alives):\n            if alive:\n                heappush(bullets[i], t + distance / armies[i].q[0].speed)\n                armies[i].q.rotate(-1)\n            else:\n                armies[i].q.popleft()\n                emptyArmies |= not armies[i].q\n        if emptyArmies:\n            armies = [army for army in armies if army.q]\n            bullets = [[] for _ in range(len(armies))]\n    if not armies:\n        return (-1, ())\n    win = armies.pop()\n    return (win.i, tuple((soldier.i for soldier in win.q)))"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "while len(armies) > 1:",
      "mutated_line": "while len(armies) != 1:",
      "code": "from heapq import heappush, heappop\nfrom collections import deque, namedtuple\nfrom itertools import starmap\nArmy = namedtuple('Army', 'i,q')\nSoldier = namedtuple('Soldier', 'i,speed')\n\ndef queue_battle(distance, *args):\n    armies = [Army(i, deque(starmap(Soldier, enumerate(q)))) for (i, q) in enumerate(args)]\n    bullets = [[] for _ in range(len(armies))]\n    t = 0\n    while len(armies) != 1:\n        t += 1\n        alives = [1] * len(armies)\n        for (i, q) in enumerate(bullets):\n            if q and q[0] <= t:\n                alives[(i + 1) % len(armies)] = 0\n            while q and q[0] <= t:\n                heappop(q)\n        emptyArmies = False\n        for (i, alive) in enumerate(alives):\n            if alive:\n                heappush(bullets[i], t + distance / armies[i].q[0].speed)\n                armies[i].q.rotate(-1)\n            else:\n                armies[i].q.popleft()\n                emptyArmies |= not armies[i].q\n        if emptyArmies:\n            armies = [army for army in armies if army.q]\n            bullets = [[] for _ in range(len(armies))]\n    if not armies:\n        return (-1, ())\n    win = armies.pop()\n    return (win.i, tuple((soldier.i for soldier in win.q)))"
    },
    {
      "operator": "ASR",
      "lineno": 15,
      "original_line": "t += 1",
      "mutated_line": "t -= 1",
      "code": "from heapq import heappush, heappop\nfrom collections import deque, namedtuple\nfrom itertools import starmap\nArmy = namedtuple('Army', 'i,q')\nSoldier = namedtuple('Soldier', 'i,speed')\n\ndef queue_battle(distance, *args):\n    armies = [Army(i, deque(starmap(Soldier, enumerate(q)))) for (i, q) in enumerate(args)]\n    bullets = [[] for _ in range(len(armies))]\n    t = 0\n    while len(armies) > 1:\n        t -= 1\n        alives = [1] * len(armies)\n        for (i, q) in enumerate(bullets):\n            if q and q[0] <= t:\n                alives[(i + 1) % len(armies)] = 0\n            while q and q[0] <= t:\n                heappop(q)\n        emptyArmies = False\n        for (i, alive) in enumerate(alives):\n            if alive:\n                heappush(bullets[i], t + distance / armies[i].q[0].speed)\n                armies[i].q.rotate(-1)\n            else:\n                armies[i].q.popleft()\n                emptyArmies |= not armies[i].q\n        if emptyArmies:\n            armies = [army for army in armies if army.q]\n            bullets = [[] for _ in range(len(armies))]\n    if not armies:\n        return (-1, ())\n    win = armies.pop()\n    return (win.i, tuple((soldier.i for soldier in win.q)))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "while len(armies) > 1:",
      "mutated_line": "while len(armies) > 2:",
      "code": "from heapq import heappush, heappop\nfrom collections import deque, namedtuple\nfrom itertools import starmap\nArmy = namedtuple('Army', 'i,q')\nSoldier = namedtuple('Soldier', 'i,speed')\n\ndef queue_battle(distance, *args):\n    armies = [Army(i, deque(starmap(Soldier, enumerate(q)))) for (i, q) in enumerate(args)]\n    bullets = [[] for _ in range(len(armies))]\n    t = 0\n    while len(armies) > 2:\n        t += 1\n        alives = [1] * len(armies)\n        for (i, q) in enumerate(bullets):\n            if q and q[0] <= t:\n                alives[(i + 1) % len(armies)] = 0\n            while q and q[0] <= t:\n                heappop(q)\n        emptyArmies = False\n        for (i, alive) in enumerate(alives):\n            if alive:\n                heappush(bullets[i], t + distance / armies[i].q[0].speed)\n                armies[i].q.rotate(-1)\n            else:\n                armies[i].q.popleft()\n                emptyArmies |= not armies[i].q\n        if emptyArmies:\n            armies = [army for army in armies if army.q]\n            bullets = [[] for _ in range(len(armies))]\n    if not armies:\n        return (-1, ())\n    win = armies.pop()\n    return (win.i, tuple((soldier.i for soldier in win.q)))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "while len(armies) > 1:",
      "mutated_line": "while len(armies) > 0:",
      "code": "from heapq import heappush, heappop\nfrom collections import deque, namedtuple\nfrom itertools import starmap\nArmy = namedtuple('Army', 'i,q')\nSoldier = namedtuple('Soldier', 'i,speed')\n\ndef queue_battle(distance, *args):\n    armies = [Army(i, deque(starmap(Soldier, enumerate(q)))) for (i, q) in enumerate(args)]\n    bullets = [[] for _ in range(len(armies))]\n    t = 0\n    while len(armies) > 0:\n        t += 1\n        alives = [1] * len(armies)\n        for (i, q) in enumerate(bullets):\n            if q and q[0] <= t:\n                alives[(i + 1) % len(armies)] = 0\n            while q and q[0] <= t:\n                heappop(q)\n        emptyArmies = False\n        for (i, alive) in enumerate(alives):\n            if alive:\n                heappush(bullets[i], t + distance / armies[i].q[0].speed)\n                armies[i].q.rotate(-1)\n            else:\n                armies[i].q.popleft()\n                emptyArmies |= not armies[i].q\n        if emptyArmies:\n            armies = [army for army in armies if army.q]\n            bullets = [[] for _ in range(len(armies))]\n    if not armies:\n        return (-1, ())\n    win = armies.pop()\n    return (win.i, tuple((soldier.i for soldier in win.q)))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "while len(armies) > 1:",
      "mutated_line": "while len(armies) > 0:",
      "code": "from heapq import heappush, heappop\nfrom collections import deque, namedtuple\nfrom itertools import starmap\nArmy = namedtuple('Army', 'i,q')\nSoldier = namedtuple('Soldier', 'i,speed')\n\ndef queue_battle(distance, *args):\n    armies = [Army(i, deque(starmap(Soldier, enumerate(q)))) for (i, q) in enumerate(args)]\n    bullets = [[] for _ in range(len(armies))]\n    t = 0\n    while len(armies) > 0:\n        t += 1\n        alives = [1] * len(armies)\n        for (i, q) in enumerate(bullets):\n            if q and q[0] <= t:\n                alives[(i + 1) % len(armies)] = 0\n            while q and q[0] <= t:\n                heappop(q)\n        emptyArmies = False\n        for (i, alive) in enumerate(alives):\n            if alive:\n                heappush(bullets[i], t + distance / armies[i].q[0].speed)\n                armies[i].q.rotate(-1)\n            else:\n                armies[i].q.popleft()\n                emptyArmies |= not armies[i].q\n        if emptyArmies:\n            armies = [army for army in armies if army.q]\n            bullets = [[] for _ in range(len(armies))]\n    if not armies:\n        return (-1, ())\n    win = armies.pop()\n    return (win.i, tuple((soldier.i for soldier in win.q)))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "while len(armies) > 1:",
      "mutated_line": "while len(armies) > -1:",
      "code": "from heapq import heappush, heappop\nfrom collections import deque, namedtuple\nfrom itertools import starmap\nArmy = namedtuple('Army', 'i,q')\nSoldier = namedtuple('Soldier', 'i,speed')\n\ndef queue_battle(distance, *args):\n    armies = [Army(i, deque(starmap(Soldier, enumerate(q)))) for (i, q) in enumerate(args)]\n    bullets = [[] for _ in range(len(armies))]\n    t = 0\n    while len(armies) > -1:\n        t += 1\n        alives = [1] * len(armies)\n        for (i, q) in enumerate(bullets):\n            if q and q[0] <= t:\n                alives[(i + 1) % len(armies)] = 0\n            while q and q[0] <= t:\n                heappop(q)\n        emptyArmies = False\n        for (i, alive) in enumerate(alives):\n            if alive:\n                heappush(bullets[i], t + distance / armies[i].q[0].speed)\n                armies[i].q.rotate(-1)\n            else:\n                armies[i].q.popleft()\n                emptyArmies |= not armies[i].q\n        if emptyArmies:\n            armies = [army for army in armies if army.q]\n            bullets = [[] for _ in range(len(armies))]\n    if not armies:\n        return (-1, ())\n    win = armies.pop()\n    return (win.i, tuple((soldier.i for soldier in win.q)))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "t += 1",
      "mutated_line": "t += 2",
      "code": "from heapq import heappush, heappop\nfrom collections import deque, namedtuple\nfrom itertools import starmap\nArmy = namedtuple('Army', 'i,q')\nSoldier = namedtuple('Soldier', 'i,speed')\n\ndef queue_battle(distance, *args):\n    armies = [Army(i, deque(starmap(Soldier, enumerate(q)))) for (i, q) in enumerate(args)]\n    bullets = [[] for _ in range(len(armies))]\n    t = 0\n    while len(armies) > 1:\n        t += 2\n        alives = [1] * len(armies)\n        for (i, q) in enumerate(bullets):\n            if q and q[0] <= t:\n                alives[(i + 1) % len(armies)] = 0\n            while q and q[0] <= t:\n                heappop(q)\n        emptyArmies = False\n        for (i, alive) in enumerate(alives):\n            if alive:\n                heappush(bullets[i], t + distance / armies[i].q[0].speed)\n                armies[i].q.rotate(-1)\n            else:\n                armies[i].q.popleft()\n                emptyArmies |= not armies[i].q\n        if emptyArmies:\n            armies = [army for army in armies if army.q]\n            bullets = [[] for _ in range(len(armies))]\n    if not armies:\n        return (-1, ())\n    win = armies.pop()\n    return (win.i, tuple((soldier.i for soldier in win.q)))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "t += 1",
      "mutated_line": "t += 0",
      "code": "from heapq import heappush, heappop\nfrom collections import deque, namedtuple\nfrom itertools import starmap\nArmy = namedtuple('Army', 'i,q')\nSoldier = namedtuple('Soldier', 'i,speed')\n\ndef queue_battle(distance, *args):\n    armies = [Army(i, deque(starmap(Soldier, enumerate(q)))) for (i, q) in enumerate(args)]\n    bullets = [[] for _ in range(len(armies))]\n    t = 0\n    while len(armies) > 1:\n        t += 0\n        alives = [1] * len(armies)\n        for (i, q) in enumerate(bullets):\n            if q and q[0] <= t:\n                alives[(i + 1) % len(armies)] = 0\n            while q and q[0] <= t:\n                heappop(q)\n        emptyArmies = False\n        for (i, alive) in enumerate(alives):\n            if alive:\n                heappush(bullets[i], t + distance / armies[i].q[0].speed)\n                armies[i].q.rotate(-1)\n            else:\n                armies[i].q.popleft()\n                emptyArmies |= not armies[i].q\n        if emptyArmies:\n            armies = [army for army in armies if army.q]\n            bullets = [[] for _ in range(len(armies))]\n    if not armies:\n        return (-1, ())\n    win = armies.pop()\n    return (win.i, tuple((soldier.i for soldier in win.q)))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "t += 1",
      "mutated_line": "t += 0",
      "code": "from heapq import heappush, heappop\nfrom collections import deque, namedtuple\nfrom itertools import starmap\nArmy = namedtuple('Army', 'i,q')\nSoldier = namedtuple('Soldier', 'i,speed')\n\ndef queue_battle(distance, *args):\n    armies = [Army(i, deque(starmap(Soldier, enumerate(q)))) for (i, q) in enumerate(args)]\n    bullets = [[] for _ in range(len(armies))]\n    t = 0\n    while len(armies) > 1:\n        t += 0\n        alives = [1] * len(armies)\n        for (i, q) in enumerate(bullets):\n            if q and q[0] <= t:\n                alives[(i + 1) % len(armies)] = 0\n            while q and q[0] <= t:\n                heappop(q)\n        emptyArmies = False\n        for (i, alive) in enumerate(alives):\n            if alive:\n                heappush(bullets[i], t + distance / armies[i].q[0].speed)\n                armies[i].q.rotate(-1)\n            else:\n                armies[i].q.popleft()\n                emptyArmies |= not armies[i].q\n        if emptyArmies:\n            armies = [army for army in armies if army.q]\n            bullets = [[] for _ in range(len(armies))]\n    if not armies:\n        return (-1, ())\n    win = armies.pop()\n    return (win.i, tuple((soldier.i for soldier in win.q)))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "t += 1",
      "mutated_line": "t += -1",
      "code": "from heapq import heappush, heappop\nfrom collections import deque, namedtuple\nfrom itertools import starmap\nArmy = namedtuple('Army', 'i,q')\nSoldier = namedtuple('Soldier', 'i,speed')\n\ndef queue_battle(distance, *args):\n    armies = [Army(i, deque(starmap(Soldier, enumerate(q)))) for (i, q) in enumerate(args)]\n    bullets = [[] for _ in range(len(armies))]\n    t = 0\n    while len(armies) > 1:\n        t += -1\n        alives = [1] * len(armies)\n        for (i, q) in enumerate(bullets):\n            if q and q[0] <= t:\n                alives[(i + 1) % len(armies)] = 0\n            while q and q[0] <= t:\n                heappop(q)\n        emptyArmies = False\n        for (i, alive) in enumerate(alives):\n            if alive:\n                heappush(bullets[i], t + distance / armies[i].q[0].speed)\n                armies[i].q.rotate(-1)\n            else:\n                armies[i].q.popleft()\n                emptyArmies |= not armies[i].q\n        if emptyArmies:\n            armies = [army for army in armies if army.q]\n            bullets = [[] for _ in range(len(armies))]\n    if not armies:\n        return (-1, ())\n    win = armies.pop()\n    return (win.i, tuple((soldier.i for soldier in win.q)))"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "alives = [1] * len(armies)",
      "mutated_line": "alives = [1] / len(armies)",
      "code": "from heapq import heappush, heappop\nfrom collections import deque, namedtuple\nfrom itertools import starmap\nArmy = namedtuple('Army', 'i,q')\nSoldier = namedtuple('Soldier', 'i,speed')\n\ndef queue_battle(distance, *args):\n    armies = [Army(i, deque(starmap(Soldier, enumerate(q)))) for (i, q) in enumerate(args)]\n    bullets = [[] for _ in range(len(armies))]\n    t = 0\n    while len(armies) > 1:\n        t += 1\n        alives = [1] / len(armies)\n        for (i, q) in enumerate(bullets):\n            if q and q[0] <= t:\n                alives[(i + 1) % len(armies)] = 0\n            while q and q[0] <= t:\n                heappop(q)\n        emptyArmies = False\n        for (i, alive) in enumerate(alives):\n            if alive:\n                heappush(bullets[i], t + distance / armies[i].q[0].speed)\n                armies[i].q.rotate(-1)\n            else:\n                armies[i].q.popleft()\n                emptyArmies |= not armies[i].q\n        if emptyArmies:\n            armies = [army for army in armies if army.q]\n            bullets = [[] for _ in range(len(armies))]\n    if not armies:\n        return (-1, ())\n    win = armies.pop()\n    return (win.i, tuple((soldier.i for soldier in win.q)))"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "alives = [1] * len(armies)",
      "mutated_line": "alives = [1] + len(armies)",
      "code": "from heapq import heappush, heappop\nfrom collections import deque, namedtuple\nfrom itertools import starmap\nArmy = namedtuple('Army', 'i,q')\nSoldier = namedtuple('Soldier', 'i,speed')\n\ndef queue_battle(distance, *args):\n    armies = [Army(i, deque(starmap(Soldier, enumerate(q)))) for (i, q) in enumerate(args)]\n    bullets = [[] for _ in range(len(armies))]\n    t = 0\n    while len(armies) > 1:\n        t += 1\n        alives = [1] + len(armies)\n        for (i, q) in enumerate(bullets):\n            if q and q[0] <= t:\n                alives[(i + 1) % len(armies)] = 0\n            while q and q[0] <= t:\n                heappop(q)\n        emptyArmies = False\n        for (i, alive) in enumerate(alives):\n            if alive:\n                heappush(bullets[i], t + distance / armies[i].q[0].speed)\n                armies[i].q.rotate(-1)\n            else:\n                armies[i].q.popleft()\n                emptyArmies |= not armies[i].q\n        if emptyArmies:\n            armies = [army for army in armies if army.q]\n            bullets = [[] for _ in range(len(armies))]\n    if not armies:\n        return (-1, ())\n    win = armies.pop()\n    return (win.i, tuple((soldier.i for soldier in win.q)))"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "alives = [1] * len(armies)",
      "mutated_line": "alives = [1] ** len(armies)",
      "code": "from heapq import heappush, heappop\nfrom collections import deque, namedtuple\nfrom itertools import starmap\nArmy = namedtuple('Army', 'i,q')\nSoldier = namedtuple('Soldier', 'i,speed')\n\ndef queue_battle(distance, *args):\n    armies = [Army(i, deque(starmap(Soldier, enumerate(q)))) for (i, q) in enumerate(args)]\n    bullets = [[] for _ in range(len(armies))]\n    t = 0\n    while len(armies) > 1:\n        t += 1\n        alives = [1] ** len(armies)\n        for (i, q) in enumerate(bullets):\n            if q and q[0] <= t:\n                alives[(i + 1) % len(armies)] = 0\n            while q and q[0] <= t:\n                heappop(q)\n        emptyArmies = False\n        for (i, alive) in enumerate(alives):\n            if alive:\n                heappush(bullets[i], t + distance / armies[i].q[0].speed)\n                armies[i].q.rotate(-1)\n            else:\n                armies[i].q.popleft()\n                emptyArmies |= not armies[i].q\n        if emptyArmies:\n            armies = [army for army in armies if army.q]\n            bullets = [[] for _ in range(len(armies))]\n    if not armies:\n        return (-1, ())\n    win = armies.pop()\n    return (win.i, tuple((soldier.i for soldier in win.q)))"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "emptyArmies = False",
      "mutated_line": "for (i, alive) in enumerate(alives):",
      "code": "from heapq import heappush, heappop\nfrom collections import deque, namedtuple\nfrom itertools import starmap\nArmy = namedtuple('Army', 'i,q')\nSoldier = namedtuple('Soldier', 'i,speed')\n\ndef queue_battle(distance, *args):\n    armies = [Army(i, deque(starmap(Soldier, enumerate(q)))) for (i, q) in enumerate(args)]\n    bullets = [[] for _ in range(len(armies))]\n    t = 0\n    while len(armies) > 1:\n        t += 1\n        alives = [1] * len(armies)\n        for (i, q) in enumerate(bullets):\n            if q and q[0] <= t:\n                alives[(i + 1) % len(armies)] = 0\n            while q and q[0] <= t:\n                heappop(q)\n        emptyArmies = True\n        for (i, alive) in enumerate(alives):\n            if alive:\n                heappush(bullets[i], t + distance / armies[i].q[0].speed)\n                armies[i].q.rotate(-1)\n            else:\n                armies[i].q.popleft()\n                emptyArmies |= not armies[i].q\n        if emptyArmies:\n            armies = [army for army in armies if army.q]\n            bullets = [[] for _ in range(len(armies))]\n    if not armies:\n        return (-1, ())\n    win = armies.pop()\n    return (win.i, tuple((soldier.i for soldier in win.q)))"
    },
    {
      "operator": "LCR",
      "lineno": 20,
      "original_line": "if q and q[0] <= t:",
      "mutated_line": "if q or q[0] <= t:",
      "code": "from heapq import heappush, heappop\nfrom collections import deque, namedtuple\nfrom itertools import starmap\nArmy = namedtuple('Army', 'i,q')\nSoldier = namedtuple('Soldier', 'i,speed')\n\ndef queue_battle(distance, *args):\n    armies = [Army(i, deque(starmap(Soldier, enumerate(q)))) for (i, q) in enumerate(args)]\n    bullets = [[] for _ in range(len(armies))]\n    t = 0\n    while len(armies) > 1:\n        t += 1\n        alives = [1] * len(armies)\n        for (i, q) in enumerate(bullets):\n            if q or q[0] <= t:\n                alives[(i + 1) % len(armies)] = 0\n            while q and q[0] <= t:\n                heappop(q)\n        emptyArmies = False\n        for (i, alive) in enumerate(alives):\n            if alive:\n                heappush(bullets[i], t + distance / armies[i].q[0].speed)\n                armies[i].q.rotate(-1)\n            else:\n                armies[i].q.popleft()\n                emptyArmies |= not armies[i].q\n        if emptyArmies:\n            armies = [army for army in armies if army.q]\n            bullets = [[] for _ in range(len(armies))]\n    if not armies:\n        return (-1, ())\n    win = armies.pop()\n    return (win.i, tuple((soldier.i for soldier in win.q)))"
    },
    {
      "operator": "LCR",
      "lineno": 22,
      "original_line": "while q and q[0] <= t:",
      "mutated_line": "while q or q[0] <= t:",
      "code": "from heapq import heappush, heappop\nfrom collections import deque, namedtuple\nfrom itertools import starmap\nArmy = namedtuple('Army', 'i,q')\nSoldier = namedtuple('Soldier', 'i,speed')\n\ndef queue_battle(distance, *args):\n    armies = [Army(i, deque(starmap(Soldier, enumerate(q)))) for (i, q) in enumerate(args)]\n    bullets = [[] for _ in range(len(armies))]\n    t = 0\n    while len(armies) > 1:\n        t += 1\n        alives = [1] * len(armies)\n        for (i, q) in enumerate(bullets):\n            if q and q[0] <= t:\n                alives[(i + 1) % len(armies)] = 0\n            while q or q[0] <= t:\n                heappop(q)\n        emptyArmies = False\n        for (i, alive) in enumerate(alives):\n            if alive:\n                heappush(bullets[i], t + distance / armies[i].q[0].speed)\n                armies[i].q.rotate(-1)\n            else:\n                armies[i].q.popleft()\n                emptyArmies |= not armies[i].q\n        if emptyArmies:\n            armies = [army for army in armies if army.q]\n            bullets = [[] for _ in range(len(armies))]\n    if not armies:\n        return (-1, ())\n    win = armies.pop()\n    return (win.i, tuple((soldier.i for soldier in win.q)))"
    },
    {
      "operator": "UOI",
      "lineno": 45,
      "original_line": "return (-1, ())",
      "mutated_line": "return (+1, ())",
      "code": "from heapq import heappush, heappop\nfrom collections import deque, namedtuple\nfrom itertools import starmap\nArmy = namedtuple('Army', 'i,q')\nSoldier = namedtuple('Soldier', 'i,speed')\n\ndef queue_battle(distance, *args):\n    armies = [Army(i, deque(starmap(Soldier, enumerate(q)))) for (i, q) in enumerate(args)]\n    bullets = [[] for _ in range(len(armies))]\n    t = 0\n    while len(armies) > 1:\n        t += 1\n        alives = [1] * len(armies)\n        for (i, q) in enumerate(bullets):\n            if q and q[0] <= t:\n                alives[(i + 1) % len(armies)] = 0\n            while q and q[0] <= t:\n                heappop(q)\n        emptyArmies = False\n        for (i, alive) in enumerate(alives):\n            if alive:\n                heappush(bullets[i], t + distance / armies[i].q[0].speed)\n                armies[i].q.rotate(-1)\n            else:\n                armies[i].q.popleft()\n                emptyArmies |= not armies[i].q\n        if emptyArmies:\n            armies = [army for army in armies if army.q]\n            bullets = [[] for _ in range(len(armies))]\n    if not armies:\n        return (+1, ())\n    win = armies.pop()\n    return (win.i, tuple((soldier.i for soldier in win.q)))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "alives = [1] * len(armies)",
      "mutated_line": "alives = [2] * len(armies)",
      "code": "from heapq import heappush, heappop\nfrom collections import deque, namedtuple\nfrom itertools import starmap\nArmy = namedtuple('Army', 'i,q')\nSoldier = namedtuple('Soldier', 'i,speed')\n\ndef queue_battle(distance, *args):\n    armies = [Army(i, deque(starmap(Soldier, enumerate(q)))) for (i, q) in enumerate(args)]\n    bullets = [[] for _ in range(len(armies))]\n    t = 0\n    while len(armies) > 1:\n        t += 1\n        alives = [2] * len(armies)\n        for (i, q) in enumerate(bullets):\n            if q and q[0] <= t:\n                alives[(i + 1) % len(armies)] = 0\n            while q and q[0] <= t:\n                heappop(q)\n        emptyArmies = False\n        for (i, alive) in enumerate(alives):\n            if alive:\n                heappush(bullets[i], t + distance / armies[i].q[0].speed)\n                armies[i].q.rotate(-1)\n            else:\n                armies[i].q.popleft()\n                emptyArmies |= not armies[i].q\n        if emptyArmies:\n            armies = [army for army in armies if army.q]\n            bullets = [[] for _ in range(len(armies))]\n    if not armies:\n        return (-1, ())\n    win = armies.pop()\n    return (win.i, tuple((soldier.i for soldier in win.q)))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "alives = [1] * len(armies)",
      "mutated_line": "alives = [0] * len(armies)",
      "code": "from heapq import heappush, heappop\nfrom collections import deque, namedtuple\nfrom itertools import starmap\nArmy = namedtuple('Army', 'i,q')\nSoldier = namedtuple('Soldier', 'i,speed')\n\ndef queue_battle(distance, *args):\n    armies = [Army(i, deque(starmap(Soldier, enumerate(q)))) for (i, q) in enumerate(args)]\n    bullets = [[] for _ in range(len(armies))]\n    t = 0\n    while len(armies) > 1:\n        t += 1\n        alives = [0] * len(armies)\n        for (i, q) in enumerate(bullets):\n            if q and q[0] <= t:\n                alives[(i + 1) % len(armies)] = 0\n            while q and q[0] <= t:\n                heappop(q)\n        emptyArmies = False\n        for (i, alive) in enumerate(alives):\n            if alive:\n                heappush(bullets[i], t + distance / armies[i].q[0].speed)\n                armies[i].q.rotate(-1)\n            else:\n                armies[i].q.popleft()\n                emptyArmies |= not armies[i].q\n        if emptyArmies:\n            armies = [army for army in armies if army.q]\n            bullets = [[] for _ in range(len(armies))]\n    if not armies:\n        return (-1, ())\n    win = armies.pop()\n    return (win.i, tuple((soldier.i for soldier in win.q)))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "alives = [1] * len(armies)",
      "mutated_line": "alives = [0] * len(armies)",
      "code": "from heapq import heappush, heappop\nfrom collections import deque, namedtuple\nfrom itertools import starmap\nArmy = namedtuple('Army', 'i,q')\nSoldier = namedtuple('Soldier', 'i,speed')\n\ndef queue_battle(distance, *args):\n    armies = [Army(i, deque(starmap(Soldier, enumerate(q)))) for (i, q) in enumerate(args)]\n    bullets = [[] for _ in range(len(armies))]\n    t = 0\n    while len(armies) > 1:\n        t += 1\n        alives = [0] * len(armies)\n        for (i, q) in enumerate(bullets):\n            if q and q[0] <= t:\n                alives[(i + 1) % len(armies)] = 0\n            while q and q[0] <= t:\n                heappop(q)\n        emptyArmies = False\n        for (i, alive) in enumerate(alives):\n            if alive:\n                heappush(bullets[i], t + distance / armies[i].q[0].speed)\n                armies[i].q.rotate(-1)\n            else:\n                armies[i].q.popleft()\n                emptyArmies |= not armies[i].q\n        if emptyArmies:\n            armies = [army for army in armies if army.q]\n            bullets = [[] for _ in range(len(armies))]\n    if not armies:\n        return (-1, ())\n    win = armies.pop()\n    return (win.i, tuple((soldier.i for soldier in win.q)))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "alives = [1] * len(armies)",
      "mutated_line": "alives = [-1] * len(armies)",
      "code": "from heapq import heappush, heappop\nfrom collections import deque, namedtuple\nfrom itertools import starmap\nArmy = namedtuple('Army', 'i,q')\nSoldier = namedtuple('Soldier', 'i,speed')\n\ndef queue_battle(distance, *args):\n    armies = [Army(i, deque(starmap(Soldier, enumerate(q)))) for (i, q) in enumerate(args)]\n    bullets = [[] for _ in range(len(armies))]\n    t = 0\n    while len(armies) > 1:\n        t += 1\n        alives = [-1] * len(armies)\n        for (i, q) in enumerate(bullets):\n            if q and q[0] <= t:\n                alives[(i + 1) % len(armies)] = 0\n            while q and q[0] <= t:\n                heappop(q)\n        emptyArmies = False\n        for (i, alive) in enumerate(alives):\n            if alive:\n                heappush(bullets[i], t + distance / armies[i].q[0].speed)\n                armies[i].q.rotate(-1)\n            else:\n                armies[i].q.popleft()\n                emptyArmies |= not armies[i].q\n        if emptyArmies:\n            armies = [army for army in armies if army.q]\n            bullets = [[] for _ in range(len(armies))]\n    if not armies:\n        return (-1, ())\n    win = armies.pop()\n    return (win.i, tuple((soldier.i for soldier in win.q)))"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if q and q[0] <= t:",
      "mutated_line": "if q and q[0] < t:",
      "code": "from heapq import heappush, heappop\nfrom collections import deque, namedtuple\nfrom itertools import starmap\nArmy = namedtuple('Army', 'i,q')\nSoldier = namedtuple('Soldier', 'i,speed')\n\ndef queue_battle(distance, *args):\n    armies = [Army(i, deque(starmap(Soldier, enumerate(q)))) for (i, q) in enumerate(args)]\n    bullets = [[] for _ in range(len(armies))]\n    t = 0\n    while len(armies) > 1:\n        t += 1\n        alives = [1] * len(armies)\n        for (i, q) in enumerate(bullets):\n            if q and q[0] < t:\n                alives[(i + 1) % len(armies)] = 0\n            while q and q[0] <= t:\n                heappop(q)\n        emptyArmies = False\n        for (i, alive) in enumerate(alives):\n            if alive:\n                heappush(bullets[i], t + distance / armies[i].q[0].speed)\n                armies[i].q.rotate(-1)\n            else:\n                armies[i].q.popleft()\n                emptyArmies |= not armies[i].q\n        if emptyArmies:\n            armies = [army for army in armies if army.q]\n            bullets = [[] for _ in range(len(armies))]\n    if not armies:\n        return (-1, ())\n    win = armies.pop()\n    return (win.i, tuple((soldier.i for soldier in win.q)))"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if q and q[0] <= t:",
      "mutated_line": "if q and q[0] > t:",
      "code": "from heapq import heappush, heappop\nfrom collections import deque, namedtuple\nfrom itertools import starmap\nArmy = namedtuple('Army', 'i,q')\nSoldier = namedtuple('Soldier', 'i,speed')\n\ndef queue_battle(distance, *args):\n    armies = [Army(i, deque(starmap(Soldier, enumerate(q)))) for (i, q) in enumerate(args)]\n    bullets = [[] for _ in range(len(armies))]\n    t = 0\n    while len(armies) > 1:\n        t += 1\n        alives = [1] * len(armies)\n        for (i, q) in enumerate(bullets):\n            if q and q[0] > t:\n                alives[(i + 1) % len(armies)] = 0\n            while q and q[0] <= t:\n                heappop(q)\n        emptyArmies = False\n        for (i, alive) in enumerate(alives):\n            if alive:\n                heappush(bullets[i], t + distance / armies[i].q[0].speed)\n                armies[i].q.rotate(-1)\n            else:\n                armies[i].q.popleft()\n                emptyArmies |= not armies[i].q\n        if emptyArmies:\n            armies = [army for army in armies if army.q]\n            bullets = [[] for _ in range(len(armies))]\n    if not armies:\n        return (-1, ())\n    win = armies.pop()\n    return (win.i, tuple((soldier.i for soldier in win.q)))"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if q and q[0] <= t:",
      "mutated_line": "if q and q[0] == t:",
      "code": "from heapq import heappush, heappop\nfrom collections import deque, namedtuple\nfrom itertools import starmap\nArmy = namedtuple('Army', 'i,q')\nSoldier = namedtuple('Soldier', 'i,speed')\n\ndef queue_battle(distance, *args):\n    armies = [Army(i, deque(starmap(Soldier, enumerate(q)))) for (i, q) in enumerate(args)]\n    bullets = [[] for _ in range(len(armies))]\n    t = 0\n    while len(armies) > 1:\n        t += 1\n        alives = [1] * len(armies)\n        for (i, q) in enumerate(bullets):\n            if q and q[0] == t:\n                alives[(i + 1) % len(armies)] = 0\n            while q and q[0] <= t:\n                heappop(q)\n        emptyArmies = False\n        for (i, alive) in enumerate(alives):\n            if alive:\n                heappush(bullets[i], t + distance / armies[i].q[0].speed)\n                armies[i].q.rotate(-1)\n            else:\n                armies[i].q.popleft()\n                emptyArmies |= not armies[i].q\n        if emptyArmies:\n            armies = [army for army in armies if army.q]\n            bullets = [[] for _ in range(len(armies))]\n    if not armies:\n        return (-1, ())\n    win = armies.pop()\n    return (win.i, tuple((soldier.i for soldier in win.q)))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "alives[(i + 1) % len(armies)] = 0",
      "mutated_line": "alives[(i + 1) % len(armies)] = 1",
      "code": "from heapq import heappush, heappop\nfrom collections import deque, namedtuple\nfrom itertools import starmap\nArmy = namedtuple('Army', 'i,q')\nSoldier = namedtuple('Soldier', 'i,speed')\n\ndef queue_battle(distance, *args):\n    armies = [Army(i, deque(starmap(Soldier, enumerate(q)))) for (i, q) in enumerate(args)]\n    bullets = [[] for _ in range(len(armies))]\n    t = 0\n    while len(armies) > 1:\n        t += 1\n        alives = [1] * len(armies)\n        for (i, q) in enumerate(bullets):\n            if q and q[0] <= t:\n                alives[(i + 1) % len(armies)] = 1\n            while q and q[0] <= t:\n                heappop(q)\n        emptyArmies = False\n        for (i, alive) in enumerate(alives):\n            if alive:\n                heappush(bullets[i], t + distance / armies[i].q[0].speed)\n                armies[i].q.rotate(-1)\n            else:\n                armies[i].q.popleft()\n                emptyArmies |= not armies[i].q\n        if emptyArmies:\n            armies = [army for army in armies if army.q]\n            bullets = [[] for _ in range(len(armies))]\n    if not armies:\n        return (-1, ())\n    win = armies.pop()\n    return (win.i, tuple((soldier.i for soldier in win.q)))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "alives[(i + 1) % len(armies)] = 0",
      "mutated_line": "alives[(i + 1) % len(armies)] = -1",
      "code": "from heapq import heappush, heappop\nfrom collections import deque, namedtuple\nfrom itertools import starmap\nArmy = namedtuple('Army', 'i,q')\nSoldier = namedtuple('Soldier', 'i,speed')\n\ndef queue_battle(distance, *args):\n    armies = [Army(i, deque(starmap(Soldier, enumerate(q)))) for (i, q) in enumerate(args)]\n    bullets = [[] for _ in range(len(armies))]\n    t = 0\n    while len(armies) > 1:\n        t += 1\n        alives = [1] * len(armies)\n        for (i, q) in enumerate(bullets):\n            if q and q[0] <= t:\n                alives[(i + 1) % len(armies)] = -1\n            while q and q[0] <= t:\n                heappop(q)\n        emptyArmies = False\n        for (i, alive) in enumerate(alives):\n            if alive:\n                heappush(bullets[i], t + distance / armies[i].q[0].speed)\n                armies[i].q.rotate(-1)\n            else:\n                armies[i].q.popleft()\n                emptyArmies |= not armies[i].q\n        if emptyArmies:\n            armies = [army for army in armies if army.q]\n            bullets = [[] for _ in range(len(armies))]\n    if not armies:\n        return (-1, ())\n    win = armies.pop()\n    return (win.i, tuple((soldier.i for soldier in win.q)))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "alives[(i + 1) % len(armies)] = 0",
      "mutated_line": "alives[(i + 1) % len(armies)] = 1",
      "code": "from heapq import heappush, heappop\nfrom collections import deque, namedtuple\nfrom itertools import starmap\nArmy = namedtuple('Army', 'i,q')\nSoldier = namedtuple('Soldier', 'i,speed')\n\ndef queue_battle(distance, *args):\n    armies = [Army(i, deque(starmap(Soldier, enumerate(q)))) for (i, q) in enumerate(args)]\n    bullets = [[] for _ in range(len(armies))]\n    t = 0\n    while len(armies) > 1:\n        t += 1\n        alives = [1] * len(armies)\n        for (i, q) in enumerate(bullets):\n            if q and q[0] <= t:\n                alives[(i + 1) % len(armies)] = 1\n            while q and q[0] <= t:\n                heappop(q)\n        emptyArmies = False\n        for (i, alive) in enumerate(alives):\n            if alive:\n                heappush(bullets[i], t + distance / armies[i].q[0].speed)\n                armies[i].q.rotate(-1)\n            else:\n                armies[i].q.popleft()\n                emptyArmies |= not armies[i].q\n        if emptyArmies:\n            armies = [army for army in armies if army.q]\n            bullets = [[] for _ in range(len(armies))]\n    if not armies:\n        return (-1, ())\n    win = armies.pop()\n    return (win.i, tuple((soldier.i for soldier in win.q)))"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "while q and q[0] <= t:",
      "mutated_line": "while q and q[0] < t:",
      "code": "from heapq import heappush, heappop\nfrom collections import deque, namedtuple\nfrom itertools import starmap\nArmy = namedtuple('Army', 'i,q')\nSoldier = namedtuple('Soldier', 'i,speed')\n\ndef queue_battle(distance, *args):\n    armies = [Army(i, deque(starmap(Soldier, enumerate(q)))) for (i, q) in enumerate(args)]\n    bullets = [[] for _ in range(len(armies))]\n    t = 0\n    while len(armies) > 1:\n        t += 1\n        alives = [1] * len(armies)\n        for (i, q) in enumerate(bullets):\n            if q and q[0] <= t:\n                alives[(i + 1) % len(armies)] = 0\n            while q and q[0] < t:\n                heappop(q)\n        emptyArmies = False\n        for (i, alive) in enumerate(alives):\n            if alive:\n                heappush(bullets[i], t + distance / armies[i].q[0].speed)\n                armies[i].q.rotate(-1)\n            else:\n                armies[i].q.popleft()\n                emptyArmies |= not armies[i].q\n        if emptyArmies:\n            armies = [army for army in armies if army.q]\n            bullets = [[] for _ in range(len(armies))]\n    if not armies:\n        return (-1, ())\n    win = armies.pop()\n    return (win.i, tuple((soldier.i for soldier in win.q)))"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "while q and q[0] <= t:",
      "mutated_line": "while q and q[0] > t:",
      "code": "from heapq import heappush, heappop\nfrom collections import deque, namedtuple\nfrom itertools import starmap\nArmy = namedtuple('Army', 'i,q')\nSoldier = namedtuple('Soldier', 'i,speed')\n\ndef queue_battle(distance, *args):\n    armies = [Army(i, deque(starmap(Soldier, enumerate(q)))) for (i, q) in enumerate(args)]\n    bullets = [[] for _ in range(len(armies))]\n    t = 0\n    while len(armies) > 1:\n        t += 1\n        alives = [1] * len(armies)\n        for (i, q) in enumerate(bullets):\n            if q and q[0] <= t:\n                alives[(i + 1) % len(armies)] = 0\n            while q and q[0] > t:\n                heappop(q)\n        emptyArmies = False\n        for (i, alive) in enumerate(alives):\n            if alive:\n                heappush(bullets[i], t + distance / armies[i].q[0].speed)\n                armies[i].q.rotate(-1)\n            else:\n                armies[i].q.popleft()\n                emptyArmies |= not armies[i].q\n        if emptyArmies:\n            armies = [army for army in armies if army.q]\n            bullets = [[] for _ in range(len(armies))]\n    if not armies:\n        return (-1, ())\n    win = armies.pop()\n    return (win.i, tuple((soldier.i for soldier in win.q)))"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "while q and q[0] <= t:",
      "mutated_line": "while q and q[0] == t:",
      "code": "from heapq import heappush, heappop\nfrom collections import deque, namedtuple\nfrom itertools import starmap\nArmy = namedtuple('Army', 'i,q')\nSoldier = namedtuple('Soldier', 'i,speed')\n\ndef queue_battle(distance, *args):\n    armies = [Army(i, deque(starmap(Soldier, enumerate(q)))) for (i, q) in enumerate(args)]\n    bullets = [[] for _ in range(len(armies))]\n    t = 0\n    while len(armies) > 1:\n        t += 1\n        alives = [1] * len(armies)\n        for (i, q) in enumerate(bullets):\n            if q and q[0] <= t:\n                alives[(i + 1) % len(armies)] = 0\n            while q and q[0] == t:\n                heappop(q)\n        emptyArmies = False\n        for (i, alive) in enumerate(alives):\n            if alive:\n                heappush(bullets[i], t + distance / armies[i].q[0].speed)\n                armies[i].q.rotate(-1)\n            else:\n                armies[i].q.popleft()\n                emptyArmies |= not armies[i].q\n        if emptyArmies:\n            armies = [army for army in armies if army.q]\n            bullets = [[] for _ in range(len(armies))]\n    if not armies:\n        return (-1, ())\n    win = armies.pop()\n    return (win.i, tuple((soldier.i for soldier in win.q)))"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return (-1, ())",
      "mutated_line": "return (-2, ())",
      "code": "from heapq import heappush, heappop\nfrom collections import deque, namedtuple\nfrom itertools import starmap\nArmy = namedtuple('Army', 'i,q')\nSoldier = namedtuple('Soldier', 'i,speed')\n\ndef queue_battle(distance, *args):\n    armies = [Army(i, deque(starmap(Soldier, enumerate(q)))) for (i, q) in enumerate(args)]\n    bullets = [[] for _ in range(len(armies))]\n    t = 0\n    while len(armies) > 1:\n        t += 1\n        alives = [1] * len(armies)\n        for (i, q) in enumerate(bullets):\n            if q and q[0] <= t:\n                alives[(i + 1) % len(armies)] = 0\n            while q and q[0] <= t:\n                heappop(q)\n        emptyArmies = False\n        for (i, alive) in enumerate(alives):\n            if alive:\n                heappush(bullets[i], t + distance / armies[i].q[0].speed)\n                armies[i].q.rotate(-1)\n            else:\n                armies[i].q.popleft()\n                emptyArmies |= not armies[i].q\n        if emptyArmies:\n            armies = [army for army in armies if army.q]\n            bullets = [[] for _ in range(len(armies))]\n    if not armies:\n        return (-2, ())\n    win = armies.pop()\n    return (win.i, tuple((soldier.i for soldier in win.q)))"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return (-1, ())",
      "mutated_line": "return (-0, ())",
      "code": "from heapq import heappush, heappop\nfrom collections import deque, namedtuple\nfrom itertools import starmap\nArmy = namedtuple('Army', 'i,q')\nSoldier = namedtuple('Soldier', 'i,speed')\n\ndef queue_battle(distance, *args):\n    armies = [Army(i, deque(starmap(Soldier, enumerate(q)))) for (i, q) in enumerate(args)]\n    bullets = [[] for _ in range(len(armies))]\n    t = 0\n    while len(armies) > 1:\n        t += 1\n        alives = [1] * len(armies)\n        for (i, q) in enumerate(bullets):\n            if q and q[0] <= t:\n                alives[(i + 1) % len(armies)] = 0\n            while q and q[0] <= t:\n                heappop(q)\n        emptyArmies = False\n        for (i, alive) in enumerate(alives):\n            if alive:\n                heappush(bullets[i], t + distance / armies[i].q[0].speed)\n                armies[i].q.rotate(-1)\n            else:\n                armies[i].q.popleft()\n                emptyArmies |= not armies[i].q\n        if emptyArmies:\n            armies = [army for army in armies if army.q]\n            bullets = [[] for _ in range(len(armies))]\n    if not armies:\n        return (-0, ())\n    win = armies.pop()\n    return (win.i, tuple((soldier.i for soldier in win.q)))"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return (-1, ())",
      "mutated_line": "return (-0, ())",
      "code": "from heapq import heappush, heappop\nfrom collections import deque, namedtuple\nfrom itertools import starmap\nArmy = namedtuple('Army', 'i,q')\nSoldier = namedtuple('Soldier', 'i,speed')\n\ndef queue_battle(distance, *args):\n    armies = [Army(i, deque(starmap(Soldier, enumerate(q)))) for (i, q) in enumerate(args)]\n    bullets = [[] for _ in range(len(armies))]\n    t = 0\n    while len(armies) > 1:\n        t += 1\n        alives = [1] * len(armies)\n        for (i, q) in enumerate(bullets):\n            if q and q[0] <= t:\n                alives[(i + 1) % len(armies)] = 0\n            while q and q[0] <= t:\n                heappop(q)\n        emptyArmies = False\n        for (i, alive) in enumerate(alives):\n            if alive:\n                heappush(bullets[i], t + distance / armies[i].q[0].speed)\n                armies[i].q.rotate(-1)\n            else:\n                armies[i].q.popleft()\n                emptyArmies |= not armies[i].q\n        if emptyArmies:\n            armies = [army for army in armies if army.q]\n            bullets = [[] for _ in range(len(armies))]\n    if not armies:\n        return (-0, ())\n    win = armies.pop()\n    return (win.i, tuple((soldier.i for soldier in win.q)))"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return (-1, ())",
      "mutated_line": "return (--1, ())",
      "code": "from heapq import heappush, heappop\nfrom collections import deque, namedtuple\nfrom itertools import starmap\nArmy = namedtuple('Army', 'i,q')\nSoldier = namedtuple('Soldier', 'i,speed')\n\ndef queue_battle(distance, *args):\n    armies = [Army(i, deque(starmap(Soldier, enumerate(q)))) for (i, q) in enumerate(args)]\n    bullets = [[] for _ in range(len(armies))]\n    t = 0\n    while len(armies) > 1:\n        t += 1\n        alives = [1] * len(armies)\n        for (i, q) in enumerate(bullets):\n            if q and q[0] <= t:\n                alives[(i + 1) % len(armies)] = 0\n            while q and q[0] <= t:\n                heappop(q)\n        emptyArmies = False\n        for (i, alive) in enumerate(alives):\n            if alive:\n                heappush(bullets[i], t + distance / armies[i].q[0].speed)\n                armies[i].q.rotate(-1)\n            else:\n                armies[i].q.popleft()\n                emptyArmies |= not armies[i].q\n        if emptyArmies:\n            armies = [army for army in armies if army.q]\n            bullets = [[] for _ in range(len(armies))]\n    if not armies:\n        return (--1, ())\n    win = armies.pop()\n    return (win.i, tuple((soldier.i for soldier in win.q)))"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "alives[(i + 1) % len(armies)] = 0",
      "mutated_line": "alives[(i + 1) * len(armies)] = 0",
      "code": "from heapq import heappush, heappop\nfrom collections import deque, namedtuple\nfrom itertools import starmap\nArmy = namedtuple('Army', 'i,q')\nSoldier = namedtuple('Soldier', 'i,speed')\n\ndef queue_battle(distance, *args):\n    armies = [Army(i, deque(starmap(Soldier, enumerate(q)))) for (i, q) in enumerate(args)]\n    bullets = [[] for _ in range(len(armies))]\n    t = 0\n    while len(armies) > 1:\n        t += 1\n        alives = [1] * len(armies)\n        for (i, q) in enumerate(bullets):\n            if q and q[0] <= t:\n                alives[(i + 1) * len(armies)] = 0\n            while q and q[0] <= t:\n                heappop(q)\n        emptyArmies = False\n        for (i, alive) in enumerate(alives):\n            if alive:\n                heappush(bullets[i], t + distance / armies[i].q[0].speed)\n                armies[i].q.rotate(-1)\n            else:\n                armies[i].q.popleft()\n                emptyArmies |= not armies[i].q\n        if emptyArmies:\n            armies = [army for army in armies if army.q]\n            bullets = [[] for _ in range(len(armies))]\n    if not armies:\n        return (-1, ())\n    win = armies.pop()\n    return (win.i, tuple((soldier.i for soldier in win.q)))"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "alives[(i + 1) % len(armies)] = 0",
      "mutated_line": "alives[i + 1 + len(armies)] = 0",
      "code": "from heapq import heappush, heappop\nfrom collections import deque, namedtuple\nfrom itertools import starmap\nArmy = namedtuple('Army', 'i,q')\nSoldier = namedtuple('Soldier', 'i,speed')\n\ndef queue_battle(distance, *args):\n    armies = [Army(i, deque(starmap(Soldier, enumerate(q)))) for (i, q) in enumerate(args)]\n    bullets = [[] for _ in range(len(armies))]\n    t = 0\n    while len(armies) > 1:\n        t += 1\n        alives = [1] * len(armies)\n        for (i, q) in enumerate(bullets):\n            if q and q[0] <= t:\n                alives[i + 1 + len(armies)] = 0\n            while q and q[0] <= t:\n                heappop(q)\n        emptyArmies = False\n        for (i, alive) in enumerate(alives):\n            if alive:\n                heappush(bullets[i], t + distance / armies[i].q[0].speed)\n                armies[i].q.rotate(-1)\n            else:\n                armies[i].q.popleft()\n                emptyArmies |= not armies[i].q\n        if emptyArmies:\n            armies = [army for army in armies if army.q]\n            bullets = [[] for _ in range(len(armies))]\n    if not armies:\n        return (-1, ())\n    win = armies.pop()\n    return (win.i, tuple((soldier.i for soldier in win.q)))"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "heappush(bullets[i], t + distance / armies[i].q[0].speed)",
      "mutated_line": "heappush(bullets[i], t - distance / armies[i].q[0].speed)",
      "code": "from heapq import heappush, heappop\nfrom collections import deque, namedtuple\nfrom itertools import starmap\nArmy = namedtuple('Army', 'i,q')\nSoldier = namedtuple('Soldier', 'i,speed')\n\ndef queue_battle(distance, *args):\n    armies = [Army(i, deque(starmap(Soldier, enumerate(q)))) for (i, q) in enumerate(args)]\n    bullets = [[] for _ in range(len(armies))]\n    t = 0\n    while len(armies) > 1:\n        t += 1\n        alives = [1] * len(armies)\n        for (i, q) in enumerate(bullets):\n            if q and q[0] <= t:\n                alives[(i + 1) % len(armies)] = 0\n            while q and q[0] <= t:\n                heappop(q)\n        emptyArmies = False\n        for (i, alive) in enumerate(alives):\n            if alive:\n                heappush(bullets[i], t - distance / armies[i].q[0].speed)\n                armies[i].q.rotate(-1)\n            else:\n                armies[i].q.popleft()\n                emptyArmies |= not armies[i].q\n        if emptyArmies:\n            armies = [army for army in armies if army.q]\n            bullets = [[] for _ in range(len(armies))]\n    if not armies:\n        return (-1, ())\n    win = armies.pop()\n    return (win.i, tuple((soldier.i for soldier in win.q)))"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "heappush(bullets[i], t + distance / armies[i].q[0].speed)",
      "mutated_line": "heappush(bullets[i], t * (distance / armies[i].q[0].speed))",
      "code": "from heapq import heappush, heappop\nfrom collections import deque, namedtuple\nfrom itertools import starmap\nArmy = namedtuple('Army', 'i,q')\nSoldier = namedtuple('Soldier', 'i,speed')\n\ndef queue_battle(distance, *args):\n    armies = [Army(i, deque(starmap(Soldier, enumerate(q)))) for (i, q) in enumerate(args)]\n    bullets = [[] for _ in range(len(armies))]\n    t = 0\n    while len(armies) > 1:\n        t += 1\n        alives = [1] * len(armies)\n        for (i, q) in enumerate(bullets):\n            if q and q[0] <= t:\n                alives[(i + 1) % len(armies)] = 0\n            while q and q[0] <= t:\n                heappop(q)\n        emptyArmies = False\n        for (i, alive) in enumerate(alives):\n            if alive:\n                heappush(bullets[i], t * (distance / armies[i].q[0].speed))\n                armies[i].q.rotate(-1)\n            else:\n                armies[i].q.popleft()\n                emptyArmies |= not armies[i].q\n        if emptyArmies:\n            armies = [army for army in armies if army.q]\n            bullets = [[] for _ in range(len(armies))]\n    if not armies:\n        return (-1, ())\n    win = armies.pop()\n    return (win.i, tuple((soldier.i for soldier in win.q)))"
    },
    {
      "operator": "UOI",
      "lineno": 32,
      "original_line": "armies[i].q.rotate(-1)",
      "mutated_line": "armies[i].q.rotate(+1)",
      "code": "from heapq import heappush, heappop\nfrom collections import deque, namedtuple\nfrom itertools import starmap\nArmy = namedtuple('Army', 'i,q')\nSoldier = namedtuple('Soldier', 'i,speed')\n\ndef queue_battle(distance, *args):\n    armies = [Army(i, deque(starmap(Soldier, enumerate(q)))) for (i, q) in enumerate(args)]\n    bullets = [[] for _ in range(len(armies))]\n    t = 0\n    while len(armies) > 1:\n        t += 1\n        alives = [1] * len(armies)\n        for (i, q) in enumerate(bullets):\n            if q and q[0] <= t:\n                alives[(i + 1) % len(armies)] = 0\n            while q and q[0] <= t:\n                heappop(q)\n        emptyArmies = False\n        for (i, alive) in enumerate(alives):\n            if alive:\n                heappush(bullets[i], t + distance / armies[i].q[0].speed)\n                armies[i].q.rotate(+1)\n            else:\n                armies[i].q.popleft()\n                emptyArmies |= not armies[i].q\n        if emptyArmies:\n            armies = [army for army in armies if army.q]\n            bullets = [[] for _ in range(len(armies))]\n    if not armies:\n        return (-1, ())\n    win = armies.pop()\n    return (win.i, tuple((soldier.i for soldier in win.q)))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if q and q[0] <= t:",
      "mutated_line": "if q and q[1] <= t:",
      "code": "from heapq import heappush, heappop\nfrom collections import deque, namedtuple\nfrom itertools import starmap\nArmy = namedtuple('Army', 'i,q')\nSoldier = namedtuple('Soldier', 'i,speed')\n\ndef queue_battle(distance, *args):\n    armies = [Army(i, deque(starmap(Soldier, enumerate(q)))) for (i, q) in enumerate(args)]\n    bullets = [[] for _ in range(len(armies))]\n    t = 0\n    while len(armies) > 1:\n        t += 1\n        alives = [1] * len(armies)\n        for (i, q) in enumerate(bullets):\n            if q and q[1] <= t:\n                alives[(i + 1) % len(armies)] = 0\n            while q and q[0] <= t:\n                heappop(q)\n        emptyArmies = False\n        for (i, alive) in enumerate(alives):\n            if alive:\n                heappush(bullets[i], t + distance / armies[i].q[0].speed)\n                armies[i].q.rotate(-1)\n            else:\n                armies[i].q.popleft()\n                emptyArmies |= not armies[i].q\n        if emptyArmies:\n            armies = [army for army in armies if army.q]\n            bullets = [[] for _ in range(len(armies))]\n    if not armies:\n        return (-1, ())\n    win = armies.pop()\n    return (win.i, tuple((soldier.i for soldier in win.q)))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if q and q[0] <= t:",
      "mutated_line": "if q and q[-1] <= t:",
      "code": "from heapq import heappush, heappop\nfrom collections import deque, namedtuple\nfrom itertools import starmap\nArmy = namedtuple('Army', 'i,q')\nSoldier = namedtuple('Soldier', 'i,speed')\n\ndef queue_battle(distance, *args):\n    armies = [Army(i, deque(starmap(Soldier, enumerate(q)))) for (i, q) in enumerate(args)]\n    bullets = [[] for _ in range(len(armies))]\n    t = 0\n    while len(armies) > 1:\n        t += 1\n        alives = [1] * len(armies)\n        for (i, q) in enumerate(bullets):\n            if q and q[-1] <= t:\n                alives[(i + 1) % len(armies)] = 0\n            while q and q[0] <= t:\n                heappop(q)\n        emptyArmies = False\n        for (i, alive) in enumerate(alives):\n            if alive:\n                heappush(bullets[i], t + distance / armies[i].q[0].speed)\n                armies[i].q.rotate(-1)\n            else:\n                armies[i].q.popleft()\n                emptyArmies |= not armies[i].q\n        if emptyArmies:\n            armies = [army for army in armies if army.q]\n            bullets = [[] for _ in range(len(armies))]\n    if not armies:\n        return (-1, ())\n    win = armies.pop()\n    return (win.i, tuple((soldier.i for soldier in win.q)))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if q and q[0] <= t:",
      "mutated_line": "if q and q[1] <= t:",
      "code": "from heapq import heappush, heappop\nfrom collections import deque, namedtuple\nfrom itertools import starmap\nArmy = namedtuple('Army', 'i,q')\nSoldier = namedtuple('Soldier', 'i,speed')\n\ndef queue_battle(distance, *args):\n    armies = [Army(i, deque(starmap(Soldier, enumerate(q)))) for (i, q) in enumerate(args)]\n    bullets = [[] for _ in range(len(armies))]\n    t = 0\n    while len(armies) > 1:\n        t += 1\n        alives = [1] * len(armies)\n        for (i, q) in enumerate(bullets):\n            if q and q[1] <= t:\n                alives[(i + 1) % len(armies)] = 0\n            while q and q[0] <= t:\n                heappop(q)\n        emptyArmies = False\n        for (i, alive) in enumerate(alives):\n            if alive:\n                heappush(bullets[i], t + distance / armies[i].q[0].speed)\n                armies[i].q.rotate(-1)\n            else:\n                armies[i].q.popleft()\n                emptyArmies |= not armies[i].q\n        if emptyArmies:\n            armies = [army for army in armies if army.q]\n            bullets = [[] for _ in range(len(armies))]\n    if not armies:\n        return (-1, ())\n    win = armies.pop()\n    return (win.i, tuple((soldier.i for soldier in win.q)))"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "alives[(i + 1) % len(armies)] = 0",
      "mutated_line": "alives[(i - 1) % len(armies)] = 0",
      "code": "from heapq import heappush, heappop\nfrom collections import deque, namedtuple\nfrom itertools import starmap\nArmy = namedtuple('Army', 'i,q')\nSoldier = namedtuple('Soldier', 'i,speed')\n\ndef queue_battle(distance, *args):\n    armies = [Army(i, deque(starmap(Soldier, enumerate(q)))) for (i, q) in enumerate(args)]\n    bullets = [[] for _ in range(len(armies))]\n    t = 0\n    while len(armies) > 1:\n        t += 1\n        alives = [1] * len(armies)\n        for (i, q) in enumerate(bullets):\n            if q and q[0] <= t:\n                alives[(i - 1) % len(armies)] = 0\n            while q and q[0] <= t:\n                heappop(q)\n        emptyArmies = False\n        for (i, alive) in enumerate(alives):\n            if alive:\n                heappush(bullets[i], t + distance / armies[i].q[0].speed)\n                armies[i].q.rotate(-1)\n            else:\n                armies[i].q.popleft()\n                emptyArmies |= not armies[i].q\n        if emptyArmies:\n            armies = [army for army in armies if army.q]\n            bullets = [[] for _ in range(len(armies))]\n    if not armies:\n        return (-1, ())\n    win = armies.pop()\n    return (win.i, tuple((soldier.i for soldier in win.q)))"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "alives[(i + 1) % len(armies)] = 0",
      "mutated_line": "alives[i * 1 % len(armies)] = 0",
      "code": "from heapq import heappush, heappop\nfrom collections import deque, namedtuple\nfrom itertools import starmap\nArmy = namedtuple('Army', 'i,q')\nSoldier = namedtuple('Soldier', 'i,speed')\n\ndef queue_battle(distance, *args):\n    armies = [Army(i, deque(starmap(Soldier, enumerate(q)))) for (i, q) in enumerate(args)]\n    bullets = [[] for _ in range(len(armies))]\n    t = 0\n    while len(armies) > 1:\n        t += 1\n        alives = [1] * len(armies)\n        for (i, q) in enumerate(bullets):\n            if q and q[0] <= t:\n                alives[i * 1 % len(armies)] = 0\n            while q and q[0] <= t:\n                heappop(q)\n        emptyArmies = False\n        for (i, alive) in enumerate(alives):\n            if alive:\n                heappush(bullets[i], t + distance / armies[i].q[0].speed)\n                armies[i].q.rotate(-1)\n            else:\n                armies[i].q.popleft()\n                emptyArmies |= not armies[i].q\n        if emptyArmies:\n            armies = [army for army in armies if army.q]\n            bullets = [[] for _ in range(len(armies))]\n    if not armies:\n        return (-1, ())\n    win = armies.pop()\n    return (win.i, tuple((soldier.i for soldier in win.q)))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "while q and q[0] <= t:",
      "mutated_line": "while q and q[1] <= t:",
      "code": "from heapq import heappush, heappop\nfrom collections import deque, namedtuple\nfrom itertools import starmap\nArmy = namedtuple('Army', 'i,q')\nSoldier = namedtuple('Soldier', 'i,speed')\n\ndef queue_battle(distance, *args):\n    armies = [Army(i, deque(starmap(Soldier, enumerate(q)))) for (i, q) in enumerate(args)]\n    bullets = [[] for _ in range(len(armies))]\n    t = 0\n    while len(armies) > 1:\n        t += 1\n        alives = [1] * len(armies)\n        for (i, q) in enumerate(bullets):\n            if q and q[0] <= t:\n                alives[(i + 1) % len(armies)] = 0\n            while q and q[1] <= t:\n                heappop(q)\n        emptyArmies = False\n        for (i, alive) in enumerate(alives):\n            if alive:\n                heappush(bullets[i], t + distance / armies[i].q[0].speed)\n                armies[i].q.rotate(-1)\n            else:\n                armies[i].q.popleft()\n                emptyArmies |= not armies[i].q\n        if emptyArmies:\n            armies = [army for army in armies if army.q]\n            bullets = [[] for _ in range(len(armies))]\n    if not armies:\n        return (-1, ())\n    win = armies.pop()\n    return (win.i, tuple((soldier.i for soldier in win.q)))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "while q and q[0] <= t:",
      "mutated_line": "while q and q[-1] <= t:",
      "code": "from heapq import heappush, heappop\nfrom collections import deque, namedtuple\nfrom itertools import starmap\nArmy = namedtuple('Army', 'i,q')\nSoldier = namedtuple('Soldier', 'i,speed')\n\ndef queue_battle(distance, *args):\n    armies = [Army(i, deque(starmap(Soldier, enumerate(q)))) for (i, q) in enumerate(args)]\n    bullets = [[] for _ in range(len(armies))]\n    t = 0\n    while len(armies) > 1:\n        t += 1\n        alives = [1] * len(armies)\n        for (i, q) in enumerate(bullets):\n            if q and q[0] <= t:\n                alives[(i + 1) % len(armies)] = 0\n            while q and q[-1] <= t:\n                heappop(q)\n        emptyArmies = False\n        for (i, alive) in enumerate(alives):\n            if alive:\n                heappush(bullets[i], t + distance / armies[i].q[0].speed)\n                armies[i].q.rotate(-1)\n            else:\n                armies[i].q.popleft()\n                emptyArmies |= not armies[i].q\n        if emptyArmies:\n            armies = [army for army in armies if army.q]\n            bullets = [[] for _ in range(len(armies))]\n    if not armies:\n        return (-1, ())\n    win = armies.pop()\n    return (win.i, tuple((soldier.i for soldier in win.q)))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "while q and q[0] <= t:",
      "mutated_line": "while q and q[1] <= t:",
      "code": "from heapq import heappush, heappop\nfrom collections import deque, namedtuple\nfrom itertools import starmap\nArmy = namedtuple('Army', 'i,q')\nSoldier = namedtuple('Soldier', 'i,speed')\n\ndef queue_battle(distance, *args):\n    armies = [Army(i, deque(starmap(Soldier, enumerate(q)))) for (i, q) in enumerate(args)]\n    bullets = [[] for _ in range(len(armies))]\n    t = 0\n    while len(armies) > 1:\n        t += 1\n        alives = [1] * len(armies)\n        for (i, q) in enumerate(bullets):\n            if q and q[0] <= t:\n                alives[(i + 1) % len(armies)] = 0\n            while q and q[1] <= t:\n                heappop(q)\n        emptyArmies = False\n        for (i, alive) in enumerate(alives):\n            if alive:\n                heappush(bullets[i], t + distance / armies[i].q[0].speed)\n                armies[i].q.rotate(-1)\n            else:\n                armies[i].q.popleft()\n                emptyArmies |= not armies[i].q\n        if emptyArmies:\n            armies = [army for army in armies if army.q]\n            bullets = [[] for _ in range(len(armies))]\n    if not armies:\n        return (-1, ())\n    win = armies.pop()\n    return (win.i, tuple((soldier.i for soldier in win.q)))"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "heappush(bullets[i], t + distance / armies[i].q[0].speed)",
      "mutated_line": "heappush(bullets[i], t + distance * armies[i].q[0].speed)",
      "code": "from heapq import heappush, heappop\nfrom collections import deque, namedtuple\nfrom itertools import starmap\nArmy = namedtuple('Army', 'i,q')\nSoldier = namedtuple('Soldier', 'i,speed')\n\ndef queue_battle(distance, *args):\n    armies = [Army(i, deque(starmap(Soldier, enumerate(q)))) for (i, q) in enumerate(args)]\n    bullets = [[] for _ in range(len(armies))]\n    t = 0\n    while len(armies) > 1:\n        t += 1\n        alives = [1] * len(armies)\n        for (i, q) in enumerate(bullets):\n            if q and q[0] <= t:\n                alives[(i + 1) % len(armies)] = 0\n            while q and q[0] <= t:\n                heappop(q)\n        emptyArmies = False\n        for (i, alive) in enumerate(alives):\n            if alive:\n                heappush(bullets[i], t + distance * armies[i].q[0].speed)\n                armies[i].q.rotate(-1)\n            else:\n                armies[i].q.popleft()\n                emptyArmies |= not armies[i].q\n        if emptyArmies:\n            armies = [army for army in armies if army.q]\n            bullets = [[] for _ in range(len(armies))]\n    if not armies:\n        return (-1, ())\n    win = armies.pop()\n    return (win.i, tuple((soldier.i for soldier in win.q)))"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "heappush(bullets[i], t + distance / armies[i].q[0].speed)",
      "mutated_line": "heappush(bullets[i], t + distance // armies[i].q[0].speed)",
      "code": "from heapq import heappush, heappop\nfrom collections import deque, namedtuple\nfrom itertools import starmap\nArmy = namedtuple('Army', 'i,q')\nSoldier = namedtuple('Soldier', 'i,speed')\n\ndef queue_battle(distance, *args):\n    armies = [Army(i, deque(starmap(Soldier, enumerate(q)))) for (i, q) in enumerate(args)]\n    bullets = [[] for _ in range(len(armies))]\n    t = 0\n    while len(armies) > 1:\n        t += 1\n        alives = [1] * len(armies)\n        for (i, q) in enumerate(bullets):\n            if q and q[0] <= t:\n                alives[(i + 1) % len(armies)] = 0\n            while q and q[0] <= t:\n                heappop(q)\n        emptyArmies = False\n        for (i, alive) in enumerate(alives):\n            if alive:\n                heappush(bullets[i], t + distance // armies[i].q[0].speed)\n                armies[i].q.rotate(-1)\n            else:\n                armies[i].q.popleft()\n                emptyArmies |= not armies[i].q\n        if emptyArmies:\n            armies = [army for army in armies if army.q]\n            bullets = [[] for _ in range(len(armies))]\n    if not armies:\n        return (-1, ())\n    win = armies.pop()\n    return (win.i, tuple((soldier.i for soldier in win.q)))"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "armies[i].q.rotate(-1)",
      "mutated_line": "armies[i].q.rotate(-2)",
      "code": "from heapq import heappush, heappop\nfrom collections import deque, namedtuple\nfrom itertools import starmap\nArmy = namedtuple('Army', 'i,q')\nSoldier = namedtuple('Soldier', 'i,speed')\n\ndef queue_battle(distance, *args):\n    armies = [Army(i, deque(starmap(Soldier, enumerate(q)))) for (i, q) in enumerate(args)]\n    bullets = [[] for _ in range(len(armies))]\n    t = 0\n    while len(armies) > 1:\n        t += 1\n        alives = [1] * len(armies)\n        for (i, q) in enumerate(bullets):\n            if q and q[0] <= t:\n                alives[(i + 1) % len(armies)] = 0\n            while q and q[0] <= t:\n                heappop(q)\n        emptyArmies = False\n        for (i, alive) in enumerate(alives):\n            if alive:\n                heappush(bullets[i], t + distance / armies[i].q[0].speed)\n                armies[i].q.rotate(-2)\n            else:\n                armies[i].q.popleft()\n                emptyArmies |= not armies[i].q\n        if emptyArmies:\n            armies = [army for army in armies if army.q]\n            bullets = [[] for _ in range(len(armies))]\n    if not armies:\n        return (-1, ())\n    win = armies.pop()\n    return (win.i, tuple((soldier.i for soldier in win.q)))"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "armies[i].q.rotate(-1)",
      "mutated_line": "armies[i].q.rotate(-0)",
      "code": "from heapq import heappush, heappop\nfrom collections import deque, namedtuple\nfrom itertools import starmap\nArmy = namedtuple('Army', 'i,q')\nSoldier = namedtuple('Soldier', 'i,speed')\n\ndef queue_battle(distance, *args):\n    armies = [Army(i, deque(starmap(Soldier, enumerate(q)))) for (i, q) in enumerate(args)]\n    bullets = [[] for _ in range(len(armies))]\n    t = 0\n    while len(armies) > 1:\n        t += 1\n        alives = [1] * len(armies)\n        for (i, q) in enumerate(bullets):\n            if q and q[0] <= t:\n                alives[(i + 1) % len(armies)] = 0\n            while q and q[0] <= t:\n                heappop(q)\n        emptyArmies = False\n        for (i, alive) in enumerate(alives):\n            if alive:\n                heappush(bullets[i], t + distance / armies[i].q[0].speed)\n                armies[i].q.rotate(-0)\n            else:\n                armies[i].q.popleft()\n                emptyArmies |= not armies[i].q\n        if emptyArmies:\n            armies = [army for army in armies if army.q]\n            bullets = [[] for _ in range(len(armies))]\n    if not armies:\n        return (-1, ())\n    win = armies.pop()\n    return (win.i, tuple((soldier.i for soldier in win.q)))"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "armies[i].q.rotate(-1)",
      "mutated_line": "armies[i].q.rotate(-0)",
      "code": "from heapq import heappush, heappop\nfrom collections import deque, namedtuple\nfrom itertools import starmap\nArmy = namedtuple('Army', 'i,q')\nSoldier = namedtuple('Soldier', 'i,speed')\n\ndef queue_battle(distance, *args):\n    armies = [Army(i, deque(starmap(Soldier, enumerate(q)))) for (i, q) in enumerate(args)]\n    bullets = [[] for _ in range(len(armies))]\n    t = 0\n    while len(armies) > 1:\n        t += 1\n        alives = [1] * len(armies)\n        for (i, q) in enumerate(bullets):\n            if q and q[0] <= t:\n                alives[(i + 1) % len(armies)] = 0\n            while q and q[0] <= t:\n                heappop(q)\n        emptyArmies = False\n        for (i, alive) in enumerate(alives):\n            if alive:\n                heappush(bullets[i], t + distance / armies[i].q[0].speed)\n                armies[i].q.rotate(-0)\n            else:\n                armies[i].q.popleft()\n                emptyArmies |= not armies[i].q\n        if emptyArmies:\n            armies = [army for army in armies if army.q]\n            bullets = [[] for _ in range(len(armies))]\n    if not armies:\n        return (-1, ())\n    win = armies.pop()\n    return (win.i, tuple((soldier.i for soldier in win.q)))"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "armies[i].q.rotate(-1)",
      "mutated_line": "armies[i].q.rotate(--1)",
      "code": "from heapq import heappush, heappop\nfrom collections import deque, namedtuple\nfrom itertools import starmap\nArmy = namedtuple('Army', 'i,q')\nSoldier = namedtuple('Soldier', 'i,speed')\n\ndef queue_battle(distance, *args):\n    armies = [Army(i, deque(starmap(Soldier, enumerate(q)))) for (i, q) in enumerate(args)]\n    bullets = [[] for _ in range(len(armies))]\n    t = 0\n    while len(armies) > 1:\n        t += 1\n        alives = [1] * len(armies)\n        for (i, q) in enumerate(bullets):\n            if q and q[0] <= t:\n                alives[(i + 1) % len(armies)] = 0\n            while q and q[0] <= t:\n                heappop(q)\n        emptyArmies = False\n        for (i, alive) in enumerate(alives):\n            if alive:\n                heappush(bullets[i], t + distance / armies[i].q[0].speed)\n                armies[i].q.rotate(--1)\n            else:\n                armies[i].q.popleft()\n                emptyArmies |= not armies[i].q\n        if emptyArmies:\n            armies = [army for army in armies if army.q]\n            bullets = [[] for _ in range(len(armies))]\n    if not armies:\n        return (-1, ())\n    win = armies.pop()\n    return (win.i, tuple((soldier.i for soldier in win.q)))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "alives[(i + 1) % len(armies)] = 0",
      "mutated_line": "alives[(i + 2) % len(armies)] = 0",
      "code": "from heapq import heappush, heappop\nfrom collections import deque, namedtuple\nfrom itertools import starmap\nArmy = namedtuple('Army', 'i,q')\nSoldier = namedtuple('Soldier', 'i,speed')\n\ndef queue_battle(distance, *args):\n    armies = [Army(i, deque(starmap(Soldier, enumerate(q)))) for (i, q) in enumerate(args)]\n    bullets = [[] for _ in range(len(armies))]\n    t = 0\n    while len(armies) > 1:\n        t += 1\n        alives = [1] * len(armies)\n        for (i, q) in enumerate(bullets):\n            if q and q[0] <= t:\n                alives[(i + 2) % len(armies)] = 0\n            while q and q[0] <= t:\n                heappop(q)\n        emptyArmies = False\n        for (i, alive) in enumerate(alives):\n            if alive:\n                heappush(bullets[i], t + distance / armies[i].q[0].speed)\n                armies[i].q.rotate(-1)\n            else:\n                armies[i].q.popleft()\n                emptyArmies |= not armies[i].q\n        if emptyArmies:\n            armies = [army for army in armies if army.q]\n            bullets = [[] for _ in range(len(armies))]\n    if not armies:\n        return (-1, ())\n    win = armies.pop()\n    return (win.i, tuple((soldier.i for soldier in win.q)))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "alives[(i + 1) % len(armies)] = 0",
      "mutated_line": "alives[(i + 0) % len(armies)] = 0",
      "code": "from heapq import heappush, heappop\nfrom collections import deque, namedtuple\nfrom itertools import starmap\nArmy = namedtuple('Army', 'i,q')\nSoldier = namedtuple('Soldier', 'i,speed')\n\ndef queue_battle(distance, *args):\n    armies = [Army(i, deque(starmap(Soldier, enumerate(q)))) for (i, q) in enumerate(args)]\n    bullets = [[] for _ in range(len(armies))]\n    t = 0\n    while len(armies) > 1:\n        t += 1\n        alives = [1] * len(armies)\n        for (i, q) in enumerate(bullets):\n            if q and q[0] <= t:\n                alives[(i + 0) % len(armies)] = 0\n            while q and q[0] <= t:\n                heappop(q)\n        emptyArmies = False\n        for (i, alive) in enumerate(alives):\n            if alive:\n                heappush(bullets[i], t + distance / armies[i].q[0].speed)\n                armies[i].q.rotate(-1)\n            else:\n                armies[i].q.popleft()\n                emptyArmies |= not armies[i].q\n        if emptyArmies:\n            armies = [army for army in armies if army.q]\n            bullets = [[] for _ in range(len(armies))]\n    if not armies:\n        return (-1, ())\n    win = armies.pop()\n    return (win.i, tuple((soldier.i for soldier in win.q)))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "alives[(i + 1) % len(armies)] = 0",
      "mutated_line": "alives[(i + 0) % len(armies)] = 0",
      "code": "from heapq import heappush, heappop\nfrom collections import deque, namedtuple\nfrom itertools import starmap\nArmy = namedtuple('Army', 'i,q')\nSoldier = namedtuple('Soldier', 'i,speed')\n\ndef queue_battle(distance, *args):\n    armies = [Army(i, deque(starmap(Soldier, enumerate(q)))) for (i, q) in enumerate(args)]\n    bullets = [[] for _ in range(len(armies))]\n    t = 0\n    while len(armies) > 1:\n        t += 1\n        alives = [1] * len(armies)\n        for (i, q) in enumerate(bullets):\n            if q and q[0] <= t:\n                alives[(i + 0) % len(armies)] = 0\n            while q and q[0] <= t:\n                heappop(q)\n        emptyArmies = False\n        for (i, alive) in enumerate(alives):\n            if alive:\n                heappush(bullets[i], t + distance / armies[i].q[0].speed)\n                armies[i].q.rotate(-1)\n            else:\n                armies[i].q.popleft()\n                emptyArmies |= not armies[i].q\n        if emptyArmies:\n            armies = [army for army in armies if army.q]\n            bullets = [[] for _ in range(len(armies))]\n    if not armies:\n        return (-1, ())\n    win = armies.pop()\n    return (win.i, tuple((soldier.i for soldier in win.q)))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "alives[(i + 1) % len(armies)] = 0",
      "mutated_line": "alives[(i + -1) % len(armies)] = 0",
      "code": "from heapq import heappush, heappop\nfrom collections import deque, namedtuple\nfrom itertools import starmap\nArmy = namedtuple('Army', 'i,q')\nSoldier = namedtuple('Soldier', 'i,speed')\n\ndef queue_battle(distance, *args):\n    armies = [Army(i, deque(starmap(Soldier, enumerate(q)))) for (i, q) in enumerate(args)]\n    bullets = [[] for _ in range(len(armies))]\n    t = 0\n    while len(armies) > 1:\n        t += 1\n        alives = [1] * len(armies)\n        for (i, q) in enumerate(bullets):\n            if q and q[0] <= t:\n                alives[(i + -1) % len(armies)] = 0\n            while q and q[0] <= t:\n                heappop(q)\n        emptyArmies = False\n        for (i, alive) in enumerate(alives):\n            if alive:\n                heappush(bullets[i], t + distance / armies[i].q[0].speed)\n                armies[i].q.rotate(-1)\n            else:\n                armies[i].q.popleft()\n                emptyArmies |= not armies[i].q\n        if emptyArmies:\n            armies = [army for army in armies if army.q]\n            bullets = [[] for _ in range(len(armies))]\n    if not armies:\n        return (-1, ())\n    win = armies.pop()\n    return (win.i, tuple((soldier.i for soldier in win.q)))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "heappush(bullets[i], t + distance / armies[i].q[0].speed)",
      "mutated_line": "heappush(bullets[i], t + distance / armies[i].q[1].speed)",
      "code": "from heapq import heappush, heappop\nfrom collections import deque, namedtuple\nfrom itertools import starmap\nArmy = namedtuple('Army', 'i,q')\nSoldier = namedtuple('Soldier', 'i,speed')\n\ndef queue_battle(distance, *args):\n    armies = [Army(i, deque(starmap(Soldier, enumerate(q)))) for (i, q) in enumerate(args)]\n    bullets = [[] for _ in range(len(armies))]\n    t = 0\n    while len(armies) > 1:\n        t += 1\n        alives = [1] * len(armies)\n        for (i, q) in enumerate(bullets):\n            if q and q[0] <= t:\n                alives[(i + 1) % len(armies)] = 0\n            while q and q[0] <= t:\n                heappop(q)\n        emptyArmies = False\n        for (i, alive) in enumerate(alives):\n            if alive:\n                heappush(bullets[i], t + distance / armies[i].q[1].speed)\n                armies[i].q.rotate(-1)\n            else:\n                armies[i].q.popleft()\n                emptyArmies |= not armies[i].q\n        if emptyArmies:\n            armies = [army for army in armies if army.q]\n            bullets = [[] for _ in range(len(armies))]\n    if not armies:\n        return (-1, ())\n    win = armies.pop()\n    return (win.i, tuple((soldier.i for soldier in win.q)))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "heappush(bullets[i], t + distance / armies[i].q[0].speed)",
      "mutated_line": "heappush(bullets[i], t + distance / armies[i].q[-1].speed)",
      "code": "from heapq import heappush, heappop\nfrom collections import deque, namedtuple\nfrom itertools import starmap\nArmy = namedtuple('Army', 'i,q')\nSoldier = namedtuple('Soldier', 'i,speed')\n\ndef queue_battle(distance, *args):\n    armies = [Army(i, deque(starmap(Soldier, enumerate(q)))) for (i, q) in enumerate(args)]\n    bullets = [[] for _ in range(len(armies))]\n    t = 0\n    while len(armies) > 1:\n        t += 1\n        alives = [1] * len(armies)\n        for (i, q) in enumerate(bullets):\n            if q and q[0] <= t:\n                alives[(i + 1) % len(armies)] = 0\n            while q and q[0] <= t:\n                heappop(q)\n        emptyArmies = False\n        for (i, alive) in enumerate(alives):\n            if alive:\n                heappush(bullets[i], t + distance / armies[i].q[-1].speed)\n                armies[i].q.rotate(-1)\n            else:\n                armies[i].q.popleft()\n                emptyArmies |= not armies[i].q\n        if emptyArmies:\n            armies = [army for army in armies if army.q]\n            bullets = [[] for _ in range(len(armies))]\n    if not armies:\n        return (-1, ())\n    win = armies.pop()\n    return (win.i, tuple((soldier.i for soldier in win.q)))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "heappush(bullets[i], t + distance / armies[i].q[0].speed)",
      "mutated_line": "heappush(bullets[i], t + distance / armies[i].q[1].speed)",
      "code": "from heapq import heappush, heappop\nfrom collections import deque, namedtuple\nfrom itertools import starmap\nArmy = namedtuple('Army', 'i,q')\nSoldier = namedtuple('Soldier', 'i,speed')\n\ndef queue_battle(distance, *args):\n    armies = [Army(i, deque(starmap(Soldier, enumerate(q)))) for (i, q) in enumerate(args)]\n    bullets = [[] for _ in range(len(armies))]\n    t = 0\n    while len(armies) > 1:\n        t += 1\n        alives = [1] * len(armies)\n        for (i, q) in enumerate(bullets):\n            if q and q[0] <= t:\n                alives[(i + 1) % len(armies)] = 0\n            while q and q[0] <= t:\n                heappop(q)\n        emptyArmies = False\n        for (i, alive) in enumerate(alives):\n            if alive:\n                heappush(bullets[i], t + distance / armies[i].q[1].speed)\n                armies[i].q.rotate(-1)\n            else:\n                armies[i].q.popleft()\n                emptyArmies |= not armies[i].q\n        if emptyArmies:\n            armies = [army for army in armies if army.q]\n            bullets = [[] for _ in range(len(armies))]\n    if not armies:\n        return (-1, ())\n    win = armies.pop()\n    return (win.i, tuple((soldier.i for soldier in win.q)))"
    }
  ]
}