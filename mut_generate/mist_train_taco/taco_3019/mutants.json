{
  "task_id": "taco_3019",
  "entry_point": "is_semi_fibonacci_string",
  "mutant_count": 53,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def is_semi_fibonacci_string(nums: list[int]) -> bool:\n    \"\"\"\"\"\"\n    import heapq\n    FIBS = []\n    CUMSUMS = []\n    a = 0\n    b = 1\n    cumsum = 0\n    while cumsum < 10 ** 12:\n        FIBS.append(b)\n        cumsum += b\n        CUMSUMS.append(cumsum)\n        (a, b) = (b, a + b)\n    s = sum(nums)\n    if s not in CUMSUMS:\n        return False\n    nums = [-n for n in nums]\n    heapq.heapify(nums)\n    not_use = 0\n    for ind in range(CUMSUMS.index(s), -1, -1):\n        f = FIBS[ind]\n        max_num = -heapq.heappop(nums)\n        if f > max_num:\n            return False\n        max_num -= f\n        heapq.heappush(nums, -not_use)\n        not_use = max_num\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "a = 0",
      "mutated_line": "a = 1",
      "code": "def is_semi_fibonacci_string(nums: list[int]) -> bool:\n    \"\"\"\n    Determines if a string represented by the counts of its letters is semi-Fibonacci.\n\n    Args:\n        nums (list[int]): A list of integers where each integer represents the count of a specific letter in the string.\n\n    Returns:\n        bool: True if the string is semi-Fibonacci, False otherwise.\n    \"\"\"\n    import heapq\n    FIBS = []\n    CUMSUMS = []\n    a = 1\n    b = 1\n    cumsum = 0\n    while cumsum < 10 ** 12:\n        FIBS.append(b)\n        cumsum += b\n        CUMSUMS.append(cumsum)\n        (a, b) = (b, a + b)\n    s = sum(nums)\n    if s not in CUMSUMS:\n        return False\n    nums = [-n for n in nums]\n    heapq.heapify(nums)\n    not_use = 0\n    for ind in range(CUMSUMS.index(s), -1, -1):\n        f = FIBS[ind]\n        max_num = -heapq.heappop(nums)\n        if f > max_num:\n            return False\n        max_num -= f\n        heapq.heappush(nums, -not_use)\n        not_use = max_num\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "a = 0",
      "mutated_line": "a = -1",
      "code": "def is_semi_fibonacci_string(nums: list[int]) -> bool:\n    \"\"\"\n    Determines if a string represented by the counts of its letters is semi-Fibonacci.\n\n    Args:\n        nums (list[int]): A list of integers where each integer represents the count of a specific letter in the string.\n\n    Returns:\n        bool: True if the string is semi-Fibonacci, False otherwise.\n    \"\"\"\n    import heapq\n    FIBS = []\n    CUMSUMS = []\n    a = -1\n    b = 1\n    cumsum = 0\n    while cumsum < 10 ** 12:\n        FIBS.append(b)\n        cumsum += b\n        CUMSUMS.append(cumsum)\n        (a, b) = (b, a + b)\n    s = sum(nums)\n    if s not in CUMSUMS:\n        return False\n    nums = [-n for n in nums]\n    heapq.heapify(nums)\n    not_use = 0\n    for ind in range(CUMSUMS.index(s), -1, -1):\n        f = FIBS[ind]\n        max_num = -heapq.heappop(nums)\n        if f > max_num:\n            return False\n        max_num -= f\n        heapq.heappush(nums, -not_use)\n        not_use = max_num\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "a = 0",
      "mutated_line": "a = 1",
      "code": "def is_semi_fibonacci_string(nums: list[int]) -> bool:\n    \"\"\"\n    Determines if a string represented by the counts of its letters is semi-Fibonacci.\n\n    Args:\n        nums (list[int]): A list of integers where each integer represents the count of a specific letter in the string.\n\n    Returns:\n        bool: True if the string is semi-Fibonacci, False otherwise.\n    \"\"\"\n    import heapq\n    FIBS = []\n    CUMSUMS = []\n    a = 1\n    b = 1\n    cumsum = 0\n    while cumsum < 10 ** 12:\n        FIBS.append(b)\n        cumsum += b\n        CUMSUMS.append(cumsum)\n        (a, b) = (b, a + b)\n    s = sum(nums)\n    if s not in CUMSUMS:\n        return False\n    nums = [-n for n in nums]\n    heapq.heapify(nums)\n    not_use = 0\n    for ind in range(CUMSUMS.index(s), -1, -1):\n        f = FIBS[ind]\n        max_num = -heapq.heappop(nums)\n        if f > max_num:\n            return False\n        max_num -= f\n        heapq.heappush(nums, -not_use)\n        not_use = max_num\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "b = 1",
      "mutated_line": "b = 2",
      "code": "def is_semi_fibonacci_string(nums: list[int]) -> bool:\n    \"\"\"\n    Determines if a string represented by the counts of its letters is semi-Fibonacci.\n\n    Args:\n        nums (list[int]): A list of integers where each integer represents the count of a specific letter in the string.\n\n    Returns:\n        bool: True if the string is semi-Fibonacci, False otherwise.\n    \"\"\"\n    import heapq\n    FIBS = []\n    CUMSUMS = []\n    a = 0\n    b = 2\n    cumsum = 0\n    while cumsum < 10 ** 12:\n        FIBS.append(b)\n        cumsum += b\n        CUMSUMS.append(cumsum)\n        (a, b) = (b, a + b)\n    s = sum(nums)\n    if s not in CUMSUMS:\n        return False\n    nums = [-n for n in nums]\n    heapq.heapify(nums)\n    not_use = 0\n    for ind in range(CUMSUMS.index(s), -1, -1):\n        f = FIBS[ind]\n        max_num = -heapq.heappop(nums)\n        if f > max_num:\n            return False\n        max_num -= f\n        heapq.heappush(nums, -not_use)\n        not_use = max_num\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "b = 1",
      "mutated_line": "b = 0",
      "code": "def is_semi_fibonacci_string(nums: list[int]) -> bool:\n    \"\"\"\n    Determines if a string represented by the counts of its letters is semi-Fibonacci.\n\n    Args:\n        nums (list[int]): A list of integers where each integer represents the count of a specific letter in the string.\n\n    Returns:\n        bool: True if the string is semi-Fibonacci, False otherwise.\n    \"\"\"\n    import heapq\n    FIBS = []\n    CUMSUMS = []\n    a = 0\n    b = 0\n    cumsum = 0\n    while cumsum < 10 ** 12:\n        FIBS.append(b)\n        cumsum += b\n        CUMSUMS.append(cumsum)\n        (a, b) = (b, a + b)\n    s = sum(nums)\n    if s not in CUMSUMS:\n        return False\n    nums = [-n for n in nums]\n    heapq.heapify(nums)\n    not_use = 0\n    for ind in range(CUMSUMS.index(s), -1, -1):\n        f = FIBS[ind]\n        max_num = -heapq.heappop(nums)\n        if f > max_num:\n            return False\n        max_num -= f\n        heapq.heappush(nums, -not_use)\n        not_use = max_num\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "b = 1",
      "mutated_line": "b = 0",
      "code": "def is_semi_fibonacci_string(nums: list[int]) -> bool:\n    \"\"\"\n    Determines if a string represented by the counts of its letters is semi-Fibonacci.\n\n    Args:\n        nums (list[int]): A list of integers where each integer represents the count of a specific letter in the string.\n\n    Returns:\n        bool: True if the string is semi-Fibonacci, False otherwise.\n    \"\"\"\n    import heapq\n    FIBS = []\n    CUMSUMS = []\n    a = 0\n    b = 0\n    cumsum = 0\n    while cumsum < 10 ** 12:\n        FIBS.append(b)\n        cumsum += b\n        CUMSUMS.append(cumsum)\n        (a, b) = (b, a + b)\n    s = sum(nums)\n    if s not in CUMSUMS:\n        return False\n    nums = [-n for n in nums]\n    heapq.heapify(nums)\n    not_use = 0\n    for ind in range(CUMSUMS.index(s), -1, -1):\n        f = FIBS[ind]\n        max_num = -heapq.heappop(nums)\n        if f > max_num:\n            return False\n        max_num -= f\n        heapq.heappush(nums, -not_use)\n        not_use = max_num\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "b = 1",
      "mutated_line": "b = -1",
      "code": "def is_semi_fibonacci_string(nums: list[int]) -> bool:\n    \"\"\"\n    Determines if a string represented by the counts of its letters is semi-Fibonacci.\n\n    Args:\n        nums (list[int]): A list of integers where each integer represents the count of a specific letter in the string.\n\n    Returns:\n        bool: True if the string is semi-Fibonacci, False otherwise.\n    \"\"\"\n    import heapq\n    FIBS = []\n    CUMSUMS = []\n    a = 0\n    b = -1\n    cumsum = 0\n    while cumsum < 10 ** 12:\n        FIBS.append(b)\n        cumsum += b\n        CUMSUMS.append(cumsum)\n        (a, b) = (b, a + b)\n    s = sum(nums)\n    if s not in CUMSUMS:\n        return False\n    nums = [-n for n in nums]\n    heapq.heapify(nums)\n    not_use = 0\n    for ind in range(CUMSUMS.index(s), -1, -1):\n        f = FIBS[ind]\n        max_num = -heapq.heappop(nums)\n        if f > max_num:\n            return False\n        max_num -= f\n        heapq.heappush(nums, -not_use)\n        not_use = max_num\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "cumsum = 0",
      "mutated_line": "cumsum = 1",
      "code": "def is_semi_fibonacci_string(nums: list[int]) -> bool:\n    \"\"\"\n    Determines if a string represented by the counts of its letters is semi-Fibonacci.\n\n    Args:\n        nums (list[int]): A list of integers where each integer represents the count of a specific letter in the string.\n\n    Returns:\n        bool: True if the string is semi-Fibonacci, False otherwise.\n    \"\"\"\n    import heapq\n    FIBS = []\n    CUMSUMS = []\n    a = 0\n    b = 1\n    cumsum = 1\n    while cumsum < 10 ** 12:\n        FIBS.append(b)\n        cumsum += b\n        CUMSUMS.append(cumsum)\n        (a, b) = (b, a + b)\n    s = sum(nums)\n    if s not in CUMSUMS:\n        return False\n    nums = [-n for n in nums]\n    heapq.heapify(nums)\n    not_use = 0\n    for ind in range(CUMSUMS.index(s), -1, -1):\n        f = FIBS[ind]\n        max_num = -heapq.heappop(nums)\n        if f > max_num:\n            return False\n        max_num -= f\n        heapq.heappush(nums, -not_use)\n        not_use = max_num\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "cumsum = 0",
      "mutated_line": "cumsum = -1",
      "code": "def is_semi_fibonacci_string(nums: list[int]) -> bool:\n    \"\"\"\n    Determines if a string represented by the counts of its letters is semi-Fibonacci.\n\n    Args:\n        nums (list[int]): A list of integers where each integer represents the count of a specific letter in the string.\n\n    Returns:\n        bool: True if the string is semi-Fibonacci, False otherwise.\n    \"\"\"\n    import heapq\n    FIBS = []\n    CUMSUMS = []\n    a = 0\n    b = 1\n    cumsum = -1\n    while cumsum < 10 ** 12:\n        FIBS.append(b)\n        cumsum += b\n        CUMSUMS.append(cumsum)\n        (a, b) = (b, a + b)\n    s = sum(nums)\n    if s not in CUMSUMS:\n        return False\n    nums = [-n for n in nums]\n    heapq.heapify(nums)\n    not_use = 0\n    for ind in range(CUMSUMS.index(s), -1, -1):\n        f = FIBS[ind]\n        max_num = -heapq.heappop(nums)\n        if f > max_num:\n            return False\n        max_num -= f\n        heapq.heappush(nums, -not_use)\n        not_use = max_num\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "cumsum = 0",
      "mutated_line": "cumsum = 1",
      "code": "def is_semi_fibonacci_string(nums: list[int]) -> bool:\n    \"\"\"\n    Determines if a string represented by the counts of its letters is semi-Fibonacci.\n\n    Args:\n        nums (list[int]): A list of integers where each integer represents the count of a specific letter in the string.\n\n    Returns:\n        bool: True if the string is semi-Fibonacci, False otherwise.\n    \"\"\"\n    import heapq\n    FIBS = []\n    CUMSUMS = []\n    a = 0\n    b = 1\n    cumsum = 1\n    while cumsum < 10 ** 12:\n        FIBS.append(b)\n        cumsum += b\n        CUMSUMS.append(cumsum)\n        (a, b) = (b, a + b)\n    s = sum(nums)\n    if s not in CUMSUMS:\n        return False\n    nums = [-n for n in nums]\n    heapq.heapify(nums)\n    not_use = 0\n    for ind in range(CUMSUMS.index(s), -1, -1):\n        f = FIBS[ind]\n        max_num = -heapq.heappop(nums)\n        if f > max_num:\n            return False\n        max_num -= f\n        heapq.heappush(nums, -not_use)\n        not_use = max_num\n    return True"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "while cumsum < 10 ** 12:",
      "mutated_line": "while cumsum <= 10 ** 12:",
      "code": "def is_semi_fibonacci_string(nums: list[int]) -> bool:\n    \"\"\"\n    Determines if a string represented by the counts of its letters is semi-Fibonacci.\n\n    Args:\n        nums (list[int]): A list of integers where each integer represents the count of a specific letter in the string.\n\n    Returns:\n        bool: True if the string is semi-Fibonacci, False otherwise.\n    \"\"\"\n    import heapq\n    FIBS = []\n    CUMSUMS = []\n    a = 0\n    b = 1\n    cumsum = 0\n    while cumsum <= 10 ** 12:\n        FIBS.append(b)\n        cumsum += b\n        CUMSUMS.append(cumsum)\n        (a, b) = (b, a + b)\n    s = sum(nums)\n    if s not in CUMSUMS:\n        return False\n    nums = [-n for n in nums]\n    heapq.heapify(nums)\n    not_use = 0\n    for ind in range(CUMSUMS.index(s), -1, -1):\n        f = FIBS[ind]\n        max_num = -heapq.heappop(nums)\n        if f > max_num:\n            return False\n        max_num -= f\n        heapq.heappush(nums, -not_use)\n        not_use = max_num\n    return True"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "while cumsum < 10 ** 12:",
      "mutated_line": "while cumsum >= 10 ** 12:",
      "code": "def is_semi_fibonacci_string(nums: list[int]) -> bool:\n    \"\"\"\n    Determines if a string represented by the counts of its letters is semi-Fibonacci.\n\n    Args:\n        nums (list[int]): A list of integers where each integer represents the count of a specific letter in the string.\n\n    Returns:\n        bool: True if the string is semi-Fibonacci, False otherwise.\n    \"\"\"\n    import heapq\n    FIBS = []\n    CUMSUMS = []\n    a = 0\n    b = 1\n    cumsum = 0\n    while cumsum >= 10 ** 12:\n        FIBS.append(b)\n        cumsum += b\n        CUMSUMS.append(cumsum)\n        (a, b) = (b, a + b)\n    s = sum(nums)\n    if s not in CUMSUMS:\n        return False\n    nums = [-n for n in nums]\n    heapq.heapify(nums)\n    not_use = 0\n    for ind in range(CUMSUMS.index(s), -1, -1):\n        f = FIBS[ind]\n        max_num = -heapq.heappop(nums)\n        if f > max_num:\n            return False\n        max_num -= f\n        heapq.heappush(nums, -not_use)\n        not_use = max_num\n    return True"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "while cumsum < 10 ** 12:",
      "mutated_line": "while cumsum != 10 ** 12:",
      "code": "def is_semi_fibonacci_string(nums: list[int]) -> bool:\n    \"\"\"\n    Determines if a string represented by the counts of its letters is semi-Fibonacci.\n\n    Args:\n        nums (list[int]): A list of integers where each integer represents the count of a specific letter in the string.\n\n    Returns:\n        bool: True if the string is semi-Fibonacci, False otherwise.\n    \"\"\"\n    import heapq\n    FIBS = []\n    CUMSUMS = []\n    a = 0\n    b = 1\n    cumsum = 0\n    while cumsum != 10 ** 12:\n        FIBS.append(b)\n        cumsum += b\n        CUMSUMS.append(cumsum)\n        (a, b) = (b, a + b)\n    s = sum(nums)\n    if s not in CUMSUMS:\n        return False\n    nums = [-n for n in nums]\n    heapq.heapify(nums)\n    not_use = 0\n    for ind in range(CUMSUMS.index(s), -1, -1):\n        f = FIBS[ind]\n        max_num = -heapq.heappop(nums)\n        if f > max_num:\n            return False\n        max_num -= f\n        heapq.heappush(nums, -not_use)\n        not_use = max_num\n    return True"
    },
    {
      "operator": "ASR",
      "lineno": 21,
      "original_line": "cumsum += b",
      "mutated_line": "cumsum -= b",
      "code": "def is_semi_fibonacci_string(nums: list[int]) -> bool:\n    \"\"\"\n    Determines if a string represented by the counts of its letters is semi-Fibonacci.\n\n    Args:\n        nums (list[int]): A list of integers where each integer represents the count of a specific letter in the string.\n\n    Returns:\n        bool: True if the string is semi-Fibonacci, False otherwise.\n    \"\"\"\n    import heapq\n    FIBS = []\n    CUMSUMS = []\n    a = 0\n    b = 1\n    cumsum = 0\n    while cumsum < 10 ** 12:\n        FIBS.append(b)\n        cumsum -= b\n        CUMSUMS.append(cumsum)\n        (a, b) = (b, a + b)\n    s = sum(nums)\n    if s not in CUMSUMS:\n        return False\n    nums = [-n for n in nums]\n    heapq.heapify(nums)\n    not_use = 0\n    for ind in range(CUMSUMS.index(s), -1, -1):\n        f = FIBS[ind]\n        max_num = -heapq.heappop(nums)\n        if f > max_num:\n            return False\n        max_num -= f\n        heapq.heappush(nums, -not_use)\n        not_use = max_num\n    return True"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if s not in CUMSUMS:",
      "mutated_line": "if s in CUMSUMS:",
      "code": "def is_semi_fibonacci_string(nums: list[int]) -> bool:\n    \"\"\"\n    Determines if a string represented by the counts of its letters is semi-Fibonacci.\n\n    Args:\n        nums (list[int]): A list of integers where each integer represents the count of a specific letter in the string.\n\n    Returns:\n        bool: True if the string is semi-Fibonacci, False otherwise.\n    \"\"\"\n    import heapq\n    FIBS = []\n    CUMSUMS = []\n    a = 0\n    b = 1\n    cumsum = 0\n    while cumsum < 10 ** 12:\n        FIBS.append(b)\n        cumsum += b\n        CUMSUMS.append(cumsum)\n        (a, b) = (b, a + b)\n    s = sum(nums)\n    if s in CUMSUMS:\n        return False\n    nums = [-n for n in nums]\n    heapq.heapify(nums)\n    not_use = 0\n    for ind in range(CUMSUMS.index(s), -1, -1):\n        f = FIBS[ind]\n        max_num = -heapq.heappop(nums)\n        if f > max_num:\n            return False\n        max_num -= f\n        heapq.heappush(nums, -not_use)\n        not_use = max_num\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "not_use = 0",
      "mutated_line": "not_use = 1",
      "code": "def is_semi_fibonacci_string(nums: list[int]) -> bool:\n    \"\"\"\n    Determines if a string represented by the counts of its letters is semi-Fibonacci.\n\n    Args:\n        nums (list[int]): A list of integers where each integer represents the count of a specific letter in the string.\n\n    Returns:\n        bool: True if the string is semi-Fibonacci, False otherwise.\n    \"\"\"\n    import heapq\n    FIBS = []\n    CUMSUMS = []\n    a = 0\n    b = 1\n    cumsum = 0\n    while cumsum < 10 ** 12:\n        FIBS.append(b)\n        cumsum += b\n        CUMSUMS.append(cumsum)\n        (a, b) = (b, a + b)\n    s = sum(nums)\n    if s not in CUMSUMS:\n        return False\n    nums = [-n for n in nums]\n    heapq.heapify(nums)\n    not_use = 1\n    for ind in range(CUMSUMS.index(s), -1, -1):\n        f = FIBS[ind]\n        max_num = -heapq.heappop(nums)\n        if f > max_num:\n            return False\n        max_num -= f\n        heapq.heappush(nums, -not_use)\n        not_use = max_num\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "not_use = 0",
      "mutated_line": "not_use = -1",
      "code": "def is_semi_fibonacci_string(nums: list[int]) -> bool:\n    \"\"\"\n    Determines if a string represented by the counts of its letters is semi-Fibonacci.\n\n    Args:\n        nums (list[int]): A list of integers where each integer represents the count of a specific letter in the string.\n\n    Returns:\n        bool: True if the string is semi-Fibonacci, False otherwise.\n    \"\"\"\n    import heapq\n    FIBS = []\n    CUMSUMS = []\n    a = 0\n    b = 1\n    cumsum = 0\n    while cumsum < 10 ** 12:\n        FIBS.append(b)\n        cumsum += b\n        CUMSUMS.append(cumsum)\n        (a, b) = (b, a + b)\n    s = sum(nums)\n    if s not in CUMSUMS:\n        return False\n    nums = [-n for n in nums]\n    heapq.heapify(nums)\n    not_use = -1\n    for ind in range(CUMSUMS.index(s), -1, -1):\n        f = FIBS[ind]\n        max_num = -heapq.heappop(nums)\n        if f > max_num:\n            return False\n        max_num -= f\n        heapq.heappush(nums, -not_use)\n        not_use = max_num\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "not_use = 0",
      "mutated_line": "not_use = 1",
      "code": "def is_semi_fibonacci_string(nums: list[int]) -> bool:\n    \"\"\"\n    Determines if a string represented by the counts of its letters is semi-Fibonacci.\n\n    Args:\n        nums (list[int]): A list of integers where each integer represents the count of a specific letter in the string.\n\n    Returns:\n        bool: True if the string is semi-Fibonacci, False otherwise.\n    \"\"\"\n    import heapq\n    FIBS = []\n    CUMSUMS = []\n    a = 0\n    b = 1\n    cumsum = 0\n    while cumsum < 10 ** 12:\n        FIBS.append(b)\n        cumsum += b\n        CUMSUMS.append(cumsum)\n        (a, b) = (b, a + b)\n    s = sum(nums)\n    if s not in CUMSUMS:\n        return False\n    nums = [-n for n in nums]\n    heapq.heapify(nums)\n    not_use = 1\n    for ind in range(CUMSUMS.index(s), -1, -1):\n        f = FIBS[ind]\n        max_num = -heapq.heappop(nums)\n        if f > max_num:\n            return False\n        max_num -= f\n        heapq.heappush(nums, -not_use)\n        not_use = max_num\n    return True"
    },
    {
      "operator": "ASR",
      "lineno": 43,
      "original_line": "max_num -= f",
      "mutated_line": "max_num += f",
      "code": "def is_semi_fibonacci_string(nums: list[int]) -> bool:\n    \"\"\"\n    Determines if a string represented by the counts of its letters is semi-Fibonacci.\n\n    Args:\n        nums (list[int]): A list of integers where each integer represents the count of a specific letter in the string.\n\n    Returns:\n        bool: True if the string is semi-Fibonacci, False otherwise.\n    \"\"\"\n    import heapq\n    FIBS = []\n    CUMSUMS = []\n    a = 0\n    b = 1\n    cumsum = 0\n    while cumsum < 10 ** 12:\n        FIBS.append(b)\n        cumsum += b\n        CUMSUMS.append(cumsum)\n        (a, b) = (b, a + b)\n    s = sum(nums)\n    if s not in CUMSUMS:\n        return False\n    nums = [-n for n in nums]\n    heapq.heapify(nums)\n    not_use = 0\n    for ind in range(CUMSUMS.index(s), -1, -1):\n        f = FIBS[ind]\n        max_num = -heapq.heappop(nums)\n        if f > max_num:\n            return False\n        max_num += f\n        heapq.heappush(nums, -not_use)\n        not_use = max_num\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def is_semi_fibonacci_string(nums: list[int]) -> bool:\n    \"\"\"\n    Determines if a string represented by the counts of its letters is semi-Fibonacci.\n\n    Args:\n        nums (list[int]): A list of integers where each integer represents the count of a specific letter in the string.\n\n    Returns:\n        bool: True if the string is semi-Fibonacci, False otherwise.\n    \"\"\"\n    import heapq\n    FIBS = []\n    CUMSUMS = []\n    a = 0\n    b = 1\n    cumsum = 0\n    while cumsum < 10 ** 12:\n        FIBS.append(b)\n        cumsum += b\n        CUMSUMS.append(cumsum)\n        (a, b) = (b, a + b)\n    s = sum(nums)\n    if s not in CUMSUMS:\n        return False\n    nums = [-n for n in nums]\n    heapq.heapify(nums)\n    not_use = 0\n    for ind in range(CUMSUMS.index(s), -1, -1):\n        f = FIBS[ind]\n        max_num = -heapq.heappop(nums)\n        if f > max_num:\n            return False\n        max_num -= f\n        heapq.heappush(nums, -not_use)\n        not_use = max_num\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "while cumsum < 10 ** 12:",
      "mutated_line": "while cumsum < 10 * 12:",
      "code": "def is_semi_fibonacci_string(nums: list[int]) -> bool:\n    \"\"\"\n    Determines if a string represented by the counts of its letters is semi-Fibonacci.\n\n    Args:\n        nums (list[int]): A list of integers where each integer represents the count of a specific letter in the string.\n\n    Returns:\n        bool: True if the string is semi-Fibonacci, False otherwise.\n    \"\"\"\n    import heapq\n    FIBS = []\n    CUMSUMS = []\n    a = 0\n    b = 1\n    cumsum = 0\n    while cumsum < 10 * 12:\n        FIBS.append(b)\n        cumsum += b\n        CUMSUMS.append(cumsum)\n        (a, b) = (b, a + b)\n    s = sum(nums)\n    if s not in CUMSUMS:\n        return False\n    nums = [-n for n in nums]\n    heapq.heapify(nums)\n    not_use = 0\n    for ind in range(CUMSUMS.index(s), -1, -1):\n        f = FIBS[ind]\n        max_num = -heapq.heappop(nums)\n        if f > max_num:\n            return False\n        max_num -= f\n        heapq.heappush(nums, -not_use)\n        not_use = max_num\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "while cumsum < 10 ** 12:",
      "mutated_line": "while cumsum < 10 + 12:",
      "code": "def is_semi_fibonacci_string(nums: list[int]) -> bool:\n    \"\"\"\n    Determines if a string represented by the counts of its letters is semi-Fibonacci.\n\n    Args:\n        nums (list[int]): A list of integers where each integer represents the count of a specific letter in the string.\n\n    Returns:\n        bool: True if the string is semi-Fibonacci, False otherwise.\n    \"\"\"\n    import heapq\n    FIBS = []\n    CUMSUMS = []\n    a = 0\n    b = 1\n    cumsum = 0\n    while cumsum < 10 + 12:\n        FIBS.append(b)\n        cumsum += b\n        CUMSUMS.append(cumsum)\n        (a, b) = (b, a + b)\n    s = sum(nums)\n    if s not in CUMSUMS:\n        return False\n    nums = [-n for n in nums]\n    heapq.heapify(nums)\n    not_use = 0\n    for ind in range(CUMSUMS.index(s), -1, -1):\n        f = FIBS[ind]\n        max_num = -heapq.heappop(nums)\n        if f > max_num:\n            return False\n        max_num -= f\n        heapq.heappush(nums, -not_use)\n        not_use = max_num\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def is_semi_fibonacci_string(nums: list[int]) -> bool:\n    \"\"\"\n    Determines if a string represented by the counts of its letters is semi-Fibonacci.\n\n    Args:\n        nums (list[int]): A list of integers where each integer represents the count of a specific letter in the string.\n\n    Returns:\n        bool: True if the string is semi-Fibonacci, False otherwise.\n    \"\"\"\n    import heapq\n    FIBS = []\n    CUMSUMS = []\n    a = 0\n    b = 1\n    cumsum = 0\n    while cumsum < 10 ** 12:\n        FIBS.append(b)\n        cumsum += b\n        CUMSUMS.append(cumsum)\n        (a, b) = (b, a + b)\n    s = sum(nums)\n    if s not in CUMSUMS:\n        return True\n    nums = [-n for n in nums]\n    heapq.heapify(nums)\n    not_use = 0\n    for ind in range(CUMSUMS.index(s), -1, -1):\n        f = FIBS[ind]\n        max_num = -heapq.heappop(nums)\n        if f > max_num:\n            return False\n        max_num -= f\n        heapq.heappush(nums, -not_use)\n        not_use = max_num\n    return True"
    },
    {
      "operator": "UOI",
      "lineno": 33,
      "original_line": "nums = [-n for n in nums]",
      "mutated_line": "nums = [+n for n in nums]",
      "code": "def is_semi_fibonacci_string(nums: list[int]) -> bool:\n    \"\"\"\n    Determines if a string represented by the counts of its letters is semi-Fibonacci.\n\n    Args:\n        nums (list[int]): A list of integers where each integer represents the count of a specific letter in the string.\n\n    Returns:\n        bool: True if the string is semi-Fibonacci, False otherwise.\n    \"\"\"\n    import heapq\n    FIBS = []\n    CUMSUMS = []\n    a = 0\n    b = 1\n    cumsum = 0\n    while cumsum < 10 ** 12:\n        FIBS.append(b)\n        cumsum += b\n        CUMSUMS.append(cumsum)\n        (a, b) = (b, a + b)\n    s = sum(nums)\n    if s not in CUMSUMS:\n        return False\n    nums = [+n for n in nums]\n    heapq.heapify(nums)\n    not_use = 0\n    for ind in range(CUMSUMS.index(s), -1, -1):\n        f = FIBS[ind]\n        max_num = -heapq.heappop(nums)\n        if f > max_num:\n            return False\n        max_num -= f\n        heapq.heappush(nums, -not_use)\n        not_use = max_num\n    return True"
    },
    {
      "operator": "UOI",
      "lineno": 38,
      "original_line": "for ind in range(CUMSUMS.index(s), -1, -1):",
      "mutated_line": "for ind in range(CUMSUMS.index(s), +1, -1):",
      "code": "def is_semi_fibonacci_string(nums: list[int]) -> bool:\n    \"\"\"\n    Determines if a string represented by the counts of its letters is semi-Fibonacci.\n\n    Args:\n        nums (list[int]): A list of integers where each integer represents the count of a specific letter in the string.\n\n    Returns:\n        bool: True if the string is semi-Fibonacci, False otherwise.\n    \"\"\"\n    import heapq\n    FIBS = []\n    CUMSUMS = []\n    a = 0\n    b = 1\n    cumsum = 0\n    while cumsum < 10 ** 12:\n        FIBS.append(b)\n        cumsum += b\n        CUMSUMS.append(cumsum)\n        (a, b) = (b, a + b)\n    s = sum(nums)\n    if s not in CUMSUMS:\n        return False\n    nums = [-n for n in nums]\n    heapq.heapify(nums)\n    not_use = 0\n    for ind in range(CUMSUMS.index(s), +1, -1):\n        f = FIBS[ind]\n        max_num = -heapq.heappop(nums)\n        if f > max_num:\n            return False\n        max_num -= f\n        heapq.heappush(nums, -not_use)\n        not_use = max_num\n    return True"
    },
    {
      "operator": "UOI",
      "lineno": 38,
      "original_line": "for ind in range(CUMSUMS.index(s), -1, -1):",
      "mutated_line": "for ind in range(CUMSUMS.index(s), -1, +1):",
      "code": "def is_semi_fibonacci_string(nums: list[int]) -> bool:\n    \"\"\"\n    Determines if a string represented by the counts of its letters is semi-Fibonacci.\n\n    Args:\n        nums (list[int]): A list of integers where each integer represents the count of a specific letter in the string.\n\n    Returns:\n        bool: True if the string is semi-Fibonacci, False otherwise.\n    \"\"\"\n    import heapq\n    FIBS = []\n    CUMSUMS = []\n    a = 0\n    b = 1\n    cumsum = 0\n    while cumsum < 10 ** 12:\n        FIBS.append(b)\n        cumsum += b\n        CUMSUMS.append(cumsum)\n        (a, b) = (b, a + b)\n    s = sum(nums)\n    if s not in CUMSUMS:\n        return False\n    nums = [-n for n in nums]\n    heapq.heapify(nums)\n    not_use = 0\n    for ind in range(CUMSUMS.index(s), -1, +1):\n        f = FIBS[ind]\n        max_num = -heapq.heappop(nums)\n        if f > max_num:\n            return False\n        max_num -= f\n        heapq.heappush(nums, -not_use)\n        not_use = max_num\n    return True"
    },
    {
      "operator": "UOI",
      "lineno": 40,
      "original_line": "max_num = -heapq.heappop(nums)",
      "mutated_line": "max_num = +heapq.heappop(nums)",
      "code": "def is_semi_fibonacci_string(nums: list[int]) -> bool:\n    \"\"\"\n    Determines if a string represented by the counts of its letters is semi-Fibonacci.\n\n    Args:\n        nums (list[int]): A list of integers where each integer represents the count of a specific letter in the string.\n\n    Returns:\n        bool: True if the string is semi-Fibonacci, False otherwise.\n    \"\"\"\n    import heapq\n    FIBS = []\n    CUMSUMS = []\n    a = 0\n    b = 1\n    cumsum = 0\n    while cumsum < 10 ** 12:\n        FIBS.append(b)\n        cumsum += b\n        CUMSUMS.append(cumsum)\n        (a, b) = (b, a + b)\n    s = sum(nums)\n    if s not in CUMSUMS:\n        return False\n    nums = [-n for n in nums]\n    heapq.heapify(nums)\n    not_use = 0\n    for ind in range(CUMSUMS.index(s), -1, -1):\n        f = FIBS[ind]\n        max_num = +heapq.heappop(nums)\n        if f > max_num:\n            return False\n        max_num -= f\n        heapq.heappush(nums, -not_use)\n        not_use = max_num\n    return True"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if f > max_num:",
      "mutated_line": "if f >= max_num:",
      "code": "def is_semi_fibonacci_string(nums: list[int]) -> bool:\n    \"\"\"\n    Determines if a string represented by the counts of its letters is semi-Fibonacci.\n\n    Args:\n        nums (list[int]): A list of integers where each integer represents the count of a specific letter in the string.\n\n    Returns:\n        bool: True if the string is semi-Fibonacci, False otherwise.\n    \"\"\"\n    import heapq\n    FIBS = []\n    CUMSUMS = []\n    a = 0\n    b = 1\n    cumsum = 0\n    while cumsum < 10 ** 12:\n        FIBS.append(b)\n        cumsum += b\n        CUMSUMS.append(cumsum)\n        (a, b) = (b, a + b)\n    s = sum(nums)\n    if s not in CUMSUMS:\n        return False\n    nums = [-n for n in nums]\n    heapq.heapify(nums)\n    not_use = 0\n    for ind in range(CUMSUMS.index(s), -1, -1):\n        f = FIBS[ind]\n        max_num = -heapq.heappop(nums)\n        if f >= max_num:\n            return False\n        max_num -= f\n        heapq.heappush(nums, -not_use)\n        not_use = max_num\n    return True"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if f > max_num:",
      "mutated_line": "if f <= max_num:",
      "code": "def is_semi_fibonacci_string(nums: list[int]) -> bool:\n    \"\"\"\n    Determines if a string represented by the counts of its letters is semi-Fibonacci.\n\n    Args:\n        nums (list[int]): A list of integers where each integer represents the count of a specific letter in the string.\n\n    Returns:\n        bool: True if the string is semi-Fibonacci, False otherwise.\n    \"\"\"\n    import heapq\n    FIBS = []\n    CUMSUMS = []\n    a = 0\n    b = 1\n    cumsum = 0\n    while cumsum < 10 ** 12:\n        FIBS.append(b)\n        cumsum += b\n        CUMSUMS.append(cumsum)\n        (a, b) = (b, a + b)\n    s = sum(nums)\n    if s not in CUMSUMS:\n        return False\n    nums = [-n for n in nums]\n    heapq.heapify(nums)\n    not_use = 0\n    for ind in range(CUMSUMS.index(s), -1, -1):\n        f = FIBS[ind]\n        max_num = -heapq.heappop(nums)\n        if f <= max_num:\n            return False\n        max_num -= f\n        heapq.heappush(nums, -not_use)\n        not_use = max_num\n    return True"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if f > max_num:",
      "mutated_line": "if f != max_num:",
      "code": "def is_semi_fibonacci_string(nums: list[int]) -> bool:\n    \"\"\"\n    Determines if a string represented by the counts of its letters is semi-Fibonacci.\n\n    Args:\n        nums (list[int]): A list of integers where each integer represents the count of a specific letter in the string.\n\n    Returns:\n        bool: True if the string is semi-Fibonacci, False otherwise.\n    \"\"\"\n    import heapq\n    FIBS = []\n    CUMSUMS = []\n    a = 0\n    b = 1\n    cumsum = 0\n    while cumsum < 10 ** 12:\n        FIBS.append(b)\n        cumsum += b\n        CUMSUMS.append(cumsum)\n        (a, b) = (b, a + b)\n    s = sum(nums)\n    if s not in CUMSUMS:\n        return False\n    nums = [-n for n in nums]\n    heapq.heapify(nums)\n    not_use = 0\n    for ind in range(CUMSUMS.index(s), -1, -1):\n        f = FIBS[ind]\n        max_num = -heapq.heappop(nums)\n        if f != max_num:\n            return False\n        max_num -= f\n        heapq.heappush(nums, -not_use)\n        not_use = max_num\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "while cumsum < 10 ** 12:",
      "mutated_line": "while cumsum < 11 ** 12:",
      "code": "def is_semi_fibonacci_string(nums: list[int]) -> bool:\n    \"\"\"\n    Determines if a string represented by the counts of its letters is semi-Fibonacci.\n\n    Args:\n        nums (list[int]): A list of integers where each integer represents the count of a specific letter in the string.\n\n    Returns:\n        bool: True if the string is semi-Fibonacci, False otherwise.\n    \"\"\"\n    import heapq\n    FIBS = []\n    CUMSUMS = []\n    a = 0\n    b = 1\n    cumsum = 0\n    while cumsum < 11 ** 12:\n        FIBS.append(b)\n        cumsum += b\n        CUMSUMS.append(cumsum)\n        (a, b) = (b, a + b)\n    s = sum(nums)\n    if s not in CUMSUMS:\n        return False\n    nums = [-n for n in nums]\n    heapq.heapify(nums)\n    not_use = 0\n    for ind in range(CUMSUMS.index(s), -1, -1):\n        f = FIBS[ind]\n        max_num = -heapq.heappop(nums)\n        if f > max_num:\n            return False\n        max_num -= f\n        heapq.heappush(nums, -not_use)\n        not_use = max_num\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "while cumsum < 10 ** 12:",
      "mutated_line": "while cumsum < 9 ** 12:",
      "code": "def is_semi_fibonacci_string(nums: list[int]) -> bool:\n    \"\"\"\n    Determines if a string represented by the counts of its letters is semi-Fibonacci.\n\n    Args:\n        nums (list[int]): A list of integers where each integer represents the count of a specific letter in the string.\n\n    Returns:\n        bool: True if the string is semi-Fibonacci, False otherwise.\n    \"\"\"\n    import heapq\n    FIBS = []\n    CUMSUMS = []\n    a = 0\n    b = 1\n    cumsum = 0\n    while cumsum < 9 ** 12:\n        FIBS.append(b)\n        cumsum += b\n        CUMSUMS.append(cumsum)\n        (a, b) = (b, a + b)\n    s = sum(nums)\n    if s not in CUMSUMS:\n        return False\n    nums = [-n for n in nums]\n    heapq.heapify(nums)\n    not_use = 0\n    for ind in range(CUMSUMS.index(s), -1, -1):\n        f = FIBS[ind]\n        max_num = -heapq.heappop(nums)\n        if f > max_num:\n            return False\n        max_num -= f\n        heapq.heappush(nums, -not_use)\n        not_use = max_num\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "while cumsum < 10 ** 12:",
      "mutated_line": "while cumsum < 0 ** 12:",
      "code": "def is_semi_fibonacci_string(nums: list[int]) -> bool:\n    \"\"\"\n    Determines if a string represented by the counts of its letters is semi-Fibonacci.\n\n    Args:\n        nums (list[int]): A list of integers where each integer represents the count of a specific letter in the string.\n\n    Returns:\n        bool: True if the string is semi-Fibonacci, False otherwise.\n    \"\"\"\n    import heapq\n    FIBS = []\n    CUMSUMS = []\n    a = 0\n    b = 1\n    cumsum = 0\n    while cumsum < 0 ** 12:\n        FIBS.append(b)\n        cumsum += b\n        CUMSUMS.append(cumsum)\n        (a, b) = (b, a + b)\n    s = sum(nums)\n    if s not in CUMSUMS:\n        return False\n    nums = [-n for n in nums]\n    heapq.heapify(nums)\n    not_use = 0\n    for ind in range(CUMSUMS.index(s), -1, -1):\n        f = FIBS[ind]\n        max_num = -heapq.heappop(nums)\n        if f > max_num:\n            return False\n        max_num -= f\n        heapq.heappush(nums, -not_use)\n        not_use = max_num\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "while cumsum < 10 ** 12:",
      "mutated_line": "while cumsum < 1 ** 12:",
      "code": "def is_semi_fibonacci_string(nums: list[int]) -> bool:\n    \"\"\"\n    Determines if a string represented by the counts of its letters is semi-Fibonacci.\n\n    Args:\n        nums (list[int]): A list of integers where each integer represents the count of a specific letter in the string.\n\n    Returns:\n        bool: True if the string is semi-Fibonacci, False otherwise.\n    \"\"\"\n    import heapq\n    FIBS = []\n    CUMSUMS = []\n    a = 0\n    b = 1\n    cumsum = 0\n    while cumsum < 1 ** 12:\n        FIBS.append(b)\n        cumsum += b\n        CUMSUMS.append(cumsum)\n        (a, b) = (b, a + b)\n    s = sum(nums)\n    if s not in CUMSUMS:\n        return False\n    nums = [-n for n in nums]\n    heapq.heapify(nums)\n    not_use = 0\n    for ind in range(CUMSUMS.index(s), -1, -1):\n        f = FIBS[ind]\n        max_num = -heapq.heappop(nums)\n        if f > max_num:\n            return False\n        max_num -= f\n        heapq.heappush(nums, -not_use)\n        not_use = max_num\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "while cumsum < 10 ** 12:",
      "mutated_line": "while cumsum < -10 ** 12:",
      "code": "def is_semi_fibonacci_string(nums: list[int]) -> bool:\n    \"\"\"\n    Determines if a string represented by the counts of its letters is semi-Fibonacci.\n\n    Args:\n        nums (list[int]): A list of integers where each integer represents the count of a specific letter in the string.\n\n    Returns:\n        bool: True if the string is semi-Fibonacci, False otherwise.\n    \"\"\"\n    import heapq\n    FIBS = []\n    CUMSUMS = []\n    a = 0\n    b = 1\n    cumsum = 0\n    while cumsum < -10 ** 12:\n        FIBS.append(b)\n        cumsum += b\n        CUMSUMS.append(cumsum)\n        (a, b) = (b, a + b)\n    s = sum(nums)\n    if s not in CUMSUMS:\n        return False\n    nums = [-n for n in nums]\n    heapq.heapify(nums)\n    not_use = 0\n    for ind in range(CUMSUMS.index(s), -1, -1):\n        f = FIBS[ind]\n        max_num = -heapq.heappop(nums)\n        if f > max_num:\n            return False\n        max_num -= f\n        heapq.heappush(nums, -not_use)\n        not_use = max_num\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "while cumsum < 10 ** 12:",
      "mutated_line": "while cumsum < 10 ** 13:",
      "code": "def is_semi_fibonacci_string(nums: list[int]) -> bool:\n    \"\"\"\n    Determines if a string represented by the counts of its letters is semi-Fibonacci.\n\n    Args:\n        nums (list[int]): A list of integers where each integer represents the count of a specific letter in the string.\n\n    Returns:\n        bool: True if the string is semi-Fibonacci, False otherwise.\n    \"\"\"\n    import heapq\n    FIBS = []\n    CUMSUMS = []\n    a = 0\n    b = 1\n    cumsum = 0\n    while cumsum < 10 ** 13:\n        FIBS.append(b)\n        cumsum += b\n        CUMSUMS.append(cumsum)\n        (a, b) = (b, a + b)\n    s = sum(nums)\n    if s not in CUMSUMS:\n        return False\n    nums = [-n for n in nums]\n    heapq.heapify(nums)\n    not_use = 0\n    for ind in range(CUMSUMS.index(s), -1, -1):\n        f = FIBS[ind]\n        max_num = -heapq.heappop(nums)\n        if f > max_num:\n            return False\n        max_num -= f\n        heapq.heappush(nums, -not_use)\n        not_use = max_num\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "while cumsum < 10 ** 12:",
      "mutated_line": "while cumsum < 10 ** 11:",
      "code": "def is_semi_fibonacci_string(nums: list[int]) -> bool:\n    \"\"\"\n    Determines if a string represented by the counts of its letters is semi-Fibonacci.\n\n    Args:\n        nums (list[int]): A list of integers where each integer represents the count of a specific letter in the string.\n\n    Returns:\n        bool: True if the string is semi-Fibonacci, False otherwise.\n    \"\"\"\n    import heapq\n    FIBS = []\n    CUMSUMS = []\n    a = 0\n    b = 1\n    cumsum = 0\n    while cumsum < 10 ** 11:\n        FIBS.append(b)\n        cumsum += b\n        CUMSUMS.append(cumsum)\n        (a, b) = (b, a + b)\n    s = sum(nums)\n    if s not in CUMSUMS:\n        return False\n    nums = [-n for n in nums]\n    heapq.heapify(nums)\n    not_use = 0\n    for ind in range(CUMSUMS.index(s), -1, -1):\n        f = FIBS[ind]\n        max_num = -heapq.heappop(nums)\n        if f > max_num:\n            return False\n        max_num -= f\n        heapq.heappush(nums, -not_use)\n        not_use = max_num\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "while cumsum < 10 ** 12:",
      "mutated_line": "while cumsum < 10 ** 0:",
      "code": "def is_semi_fibonacci_string(nums: list[int]) -> bool:\n    \"\"\"\n    Determines if a string represented by the counts of its letters is semi-Fibonacci.\n\n    Args:\n        nums (list[int]): A list of integers where each integer represents the count of a specific letter in the string.\n\n    Returns:\n        bool: True if the string is semi-Fibonacci, False otherwise.\n    \"\"\"\n    import heapq\n    FIBS = []\n    CUMSUMS = []\n    a = 0\n    b = 1\n    cumsum = 0\n    while cumsum < 10 ** 0:\n        FIBS.append(b)\n        cumsum += b\n        CUMSUMS.append(cumsum)\n        (a, b) = (b, a + b)\n    s = sum(nums)\n    if s not in CUMSUMS:\n        return False\n    nums = [-n for n in nums]\n    heapq.heapify(nums)\n    not_use = 0\n    for ind in range(CUMSUMS.index(s), -1, -1):\n        f = FIBS[ind]\n        max_num = -heapq.heappop(nums)\n        if f > max_num:\n            return False\n        max_num -= f\n        heapq.heappush(nums, -not_use)\n        not_use = max_num\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "while cumsum < 10 ** 12:",
      "mutated_line": "while cumsum < 10 ** 1:",
      "code": "def is_semi_fibonacci_string(nums: list[int]) -> bool:\n    \"\"\"\n    Determines if a string represented by the counts of its letters is semi-Fibonacci.\n\n    Args:\n        nums (list[int]): A list of integers where each integer represents the count of a specific letter in the string.\n\n    Returns:\n        bool: True if the string is semi-Fibonacci, False otherwise.\n    \"\"\"\n    import heapq\n    FIBS = []\n    CUMSUMS = []\n    a = 0\n    b = 1\n    cumsum = 0\n    while cumsum < 10 ** 1:\n        FIBS.append(b)\n        cumsum += b\n        CUMSUMS.append(cumsum)\n        (a, b) = (b, a + b)\n    s = sum(nums)\n    if s not in CUMSUMS:\n        return False\n    nums = [-n for n in nums]\n    heapq.heapify(nums)\n    not_use = 0\n    for ind in range(CUMSUMS.index(s), -1, -1):\n        f = FIBS[ind]\n        max_num = -heapq.heappop(nums)\n        if f > max_num:\n            return False\n        max_num -= f\n        heapq.heappush(nums, -not_use)\n        not_use = max_num\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "while cumsum < 10 ** 12:",
      "mutated_line": "while cumsum < 10 ** -12:",
      "code": "def is_semi_fibonacci_string(nums: list[int]) -> bool:\n    \"\"\"\n    Determines if a string represented by the counts of its letters is semi-Fibonacci.\n\n    Args:\n        nums (list[int]): A list of integers where each integer represents the count of a specific letter in the string.\n\n    Returns:\n        bool: True if the string is semi-Fibonacci, False otherwise.\n    \"\"\"\n    import heapq\n    FIBS = []\n    CUMSUMS = []\n    a = 0\n    b = 1\n    cumsum = 0\n    while cumsum < 10 ** -12:\n        FIBS.append(b)\n        cumsum += b\n        CUMSUMS.append(cumsum)\n        (a, b) = (b, a + b)\n    s = sum(nums)\n    if s not in CUMSUMS:\n        return False\n    nums = [-n for n in nums]\n    heapq.heapify(nums)\n    not_use = 0\n    for ind in range(CUMSUMS.index(s), -1, -1):\n        f = FIBS[ind]\n        max_num = -heapq.heappop(nums)\n        if f > max_num:\n            return False\n        max_num -= f\n        heapq.heappush(nums, -not_use)\n        not_use = max_num\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "(a, b) = (b, a + b)",
      "mutated_line": "(a, b) = (b, a - b)",
      "code": "def is_semi_fibonacci_string(nums: list[int]) -> bool:\n    \"\"\"\n    Determines if a string represented by the counts of its letters is semi-Fibonacci.\n\n    Args:\n        nums (list[int]): A list of integers where each integer represents the count of a specific letter in the string.\n\n    Returns:\n        bool: True if the string is semi-Fibonacci, False otherwise.\n    \"\"\"\n    import heapq\n    FIBS = []\n    CUMSUMS = []\n    a = 0\n    b = 1\n    cumsum = 0\n    while cumsum < 10 ** 12:\n        FIBS.append(b)\n        cumsum += b\n        CUMSUMS.append(cumsum)\n        (a, b) = (b, a - b)\n    s = sum(nums)\n    if s not in CUMSUMS:\n        return False\n    nums = [-n for n in nums]\n    heapq.heapify(nums)\n    not_use = 0\n    for ind in range(CUMSUMS.index(s), -1, -1):\n        f = FIBS[ind]\n        max_num = -heapq.heappop(nums)\n        if f > max_num:\n            return False\n        max_num -= f\n        heapq.heappush(nums, -not_use)\n        not_use = max_num\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "(a, b) = (b, a + b)",
      "mutated_line": "(a, b) = (b, a * b)",
      "code": "def is_semi_fibonacci_string(nums: list[int]) -> bool:\n    \"\"\"\n    Determines if a string represented by the counts of its letters is semi-Fibonacci.\n\n    Args:\n        nums (list[int]): A list of integers where each integer represents the count of a specific letter in the string.\n\n    Returns:\n        bool: True if the string is semi-Fibonacci, False otherwise.\n    \"\"\"\n    import heapq\n    FIBS = []\n    CUMSUMS = []\n    a = 0\n    b = 1\n    cumsum = 0\n    while cumsum < 10 ** 12:\n        FIBS.append(b)\n        cumsum += b\n        CUMSUMS.append(cumsum)\n        (a, b) = (b, a * b)\n    s = sum(nums)\n    if s not in CUMSUMS:\n        return False\n    nums = [-n for n in nums]\n    heapq.heapify(nums)\n    not_use = 0\n    for ind in range(CUMSUMS.index(s), -1, -1):\n        f = FIBS[ind]\n        max_num = -heapq.heappop(nums)\n        if f > max_num:\n            return False\n        max_num -= f\n        heapq.heappush(nums, -not_use)\n        not_use = max_num\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for ind in range(CUMSUMS.index(s), -1, -1):",
      "mutated_line": "for ind in range(CUMSUMS.index(s), -2, -1):",
      "code": "def is_semi_fibonacci_string(nums: list[int]) -> bool:\n    \"\"\"\n    Determines if a string represented by the counts of its letters is semi-Fibonacci.\n\n    Args:\n        nums (list[int]): A list of integers where each integer represents the count of a specific letter in the string.\n\n    Returns:\n        bool: True if the string is semi-Fibonacci, False otherwise.\n    \"\"\"\n    import heapq\n    FIBS = []\n    CUMSUMS = []\n    a = 0\n    b = 1\n    cumsum = 0\n    while cumsum < 10 ** 12:\n        FIBS.append(b)\n        cumsum += b\n        CUMSUMS.append(cumsum)\n        (a, b) = (b, a + b)\n    s = sum(nums)\n    if s not in CUMSUMS:\n        return False\n    nums = [-n for n in nums]\n    heapq.heapify(nums)\n    not_use = 0\n    for ind in range(CUMSUMS.index(s), -2, -1):\n        f = FIBS[ind]\n        max_num = -heapq.heappop(nums)\n        if f > max_num:\n            return False\n        max_num -= f\n        heapq.heappush(nums, -not_use)\n        not_use = max_num\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for ind in range(CUMSUMS.index(s), -1, -1):",
      "mutated_line": "for ind in range(CUMSUMS.index(s), -0, -1):",
      "code": "def is_semi_fibonacci_string(nums: list[int]) -> bool:\n    \"\"\"\n    Determines if a string represented by the counts of its letters is semi-Fibonacci.\n\n    Args:\n        nums (list[int]): A list of integers where each integer represents the count of a specific letter in the string.\n\n    Returns:\n        bool: True if the string is semi-Fibonacci, False otherwise.\n    \"\"\"\n    import heapq\n    FIBS = []\n    CUMSUMS = []\n    a = 0\n    b = 1\n    cumsum = 0\n    while cumsum < 10 ** 12:\n        FIBS.append(b)\n        cumsum += b\n        CUMSUMS.append(cumsum)\n        (a, b) = (b, a + b)\n    s = sum(nums)\n    if s not in CUMSUMS:\n        return False\n    nums = [-n for n in nums]\n    heapq.heapify(nums)\n    not_use = 0\n    for ind in range(CUMSUMS.index(s), -0, -1):\n        f = FIBS[ind]\n        max_num = -heapq.heappop(nums)\n        if f > max_num:\n            return False\n        max_num -= f\n        heapq.heappush(nums, -not_use)\n        not_use = max_num\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for ind in range(CUMSUMS.index(s), -1, -1):",
      "mutated_line": "for ind in range(CUMSUMS.index(s), -0, -1):",
      "code": "def is_semi_fibonacci_string(nums: list[int]) -> bool:\n    \"\"\"\n    Determines if a string represented by the counts of its letters is semi-Fibonacci.\n\n    Args:\n        nums (list[int]): A list of integers where each integer represents the count of a specific letter in the string.\n\n    Returns:\n        bool: True if the string is semi-Fibonacci, False otherwise.\n    \"\"\"\n    import heapq\n    FIBS = []\n    CUMSUMS = []\n    a = 0\n    b = 1\n    cumsum = 0\n    while cumsum < 10 ** 12:\n        FIBS.append(b)\n        cumsum += b\n        CUMSUMS.append(cumsum)\n        (a, b) = (b, a + b)\n    s = sum(nums)\n    if s not in CUMSUMS:\n        return False\n    nums = [-n for n in nums]\n    heapq.heapify(nums)\n    not_use = 0\n    for ind in range(CUMSUMS.index(s), -0, -1):\n        f = FIBS[ind]\n        max_num = -heapq.heappop(nums)\n        if f > max_num:\n            return False\n        max_num -= f\n        heapq.heappush(nums, -not_use)\n        not_use = max_num\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for ind in range(CUMSUMS.index(s), -1, -1):",
      "mutated_line": "for ind in range(CUMSUMS.index(s), --1, -1):",
      "code": "def is_semi_fibonacci_string(nums: list[int]) -> bool:\n    \"\"\"\n    Determines if a string represented by the counts of its letters is semi-Fibonacci.\n\n    Args:\n        nums (list[int]): A list of integers where each integer represents the count of a specific letter in the string.\n\n    Returns:\n        bool: True if the string is semi-Fibonacci, False otherwise.\n    \"\"\"\n    import heapq\n    FIBS = []\n    CUMSUMS = []\n    a = 0\n    b = 1\n    cumsum = 0\n    while cumsum < 10 ** 12:\n        FIBS.append(b)\n        cumsum += b\n        CUMSUMS.append(cumsum)\n        (a, b) = (b, a + b)\n    s = sum(nums)\n    if s not in CUMSUMS:\n        return False\n    nums = [-n for n in nums]\n    heapq.heapify(nums)\n    not_use = 0\n    for ind in range(CUMSUMS.index(s), --1, -1):\n        f = FIBS[ind]\n        max_num = -heapq.heappop(nums)\n        if f > max_num:\n            return False\n        max_num -= f\n        heapq.heappush(nums, -not_use)\n        not_use = max_num\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for ind in range(CUMSUMS.index(s), -1, -1):",
      "mutated_line": "for ind in range(CUMSUMS.index(s), -1, -2):",
      "code": "def is_semi_fibonacci_string(nums: list[int]) -> bool:\n    \"\"\"\n    Determines if a string represented by the counts of its letters is semi-Fibonacci.\n\n    Args:\n        nums (list[int]): A list of integers where each integer represents the count of a specific letter in the string.\n\n    Returns:\n        bool: True if the string is semi-Fibonacci, False otherwise.\n    \"\"\"\n    import heapq\n    FIBS = []\n    CUMSUMS = []\n    a = 0\n    b = 1\n    cumsum = 0\n    while cumsum < 10 ** 12:\n        FIBS.append(b)\n        cumsum += b\n        CUMSUMS.append(cumsum)\n        (a, b) = (b, a + b)\n    s = sum(nums)\n    if s not in CUMSUMS:\n        return False\n    nums = [-n for n in nums]\n    heapq.heapify(nums)\n    not_use = 0\n    for ind in range(CUMSUMS.index(s), -1, -2):\n        f = FIBS[ind]\n        max_num = -heapq.heappop(nums)\n        if f > max_num:\n            return False\n        max_num -= f\n        heapq.heappush(nums, -not_use)\n        not_use = max_num\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for ind in range(CUMSUMS.index(s), -1, -1):",
      "mutated_line": "for ind in range(CUMSUMS.index(s), -1, -0):",
      "code": "def is_semi_fibonacci_string(nums: list[int]) -> bool:\n    \"\"\"\n    Determines if a string represented by the counts of its letters is semi-Fibonacci.\n\n    Args:\n        nums (list[int]): A list of integers where each integer represents the count of a specific letter in the string.\n\n    Returns:\n        bool: True if the string is semi-Fibonacci, False otherwise.\n    \"\"\"\n    import heapq\n    FIBS = []\n    CUMSUMS = []\n    a = 0\n    b = 1\n    cumsum = 0\n    while cumsum < 10 ** 12:\n        FIBS.append(b)\n        cumsum += b\n        CUMSUMS.append(cumsum)\n        (a, b) = (b, a + b)\n    s = sum(nums)\n    if s not in CUMSUMS:\n        return False\n    nums = [-n for n in nums]\n    heapq.heapify(nums)\n    not_use = 0\n    for ind in range(CUMSUMS.index(s), -1, -0):\n        f = FIBS[ind]\n        max_num = -heapq.heappop(nums)\n        if f > max_num:\n            return False\n        max_num -= f\n        heapq.heappush(nums, -not_use)\n        not_use = max_num\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for ind in range(CUMSUMS.index(s), -1, -1):",
      "mutated_line": "for ind in range(CUMSUMS.index(s), -1, -0):",
      "code": "def is_semi_fibonacci_string(nums: list[int]) -> bool:\n    \"\"\"\n    Determines if a string represented by the counts of its letters is semi-Fibonacci.\n\n    Args:\n        nums (list[int]): A list of integers where each integer represents the count of a specific letter in the string.\n\n    Returns:\n        bool: True if the string is semi-Fibonacci, False otherwise.\n    \"\"\"\n    import heapq\n    FIBS = []\n    CUMSUMS = []\n    a = 0\n    b = 1\n    cumsum = 0\n    while cumsum < 10 ** 12:\n        FIBS.append(b)\n        cumsum += b\n        CUMSUMS.append(cumsum)\n        (a, b) = (b, a + b)\n    s = sum(nums)\n    if s not in CUMSUMS:\n        return False\n    nums = [-n for n in nums]\n    heapq.heapify(nums)\n    not_use = 0\n    for ind in range(CUMSUMS.index(s), -1, -0):\n        f = FIBS[ind]\n        max_num = -heapq.heappop(nums)\n        if f > max_num:\n            return False\n        max_num -= f\n        heapq.heappush(nums, -not_use)\n        not_use = max_num\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for ind in range(CUMSUMS.index(s), -1, -1):",
      "mutated_line": "for ind in range(CUMSUMS.index(s), -1, --1):",
      "code": "def is_semi_fibonacci_string(nums: list[int]) -> bool:\n    \"\"\"\n    Determines if a string represented by the counts of its letters is semi-Fibonacci.\n\n    Args:\n        nums (list[int]): A list of integers where each integer represents the count of a specific letter in the string.\n\n    Returns:\n        bool: True if the string is semi-Fibonacci, False otherwise.\n    \"\"\"\n    import heapq\n    FIBS = []\n    CUMSUMS = []\n    a = 0\n    b = 1\n    cumsum = 0\n    while cumsum < 10 ** 12:\n        FIBS.append(b)\n        cumsum += b\n        CUMSUMS.append(cumsum)\n        (a, b) = (b, a + b)\n    s = sum(nums)\n    if s not in CUMSUMS:\n        return False\n    nums = [-n for n in nums]\n    heapq.heapify(nums)\n    not_use = 0\n    for ind in range(CUMSUMS.index(s), -1, --1):\n        f = FIBS[ind]\n        max_num = -heapq.heappop(nums)\n        if f > max_num:\n            return False\n        max_num -= f\n        heapq.heappush(nums, -not_use)\n        not_use = max_num\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def is_semi_fibonacci_string(nums: list[int]) -> bool:\n    \"\"\"\n    Determines if a string represented by the counts of its letters is semi-Fibonacci.\n\n    Args:\n        nums (list[int]): A list of integers where each integer represents the count of a specific letter in the string.\n\n    Returns:\n        bool: True if the string is semi-Fibonacci, False otherwise.\n    \"\"\"\n    import heapq\n    FIBS = []\n    CUMSUMS = []\n    a = 0\n    b = 1\n    cumsum = 0\n    while cumsum < 10 ** 12:\n        FIBS.append(b)\n        cumsum += b\n        CUMSUMS.append(cumsum)\n        (a, b) = (b, a + b)\n    s = sum(nums)\n    if s not in CUMSUMS:\n        return False\n    nums = [-n for n in nums]\n    heapq.heapify(nums)\n    not_use = 0\n    for ind in range(CUMSUMS.index(s), -1, -1):\n        f = FIBS[ind]\n        max_num = -heapq.heappop(nums)\n        if f > max_num:\n            return True\n        max_num -= f\n        heapq.heappush(nums, -not_use)\n        not_use = max_num\n    return True"
    },
    {
      "operator": "UOI",
      "lineno": 44,
      "original_line": "heapq.heappush(nums, -not_use)",
      "mutated_line": "heapq.heappush(nums, +not_use)",
      "code": "def is_semi_fibonacci_string(nums: list[int]) -> bool:\n    \"\"\"\n    Determines if a string represented by the counts of its letters is semi-Fibonacci.\n\n    Args:\n        nums (list[int]): A list of integers where each integer represents the count of a specific letter in the string.\n\n    Returns:\n        bool: True if the string is semi-Fibonacci, False otherwise.\n    \"\"\"\n    import heapq\n    FIBS = []\n    CUMSUMS = []\n    a = 0\n    b = 1\n    cumsum = 0\n    while cumsum < 10 ** 12:\n        FIBS.append(b)\n        cumsum += b\n        CUMSUMS.append(cumsum)\n        (a, b) = (b, a + b)\n    s = sum(nums)\n    if s not in CUMSUMS:\n        return False\n    nums = [-n for n in nums]\n    heapq.heapify(nums)\n    not_use = 0\n    for ind in range(CUMSUMS.index(s), -1, -1):\n        f = FIBS[ind]\n        max_num = -heapq.heappop(nums)\n        if f > max_num:\n            return False\n        max_num -= f\n        heapq.heappush(nums, +not_use)\n        not_use = max_num\n    return True"
    }
  ]
}