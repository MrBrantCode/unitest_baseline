{
  "task_id": "taco_18392",
  "entry_point": "count_special_numbers",
  "mutant_count": 185,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "pd = 1",
      "mutated_line": "pd = 2",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 2\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "pd = 1",
      "mutated_line": "pd = 0",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 0\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "pd = 1",
      "mutated_line": "pd = 0",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 0\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "pd = 1",
      "mutated_line": "pd = -1",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = -1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 7,
      "original_line": "pd *= int(d) + 1",
      "mutated_line": "pd /= int(d) + 1",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd /= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "res2 = dfs1(0, su, pd, 0) - 1",
      "mutated_line": "res2 = dfs1(0, su, pd, 0) + 1",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) + 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "res2 = dfs1(0, su, pd, 0) - 1",
      "mutated_line": "res2 = dfs1(0, su, pd, 0) * 1",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) * 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "ans = res1 + res2",
      "mutated_line": "ans = res1 - res2",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 - res2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "ans = res1 + res2",
      "mutated_line": "ans = res1 * res2",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 * res2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "pd *= int(d) + 1",
      "mutated_line": "pd *= int(d) - 1",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) - 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "pd *= int(d) + 1",
      "mutated_line": "pd *= int(d) * 1",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) * 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if i == N:",
      "mutated_line": "if i != N:",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i != N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if key in memo[i]:",
      "mutated_line": "if key not in memo[i]:",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key not in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "r = 0",
      "mutated_line": "r = 1",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 1\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "r = 0",
      "mutated_line": "r = -1",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = -1\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "r = 0",
      "mutated_line": "r = 1",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 1\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 18,
      "original_line": "r += dfs0(i + 1, s - v, p * (v + 1))",
      "mutated_line": "r -= dfs0(i + 1, s - v, p * (v + 1))",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r -= dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "res1 = dfs0(0, su, 1)",
      "mutated_line": "res1 = dfs0(1, su, 1)",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(1, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "res1 = dfs0(0, su, 1)",
      "mutated_line": "res1 = dfs0(-1, su, 1)",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(-1, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "res1 = dfs0(0, su, 1)",
      "mutated_line": "res1 = dfs0(1, su, 1)",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(1, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "res1 = dfs0(0, su, 1)",
      "mutated_line": "res1 = dfs0(0, su, 2)",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 2)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "res1 = dfs0(0, su, 1)",
      "mutated_line": "res1 = dfs0(0, su, 0)",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 0)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "res1 = dfs0(0, su, 1)",
      "mutated_line": "res1 = dfs0(0, su, 0)",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 0)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "res1 = dfs0(0, su, 1)",
      "mutated_line": "res1 = dfs0(0, su, -1)",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, -1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if i == N:",
      "mutated_line": "if i != N:",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i != N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if key in memo1[i]:",
      "mutated_line": "if key not in memo1[i]:",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key not in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "r = 0",
      "mutated_line": "r = 1",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 1\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "r = 0",
      "mutated_line": "r = -1",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = -1\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "r = 0",
      "mutated_line": "r = 1",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 1\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "b = s - (N - 1 - i) * 9",
      "mutated_line": "b = s + (N - 1 - i) * 9",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s + (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "b = s - (N - 1 - i) * 9",
      "mutated_line": "b = s * ((N - 1 - i) * 9)",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s * ((N - 1 - i) * 9)\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "res2 = dfs1(0, su, pd, 0) - 1",
      "mutated_line": "res2 = dfs1(0, su, pd, 0) - 2",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 2\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "res2 = dfs1(0, su, pd, 0) - 1",
      "mutated_line": "res2 = dfs1(0, su, pd, 0) - 0",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 0\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "res2 = dfs1(0, su, pd, 0) - 1",
      "mutated_line": "res2 = dfs1(0, su, pd, 0) - 0",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 0\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "res2 = dfs1(0, su, pd, 0) - 1",
      "mutated_line": "res2 = dfs1(0, su, pd, 0) - -1",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - -1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "pd *= int(d) + 1",
      "mutated_line": "pd *= int(d) + 2",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 2\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "pd *= int(d) + 1",
      "mutated_line": "pd *= int(d) + 0",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 0\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "pd *= int(d) + 1",
      "mutated_line": "pd *= int(d) + 0",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 0\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "pd *= int(d) + 1",
      "mutated_line": "pd *= int(d) + -1",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + -1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 13,
      "original_line": "return s > 0 or (s == 0 and p < pd)",
      "mutated_line": "return s > 0 and (s == 0 and p < pd)",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 and (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for v in range(min(s, 9) + 1):",
      "mutated_line": "for v in range(min(s, 9) - 1):",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) - 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for v in range(min(s, 9) + 1):",
      "mutated_line": "for v in range(min(s, 9) * 1):",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) * 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 28,
      "original_line": "return s == 0 and p == 1",
      "mutated_line": "return s == 0 or p == 1",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 or p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "b = s - (N - 1 - i) * 9",
      "mutated_line": "b = s - (N - 1 - i) / 9",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) / 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "b = s - (N - 1 - i) * 9",
      "mutated_line": "b = s - (N - 1 - i + 9)",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i + 9)\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "b = s - (N - 1 - i) * 9",
      "mutated_line": "b = s - (N - 1 - i) ** 9",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) ** 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "for v in range(max(b, 0), min(s, 9) + 1):",
      "mutated_line": "for v in range(max(b, 0), min(s, 9) - 1):",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) - 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "for v in range(max(b, 0), min(s, 9) + 1):",
      "mutated_line": "for v in range(max(b, 0), min(s, 9) * 1):",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) * 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "if p % (v + 1):",
      "mutated_line": "if p * (v + 1):",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p * (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "if p % (v + 1):",
      "mutated_line": "if p + (v + 1):",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p + (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if m == 0:",
      "mutated_line": "if m != 0:",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m != 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 40,
      "original_line": "r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))",
      "mutated_line": "r -= dfs1(i + 1, s - v, p // (v + 1), +(v < di))",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r -= dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 42,
      "original_line": "r += dfs1(i + 1, s - v, p // (v + 1), 1)",
      "mutated_line": "r -= dfs1(i + 1, s - v, p // (v + 1), 1)",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r -= dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "res2 = dfs1(0, su, pd, 0) - 1",
      "mutated_line": "res2 = dfs1(1, su, pd, 0) - 1",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(1, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "res2 = dfs1(0, su, pd, 0) - 1",
      "mutated_line": "res2 = dfs1(-1, su, pd, 0) - 1",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(-1, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "res2 = dfs1(0, su, pd, 0) - 1",
      "mutated_line": "res2 = dfs1(1, su, pd, 0) - 1",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(1, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "res2 = dfs1(0, su, pd, 0) - 1",
      "mutated_line": "res2 = dfs1(0, su, pd, 1) - 1",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 1) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "res2 = dfs1(0, su, pd, 0) - 1",
      "mutated_line": "res2 = dfs1(0, su, pd, -1) - 1",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, -1) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "res2 = dfs1(0, su, pd, 0) - 1",
      "mutated_line": "res2 = dfs1(0, su, pd, 1) - 1",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 1) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "return s > 0 or (s == 0 and p < pd)",
      "mutated_line": "return s >= 0 or (s == 0 and p < pd)",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s >= 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "return s > 0 or (s == 0 and p < pd)",
      "mutated_line": "return s <= 0 or (s == 0 and p < pd)",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s <= 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "return s > 0 or (s == 0 and p < pd)",
      "mutated_line": "return s != 0 or (s == 0 and p < pd)",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s != 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 13,
      "original_line": "return s > 0 or (s == 0 and p < pd)",
      "mutated_line": "return s > 0 or (s == 0 or p < pd)",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 or p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for v in range(min(s, 9) + 1):",
      "mutated_line": "for v in range(min(s, 9) + 2):",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 2):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for v in range(min(s, 9) + 1):",
      "mutated_line": "for v in range(min(s, 9) + 0):",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 0):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for v in range(min(s, 9) + 1):",
      "mutated_line": "for v in range(min(s, 9) + 0):",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 0):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for v in range(min(s, 9) + 1):",
      "mutated_line": "for v in range(min(s, 9) + -1):",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + -1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "r += dfs0(i + 1, s - v, p * (v + 1))",
      "mutated_line": "r += dfs0(i - 1, s - v, p * (v + 1))",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i - 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "r += dfs0(i + 1, s - v, p * (v + 1))",
      "mutated_line": "r += dfs0(i * 1, s - v, p * (v + 1))",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i * 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "r += dfs0(i + 1, s - v, p * (v + 1))",
      "mutated_line": "r += dfs0(i + 1, s + v, p * (v + 1))",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s + v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "r += dfs0(i + 1, s - v, p * (v + 1))",
      "mutated_line": "r += dfs0(i + 1, s * v, p * (v + 1))",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s * v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "r += dfs0(i + 1, s - v, p * (v + 1))",
      "mutated_line": "r += dfs0(i + 1, s - v, p / (v + 1))",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p / (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "r += dfs0(i + 1, s - v, p * (v + 1))",
      "mutated_line": "r += dfs0(i + 1, s - v, p + (v + 1))",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p + (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "r += dfs0(i + 1, s - v, p * (v + 1))",
      "mutated_line": "r += dfs0(i + 1, s - v, p ** (v + 1))",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p ** (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "return s == 0 and p == 1",
      "mutated_line": "return s != 0 and p == 1",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s != 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "return s == 0 and p == 1",
      "mutated_line": "return s == 0 and p != 1",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p != 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "b = s - (N - 1 - i) * 9",
      "mutated_line": "b = s - (N - 1 + i) * 9",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 + i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "b = s - (N - 1 - i) * 9",
      "mutated_line": "b = s - (N - 1) * i * 9",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1) * i * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "b = s - (N - 1 - i) * 9",
      "mutated_line": "b = s - (N - 1 - i) * 10",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 10\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "b = s - (N - 1 - i) * 9",
      "mutated_line": "b = s - (N - 1 - i) * 8",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 8\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "b = s - (N - 1 - i) * 9",
      "mutated_line": "b = s - (N - 1 - i) * 0",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 0\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "b = s - (N - 1 - i) * 9",
      "mutated_line": "b = s - (N - 1 - i) * 1",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 1\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "b = s - (N - 1 - i) * 9",
      "mutated_line": "b = s - (N - 1 - i) * -9",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * -9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for v in range(max(b, 0), min(s, 9) + 1):",
      "mutated_line": "for v in range(max(b, 1), min(s, 9) + 1):",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 1), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for v in range(max(b, 0), min(s, 9) + 1):",
      "mutated_line": "for v in range(max(b, -1), min(s, 9) + 1):",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, -1), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for v in range(max(b, 0), min(s, 9) + 1):",
      "mutated_line": "for v in range(max(b, 1), min(s, 9) + 1):",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 1), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for v in range(max(b, 0), min(s, 9) + 1):",
      "mutated_line": "for v in range(max(b, 0), min(s, 9) + 2):",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 2):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for v in range(max(b, 0), min(s, 9) + 1):",
      "mutated_line": "for v in range(max(b, 0), min(s, 9) + 0):",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 0):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for v in range(max(b, 0), min(s, 9) + 1):",
      "mutated_line": "for v in range(max(b, 0), min(s, 9) + 0):",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 0):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for v in range(max(b, 0), min(s, 9) + 1):",
      "mutated_line": "for v in range(max(b, 0), min(s, 9) + -1):",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + -1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "if p % (v + 1):",
      "mutated_line": "if p % (v - 1):",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v - 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "if p % (v + 1):",
      "mutated_line": "if p % (v * 1):",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v * 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if m == 0:",
      "mutated_line": "if m == 1:",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 1:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if m == 0:",
      "mutated_line": "if m == -1:",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == -1:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if m == 0:",
      "mutated_line": "if m == 1:",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 1:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if di < v:",
      "mutated_line": "if di <= v:",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di <= v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if di < v:",
      "mutated_line": "if di >= v:",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di >= v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if di < v:",
      "mutated_line": "if di != v:",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di != v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return s > 0 or (s == 0 and p < pd)",
      "mutated_line": "return s > 1 or (s == 0 and p < pd)",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 1 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return s > 0 or (s == 0 and p < pd)",
      "mutated_line": "return s > -1 or (s == 0 and p < pd)",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > -1 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return s > 0 or (s == 0 and p < pd)",
      "mutated_line": "return s > 1 or (s == 0 and p < pd)",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 1 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "return s > 0 or (s == 0 and p < pd)",
      "mutated_line": "return s > 0 or (s != 0 and p < pd)",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s != 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "return s > 0 or (s == 0 and p < pd)",
      "mutated_line": "return s > 0 or (s == 0 and p <= pd)",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p <= pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "return s > 0 or (s == 0 and p < pd)",
      "mutated_line": "return s > 0 or (s == 0 and p >= pd)",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p >= pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "return s > 0 or (s == 0 and p < pd)",
      "mutated_line": "return s > 0 or (s == 0 and p != pd)",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p != pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for v in range(min(s, 9) + 1):",
      "mutated_line": "for v in range(min(s, 10) + 1):",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 10) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for v in range(min(s, 9) + 1):",
      "mutated_line": "for v in range(min(s, 8) + 1):",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 8) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for v in range(min(s, 9) + 1):",
      "mutated_line": "for v in range(min(s, 0) + 1):",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 0) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for v in range(min(s, 9) + 1):",
      "mutated_line": "for v in range(min(s, 1) + 1):",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 1) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for v in range(min(s, 9) + 1):",
      "mutated_line": "for v in range(min(s, -9) + 1):",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, -9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "r += dfs0(i + 1, s - v, p * (v + 1))",
      "mutated_line": "r += dfs0(i + 2, s - v, p * (v + 1))",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 2, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "r += dfs0(i + 1, s - v, p * (v + 1))",
      "mutated_line": "r += dfs0(i + 0, s - v, p * (v + 1))",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 0, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "r += dfs0(i + 1, s - v, p * (v + 1))",
      "mutated_line": "r += dfs0(i + 0, s - v, p * (v + 1))",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 0, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "r += dfs0(i + 1, s - v, p * (v + 1))",
      "mutated_line": "r += dfs0(i + -1, s - v, p * (v + 1))",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + -1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "r += dfs0(i + 1, s - v, p * (v + 1))",
      "mutated_line": "r += dfs0(i + 1, s - v, p * (v - 1))",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v - 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "r += dfs0(i + 1, s - v, p * (v + 1))",
      "mutated_line": "r += dfs0(i + 1, s - v, p * (v * 1))",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v * 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return s == 0 and p == 1",
      "mutated_line": "return s == 1 and p == 1",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 1 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return s == 0 and p == 1",
      "mutated_line": "return s == -1 and p == 1",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == -1 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return s == 0 and p == 1",
      "mutated_line": "return s == 1 and p == 1",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 1 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return s == 0 and p == 1",
      "mutated_line": "return s == 0 and p == 2",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 2\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return s == 0 and p == 1",
      "mutated_line": "return s == 0 and p == 0",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 0\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return s == 0 and p == 1",
      "mutated_line": "return s == 0 and p == 0",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 0\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return s == 0 and p == 1",
      "mutated_line": "return s == 0 and p == -1",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == -1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "b = s - (N - 1 - i) * 9",
      "mutated_line": "b = s - (N + 1 - i) * 9",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N + 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "b = s - (N - 1 - i) * 9",
      "mutated_line": "b = s - (N * 1 - i) * 9",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N * 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for v in range(max(b, 0), min(s, 9) + 1):",
      "mutated_line": "for v in range(max(b, 0), min(s, 10) + 1):",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 10) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for v in range(max(b, 0), min(s, 9) + 1):",
      "mutated_line": "for v in range(max(b, 0), min(s, 8) + 1):",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 8) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for v in range(max(b, 0), min(s, 9) + 1):",
      "mutated_line": "for v in range(max(b, 0), min(s, 0) + 1):",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 0) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for v in range(max(b, 0), min(s, 9) + 1):",
      "mutated_line": "for v in range(max(b, 0), min(s, 1) + 1):",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 1) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for v in range(max(b, 0), min(s, 9) + 1):",
      "mutated_line": "for v in range(max(b, 0), min(s, -9) + 1):",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, -9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if p % (v + 1):",
      "mutated_line": "if p % (v + 2):",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 2):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if p % (v + 1):",
      "mutated_line": "if p % (v + 0):",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 0):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if p % (v + 1):",
      "mutated_line": "if p % (v + 0):",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 0):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if p % (v + 1):",
      "mutated_line": "if p % (v + -1):",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + -1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))",
      "mutated_line": "r += dfs1(i - 1, s - v, p // (v + 1), +(v < di))",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i - 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))",
      "mutated_line": "r += dfs1(i * 1, s - v, p // (v + 1), +(v < di))",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i * 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))",
      "mutated_line": "r += dfs1(i + 1, s + v, p // (v + 1), +(v < di))",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s + v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))",
      "mutated_line": "r += dfs1(i + 1, s * v, p // (v + 1), +(v < di))",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s * v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))",
      "mutated_line": "r += dfs1(i + 1, s - v, p / (v + 1), +(v < di))",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p / (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))",
      "mutated_line": "r += dfs1(i + 1, s - v, p * (v + 1), +(v < di))",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p * (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 40,
      "original_line": "r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))",
      "mutated_line": "r += dfs1(i + 1, s - v, p // (v + 1), -(v < di))",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), -(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "r += dfs1(i + 1, s - v, p // (v + 1), 1)",
      "mutated_line": "r += dfs1(i - 1, s - v, p // (v + 1), 1)",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i - 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "r += dfs1(i + 1, s - v, p // (v + 1), 1)",
      "mutated_line": "r += dfs1(i * 1, s - v, p // (v + 1), 1)",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i * 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "r += dfs1(i + 1, s - v, p // (v + 1), 1)",
      "mutated_line": "r += dfs1(i + 1, s + v, p // (v + 1), 1)",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s + v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "r += dfs1(i + 1, s - v, p // (v + 1), 1)",
      "mutated_line": "r += dfs1(i + 1, s * v, p // (v + 1), 1)",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s * v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "r += dfs1(i + 1, s - v, p // (v + 1), 1)",
      "mutated_line": "r += dfs1(i + 1, s - v, p / (v + 1), 1)",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p / (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "r += dfs1(i + 1, s - v, p // (v + 1), 1)",
      "mutated_line": "r += dfs1(i + 1, s - v, p * (v + 1), 1)",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p * (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "r += dfs1(i + 1, s - v, p // (v + 1), 1)",
      "mutated_line": "r += dfs1(i + 1, s - v, p // (v + 1), 2)",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 2)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "r += dfs1(i + 1, s - v, p // (v + 1), 1)",
      "mutated_line": "r += dfs1(i + 1, s - v, p // (v + 1), 0)",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 0)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "r += dfs1(i + 1, s - v, p // (v + 1), 1)",
      "mutated_line": "r += dfs1(i + 1, s - v, p // (v + 1), 0)",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 0)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "r += dfs1(i + 1, s - v, p // (v + 1), 1)",
      "mutated_line": "r += dfs1(i + 1, s - v, p // (v + 1), -1)",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), -1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return s > 0 or (s == 0 and p < pd)",
      "mutated_line": "return s > 0 or (s == 1 and p < pd)",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 1 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return s > 0 or (s == 0 and p < pd)",
      "mutated_line": "return s > 0 or (s == -1 and p < pd)",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == -1 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return s > 0 or (s == 0 and p < pd)",
      "mutated_line": "return s > 0 or (s == 1 and p < pd)",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 1 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "r += dfs0(i + 1, s - v, p * (v + 1))",
      "mutated_line": "r += dfs0(i + 1, s - v, p * (v + 2))",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 2))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "r += dfs0(i + 1, s - v, p * (v + 1))",
      "mutated_line": "r += dfs0(i + 1, s - v, p * (v + 0))",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 0))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "r += dfs0(i + 1, s - v, p * (v + 1))",
      "mutated_line": "r += dfs0(i + 1, s - v, p * (v + 0))",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 0))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "r += dfs0(i + 1, s - v, p * (v + 1))",
      "mutated_line": "r += dfs0(i + 1, s - v, p * (v + -1))",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + -1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "b = s - (N - 1 - i) * 9",
      "mutated_line": "b = s - (N - 2 - i) * 9",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 2 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "b = s - (N - 1 - i) * 9",
      "mutated_line": "b = s - (N - 0 - i) * 9",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 0 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "b = s - (N - 1 - i) * 9",
      "mutated_line": "b = s - (N - 0 - i) * 9",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 0 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "b = s - (N - 1 - i) * 9",
      "mutated_line": "b = s - (N - -1 - i) * 9",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - -1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))",
      "mutated_line": "r += dfs1(i + 2, s - v, p // (v + 1), +(v < di))",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 2, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))",
      "mutated_line": "r += dfs1(i + 0, s - v, p // (v + 1), +(v < di))",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 0, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))",
      "mutated_line": "r += dfs1(i + 0, s - v, p // (v + 1), +(v < di))",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 0, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))",
      "mutated_line": "r += dfs1(i + -1, s - v, p // (v + 1), +(v < di))",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + -1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))",
      "mutated_line": "r += dfs1(i + 1, s - v, p // (v - 1), +(v < di))",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v - 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))",
      "mutated_line": "r += dfs1(i + 1, s - v, p // (v * 1), +(v < di))",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v * 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))",
      "mutated_line": "r += dfs1(i + 1, s - v, p // (v + 1), +(v <= di))",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v <= di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))",
      "mutated_line": "r += dfs1(i + 1, s - v, p // (v + 1), +(v >= di))",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v >= di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))",
      "mutated_line": "r += dfs1(i + 1, s - v, p // (v + 1), +(v != di))",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v != di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "r += dfs1(i + 1, s - v, p // (v + 1), 1)",
      "mutated_line": "r += dfs1(i + 2, s - v, p // (v + 1), 1)",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 2, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "r += dfs1(i + 1, s - v, p // (v + 1), 1)",
      "mutated_line": "r += dfs1(i + 0, s - v, p // (v + 1), 1)",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 0, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "r += dfs1(i + 1, s - v, p // (v + 1), 1)",
      "mutated_line": "r += dfs1(i + 0, s - v, p // (v + 1), 1)",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 0, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "r += dfs1(i + 1, s - v, p // (v + 1), 1)",
      "mutated_line": "r += dfs1(i + -1, s - v, p // (v + 1), 1)",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + -1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "r += dfs1(i + 1, s - v, p // (v + 1), 1)",
      "mutated_line": "r += dfs1(i + 1, s - v, p // (v - 1), 1)",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v - 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "r += dfs1(i + 1, s - v, p // (v + 1), 1)",
      "mutated_line": "r += dfs1(i + 1, s - v, p // (v * 1), 1)",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v * 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))",
      "mutated_line": "r += dfs1(i + 1, s - v, p // (v + 2), +(v < di))",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 2), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))",
      "mutated_line": "r += dfs1(i + 1, s - v, p // (v + 0), +(v < di))",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 0), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))",
      "mutated_line": "r += dfs1(i + 1, s - v, p // (v + 0), +(v < di))",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 0), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))",
      "mutated_line": "r += dfs1(i + 1, s - v, p // (v + -1), +(v < di))",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + -1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "r += dfs1(i + 1, s - v, p // (v + 1), 1)",
      "mutated_line": "r += dfs1(i + 1, s - v, p // (v + 2), 1)",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 2), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "r += dfs1(i + 1, s - v, p // (v + 1), 1)",
      "mutated_line": "r += dfs1(i + 1, s - v, p // (v + 0), 1)",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 0), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "r += dfs1(i + 1, s - v, p // (v + 1), 1)",
      "mutated_line": "r += dfs1(i + 1, s - v, p // (v + 0), 1)",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + 0), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "r += dfs1(i + 1, s - v, p // (v + 1), 1)",
      "mutated_line": "r += dfs1(i + 1, s - v, p // (v + -1), 1)",
      "code": "def count_special_numbers(D: str) -> int:\n    N = len(D)\n    DI = list(map(int, D))\n    su = sum(DI)\n    pd = 1\n    for d in D:\n        pd *= int(d) + 1\n    memo = [{} for _ in range(N)]\n\n    def dfs0(i, s, p):\n        key = (s, p)\n        if i == N:\n            return s > 0 or (s == 0 and p < pd)\n        if key in memo[i]:\n            return memo[i][key]\n        r = 0\n        for v in range(min(s, 9) + 1):\n            r += dfs0(i + 1, s - v, p * (v + 1))\n        memo[i][key] = r\n        return r\n    res1 = dfs0(0, su, 1)\n    memo1 = [{} for _ in range(N)]\n\n    def dfs1(i, s, p, m):\n        key = (s, p, m)\n        if i == N:\n            return s == 0 and p == 1\n        if key in memo1[i]:\n            return memo1[i][key]\n        r = 0\n        b = s - (N - 1 - i) * 9\n        di = DI[i]\n        for v in range(max(b, 0), min(s, 9) + 1):\n            if p % (v + 1):\n                continue\n            if m == 0:\n                if di < v:\n                    break\n                r += dfs1(i + 1, s - v, p // (v + 1), +(v < di))\n            else:\n                r += dfs1(i + 1, s - v, p // (v + -1), 1)\n        memo1[i][key] = r\n        return r\n    res2 = dfs1(0, su, pd, 0) - 1\n    ans = res1 + res2\n    return ans"
    }
  ]
}