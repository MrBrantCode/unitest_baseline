{
  "task_id": "taco_18610",
  "entry_point": "restore_network_topology",
  "mutant_count": 72,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dp = [[0] * n for _ in range(n)]",
      "mutated_line": "dp = [[0] / n for _ in range(n)]",
      "code": "def restore_network_topology(n, router_lists):\n    sub = [[] for _ in range(n)]\n    for i in range(n):\n        data = router_lists[i]\n        for j in data.split('-'):\n            tree = list(map(int, j.split(':')[1].split(',')))\n            for k in range(len(tree)):\n                tree[k] -= 1\n            sub[i].append(sorted(tree))\n        sub[i].sort()\n    dp = [[0] / n for _ in range(n)]\n    for i in range(n):\n        for j in sub[i]:\n            for k in j:\n                dp[i][k] = n - len(j)\n    g = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i < j and dp[i][j] + dp[j][i] == n:\n                g[i].append(j)\n                g[j].append(i)\n\n    def dfs(x, vis):\n        arr = [x]\n        vis[x] = True\n        pt = 0\n        while pt < len(arr):\n            y = arr[pt]\n            pt += 1\n            for i in g[y]:\n                if not vis[i]:\n                    vis[i] = True\n                    arr.append(i)\n        return sorted(arr)\n    for i in range(n):\n        subtree = []\n        vis = [False] * n\n        vis[i] = True\n        for j in g[i]:\n            arr = dfs(j, vis)\n            subtree.append(arr)\n        subtree.sort()\n        if subtree != sub[i]:\n            return -1\n    patch_cords = []\n    for i in range(n):\n        for j in g[i]:\n            if i < j:\n                patch_cords.append((i + 1, j + 1))\n    return (n - 1, patch_cords)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dp = [[0] * n for _ in range(n)]",
      "mutated_line": "dp = [[0] + n for _ in range(n)]",
      "code": "def restore_network_topology(n, router_lists):\n    sub = [[] for _ in range(n)]\n    for i in range(n):\n        data = router_lists[i]\n        for j in data.split('-'):\n            tree = list(map(int, j.split(':')[1].split(',')))\n            for k in range(len(tree)):\n                tree[k] -= 1\n            sub[i].append(sorted(tree))\n        sub[i].sort()\n    dp = [[0] + n for _ in range(n)]\n    for i in range(n):\n        for j in sub[i]:\n            for k in j:\n                dp[i][k] = n - len(j)\n    g = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i < j and dp[i][j] + dp[j][i] == n:\n                g[i].append(j)\n                g[j].append(i)\n\n    def dfs(x, vis):\n        arr = [x]\n        vis[x] = True\n        pt = 0\n        while pt < len(arr):\n            y = arr[pt]\n            pt += 1\n            for i in g[y]:\n                if not vis[i]:\n                    vis[i] = True\n                    arr.append(i)\n        return sorted(arr)\n    for i in range(n):\n        subtree = []\n        vis = [False] * n\n        vis[i] = True\n        for j in g[i]:\n            arr = dfs(j, vis)\n            subtree.append(arr)\n        subtree.sort()\n        if subtree != sub[i]:\n            return -1\n    patch_cords = []\n    for i in range(n):\n        for j in g[i]:\n            if i < j:\n                patch_cords.append((i + 1, j + 1))\n    return (n - 1, patch_cords)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dp = [[0] * n for _ in range(n)]",
      "mutated_line": "dp = [[0] ** n for _ in range(n)]",
      "code": "def restore_network_topology(n, router_lists):\n    sub = [[] for _ in range(n)]\n    for i in range(n):\n        data = router_lists[i]\n        for j in data.split('-'):\n            tree = list(map(int, j.split(':')[1].split(',')))\n            for k in range(len(tree)):\n                tree[k] -= 1\n            sub[i].append(sorted(tree))\n        sub[i].sort()\n    dp = [[0] ** n for _ in range(n)]\n    for i in range(n):\n        for j in sub[i]:\n            for k in j:\n                dp[i][k] = n - len(j)\n    g = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i < j and dp[i][j] + dp[j][i] == n:\n                g[i].append(j)\n                g[j].append(i)\n\n    def dfs(x, vis):\n        arr = [x]\n        vis[x] = True\n        pt = 0\n        while pt < len(arr):\n            y = arr[pt]\n            pt += 1\n            for i in g[y]:\n                if not vis[i]:\n                    vis[i] = True\n                    arr.append(i)\n        return sorted(arr)\n    for i in range(n):\n        subtree = []\n        vis = [False] * n\n        vis[i] = True\n        for j in g[i]:\n            arr = dfs(j, vis)\n            subtree.append(arr)\n        subtree.sort()\n        if subtree != sub[i]:\n            return -1\n    patch_cords = []\n    for i in range(n):\n        for j in g[i]:\n            if i < j:\n                patch_cords.append((i + 1, j + 1))\n    return (n - 1, patch_cords)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "vis[x] = True",
      "mutated_line": "vis[x] = False",
      "code": "def restore_network_topology(n, router_lists):\n    sub = [[] for _ in range(n)]\n    for i in range(n):\n        data = router_lists[i]\n        for j in data.split('-'):\n            tree = list(map(int, j.split(':')[1].split(',')))\n            for k in range(len(tree)):\n                tree[k] -= 1\n            sub[i].append(sorted(tree))\n        sub[i].sort()\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in sub[i]:\n            for k in j:\n                dp[i][k] = n - len(j)\n    g = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i < j and dp[i][j] + dp[j][i] == n:\n                g[i].append(j)\n                g[j].append(i)\n\n    def dfs(x, vis):\n        arr = [x]\n        vis[x] = False\n        pt = 0\n        while pt < len(arr):\n            y = arr[pt]\n            pt += 1\n            for i in g[y]:\n                if not vis[i]:\n                    vis[i] = True\n                    arr.append(i)\n        return sorted(arr)\n    for i in range(n):\n        subtree = []\n        vis = [False] * n\n        vis[i] = True\n        for j in g[i]:\n            arr = dfs(j, vis)\n            subtree.append(arr)\n        subtree.sort()\n        if subtree != sub[i]:\n            return -1\n    patch_cords = []\n    for i in range(n):\n        for j in g[i]:\n            if i < j:\n                patch_cords.append((i + 1, j + 1))\n    return (n - 1, patch_cords)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "pt = 0",
      "mutated_line": "pt = 1",
      "code": "def restore_network_topology(n, router_lists):\n    sub = [[] for _ in range(n)]\n    for i in range(n):\n        data = router_lists[i]\n        for j in data.split('-'):\n            tree = list(map(int, j.split(':')[1].split(',')))\n            for k in range(len(tree)):\n                tree[k] -= 1\n            sub[i].append(sorted(tree))\n        sub[i].sort()\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in sub[i]:\n            for k in j:\n                dp[i][k] = n - len(j)\n    g = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i < j and dp[i][j] + dp[j][i] == n:\n                g[i].append(j)\n                g[j].append(i)\n\n    def dfs(x, vis):\n        arr = [x]\n        vis[x] = True\n        pt = 1\n        while pt < len(arr):\n            y = arr[pt]\n            pt += 1\n            for i in g[y]:\n                if not vis[i]:\n                    vis[i] = True\n                    arr.append(i)\n        return sorted(arr)\n    for i in range(n):\n        subtree = []\n        vis = [False] * n\n        vis[i] = True\n        for j in g[i]:\n            arr = dfs(j, vis)\n            subtree.append(arr)\n        subtree.sort()\n        if subtree != sub[i]:\n            return -1\n    patch_cords = []\n    for i in range(n):\n        for j in g[i]:\n            if i < j:\n                patch_cords.append((i + 1, j + 1))\n    return (n - 1, patch_cords)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "pt = 0",
      "mutated_line": "pt = -1",
      "code": "def restore_network_topology(n, router_lists):\n    sub = [[] for _ in range(n)]\n    for i in range(n):\n        data = router_lists[i]\n        for j in data.split('-'):\n            tree = list(map(int, j.split(':')[1].split(',')))\n            for k in range(len(tree)):\n                tree[k] -= 1\n            sub[i].append(sorted(tree))\n        sub[i].sort()\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in sub[i]:\n            for k in j:\n                dp[i][k] = n - len(j)\n    g = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i < j and dp[i][j] + dp[j][i] == n:\n                g[i].append(j)\n                g[j].append(i)\n\n    def dfs(x, vis):\n        arr = [x]\n        vis[x] = True\n        pt = -1\n        while pt < len(arr):\n            y = arr[pt]\n            pt += 1\n            for i in g[y]:\n                if not vis[i]:\n                    vis[i] = True\n                    arr.append(i)\n        return sorted(arr)\n    for i in range(n):\n        subtree = []\n        vis = [False] * n\n        vis[i] = True\n        for j in g[i]:\n            arr = dfs(j, vis)\n            subtree.append(arr)\n        subtree.sort()\n        if subtree != sub[i]:\n            return -1\n    patch_cords = []\n    for i in range(n):\n        for j in g[i]:\n            if i < j:\n                patch_cords.append((i + 1, j + 1))\n    return (n - 1, patch_cords)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "pt = 0",
      "mutated_line": "pt = 1",
      "code": "def restore_network_topology(n, router_lists):\n    sub = [[] for _ in range(n)]\n    for i in range(n):\n        data = router_lists[i]\n        for j in data.split('-'):\n            tree = list(map(int, j.split(':')[1].split(',')))\n            for k in range(len(tree)):\n                tree[k] -= 1\n            sub[i].append(sorted(tree))\n        sub[i].sort()\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in sub[i]:\n            for k in j:\n                dp[i][k] = n - len(j)\n    g = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i < j and dp[i][j] + dp[j][i] == n:\n                g[i].append(j)\n                g[j].append(i)\n\n    def dfs(x, vis):\n        arr = [x]\n        vis[x] = True\n        pt = 1\n        while pt < len(arr):\n            y = arr[pt]\n            pt += 1\n            for i in g[y]:\n                if not vis[i]:\n                    vis[i] = True\n                    arr.append(i)\n        return sorted(arr)\n    for i in range(n):\n        subtree = []\n        vis = [False] * n\n        vis[i] = True\n        for j in g[i]:\n            arr = dfs(j, vis)\n            subtree.append(arr)\n        subtree.sort()\n        if subtree != sub[i]:\n            return -1\n    patch_cords = []\n    for i in range(n):\n        for j in g[i]:\n            if i < j:\n                patch_cords.append((i + 1, j + 1))\n    return (n - 1, patch_cords)"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "while pt < len(arr):",
      "mutated_line": "while pt <= len(arr):",
      "code": "def restore_network_topology(n, router_lists):\n    sub = [[] for _ in range(n)]\n    for i in range(n):\n        data = router_lists[i]\n        for j in data.split('-'):\n            tree = list(map(int, j.split(':')[1].split(',')))\n            for k in range(len(tree)):\n                tree[k] -= 1\n            sub[i].append(sorted(tree))\n        sub[i].sort()\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in sub[i]:\n            for k in j:\n                dp[i][k] = n - len(j)\n    g = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i < j and dp[i][j] + dp[j][i] == n:\n                g[i].append(j)\n                g[j].append(i)\n\n    def dfs(x, vis):\n        arr = [x]\n        vis[x] = True\n        pt = 0\n        while pt <= len(arr):\n            y = arr[pt]\n            pt += 1\n            for i in g[y]:\n                if not vis[i]:\n                    vis[i] = True\n                    arr.append(i)\n        return sorted(arr)\n    for i in range(n):\n        subtree = []\n        vis = [False] * n\n        vis[i] = True\n        for j in g[i]:\n            arr = dfs(j, vis)\n            subtree.append(arr)\n        subtree.sort()\n        if subtree != sub[i]:\n            return -1\n    patch_cords = []\n    for i in range(n):\n        for j in g[i]:\n            if i < j:\n                patch_cords.append((i + 1, j + 1))\n    return (n - 1, patch_cords)"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "while pt < len(arr):",
      "mutated_line": "while pt >= len(arr):",
      "code": "def restore_network_topology(n, router_lists):\n    sub = [[] for _ in range(n)]\n    for i in range(n):\n        data = router_lists[i]\n        for j in data.split('-'):\n            tree = list(map(int, j.split(':')[1].split(',')))\n            for k in range(len(tree)):\n                tree[k] -= 1\n            sub[i].append(sorted(tree))\n        sub[i].sort()\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in sub[i]:\n            for k in j:\n                dp[i][k] = n - len(j)\n    g = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i < j and dp[i][j] + dp[j][i] == n:\n                g[i].append(j)\n                g[j].append(i)\n\n    def dfs(x, vis):\n        arr = [x]\n        vis[x] = True\n        pt = 0\n        while pt >= len(arr):\n            y = arr[pt]\n            pt += 1\n            for i in g[y]:\n                if not vis[i]:\n                    vis[i] = True\n                    arr.append(i)\n        return sorted(arr)\n    for i in range(n):\n        subtree = []\n        vis = [False] * n\n        vis[i] = True\n        for j in g[i]:\n            arr = dfs(j, vis)\n            subtree.append(arr)\n        subtree.sort()\n        if subtree != sub[i]:\n            return -1\n    patch_cords = []\n    for i in range(n):\n        for j in g[i]:\n            if i < j:\n                patch_cords.append((i + 1, j + 1))\n    return (n - 1, patch_cords)"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "while pt < len(arr):",
      "mutated_line": "while pt != len(arr):",
      "code": "def restore_network_topology(n, router_lists):\n    sub = [[] for _ in range(n)]\n    for i in range(n):\n        data = router_lists[i]\n        for j in data.split('-'):\n            tree = list(map(int, j.split(':')[1].split(',')))\n            for k in range(len(tree)):\n                tree[k] -= 1\n            sub[i].append(sorted(tree))\n        sub[i].sort()\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in sub[i]:\n            for k in j:\n                dp[i][k] = n - len(j)\n    g = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i < j and dp[i][j] + dp[j][i] == n:\n                g[i].append(j)\n                g[j].append(i)\n\n    def dfs(x, vis):\n        arr = [x]\n        vis[x] = True\n        pt = 0\n        while pt != len(arr):\n            y = arr[pt]\n            pt += 1\n            for i in g[y]:\n                if not vis[i]:\n                    vis[i] = True\n                    arr.append(i)\n        return sorted(arr)\n    for i in range(n):\n        subtree = []\n        vis = [False] * n\n        vis[i] = True\n        for j in g[i]:\n            arr = dfs(j, vis)\n            subtree.append(arr)\n        subtree.sort()\n        if subtree != sub[i]:\n            return -1\n    patch_cords = []\n    for i in range(n):\n        for j in g[i]:\n            if i < j:\n                patch_cords.append((i + 1, j + 1))\n    return (n - 1, patch_cords)"
    },
    {
      "operator": "ASR",
      "lineno": 31,
      "original_line": "pt += 1",
      "mutated_line": "pt -= 1",
      "code": "def restore_network_topology(n, router_lists):\n    sub = [[] for _ in range(n)]\n    for i in range(n):\n        data = router_lists[i]\n        for j in data.split('-'):\n            tree = list(map(int, j.split(':')[1].split(',')))\n            for k in range(len(tree)):\n                tree[k] -= 1\n            sub[i].append(sorted(tree))\n        sub[i].sort()\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in sub[i]:\n            for k in j:\n                dp[i][k] = n - len(j)\n    g = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i < j and dp[i][j] + dp[j][i] == n:\n                g[i].append(j)\n                g[j].append(i)\n\n    def dfs(x, vis):\n        arr = [x]\n        vis[x] = True\n        pt = 0\n        while pt < len(arr):\n            y = arr[pt]\n            pt -= 1\n            for i in g[y]:\n                if not vis[i]:\n                    vis[i] = True\n                    arr.append(i)\n        return sorted(arr)\n    for i in range(n):\n        subtree = []\n        vis = [False] * n\n        vis[i] = True\n        for j in g[i]:\n            arr = dfs(j, vis)\n            subtree.append(arr)\n        subtree.sort()\n        if subtree != sub[i]:\n            return -1\n    patch_cords = []\n    for i in range(n):\n        for j in g[i]:\n            if i < j:\n                patch_cords.append((i + 1, j + 1))\n    return (n - 1, patch_cords)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "vis = [False] * n",
      "mutated_line": "vis = [False] / n",
      "code": "def restore_network_topology(n, router_lists):\n    sub = [[] for _ in range(n)]\n    for i in range(n):\n        data = router_lists[i]\n        for j in data.split('-'):\n            tree = list(map(int, j.split(':')[1].split(',')))\n            for k in range(len(tree)):\n                tree[k] -= 1\n            sub[i].append(sorted(tree))\n        sub[i].sort()\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in sub[i]:\n            for k in j:\n                dp[i][k] = n - len(j)\n    g = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i < j and dp[i][j] + dp[j][i] == n:\n                g[i].append(j)\n                g[j].append(i)\n\n    def dfs(x, vis):\n        arr = [x]\n        vis[x] = True\n        pt = 0\n        while pt < len(arr):\n            y = arr[pt]\n            pt += 1\n            for i in g[y]:\n                if not vis[i]:\n                    vis[i] = True\n                    arr.append(i)\n        return sorted(arr)\n    for i in range(n):\n        subtree = []\n        vis = [False] / n\n        vis[i] = True\n        for j in g[i]:\n            arr = dfs(j, vis)\n            subtree.append(arr)\n        subtree.sort()\n        if subtree != sub[i]:\n            return -1\n    patch_cords = []\n    for i in range(n):\n        for j in g[i]:\n            if i < j:\n                patch_cords.append((i + 1, j + 1))\n    return (n - 1, patch_cords)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "vis = [False] * n",
      "mutated_line": "vis = [False] + n",
      "code": "def restore_network_topology(n, router_lists):\n    sub = [[] for _ in range(n)]\n    for i in range(n):\n        data = router_lists[i]\n        for j in data.split('-'):\n            tree = list(map(int, j.split(':')[1].split(',')))\n            for k in range(len(tree)):\n                tree[k] -= 1\n            sub[i].append(sorted(tree))\n        sub[i].sort()\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in sub[i]:\n            for k in j:\n                dp[i][k] = n - len(j)\n    g = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i < j and dp[i][j] + dp[j][i] == n:\n                g[i].append(j)\n                g[j].append(i)\n\n    def dfs(x, vis):\n        arr = [x]\n        vis[x] = True\n        pt = 0\n        while pt < len(arr):\n            y = arr[pt]\n            pt += 1\n            for i in g[y]:\n                if not vis[i]:\n                    vis[i] = True\n                    arr.append(i)\n        return sorted(arr)\n    for i in range(n):\n        subtree = []\n        vis = [False] + n\n        vis[i] = True\n        for j in g[i]:\n            arr = dfs(j, vis)\n            subtree.append(arr)\n        subtree.sort()\n        if subtree != sub[i]:\n            return -1\n    patch_cords = []\n    for i in range(n):\n        for j in g[i]:\n            if i < j:\n                patch_cords.append((i + 1, j + 1))\n    return (n - 1, patch_cords)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "vis = [False] * n",
      "mutated_line": "vis = [False] ** n",
      "code": "def restore_network_topology(n, router_lists):\n    sub = [[] for _ in range(n)]\n    for i in range(n):\n        data = router_lists[i]\n        for j in data.split('-'):\n            tree = list(map(int, j.split(':')[1].split(',')))\n            for k in range(len(tree)):\n                tree[k] -= 1\n            sub[i].append(sorted(tree))\n        sub[i].sort()\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in sub[i]:\n            for k in j:\n                dp[i][k] = n - len(j)\n    g = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i < j and dp[i][j] + dp[j][i] == n:\n                g[i].append(j)\n                g[j].append(i)\n\n    def dfs(x, vis):\n        arr = [x]\n        vis[x] = True\n        pt = 0\n        while pt < len(arr):\n            y = arr[pt]\n            pt += 1\n            for i in g[y]:\n                if not vis[i]:\n                    vis[i] = True\n                    arr.append(i)\n        return sorted(arr)\n    for i in range(n):\n        subtree = []\n        vis = [False] ** n\n        vis[i] = True\n        for j in g[i]:\n            arr = dfs(j, vis)\n            subtree.append(arr)\n        subtree.sort()\n        if subtree != sub[i]:\n            return -1\n    patch_cords = []\n    for i in range(n):\n        for j in g[i]:\n            if i < j:\n                patch_cords.append((i + 1, j + 1))\n    return (n - 1, patch_cords)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "vis[i] = True",
      "mutated_line": "vis[i] = False",
      "code": "def restore_network_topology(n, router_lists):\n    sub = [[] for _ in range(n)]\n    for i in range(n):\n        data = router_lists[i]\n        for j in data.split('-'):\n            tree = list(map(int, j.split(':')[1].split(',')))\n            for k in range(len(tree)):\n                tree[k] -= 1\n            sub[i].append(sorted(tree))\n        sub[i].sort()\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in sub[i]:\n            for k in j:\n                dp[i][k] = n - len(j)\n    g = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i < j and dp[i][j] + dp[j][i] == n:\n                g[i].append(j)\n                g[j].append(i)\n\n    def dfs(x, vis):\n        arr = [x]\n        vis[x] = True\n        pt = 0\n        while pt < len(arr):\n            y = arr[pt]\n            pt += 1\n            for i in g[y]:\n                if not vis[i]:\n                    vis[i] = True\n                    arr.append(i)\n        return sorted(arr)\n    for i in range(n):\n        subtree = []\n        vis = [False] * n\n        vis[i] = False\n        for j in g[i]:\n            arr = dfs(j, vis)\n            subtree.append(arr)\n        subtree.sort()\n        if subtree != sub[i]:\n            return -1\n    patch_cords = []\n    for i in range(n):\n        for j in g[i]:\n            if i < j:\n                patch_cords.append((i + 1, j + 1))\n    return (n - 1, patch_cords)"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "if subtree != sub[i]:",
      "mutated_line": "if subtree == sub[i]:",
      "code": "def restore_network_topology(n, router_lists):\n    sub = [[] for _ in range(n)]\n    for i in range(n):\n        data = router_lists[i]\n        for j in data.split('-'):\n            tree = list(map(int, j.split(':')[1].split(',')))\n            for k in range(len(tree)):\n                tree[k] -= 1\n            sub[i].append(sorted(tree))\n        sub[i].sort()\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in sub[i]:\n            for k in j:\n                dp[i][k] = n - len(j)\n    g = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i < j and dp[i][j] + dp[j][i] == n:\n                g[i].append(j)\n                g[j].append(i)\n\n    def dfs(x, vis):\n        arr = [x]\n        vis[x] = True\n        pt = 0\n        while pt < len(arr):\n            y = arr[pt]\n            pt += 1\n            for i in g[y]:\n                if not vis[i]:\n                    vis[i] = True\n                    arr.append(i)\n        return sorted(arr)\n    for i in range(n):\n        subtree = []\n        vis = [False] * n\n        vis[i] = True\n        for j in g[i]:\n            arr = dfs(j, vis)\n            subtree.append(arr)\n        subtree.sort()\n        if subtree == sub[i]:\n            return -1\n    patch_cords = []\n    for i in range(n):\n        for j in g[i]:\n            if i < j:\n                patch_cords.append((i + 1, j + 1))\n    return (n - 1, patch_cords)"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "return (n - 1, patch_cords)",
      "mutated_line": "return (n + 1, patch_cords)",
      "code": "def restore_network_topology(n, router_lists):\n    sub = [[] for _ in range(n)]\n    for i in range(n):\n        data = router_lists[i]\n        for j in data.split('-'):\n            tree = list(map(int, j.split(':')[1].split(',')))\n            for k in range(len(tree)):\n                tree[k] -= 1\n            sub[i].append(sorted(tree))\n        sub[i].sort()\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in sub[i]:\n            for k in j:\n                dp[i][k] = n - len(j)\n    g = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i < j and dp[i][j] + dp[j][i] == n:\n                g[i].append(j)\n                g[j].append(i)\n\n    def dfs(x, vis):\n        arr = [x]\n        vis[x] = True\n        pt = 0\n        while pt < len(arr):\n            y = arr[pt]\n            pt += 1\n            for i in g[y]:\n                if not vis[i]:\n                    vis[i] = True\n                    arr.append(i)\n        return sorted(arr)\n    for i in range(n):\n        subtree = []\n        vis = [False] * n\n        vis[i] = True\n        for j in g[i]:\n            arr = dfs(j, vis)\n            subtree.append(arr)\n        subtree.sort()\n        if subtree != sub[i]:\n            return -1\n    patch_cords = []\n    for i in range(n):\n        for j in g[i]:\n            if i < j:\n                patch_cords.append((i + 1, j + 1))\n    return (n + 1, patch_cords)"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "return (n - 1, patch_cords)",
      "mutated_line": "return (n * 1, patch_cords)",
      "code": "def restore_network_topology(n, router_lists):\n    sub = [[] for _ in range(n)]\n    for i in range(n):\n        data = router_lists[i]\n        for j in data.split('-'):\n            tree = list(map(int, j.split(':')[1].split(',')))\n            for k in range(len(tree)):\n                tree[k] -= 1\n            sub[i].append(sorted(tree))\n        sub[i].sort()\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in sub[i]:\n            for k in j:\n                dp[i][k] = n - len(j)\n    g = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i < j and dp[i][j] + dp[j][i] == n:\n                g[i].append(j)\n                g[j].append(i)\n\n    def dfs(x, vis):\n        arr = [x]\n        vis[x] = True\n        pt = 0\n        while pt < len(arr):\n            y = arr[pt]\n            pt += 1\n            for i in g[y]:\n                if not vis[i]:\n                    vis[i] = True\n                    arr.append(i)\n        return sorted(arr)\n    for i in range(n):\n        subtree = []\n        vis = [False] * n\n        vis[i] = True\n        for j in g[i]:\n            arr = dfs(j, vis)\n            subtree.append(arr)\n        subtree.sort()\n        if subtree != sub[i]:\n            return -1\n    patch_cords = []\n    for i in range(n):\n        for j in g[i]:\n            if i < j:\n                patch_cords.append((i + 1, j + 1))\n    return (n * 1, patch_cords)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for j in data.split('-'):",
      "mutated_line": "for j in data.split(''):",
      "code": "def restore_network_topology(n, router_lists):\n    sub = [[] for _ in range(n)]\n    for i in range(n):\n        data = router_lists[i]\n        for j in data.split(''):\n            tree = list(map(int, j.split(':')[1].split(',')))\n            for k in range(len(tree)):\n                tree[k] -= 1\n            sub[i].append(sorted(tree))\n        sub[i].sort()\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in sub[i]:\n            for k in j:\n                dp[i][k] = n - len(j)\n    g = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i < j and dp[i][j] + dp[j][i] == n:\n                g[i].append(j)\n                g[j].append(i)\n\n    def dfs(x, vis):\n        arr = [x]\n        vis[x] = True\n        pt = 0\n        while pt < len(arr):\n            y = arr[pt]\n            pt += 1\n            for i in g[y]:\n                if not vis[i]:\n                    vis[i] = True\n                    arr.append(i)\n        return sorted(arr)\n    for i in range(n):\n        subtree = []\n        vis = [False] * n\n        vis[i] = True\n        for j in g[i]:\n            arr = dfs(j, vis)\n            subtree.append(arr)\n        subtree.sort()\n        if subtree != sub[i]:\n            return -1\n    patch_cords = []\n    for i in range(n):\n        for j in g[i]:\n            if i < j:\n                patch_cords.append((i + 1, j + 1))\n    return (n - 1, patch_cords)"
    },
    {
      "operator": "ASR",
      "lineno": 8,
      "original_line": "tree[k] -= 1",
      "mutated_line": "tree[k] += 1",
      "code": "def restore_network_topology(n, router_lists):\n    sub = [[] for _ in range(n)]\n    for i in range(n):\n        data = router_lists[i]\n        for j in data.split('-'):\n            tree = list(map(int, j.split(':')[1].split(',')))\n            for k in range(len(tree)):\n                tree[k] += 1\n            sub[i].append(sorted(tree))\n        sub[i].sort()\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in sub[i]:\n            for k in j:\n                dp[i][k] = n - len(j)\n    g = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i < j and dp[i][j] + dp[j][i] == n:\n                g[i].append(j)\n                g[j].append(i)\n\n    def dfs(x, vis):\n        arr = [x]\n        vis[x] = True\n        pt = 0\n        while pt < len(arr):\n            y = arr[pt]\n            pt += 1\n            for i in g[y]:\n                if not vis[i]:\n                    vis[i] = True\n                    arr.append(i)\n        return sorted(arr)\n    for i in range(n):\n        subtree = []\n        vis = [False] * n\n        vis[i] = True\n        for j in g[i]:\n            arr = dfs(j, vis)\n            subtree.append(arr)\n        subtree.sort()\n        if subtree != sub[i]:\n            return -1\n    patch_cords = []\n    for i in range(n):\n        for j in g[i]:\n            if i < j:\n                patch_cords.append((i + 1, j + 1))\n    return (n - 1, patch_cords)"
    },
    {
      "operator": "LCR",
      "lineno": 21,
      "original_line": "if i < j and dp[i][j] + dp[j][i] == n:",
      "mutated_line": "if i < j or dp[i][j] + dp[j][i] == n:",
      "code": "def restore_network_topology(n, router_lists):\n    sub = [[] for _ in range(n)]\n    for i in range(n):\n        data = router_lists[i]\n        for j in data.split('-'):\n            tree = list(map(int, j.split(':')[1].split(',')))\n            for k in range(len(tree)):\n                tree[k] -= 1\n            sub[i].append(sorted(tree))\n        sub[i].sort()\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in sub[i]:\n            for k in j:\n                dp[i][k] = n - len(j)\n    g = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i < j or dp[i][j] + dp[j][i] == n:\n                g[i].append(j)\n                g[j].append(i)\n\n    def dfs(x, vis):\n        arr = [x]\n        vis[x] = True\n        pt = 0\n        while pt < len(arr):\n            y = arr[pt]\n            pt += 1\n            for i in g[y]:\n                if not vis[i]:\n                    vis[i] = True\n                    arr.append(i)\n        return sorted(arr)\n    for i in range(n):\n        subtree = []\n        vis = [False] * n\n        vis[i] = True\n        for j in g[i]:\n            arr = dfs(j, vis)\n            subtree.append(arr)\n        subtree.sort()\n        if subtree != sub[i]:\n            return -1\n    patch_cords = []\n    for i in range(n):\n        for j in g[i]:\n            if i < j:\n                patch_cords.append((i + 1, j + 1))\n    return (n - 1, patch_cords)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "pt += 1",
      "mutated_line": "pt += 2",
      "code": "def restore_network_topology(n, router_lists):\n    sub = [[] for _ in range(n)]\n    for i in range(n):\n        data = router_lists[i]\n        for j in data.split('-'):\n            tree = list(map(int, j.split(':')[1].split(',')))\n            for k in range(len(tree)):\n                tree[k] -= 1\n            sub[i].append(sorted(tree))\n        sub[i].sort()\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in sub[i]:\n            for k in j:\n                dp[i][k] = n - len(j)\n    g = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i < j and dp[i][j] + dp[j][i] == n:\n                g[i].append(j)\n                g[j].append(i)\n\n    def dfs(x, vis):\n        arr = [x]\n        vis[x] = True\n        pt = 0\n        while pt < len(arr):\n            y = arr[pt]\n            pt += 2\n            for i in g[y]:\n                if not vis[i]:\n                    vis[i] = True\n                    arr.append(i)\n        return sorted(arr)\n    for i in range(n):\n        subtree = []\n        vis = [False] * n\n        vis[i] = True\n        for j in g[i]:\n            arr = dfs(j, vis)\n            subtree.append(arr)\n        subtree.sort()\n        if subtree != sub[i]:\n            return -1\n    patch_cords = []\n    for i in range(n):\n        for j in g[i]:\n            if i < j:\n                patch_cords.append((i + 1, j + 1))\n    return (n - 1, patch_cords)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "pt += 1",
      "mutated_line": "pt += 0",
      "code": "def restore_network_topology(n, router_lists):\n    sub = [[] for _ in range(n)]\n    for i in range(n):\n        data = router_lists[i]\n        for j in data.split('-'):\n            tree = list(map(int, j.split(':')[1].split(',')))\n            for k in range(len(tree)):\n                tree[k] -= 1\n            sub[i].append(sorted(tree))\n        sub[i].sort()\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in sub[i]:\n            for k in j:\n                dp[i][k] = n - len(j)\n    g = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i < j and dp[i][j] + dp[j][i] == n:\n                g[i].append(j)\n                g[j].append(i)\n\n    def dfs(x, vis):\n        arr = [x]\n        vis[x] = True\n        pt = 0\n        while pt < len(arr):\n            y = arr[pt]\n            pt += 0\n            for i in g[y]:\n                if not vis[i]:\n                    vis[i] = True\n                    arr.append(i)\n        return sorted(arr)\n    for i in range(n):\n        subtree = []\n        vis = [False] * n\n        vis[i] = True\n        for j in g[i]:\n            arr = dfs(j, vis)\n            subtree.append(arr)\n        subtree.sort()\n        if subtree != sub[i]:\n            return -1\n    patch_cords = []\n    for i in range(n):\n        for j in g[i]:\n            if i < j:\n                patch_cords.append((i + 1, j + 1))\n    return (n - 1, patch_cords)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "pt += 1",
      "mutated_line": "pt += 0",
      "code": "def restore_network_topology(n, router_lists):\n    sub = [[] for _ in range(n)]\n    for i in range(n):\n        data = router_lists[i]\n        for j in data.split('-'):\n            tree = list(map(int, j.split(':')[1].split(',')))\n            for k in range(len(tree)):\n                tree[k] -= 1\n            sub[i].append(sorted(tree))\n        sub[i].sort()\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in sub[i]:\n            for k in j:\n                dp[i][k] = n - len(j)\n    g = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i < j and dp[i][j] + dp[j][i] == n:\n                g[i].append(j)\n                g[j].append(i)\n\n    def dfs(x, vis):\n        arr = [x]\n        vis[x] = True\n        pt = 0\n        while pt < len(arr):\n            y = arr[pt]\n            pt += 0\n            for i in g[y]:\n                if not vis[i]:\n                    vis[i] = True\n                    arr.append(i)\n        return sorted(arr)\n    for i in range(n):\n        subtree = []\n        vis = [False] * n\n        vis[i] = True\n        for j in g[i]:\n            arr = dfs(j, vis)\n            subtree.append(arr)\n        subtree.sort()\n        if subtree != sub[i]:\n            return -1\n    patch_cords = []\n    for i in range(n):\n        for j in g[i]:\n            if i < j:\n                patch_cords.append((i + 1, j + 1))\n    return (n - 1, patch_cords)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "pt += 1",
      "mutated_line": "pt += -1",
      "code": "def restore_network_topology(n, router_lists):\n    sub = [[] for _ in range(n)]\n    for i in range(n):\n        data = router_lists[i]\n        for j in data.split('-'):\n            tree = list(map(int, j.split(':')[1].split(',')))\n            for k in range(len(tree)):\n                tree[k] -= 1\n            sub[i].append(sorted(tree))\n        sub[i].sort()\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in sub[i]:\n            for k in j:\n                dp[i][k] = n - len(j)\n    g = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i < j and dp[i][j] + dp[j][i] == n:\n                g[i].append(j)\n                g[j].append(i)\n\n    def dfs(x, vis):\n        arr = [x]\n        vis[x] = True\n        pt = 0\n        while pt < len(arr):\n            y = arr[pt]\n            pt += -1\n            for i in g[y]:\n                if not vis[i]:\n                    vis[i] = True\n                    arr.append(i)\n        return sorted(arr)\n    for i in range(n):\n        subtree = []\n        vis = [False] * n\n        vis[i] = True\n        for j in g[i]:\n            arr = dfs(j, vis)\n            subtree.append(arr)\n        subtree.sort()\n        if subtree != sub[i]:\n            return -1\n    patch_cords = []\n    for i in range(n):\n        for j in g[i]:\n            if i < j:\n                patch_cords.append((i + 1, j + 1))\n    return (n - 1, patch_cords)"
    },
    {
      "operator": "UOI",
      "lineno": 47,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def restore_network_topology(n, router_lists):\n    sub = [[] for _ in range(n)]\n    for i in range(n):\n        data = router_lists[i]\n        for j in data.split('-'):\n            tree = list(map(int, j.split(':')[1].split(',')))\n            for k in range(len(tree)):\n                tree[k] -= 1\n            sub[i].append(sorted(tree))\n        sub[i].sort()\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in sub[i]:\n            for k in j:\n                dp[i][k] = n - len(j)\n    g = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i < j and dp[i][j] + dp[j][i] == n:\n                g[i].append(j)\n                g[j].append(i)\n\n    def dfs(x, vis):\n        arr = [x]\n        vis[x] = True\n        pt = 0\n        while pt < len(arr):\n            y = arr[pt]\n            pt += 1\n            for i in g[y]:\n                if not vis[i]:\n                    vis[i] = True\n                    arr.append(i)\n        return sorted(arr)\n    for i in range(n):\n        subtree = []\n        vis = [False] * n\n        vis[i] = True\n        for j in g[i]:\n            arr = dfs(j, vis)\n            subtree.append(arr)\n        subtree.sort()\n        if subtree != sub[i]:\n            return +1\n    patch_cords = []\n    for i in range(n):\n        for j in g[i]:\n            if i < j:\n                patch_cords.append((i + 1, j + 1))\n    return (n - 1, patch_cords)"
    },
    {
      "operator": "ROR",
      "lineno": 52,
      "original_line": "if i < j:",
      "mutated_line": "if i <= j:",
      "code": "def restore_network_topology(n, router_lists):\n    sub = [[] for _ in range(n)]\n    for i in range(n):\n        data = router_lists[i]\n        for j in data.split('-'):\n            tree = list(map(int, j.split(':')[1].split(',')))\n            for k in range(len(tree)):\n                tree[k] -= 1\n            sub[i].append(sorted(tree))\n        sub[i].sort()\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in sub[i]:\n            for k in j:\n                dp[i][k] = n - len(j)\n    g = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i < j and dp[i][j] + dp[j][i] == n:\n                g[i].append(j)\n                g[j].append(i)\n\n    def dfs(x, vis):\n        arr = [x]\n        vis[x] = True\n        pt = 0\n        while pt < len(arr):\n            y = arr[pt]\n            pt += 1\n            for i in g[y]:\n                if not vis[i]:\n                    vis[i] = True\n                    arr.append(i)\n        return sorted(arr)\n    for i in range(n):\n        subtree = []\n        vis = [False] * n\n        vis[i] = True\n        for j in g[i]:\n            arr = dfs(j, vis)\n            subtree.append(arr)\n        subtree.sort()\n        if subtree != sub[i]:\n            return -1\n    patch_cords = []\n    for i in range(n):\n        for j in g[i]:\n            if i <= j:\n                patch_cords.append((i + 1, j + 1))\n    return (n - 1, patch_cords)"
    },
    {
      "operator": "ROR",
      "lineno": 52,
      "original_line": "if i < j:",
      "mutated_line": "if i >= j:",
      "code": "def restore_network_topology(n, router_lists):\n    sub = [[] for _ in range(n)]\n    for i in range(n):\n        data = router_lists[i]\n        for j in data.split('-'):\n            tree = list(map(int, j.split(':')[1].split(',')))\n            for k in range(len(tree)):\n                tree[k] -= 1\n            sub[i].append(sorted(tree))\n        sub[i].sort()\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in sub[i]:\n            for k in j:\n                dp[i][k] = n - len(j)\n    g = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i < j and dp[i][j] + dp[j][i] == n:\n                g[i].append(j)\n                g[j].append(i)\n\n    def dfs(x, vis):\n        arr = [x]\n        vis[x] = True\n        pt = 0\n        while pt < len(arr):\n            y = arr[pt]\n            pt += 1\n            for i in g[y]:\n                if not vis[i]:\n                    vis[i] = True\n                    arr.append(i)\n        return sorted(arr)\n    for i in range(n):\n        subtree = []\n        vis = [False] * n\n        vis[i] = True\n        for j in g[i]:\n            arr = dfs(j, vis)\n            subtree.append(arr)\n        subtree.sort()\n        if subtree != sub[i]:\n            return -1\n    patch_cords = []\n    for i in range(n):\n        for j in g[i]:\n            if i >= j:\n                patch_cords.append((i + 1, j + 1))\n    return (n - 1, patch_cords)"
    },
    {
      "operator": "ROR",
      "lineno": 52,
      "original_line": "if i < j:",
      "mutated_line": "if i != j:",
      "code": "def restore_network_topology(n, router_lists):\n    sub = [[] for _ in range(n)]\n    for i in range(n):\n        data = router_lists[i]\n        for j in data.split('-'):\n            tree = list(map(int, j.split(':')[1].split(',')))\n            for k in range(len(tree)):\n                tree[k] -= 1\n            sub[i].append(sorted(tree))\n        sub[i].sort()\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in sub[i]:\n            for k in j:\n                dp[i][k] = n - len(j)\n    g = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i < j and dp[i][j] + dp[j][i] == n:\n                g[i].append(j)\n                g[j].append(i)\n\n    def dfs(x, vis):\n        arr = [x]\n        vis[x] = True\n        pt = 0\n        while pt < len(arr):\n            y = arr[pt]\n            pt += 1\n            for i in g[y]:\n                if not vis[i]:\n                    vis[i] = True\n                    arr.append(i)\n        return sorted(arr)\n    for i in range(n):\n        subtree = []\n        vis = [False] * n\n        vis[i] = True\n        for j in g[i]:\n            arr = dfs(j, vis)\n            subtree.append(arr)\n        subtree.sort()\n        if subtree != sub[i]:\n            return -1\n    patch_cords = []\n    for i in range(n):\n        for j in g[i]:\n            if i != j:\n                patch_cords.append((i + 1, j + 1))\n    return (n - 1, patch_cords)"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return (n - 1, patch_cords)",
      "mutated_line": "return (n - 2, patch_cords)",
      "code": "def restore_network_topology(n, router_lists):\n    sub = [[] for _ in range(n)]\n    for i in range(n):\n        data = router_lists[i]\n        for j in data.split('-'):\n            tree = list(map(int, j.split(':')[1].split(',')))\n            for k in range(len(tree)):\n                tree[k] -= 1\n            sub[i].append(sorted(tree))\n        sub[i].sort()\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in sub[i]:\n            for k in j:\n                dp[i][k] = n - len(j)\n    g = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i < j and dp[i][j] + dp[j][i] == n:\n                g[i].append(j)\n                g[j].append(i)\n\n    def dfs(x, vis):\n        arr = [x]\n        vis[x] = True\n        pt = 0\n        while pt < len(arr):\n            y = arr[pt]\n            pt += 1\n            for i in g[y]:\n                if not vis[i]:\n                    vis[i] = True\n                    arr.append(i)\n        return sorted(arr)\n    for i in range(n):\n        subtree = []\n        vis = [False] * n\n        vis[i] = True\n        for j in g[i]:\n            arr = dfs(j, vis)\n            subtree.append(arr)\n        subtree.sort()\n        if subtree != sub[i]:\n            return -1\n    patch_cords = []\n    for i in range(n):\n        for j in g[i]:\n            if i < j:\n                patch_cords.append((i + 1, j + 1))\n    return (n - 2, patch_cords)"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return (n - 1, patch_cords)",
      "mutated_line": "return (n - 0, patch_cords)",
      "code": "def restore_network_topology(n, router_lists):\n    sub = [[] for _ in range(n)]\n    for i in range(n):\n        data = router_lists[i]\n        for j in data.split('-'):\n            tree = list(map(int, j.split(':')[1].split(',')))\n            for k in range(len(tree)):\n                tree[k] -= 1\n            sub[i].append(sorted(tree))\n        sub[i].sort()\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in sub[i]:\n            for k in j:\n                dp[i][k] = n - len(j)\n    g = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i < j and dp[i][j] + dp[j][i] == n:\n                g[i].append(j)\n                g[j].append(i)\n\n    def dfs(x, vis):\n        arr = [x]\n        vis[x] = True\n        pt = 0\n        while pt < len(arr):\n            y = arr[pt]\n            pt += 1\n            for i in g[y]:\n                if not vis[i]:\n                    vis[i] = True\n                    arr.append(i)\n        return sorted(arr)\n    for i in range(n):\n        subtree = []\n        vis = [False] * n\n        vis[i] = True\n        for j in g[i]:\n            arr = dfs(j, vis)\n            subtree.append(arr)\n        subtree.sort()\n        if subtree != sub[i]:\n            return -1\n    patch_cords = []\n    for i in range(n):\n        for j in g[i]:\n            if i < j:\n                patch_cords.append((i + 1, j + 1))\n    return (n - 0, patch_cords)"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return (n - 1, patch_cords)",
      "mutated_line": "return (n - 0, patch_cords)",
      "code": "def restore_network_topology(n, router_lists):\n    sub = [[] for _ in range(n)]\n    for i in range(n):\n        data = router_lists[i]\n        for j in data.split('-'):\n            tree = list(map(int, j.split(':')[1].split(',')))\n            for k in range(len(tree)):\n                tree[k] -= 1\n            sub[i].append(sorted(tree))\n        sub[i].sort()\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in sub[i]:\n            for k in j:\n                dp[i][k] = n - len(j)\n    g = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i < j and dp[i][j] + dp[j][i] == n:\n                g[i].append(j)\n                g[j].append(i)\n\n    def dfs(x, vis):\n        arr = [x]\n        vis[x] = True\n        pt = 0\n        while pt < len(arr):\n            y = arr[pt]\n            pt += 1\n            for i in g[y]:\n                if not vis[i]:\n                    vis[i] = True\n                    arr.append(i)\n        return sorted(arr)\n    for i in range(n):\n        subtree = []\n        vis = [False] * n\n        vis[i] = True\n        for j in g[i]:\n            arr = dfs(j, vis)\n            subtree.append(arr)\n        subtree.sort()\n        if subtree != sub[i]:\n            return -1\n    patch_cords = []\n    for i in range(n):\n        for j in g[i]:\n            if i < j:\n                patch_cords.append((i + 1, j + 1))\n    return (n - 0, patch_cords)"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return (n - 1, patch_cords)",
      "mutated_line": "return (n - -1, patch_cords)",
      "code": "def restore_network_topology(n, router_lists):\n    sub = [[] for _ in range(n)]\n    for i in range(n):\n        data = router_lists[i]\n        for j in data.split('-'):\n            tree = list(map(int, j.split(':')[1].split(',')))\n            for k in range(len(tree)):\n                tree[k] -= 1\n            sub[i].append(sorted(tree))\n        sub[i].sort()\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in sub[i]:\n            for k in j:\n                dp[i][k] = n - len(j)\n    g = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i < j and dp[i][j] + dp[j][i] == n:\n                g[i].append(j)\n                g[j].append(i)\n\n    def dfs(x, vis):\n        arr = [x]\n        vis[x] = True\n        pt = 0\n        while pt < len(arr):\n            y = arr[pt]\n            pt += 1\n            for i in g[y]:\n                if not vis[i]:\n                    vis[i] = True\n                    arr.append(i)\n        return sorted(arr)\n    for i in range(n):\n        subtree = []\n        vis = [False] * n\n        vis[i] = True\n        for j in g[i]:\n            arr = dfs(j, vis)\n            subtree.append(arr)\n        subtree.sort()\n        if subtree != sub[i]:\n            return -1\n    patch_cords = []\n    for i in range(n):\n        for j in g[i]:\n            if i < j:\n                patch_cords.append((i + 1, j + 1))\n    return (n - -1, patch_cords)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "tree[k] -= 1",
      "mutated_line": "tree[k] -= 2",
      "code": "def restore_network_topology(n, router_lists):\n    sub = [[] for _ in range(n)]\n    for i in range(n):\n        data = router_lists[i]\n        for j in data.split('-'):\n            tree = list(map(int, j.split(':')[1].split(',')))\n            for k in range(len(tree)):\n                tree[k] -= 2\n            sub[i].append(sorted(tree))\n        sub[i].sort()\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in sub[i]:\n            for k in j:\n                dp[i][k] = n - len(j)\n    g = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i < j and dp[i][j] + dp[j][i] == n:\n                g[i].append(j)\n                g[j].append(i)\n\n    def dfs(x, vis):\n        arr = [x]\n        vis[x] = True\n        pt = 0\n        while pt < len(arr):\n            y = arr[pt]\n            pt += 1\n            for i in g[y]:\n                if not vis[i]:\n                    vis[i] = True\n                    arr.append(i)\n        return sorted(arr)\n    for i in range(n):\n        subtree = []\n        vis = [False] * n\n        vis[i] = True\n        for j in g[i]:\n            arr = dfs(j, vis)\n            subtree.append(arr)\n        subtree.sort()\n        if subtree != sub[i]:\n            return -1\n    patch_cords = []\n    for i in range(n):\n        for j in g[i]:\n            if i < j:\n                patch_cords.append((i + 1, j + 1))\n    return (n - 1, patch_cords)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "tree[k] -= 1",
      "mutated_line": "tree[k] -= 0",
      "code": "def restore_network_topology(n, router_lists):\n    sub = [[] for _ in range(n)]\n    for i in range(n):\n        data = router_lists[i]\n        for j in data.split('-'):\n            tree = list(map(int, j.split(':')[1].split(',')))\n            for k in range(len(tree)):\n                tree[k] -= 0\n            sub[i].append(sorted(tree))\n        sub[i].sort()\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in sub[i]:\n            for k in j:\n                dp[i][k] = n - len(j)\n    g = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i < j and dp[i][j] + dp[j][i] == n:\n                g[i].append(j)\n                g[j].append(i)\n\n    def dfs(x, vis):\n        arr = [x]\n        vis[x] = True\n        pt = 0\n        while pt < len(arr):\n            y = arr[pt]\n            pt += 1\n            for i in g[y]:\n                if not vis[i]:\n                    vis[i] = True\n                    arr.append(i)\n        return sorted(arr)\n    for i in range(n):\n        subtree = []\n        vis = [False] * n\n        vis[i] = True\n        for j in g[i]:\n            arr = dfs(j, vis)\n            subtree.append(arr)\n        subtree.sort()\n        if subtree != sub[i]:\n            return -1\n    patch_cords = []\n    for i in range(n):\n        for j in g[i]:\n            if i < j:\n                patch_cords.append((i + 1, j + 1))\n    return (n - 1, patch_cords)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "tree[k] -= 1",
      "mutated_line": "tree[k] -= 0",
      "code": "def restore_network_topology(n, router_lists):\n    sub = [[] for _ in range(n)]\n    for i in range(n):\n        data = router_lists[i]\n        for j in data.split('-'):\n            tree = list(map(int, j.split(':')[1].split(',')))\n            for k in range(len(tree)):\n                tree[k] -= 0\n            sub[i].append(sorted(tree))\n        sub[i].sort()\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in sub[i]:\n            for k in j:\n                dp[i][k] = n - len(j)\n    g = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i < j and dp[i][j] + dp[j][i] == n:\n                g[i].append(j)\n                g[j].append(i)\n\n    def dfs(x, vis):\n        arr = [x]\n        vis[x] = True\n        pt = 0\n        while pt < len(arr):\n            y = arr[pt]\n            pt += 1\n            for i in g[y]:\n                if not vis[i]:\n                    vis[i] = True\n                    arr.append(i)\n        return sorted(arr)\n    for i in range(n):\n        subtree = []\n        vis = [False] * n\n        vis[i] = True\n        for j in g[i]:\n            arr = dfs(j, vis)\n            subtree.append(arr)\n        subtree.sort()\n        if subtree != sub[i]:\n            return -1\n    patch_cords = []\n    for i in range(n):\n        for j in g[i]:\n            if i < j:\n                patch_cords.append((i + 1, j + 1))\n    return (n - 1, patch_cords)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "tree[k] -= 1",
      "mutated_line": "tree[k] -= -1",
      "code": "def restore_network_topology(n, router_lists):\n    sub = [[] for _ in range(n)]\n    for i in range(n):\n        data = router_lists[i]\n        for j in data.split('-'):\n            tree = list(map(int, j.split(':')[1].split(',')))\n            for k in range(len(tree)):\n                tree[k] -= -1\n            sub[i].append(sorted(tree))\n        sub[i].sort()\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in sub[i]:\n            for k in j:\n                dp[i][k] = n - len(j)\n    g = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i < j and dp[i][j] + dp[j][i] == n:\n                g[i].append(j)\n                g[j].append(i)\n\n    def dfs(x, vis):\n        arr = [x]\n        vis[x] = True\n        pt = 0\n        while pt < len(arr):\n            y = arr[pt]\n            pt += 1\n            for i in g[y]:\n                if not vis[i]:\n                    vis[i] = True\n                    arr.append(i)\n        return sorted(arr)\n    for i in range(n):\n        subtree = []\n        vis = [False] * n\n        vis[i] = True\n        for j in g[i]:\n            arr = dfs(j, vis)\n            subtree.append(arr)\n        subtree.sort()\n        if subtree != sub[i]:\n            return -1\n    patch_cords = []\n    for i in range(n):\n        for j in g[i]:\n            if i < j:\n                patch_cords.append((i + 1, j + 1))\n    return (n - 1, patch_cords)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp = [[0] * n for _ in range(n)]",
      "mutated_line": "dp = [[1] * n for _ in range(n)]",
      "code": "def restore_network_topology(n, router_lists):\n    sub = [[] for _ in range(n)]\n    for i in range(n):\n        data = router_lists[i]\n        for j in data.split('-'):\n            tree = list(map(int, j.split(':')[1].split(',')))\n            for k in range(len(tree)):\n                tree[k] -= 1\n            sub[i].append(sorted(tree))\n        sub[i].sort()\n    dp = [[1] * n for _ in range(n)]\n    for i in range(n):\n        for j in sub[i]:\n            for k in j:\n                dp[i][k] = n - len(j)\n    g = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i < j and dp[i][j] + dp[j][i] == n:\n                g[i].append(j)\n                g[j].append(i)\n\n    def dfs(x, vis):\n        arr = [x]\n        vis[x] = True\n        pt = 0\n        while pt < len(arr):\n            y = arr[pt]\n            pt += 1\n            for i in g[y]:\n                if not vis[i]:\n                    vis[i] = True\n                    arr.append(i)\n        return sorted(arr)\n    for i in range(n):\n        subtree = []\n        vis = [False] * n\n        vis[i] = True\n        for j in g[i]:\n            arr = dfs(j, vis)\n            subtree.append(arr)\n        subtree.sort()\n        if subtree != sub[i]:\n            return -1\n    patch_cords = []\n    for i in range(n):\n        for j in g[i]:\n            if i < j:\n                patch_cords.append((i + 1, j + 1))\n    return (n - 1, patch_cords)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp = [[0] * n for _ in range(n)]",
      "mutated_line": "dp = [[-1] * n for _ in range(n)]",
      "code": "def restore_network_topology(n, router_lists):\n    sub = [[] for _ in range(n)]\n    for i in range(n):\n        data = router_lists[i]\n        for j in data.split('-'):\n            tree = list(map(int, j.split(':')[1].split(',')))\n            for k in range(len(tree)):\n                tree[k] -= 1\n            sub[i].append(sorted(tree))\n        sub[i].sort()\n    dp = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        for j in sub[i]:\n            for k in j:\n                dp[i][k] = n - len(j)\n    g = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i < j and dp[i][j] + dp[j][i] == n:\n                g[i].append(j)\n                g[j].append(i)\n\n    def dfs(x, vis):\n        arr = [x]\n        vis[x] = True\n        pt = 0\n        while pt < len(arr):\n            y = arr[pt]\n            pt += 1\n            for i in g[y]:\n                if not vis[i]:\n                    vis[i] = True\n                    arr.append(i)\n        return sorted(arr)\n    for i in range(n):\n        subtree = []\n        vis = [False] * n\n        vis[i] = True\n        for j in g[i]:\n            arr = dfs(j, vis)\n            subtree.append(arr)\n        subtree.sort()\n        if subtree != sub[i]:\n            return -1\n    patch_cords = []\n    for i in range(n):\n        for j in g[i]:\n            if i < j:\n                patch_cords.append((i + 1, j + 1))\n    return (n - 1, patch_cords)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp = [[0] * n for _ in range(n)]",
      "mutated_line": "dp = [[1] * n for _ in range(n)]",
      "code": "def restore_network_topology(n, router_lists):\n    sub = [[] for _ in range(n)]\n    for i in range(n):\n        data = router_lists[i]\n        for j in data.split('-'):\n            tree = list(map(int, j.split(':')[1].split(',')))\n            for k in range(len(tree)):\n                tree[k] -= 1\n            sub[i].append(sorted(tree))\n        sub[i].sort()\n    dp = [[1] * n for _ in range(n)]\n    for i in range(n):\n        for j in sub[i]:\n            for k in j:\n                dp[i][k] = n - len(j)\n    g = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i < j and dp[i][j] + dp[j][i] == n:\n                g[i].append(j)\n                g[j].append(i)\n\n    def dfs(x, vis):\n        arr = [x]\n        vis[x] = True\n        pt = 0\n        while pt < len(arr):\n            y = arr[pt]\n            pt += 1\n            for i in g[y]:\n                if not vis[i]:\n                    vis[i] = True\n                    arr.append(i)\n        return sorted(arr)\n    for i in range(n):\n        subtree = []\n        vis = [False] * n\n        vis[i] = True\n        for j in g[i]:\n            arr = dfs(j, vis)\n            subtree.append(arr)\n        subtree.sort()\n        if subtree != sub[i]:\n            return -1\n    patch_cords = []\n    for i in range(n):\n        for j in g[i]:\n            if i < j:\n                patch_cords.append((i + 1, j + 1))\n    return (n - 1, patch_cords)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "dp[i][k] = n - len(j)",
      "mutated_line": "dp[i][k] = n + len(j)",
      "code": "def restore_network_topology(n, router_lists):\n    sub = [[] for _ in range(n)]\n    for i in range(n):\n        data = router_lists[i]\n        for j in data.split('-'):\n            tree = list(map(int, j.split(':')[1].split(',')))\n            for k in range(len(tree)):\n                tree[k] -= 1\n            sub[i].append(sorted(tree))\n        sub[i].sort()\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in sub[i]:\n            for k in j:\n                dp[i][k] = n + len(j)\n    g = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i < j and dp[i][j] + dp[j][i] == n:\n                g[i].append(j)\n                g[j].append(i)\n\n    def dfs(x, vis):\n        arr = [x]\n        vis[x] = True\n        pt = 0\n        while pt < len(arr):\n            y = arr[pt]\n            pt += 1\n            for i in g[y]:\n                if not vis[i]:\n                    vis[i] = True\n                    arr.append(i)\n        return sorted(arr)\n    for i in range(n):\n        subtree = []\n        vis = [False] * n\n        vis[i] = True\n        for j in g[i]:\n            arr = dfs(j, vis)\n            subtree.append(arr)\n        subtree.sort()\n        if subtree != sub[i]:\n            return -1\n    patch_cords = []\n    for i in range(n):\n        for j in g[i]:\n            if i < j:\n                patch_cords.append((i + 1, j + 1))\n    return (n - 1, patch_cords)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "dp[i][k] = n - len(j)",
      "mutated_line": "dp[i][k] = n * len(j)",
      "code": "def restore_network_topology(n, router_lists):\n    sub = [[] for _ in range(n)]\n    for i in range(n):\n        data = router_lists[i]\n        for j in data.split('-'):\n            tree = list(map(int, j.split(':')[1].split(',')))\n            for k in range(len(tree)):\n                tree[k] -= 1\n            sub[i].append(sorted(tree))\n        sub[i].sort()\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in sub[i]:\n            for k in j:\n                dp[i][k] = n * len(j)\n    g = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i < j and dp[i][j] + dp[j][i] == n:\n                g[i].append(j)\n                g[j].append(i)\n\n    def dfs(x, vis):\n        arr = [x]\n        vis[x] = True\n        pt = 0\n        while pt < len(arr):\n            y = arr[pt]\n            pt += 1\n            for i in g[y]:\n                if not vis[i]:\n                    vis[i] = True\n                    arr.append(i)\n        return sorted(arr)\n    for i in range(n):\n        subtree = []\n        vis = [False] * n\n        vis[i] = True\n        for j in g[i]:\n            arr = dfs(j, vis)\n            subtree.append(arr)\n        subtree.sort()\n        if subtree != sub[i]:\n            return -1\n    patch_cords = []\n    for i in range(n):\n        for j in g[i]:\n            if i < j:\n                patch_cords.append((i + 1, j + 1))\n    return (n - 1, patch_cords)"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if i < j and dp[i][j] + dp[j][i] == n:",
      "mutated_line": "if i <= j and dp[i][j] + dp[j][i] == n:",
      "code": "def restore_network_topology(n, router_lists):\n    sub = [[] for _ in range(n)]\n    for i in range(n):\n        data = router_lists[i]\n        for j in data.split('-'):\n            tree = list(map(int, j.split(':')[1].split(',')))\n            for k in range(len(tree)):\n                tree[k] -= 1\n            sub[i].append(sorted(tree))\n        sub[i].sort()\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in sub[i]:\n            for k in j:\n                dp[i][k] = n - len(j)\n    g = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i <= j and dp[i][j] + dp[j][i] == n:\n                g[i].append(j)\n                g[j].append(i)\n\n    def dfs(x, vis):\n        arr = [x]\n        vis[x] = True\n        pt = 0\n        while pt < len(arr):\n            y = arr[pt]\n            pt += 1\n            for i in g[y]:\n                if not vis[i]:\n                    vis[i] = True\n                    arr.append(i)\n        return sorted(arr)\n    for i in range(n):\n        subtree = []\n        vis = [False] * n\n        vis[i] = True\n        for j in g[i]:\n            arr = dfs(j, vis)\n            subtree.append(arr)\n        subtree.sort()\n        if subtree != sub[i]:\n            return -1\n    patch_cords = []\n    for i in range(n):\n        for j in g[i]:\n            if i < j:\n                patch_cords.append((i + 1, j + 1))\n    return (n - 1, patch_cords)"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if i < j and dp[i][j] + dp[j][i] == n:",
      "mutated_line": "if i >= j and dp[i][j] + dp[j][i] == n:",
      "code": "def restore_network_topology(n, router_lists):\n    sub = [[] for _ in range(n)]\n    for i in range(n):\n        data = router_lists[i]\n        for j in data.split('-'):\n            tree = list(map(int, j.split(':')[1].split(',')))\n            for k in range(len(tree)):\n                tree[k] -= 1\n            sub[i].append(sorted(tree))\n        sub[i].sort()\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in sub[i]:\n            for k in j:\n                dp[i][k] = n - len(j)\n    g = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i >= j and dp[i][j] + dp[j][i] == n:\n                g[i].append(j)\n                g[j].append(i)\n\n    def dfs(x, vis):\n        arr = [x]\n        vis[x] = True\n        pt = 0\n        while pt < len(arr):\n            y = arr[pt]\n            pt += 1\n            for i in g[y]:\n                if not vis[i]:\n                    vis[i] = True\n                    arr.append(i)\n        return sorted(arr)\n    for i in range(n):\n        subtree = []\n        vis = [False] * n\n        vis[i] = True\n        for j in g[i]:\n            arr = dfs(j, vis)\n            subtree.append(arr)\n        subtree.sort()\n        if subtree != sub[i]:\n            return -1\n    patch_cords = []\n    for i in range(n):\n        for j in g[i]:\n            if i < j:\n                patch_cords.append((i + 1, j + 1))\n    return (n - 1, patch_cords)"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if i < j and dp[i][j] + dp[j][i] == n:",
      "mutated_line": "if i != j and dp[i][j] + dp[j][i] == n:",
      "code": "def restore_network_topology(n, router_lists):\n    sub = [[] for _ in range(n)]\n    for i in range(n):\n        data = router_lists[i]\n        for j in data.split('-'):\n            tree = list(map(int, j.split(':')[1].split(',')))\n            for k in range(len(tree)):\n                tree[k] -= 1\n            sub[i].append(sorted(tree))\n        sub[i].sort()\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in sub[i]:\n            for k in j:\n                dp[i][k] = n - len(j)\n    g = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i != j and dp[i][j] + dp[j][i] == n:\n                g[i].append(j)\n                g[j].append(i)\n\n    def dfs(x, vis):\n        arr = [x]\n        vis[x] = True\n        pt = 0\n        while pt < len(arr):\n            y = arr[pt]\n            pt += 1\n            for i in g[y]:\n                if not vis[i]:\n                    vis[i] = True\n                    arr.append(i)\n        return sorted(arr)\n    for i in range(n):\n        subtree = []\n        vis = [False] * n\n        vis[i] = True\n        for j in g[i]:\n            arr = dfs(j, vis)\n            subtree.append(arr)\n        subtree.sort()\n        if subtree != sub[i]:\n            return -1\n    patch_cords = []\n    for i in range(n):\n        for j in g[i]:\n            if i < j:\n                patch_cords.append((i + 1, j + 1))\n    return (n - 1, patch_cords)"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if i < j and dp[i][j] + dp[j][i] == n:",
      "mutated_line": "if i < j and dp[i][j] + dp[j][i] != n:",
      "code": "def restore_network_topology(n, router_lists):\n    sub = [[] for _ in range(n)]\n    for i in range(n):\n        data = router_lists[i]\n        for j in data.split('-'):\n            tree = list(map(int, j.split(':')[1].split(',')))\n            for k in range(len(tree)):\n                tree[k] -= 1\n            sub[i].append(sorted(tree))\n        sub[i].sort()\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in sub[i]:\n            for k in j:\n                dp[i][k] = n - len(j)\n    g = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i < j and dp[i][j] + dp[j][i] != n:\n                g[i].append(j)\n                g[j].append(i)\n\n    def dfs(x, vis):\n        arr = [x]\n        vis[x] = True\n        pt = 0\n        while pt < len(arr):\n            y = arr[pt]\n            pt += 1\n            for i in g[y]:\n                if not vis[i]:\n                    vis[i] = True\n                    arr.append(i)\n        return sorted(arr)\n    for i in range(n):\n        subtree = []\n        vis = [False] * n\n        vis[i] = True\n        for j in g[i]:\n            arr = dfs(j, vis)\n            subtree.append(arr)\n        subtree.sort()\n        if subtree != sub[i]:\n            return -1\n    patch_cords = []\n    for i in range(n):\n        for j in g[i]:\n            if i < j:\n                patch_cords.append((i + 1, j + 1))\n    return (n - 1, patch_cords)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "vis = [False] * n",
      "mutated_line": "vis = [True] * n",
      "code": "def restore_network_topology(n, router_lists):\n    sub = [[] for _ in range(n)]\n    for i in range(n):\n        data = router_lists[i]\n        for j in data.split('-'):\n            tree = list(map(int, j.split(':')[1].split(',')))\n            for k in range(len(tree)):\n                tree[k] -= 1\n            sub[i].append(sorted(tree))\n        sub[i].sort()\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in sub[i]:\n            for k in j:\n                dp[i][k] = n - len(j)\n    g = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i < j and dp[i][j] + dp[j][i] == n:\n                g[i].append(j)\n                g[j].append(i)\n\n    def dfs(x, vis):\n        arr = [x]\n        vis[x] = True\n        pt = 0\n        while pt < len(arr):\n            y = arr[pt]\n            pt += 1\n            for i in g[y]:\n                if not vis[i]:\n                    vis[i] = True\n                    arr.append(i)\n        return sorted(arr)\n    for i in range(n):\n        subtree = []\n        vis = [True] * n\n        vis[i] = True\n        for j in g[i]:\n            arr = dfs(j, vis)\n            subtree.append(arr)\n        subtree.sort()\n        if subtree != sub[i]:\n            return -1\n    patch_cords = []\n    for i in range(n):\n        for j in g[i]:\n            if i < j:\n                patch_cords.append((i + 1, j + 1))\n    return (n - 1, patch_cords)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def restore_network_topology(n, router_lists):\n    sub = [[] for _ in range(n)]\n    for i in range(n):\n        data = router_lists[i]\n        for j in data.split('-'):\n            tree = list(map(int, j.split(':')[1].split(',')))\n            for k in range(len(tree)):\n                tree[k] -= 1\n            sub[i].append(sorted(tree))\n        sub[i].sort()\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in sub[i]:\n            for k in j:\n                dp[i][k] = n - len(j)\n    g = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i < j and dp[i][j] + dp[j][i] == n:\n                g[i].append(j)\n                g[j].append(i)\n\n    def dfs(x, vis):\n        arr = [x]\n        vis[x] = True\n        pt = 0\n        while pt < len(arr):\n            y = arr[pt]\n            pt += 1\n            for i in g[y]:\n                if not vis[i]:\n                    vis[i] = True\n                    arr.append(i)\n        return sorted(arr)\n    for i in range(n):\n        subtree = []\n        vis = [False] * n\n        vis[i] = True\n        for j in g[i]:\n            arr = dfs(j, vis)\n            subtree.append(arr)\n        subtree.sort()\n        if subtree != sub[i]:\n            return -2\n    patch_cords = []\n    for i in range(n):\n        for j in g[i]:\n            if i < j:\n                patch_cords.append((i + 1, j + 1))\n    return (n - 1, patch_cords)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def restore_network_topology(n, router_lists):\n    sub = [[] for _ in range(n)]\n    for i in range(n):\n        data = router_lists[i]\n        for j in data.split('-'):\n            tree = list(map(int, j.split(':')[1].split(',')))\n            for k in range(len(tree)):\n                tree[k] -= 1\n            sub[i].append(sorted(tree))\n        sub[i].sort()\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in sub[i]:\n            for k in j:\n                dp[i][k] = n - len(j)\n    g = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i < j and dp[i][j] + dp[j][i] == n:\n                g[i].append(j)\n                g[j].append(i)\n\n    def dfs(x, vis):\n        arr = [x]\n        vis[x] = True\n        pt = 0\n        while pt < len(arr):\n            y = arr[pt]\n            pt += 1\n            for i in g[y]:\n                if not vis[i]:\n                    vis[i] = True\n                    arr.append(i)\n        return sorted(arr)\n    for i in range(n):\n        subtree = []\n        vis = [False] * n\n        vis[i] = True\n        for j in g[i]:\n            arr = dfs(j, vis)\n            subtree.append(arr)\n        subtree.sort()\n        if subtree != sub[i]:\n            return -0\n    patch_cords = []\n    for i in range(n):\n        for j in g[i]:\n            if i < j:\n                patch_cords.append((i + 1, j + 1))\n    return (n - 1, patch_cords)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def restore_network_topology(n, router_lists):\n    sub = [[] for _ in range(n)]\n    for i in range(n):\n        data = router_lists[i]\n        for j in data.split('-'):\n            tree = list(map(int, j.split(':')[1].split(',')))\n            for k in range(len(tree)):\n                tree[k] -= 1\n            sub[i].append(sorted(tree))\n        sub[i].sort()\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in sub[i]:\n            for k in j:\n                dp[i][k] = n - len(j)\n    g = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i < j and dp[i][j] + dp[j][i] == n:\n                g[i].append(j)\n                g[j].append(i)\n\n    def dfs(x, vis):\n        arr = [x]\n        vis[x] = True\n        pt = 0\n        while pt < len(arr):\n            y = arr[pt]\n            pt += 1\n            for i in g[y]:\n                if not vis[i]:\n                    vis[i] = True\n                    arr.append(i)\n        return sorted(arr)\n    for i in range(n):\n        subtree = []\n        vis = [False] * n\n        vis[i] = True\n        for j in g[i]:\n            arr = dfs(j, vis)\n            subtree.append(arr)\n        subtree.sort()\n        if subtree != sub[i]:\n            return -0\n    patch_cords = []\n    for i in range(n):\n        for j in g[i]:\n            if i < j:\n                patch_cords.append((i + 1, j + 1))\n    return (n - 1, patch_cords)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def restore_network_topology(n, router_lists):\n    sub = [[] for _ in range(n)]\n    for i in range(n):\n        data = router_lists[i]\n        for j in data.split('-'):\n            tree = list(map(int, j.split(':')[1].split(',')))\n            for k in range(len(tree)):\n                tree[k] -= 1\n            sub[i].append(sorted(tree))\n        sub[i].sort()\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in sub[i]:\n            for k in j:\n                dp[i][k] = n - len(j)\n    g = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i < j and dp[i][j] + dp[j][i] == n:\n                g[i].append(j)\n                g[j].append(i)\n\n    def dfs(x, vis):\n        arr = [x]\n        vis[x] = True\n        pt = 0\n        while pt < len(arr):\n            y = arr[pt]\n            pt += 1\n            for i in g[y]:\n                if not vis[i]:\n                    vis[i] = True\n                    arr.append(i)\n        return sorted(arr)\n    for i in range(n):\n        subtree = []\n        vis = [False] * n\n        vis[i] = True\n        for j in g[i]:\n            arr = dfs(j, vis)\n            subtree.append(arr)\n        subtree.sort()\n        if subtree != sub[i]:\n            return --1\n    patch_cords = []\n    for i in range(n):\n        for j in g[i]:\n            if i < j:\n                patch_cords.append((i + 1, j + 1))\n    return (n - 1, patch_cords)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if i < j and dp[i][j] + dp[j][i] == n:",
      "mutated_line": "if i < j and dp[i][j] - dp[j][i] == n:",
      "code": "def restore_network_topology(n, router_lists):\n    sub = [[] for _ in range(n)]\n    for i in range(n):\n        data = router_lists[i]\n        for j in data.split('-'):\n            tree = list(map(int, j.split(':')[1].split(',')))\n            for k in range(len(tree)):\n                tree[k] -= 1\n            sub[i].append(sorted(tree))\n        sub[i].sort()\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in sub[i]:\n            for k in j:\n                dp[i][k] = n - len(j)\n    g = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i < j and dp[i][j] - dp[j][i] == n:\n                g[i].append(j)\n                g[j].append(i)\n\n    def dfs(x, vis):\n        arr = [x]\n        vis[x] = True\n        pt = 0\n        while pt < len(arr):\n            y = arr[pt]\n            pt += 1\n            for i in g[y]:\n                if not vis[i]:\n                    vis[i] = True\n                    arr.append(i)\n        return sorted(arr)\n    for i in range(n):\n        subtree = []\n        vis = [False] * n\n        vis[i] = True\n        for j in g[i]:\n            arr = dfs(j, vis)\n            subtree.append(arr)\n        subtree.sort()\n        if subtree != sub[i]:\n            return -1\n    patch_cords = []\n    for i in range(n):\n        for j in g[i]:\n            if i < j:\n                patch_cords.append((i + 1, j + 1))\n    return (n - 1, patch_cords)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if i < j and dp[i][j] + dp[j][i] == n:",
      "mutated_line": "if i < j and dp[i][j] * dp[j][i] == n:",
      "code": "def restore_network_topology(n, router_lists):\n    sub = [[] for _ in range(n)]\n    for i in range(n):\n        data = router_lists[i]\n        for j in data.split('-'):\n            tree = list(map(int, j.split(':')[1].split(',')))\n            for k in range(len(tree)):\n                tree[k] -= 1\n            sub[i].append(sorted(tree))\n        sub[i].sort()\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in sub[i]:\n            for k in j:\n                dp[i][k] = n - len(j)\n    g = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i < j and dp[i][j] * dp[j][i] == n:\n                g[i].append(j)\n                g[j].append(i)\n\n    def dfs(x, vis):\n        arr = [x]\n        vis[x] = True\n        pt = 0\n        while pt < len(arr):\n            y = arr[pt]\n            pt += 1\n            for i in g[y]:\n                if not vis[i]:\n                    vis[i] = True\n                    arr.append(i)\n        return sorted(arr)\n    for i in range(n):\n        subtree = []\n        vis = [False] * n\n        vis[i] = True\n        for j in g[i]:\n            arr = dfs(j, vis)\n            subtree.append(arr)\n        subtree.sort()\n        if subtree != sub[i]:\n            return -1\n    patch_cords = []\n    for i in range(n):\n        for j in g[i]:\n            if i < j:\n                patch_cords.append((i + 1, j + 1))\n    return (n - 1, patch_cords)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "vis[i] = True",
      "mutated_line": "vis[i] = False",
      "code": "def restore_network_topology(n, router_lists):\n    sub = [[] for _ in range(n)]\n    for i in range(n):\n        data = router_lists[i]\n        for j in data.split('-'):\n            tree = list(map(int, j.split(':')[1].split(',')))\n            for k in range(len(tree)):\n                tree[k] -= 1\n            sub[i].append(sorted(tree))\n        sub[i].sort()\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in sub[i]:\n            for k in j:\n                dp[i][k] = n - len(j)\n    g = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i < j and dp[i][j] + dp[j][i] == n:\n                g[i].append(j)\n                g[j].append(i)\n\n    def dfs(x, vis):\n        arr = [x]\n        vis[x] = True\n        pt = 0\n        while pt < len(arr):\n            y = arr[pt]\n            pt += 1\n            for i in g[y]:\n                if not vis[i]:\n                    vis[i] = False\n                    arr.append(i)\n        return sorted(arr)\n    for i in range(n):\n        subtree = []\n        vis = [False] * n\n        vis[i] = True\n        for j in g[i]:\n            arr = dfs(j, vis)\n            subtree.append(arr)\n        subtree.sort()\n        if subtree != sub[i]:\n            return -1\n    patch_cords = []\n    for i in range(n):\n        for j in g[i]:\n            if i < j:\n                patch_cords.append((i + 1, j + 1))\n    return (n - 1, patch_cords)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "tree = list(map(int, j.split(':')[1].split(',')))",
      "mutated_line": "tree = list(map(int, j.split(':')[1].split('')))",
      "code": "def restore_network_topology(n, router_lists):\n    sub = [[] for _ in range(n)]\n    for i in range(n):\n        data = router_lists[i]\n        for j in data.split('-'):\n            tree = list(map(int, j.split(':')[1].split('')))\n            for k in range(len(tree)):\n                tree[k] -= 1\n            sub[i].append(sorted(tree))\n        sub[i].sort()\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in sub[i]:\n            for k in j:\n                dp[i][k] = n - len(j)\n    g = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i < j and dp[i][j] + dp[j][i] == n:\n                g[i].append(j)\n                g[j].append(i)\n\n    def dfs(x, vis):\n        arr = [x]\n        vis[x] = True\n        pt = 0\n        while pt < len(arr):\n            y = arr[pt]\n            pt += 1\n            for i in g[y]:\n                if not vis[i]:\n                    vis[i] = True\n                    arr.append(i)\n        return sorted(arr)\n    for i in range(n):\n        subtree = []\n        vis = [False] * n\n        vis[i] = True\n        for j in g[i]:\n            arr = dfs(j, vis)\n            subtree.append(arr)\n        subtree.sort()\n        if subtree != sub[i]:\n            return -1\n    patch_cords = []\n    for i in range(n):\n        for j in g[i]:\n            if i < j:\n                patch_cords.append((i + 1, j + 1))\n    return (n - 1, patch_cords)"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "patch_cords.append((i + 1, j + 1))",
      "mutated_line": "patch_cords.append((i - 1, j + 1))",
      "code": "def restore_network_topology(n, router_lists):\n    sub = [[] for _ in range(n)]\n    for i in range(n):\n        data = router_lists[i]\n        for j in data.split('-'):\n            tree = list(map(int, j.split(':')[1].split(',')))\n            for k in range(len(tree)):\n                tree[k] -= 1\n            sub[i].append(sorted(tree))\n        sub[i].sort()\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in sub[i]:\n            for k in j:\n                dp[i][k] = n - len(j)\n    g = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i < j and dp[i][j] + dp[j][i] == n:\n                g[i].append(j)\n                g[j].append(i)\n\n    def dfs(x, vis):\n        arr = [x]\n        vis[x] = True\n        pt = 0\n        while pt < len(arr):\n            y = arr[pt]\n            pt += 1\n            for i in g[y]:\n                if not vis[i]:\n                    vis[i] = True\n                    arr.append(i)\n        return sorted(arr)\n    for i in range(n):\n        subtree = []\n        vis = [False] * n\n        vis[i] = True\n        for j in g[i]:\n            arr = dfs(j, vis)\n            subtree.append(arr)\n        subtree.sort()\n        if subtree != sub[i]:\n            return -1\n    patch_cords = []\n    for i in range(n):\n        for j in g[i]:\n            if i < j:\n                patch_cords.append((i - 1, j + 1))\n    return (n - 1, patch_cords)"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "patch_cords.append((i + 1, j + 1))",
      "mutated_line": "patch_cords.append((i * 1, j + 1))",
      "code": "def restore_network_topology(n, router_lists):\n    sub = [[] for _ in range(n)]\n    for i in range(n):\n        data = router_lists[i]\n        for j in data.split('-'):\n            tree = list(map(int, j.split(':')[1].split(',')))\n            for k in range(len(tree)):\n                tree[k] -= 1\n            sub[i].append(sorted(tree))\n        sub[i].sort()\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in sub[i]:\n            for k in j:\n                dp[i][k] = n - len(j)\n    g = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i < j and dp[i][j] + dp[j][i] == n:\n                g[i].append(j)\n                g[j].append(i)\n\n    def dfs(x, vis):\n        arr = [x]\n        vis[x] = True\n        pt = 0\n        while pt < len(arr):\n            y = arr[pt]\n            pt += 1\n            for i in g[y]:\n                if not vis[i]:\n                    vis[i] = True\n                    arr.append(i)\n        return sorted(arr)\n    for i in range(n):\n        subtree = []\n        vis = [False] * n\n        vis[i] = True\n        for j in g[i]:\n            arr = dfs(j, vis)\n            subtree.append(arr)\n        subtree.sort()\n        if subtree != sub[i]:\n            return -1\n    patch_cords = []\n    for i in range(n):\n        for j in g[i]:\n            if i < j:\n                patch_cords.append((i * 1, j + 1))\n    return (n - 1, patch_cords)"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "patch_cords.append((i + 1, j + 1))",
      "mutated_line": "patch_cords.append((i + 1, j - 1))",
      "code": "def restore_network_topology(n, router_lists):\n    sub = [[] for _ in range(n)]\n    for i in range(n):\n        data = router_lists[i]\n        for j in data.split('-'):\n            tree = list(map(int, j.split(':')[1].split(',')))\n            for k in range(len(tree)):\n                tree[k] -= 1\n            sub[i].append(sorted(tree))\n        sub[i].sort()\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in sub[i]:\n            for k in j:\n                dp[i][k] = n - len(j)\n    g = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i < j and dp[i][j] + dp[j][i] == n:\n                g[i].append(j)\n                g[j].append(i)\n\n    def dfs(x, vis):\n        arr = [x]\n        vis[x] = True\n        pt = 0\n        while pt < len(arr):\n            y = arr[pt]\n            pt += 1\n            for i in g[y]:\n                if not vis[i]:\n                    vis[i] = True\n                    arr.append(i)\n        return sorted(arr)\n    for i in range(n):\n        subtree = []\n        vis = [False] * n\n        vis[i] = True\n        for j in g[i]:\n            arr = dfs(j, vis)\n            subtree.append(arr)\n        subtree.sort()\n        if subtree != sub[i]:\n            return -1\n    patch_cords = []\n    for i in range(n):\n        for j in g[i]:\n            if i < j:\n                patch_cords.append((i + 1, j - 1))\n    return (n - 1, patch_cords)"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "patch_cords.append((i + 1, j + 1))",
      "mutated_line": "patch_cords.append((i + 1, j * 1))",
      "code": "def restore_network_topology(n, router_lists):\n    sub = [[] for _ in range(n)]\n    for i in range(n):\n        data = router_lists[i]\n        for j in data.split('-'):\n            tree = list(map(int, j.split(':')[1].split(',')))\n            for k in range(len(tree)):\n                tree[k] -= 1\n            sub[i].append(sorted(tree))\n        sub[i].sort()\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in sub[i]:\n            for k in j:\n                dp[i][k] = n - len(j)\n    g = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i < j and dp[i][j] + dp[j][i] == n:\n                g[i].append(j)\n                g[j].append(i)\n\n    def dfs(x, vis):\n        arr = [x]\n        vis[x] = True\n        pt = 0\n        while pt < len(arr):\n            y = arr[pt]\n            pt += 1\n            for i in g[y]:\n                if not vis[i]:\n                    vis[i] = True\n                    arr.append(i)\n        return sorted(arr)\n    for i in range(n):\n        subtree = []\n        vis = [False] * n\n        vis[i] = True\n        for j in g[i]:\n            arr = dfs(j, vis)\n            subtree.append(arr)\n        subtree.sort()\n        if subtree != sub[i]:\n            return -1\n    patch_cords = []\n    for i in range(n):\n        for j in g[i]:\n            if i < j:\n                patch_cords.append((i + 1, j * 1))\n    return (n - 1, patch_cords)"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "patch_cords.append((i + 1, j + 1))",
      "mutated_line": "patch_cords.append((i + 2, j + 1))",
      "code": "def restore_network_topology(n, router_lists):\n    sub = [[] for _ in range(n)]\n    for i in range(n):\n        data = router_lists[i]\n        for j in data.split('-'):\n            tree = list(map(int, j.split(':')[1].split(',')))\n            for k in range(len(tree)):\n                tree[k] -= 1\n            sub[i].append(sorted(tree))\n        sub[i].sort()\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in sub[i]:\n            for k in j:\n                dp[i][k] = n - len(j)\n    g = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i < j and dp[i][j] + dp[j][i] == n:\n                g[i].append(j)\n                g[j].append(i)\n\n    def dfs(x, vis):\n        arr = [x]\n        vis[x] = True\n        pt = 0\n        while pt < len(arr):\n            y = arr[pt]\n            pt += 1\n            for i in g[y]:\n                if not vis[i]:\n                    vis[i] = True\n                    arr.append(i)\n        return sorted(arr)\n    for i in range(n):\n        subtree = []\n        vis = [False] * n\n        vis[i] = True\n        for j in g[i]:\n            arr = dfs(j, vis)\n            subtree.append(arr)\n        subtree.sort()\n        if subtree != sub[i]:\n            return -1\n    patch_cords = []\n    for i in range(n):\n        for j in g[i]:\n            if i < j:\n                patch_cords.append((i + 2, j + 1))\n    return (n - 1, patch_cords)"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "patch_cords.append((i + 1, j + 1))",
      "mutated_line": "patch_cords.append((i + 0, j + 1))",
      "code": "def restore_network_topology(n, router_lists):\n    sub = [[] for _ in range(n)]\n    for i in range(n):\n        data = router_lists[i]\n        for j in data.split('-'):\n            tree = list(map(int, j.split(':')[1].split(',')))\n            for k in range(len(tree)):\n                tree[k] -= 1\n            sub[i].append(sorted(tree))\n        sub[i].sort()\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in sub[i]:\n            for k in j:\n                dp[i][k] = n - len(j)\n    g = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i < j and dp[i][j] + dp[j][i] == n:\n                g[i].append(j)\n                g[j].append(i)\n\n    def dfs(x, vis):\n        arr = [x]\n        vis[x] = True\n        pt = 0\n        while pt < len(arr):\n            y = arr[pt]\n            pt += 1\n            for i in g[y]:\n                if not vis[i]:\n                    vis[i] = True\n                    arr.append(i)\n        return sorted(arr)\n    for i in range(n):\n        subtree = []\n        vis = [False] * n\n        vis[i] = True\n        for j in g[i]:\n            arr = dfs(j, vis)\n            subtree.append(arr)\n        subtree.sort()\n        if subtree != sub[i]:\n            return -1\n    patch_cords = []\n    for i in range(n):\n        for j in g[i]:\n            if i < j:\n                patch_cords.append((i + 0, j + 1))\n    return (n - 1, patch_cords)"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "patch_cords.append((i + 1, j + 1))",
      "mutated_line": "patch_cords.append((i + 0, j + 1))",
      "code": "def restore_network_topology(n, router_lists):\n    sub = [[] for _ in range(n)]\n    for i in range(n):\n        data = router_lists[i]\n        for j in data.split('-'):\n            tree = list(map(int, j.split(':')[1].split(',')))\n            for k in range(len(tree)):\n                tree[k] -= 1\n            sub[i].append(sorted(tree))\n        sub[i].sort()\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in sub[i]:\n            for k in j:\n                dp[i][k] = n - len(j)\n    g = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i < j and dp[i][j] + dp[j][i] == n:\n                g[i].append(j)\n                g[j].append(i)\n\n    def dfs(x, vis):\n        arr = [x]\n        vis[x] = True\n        pt = 0\n        while pt < len(arr):\n            y = arr[pt]\n            pt += 1\n            for i in g[y]:\n                if not vis[i]:\n                    vis[i] = True\n                    arr.append(i)\n        return sorted(arr)\n    for i in range(n):\n        subtree = []\n        vis = [False] * n\n        vis[i] = True\n        for j in g[i]:\n            arr = dfs(j, vis)\n            subtree.append(arr)\n        subtree.sort()\n        if subtree != sub[i]:\n            return -1\n    patch_cords = []\n    for i in range(n):\n        for j in g[i]:\n            if i < j:\n                patch_cords.append((i + 0, j + 1))\n    return (n - 1, patch_cords)"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "patch_cords.append((i + 1, j + 1))",
      "mutated_line": "patch_cords.append((i + -1, j + 1))",
      "code": "def restore_network_topology(n, router_lists):\n    sub = [[] for _ in range(n)]\n    for i in range(n):\n        data = router_lists[i]\n        for j in data.split('-'):\n            tree = list(map(int, j.split(':')[1].split(',')))\n            for k in range(len(tree)):\n                tree[k] -= 1\n            sub[i].append(sorted(tree))\n        sub[i].sort()\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in sub[i]:\n            for k in j:\n                dp[i][k] = n - len(j)\n    g = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i < j and dp[i][j] + dp[j][i] == n:\n                g[i].append(j)\n                g[j].append(i)\n\n    def dfs(x, vis):\n        arr = [x]\n        vis[x] = True\n        pt = 0\n        while pt < len(arr):\n            y = arr[pt]\n            pt += 1\n            for i in g[y]:\n                if not vis[i]:\n                    vis[i] = True\n                    arr.append(i)\n        return sorted(arr)\n    for i in range(n):\n        subtree = []\n        vis = [False] * n\n        vis[i] = True\n        for j in g[i]:\n            arr = dfs(j, vis)\n            subtree.append(arr)\n        subtree.sort()\n        if subtree != sub[i]:\n            return -1\n    patch_cords = []\n    for i in range(n):\n        for j in g[i]:\n            if i < j:\n                patch_cords.append((i + -1, j + 1))\n    return (n - 1, patch_cords)"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "patch_cords.append((i + 1, j + 1))",
      "mutated_line": "patch_cords.append((i + 1, j + 2))",
      "code": "def restore_network_topology(n, router_lists):\n    sub = [[] for _ in range(n)]\n    for i in range(n):\n        data = router_lists[i]\n        for j in data.split('-'):\n            tree = list(map(int, j.split(':')[1].split(',')))\n            for k in range(len(tree)):\n                tree[k] -= 1\n            sub[i].append(sorted(tree))\n        sub[i].sort()\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in sub[i]:\n            for k in j:\n                dp[i][k] = n - len(j)\n    g = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i < j and dp[i][j] + dp[j][i] == n:\n                g[i].append(j)\n                g[j].append(i)\n\n    def dfs(x, vis):\n        arr = [x]\n        vis[x] = True\n        pt = 0\n        while pt < len(arr):\n            y = arr[pt]\n            pt += 1\n            for i in g[y]:\n                if not vis[i]:\n                    vis[i] = True\n                    arr.append(i)\n        return sorted(arr)\n    for i in range(n):\n        subtree = []\n        vis = [False] * n\n        vis[i] = True\n        for j in g[i]:\n            arr = dfs(j, vis)\n            subtree.append(arr)\n        subtree.sort()\n        if subtree != sub[i]:\n            return -1\n    patch_cords = []\n    for i in range(n):\n        for j in g[i]:\n            if i < j:\n                patch_cords.append((i + 1, j + 2))\n    return (n - 1, patch_cords)"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "patch_cords.append((i + 1, j + 1))",
      "mutated_line": "patch_cords.append((i + 1, j + 0))",
      "code": "def restore_network_topology(n, router_lists):\n    sub = [[] for _ in range(n)]\n    for i in range(n):\n        data = router_lists[i]\n        for j in data.split('-'):\n            tree = list(map(int, j.split(':')[1].split(',')))\n            for k in range(len(tree)):\n                tree[k] -= 1\n            sub[i].append(sorted(tree))\n        sub[i].sort()\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in sub[i]:\n            for k in j:\n                dp[i][k] = n - len(j)\n    g = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i < j and dp[i][j] + dp[j][i] == n:\n                g[i].append(j)\n                g[j].append(i)\n\n    def dfs(x, vis):\n        arr = [x]\n        vis[x] = True\n        pt = 0\n        while pt < len(arr):\n            y = arr[pt]\n            pt += 1\n            for i in g[y]:\n                if not vis[i]:\n                    vis[i] = True\n                    arr.append(i)\n        return sorted(arr)\n    for i in range(n):\n        subtree = []\n        vis = [False] * n\n        vis[i] = True\n        for j in g[i]:\n            arr = dfs(j, vis)\n            subtree.append(arr)\n        subtree.sort()\n        if subtree != sub[i]:\n            return -1\n    patch_cords = []\n    for i in range(n):\n        for j in g[i]:\n            if i < j:\n                patch_cords.append((i + 1, j + 0))\n    return (n - 1, patch_cords)"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "patch_cords.append((i + 1, j + 1))",
      "mutated_line": "patch_cords.append((i + 1, j + 0))",
      "code": "def restore_network_topology(n, router_lists):\n    sub = [[] for _ in range(n)]\n    for i in range(n):\n        data = router_lists[i]\n        for j in data.split('-'):\n            tree = list(map(int, j.split(':')[1].split(',')))\n            for k in range(len(tree)):\n                tree[k] -= 1\n            sub[i].append(sorted(tree))\n        sub[i].sort()\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in sub[i]:\n            for k in j:\n                dp[i][k] = n - len(j)\n    g = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i < j and dp[i][j] + dp[j][i] == n:\n                g[i].append(j)\n                g[j].append(i)\n\n    def dfs(x, vis):\n        arr = [x]\n        vis[x] = True\n        pt = 0\n        while pt < len(arr):\n            y = arr[pt]\n            pt += 1\n            for i in g[y]:\n                if not vis[i]:\n                    vis[i] = True\n                    arr.append(i)\n        return sorted(arr)\n    for i in range(n):\n        subtree = []\n        vis = [False] * n\n        vis[i] = True\n        for j in g[i]:\n            arr = dfs(j, vis)\n            subtree.append(arr)\n        subtree.sort()\n        if subtree != sub[i]:\n            return -1\n    patch_cords = []\n    for i in range(n):\n        for j in g[i]:\n            if i < j:\n                patch_cords.append((i + 1, j + 0))\n    return (n - 1, patch_cords)"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "patch_cords.append((i + 1, j + 1))",
      "mutated_line": "patch_cords.append((i + 1, j + -1))",
      "code": "def restore_network_topology(n, router_lists):\n    sub = [[] for _ in range(n)]\n    for i in range(n):\n        data = router_lists[i]\n        for j in data.split('-'):\n            tree = list(map(int, j.split(':')[1].split(',')))\n            for k in range(len(tree)):\n                tree[k] -= 1\n            sub[i].append(sorted(tree))\n        sub[i].sort()\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in sub[i]:\n            for k in j:\n                dp[i][k] = n - len(j)\n    g = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i < j and dp[i][j] + dp[j][i] == n:\n                g[i].append(j)\n                g[j].append(i)\n\n    def dfs(x, vis):\n        arr = [x]\n        vis[x] = True\n        pt = 0\n        while pt < len(arr):\n            y = arr[pt]\n            pt += 1\n            for i in g[y]:\n                if not vis[i]:\n                    vis[i] = True\n                    arr.append(i)\n        return sorted(arr)\n    for i in range(n):\n        subtree = []\n        vis = [False] * n\n        vis[i] = True\n        for j in g[i]:\n            arr = dfs(j, vis)\n            subtree.append(arr)\n        subtree.sort()\n        if subtree != sub[i]:\n            return -1\n    patch_cords = []\n    for i in range(n):\n        for j in g[i]:\n            if i < j:\n                patch_cords.append((i + 1, j + -1))\n    return (n - 1, patch_cords)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "tree = list(map(int, j.split(':')[1].split(',')))",
      "mutated_line": "tree = list(map(int, j.split(':')[2].split(',')))",
      "code": "def restore_network_topology(n, router_lists):\n    sub = [[] for _ in range(n)]\n    for i in range(n):\n        data = router_lists[i]\n        for j in data.split('-'):\n            tree = list(map(int, j.split(':')[2].split(',')))\n            for k in range(len(tree)):\n                tree[k] -= 1\n            sub[i].append(sorted(tree))\n        sub[i].sort()\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in sub[i]:\n            for k in j:\n                dp[i][k] = n - len(j)\n    g = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i < j and dp[i][j] + dp[j][i] == n:\n                g[i].append(j)\n                g[j].append(i)\n\n    def dfs(x, vis):\n        arr = [x]\n        vis[x] = True\n        pt = 0\n        while pt < len(arr):\n            y = arr[pt]\n            pt += 1\n            for i in g[y]:\n                if not vis[i]:\n                    vis[i] = True\n                    arr.append(i)\n        return sorted(arr)\n    for i in range(n):\n        subtree = []\n        vis = [False] * n\n        vis[i] = True\n        for j in g[i]:\n            arr = dfs(j, vis)\n            subtree.append(arr)\n        subtree.sort()\n        if subtree != sub[i]:\n            return -1\n    patch_cords = []\n    for i in range(n):\n        for j in g[i]:\n            if i < j:\n                patch_cords.append((i + 1, j + 1))\n    return (n - 1, patch_cords)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "tree = list(map(int, j.split(':')[1].split(',')))",
      "mutated_line": "tree = list(map(int, j.split(':')[0].split(',')))",
      "code": "def restore_network_topology(n, router_lists):\n    sub = [[] for _ in range(n)]\n    for i in range(n):\n        data = router_lists[i]\n        for j in data.split('-'):\n            tree = list(map(int, j.split(':')[0].split(',')))\n            for k in range(len(tree)):\n                tree[k] -= 1\n            sub[i].append(sorted(tree))\n        sub[i].sort()\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in sub[i]:\n            for k in j:\n                dp[i][k] = n - len(j)\n    g = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i < j and dp[i][j] + dp[j][i] == n:\n                g[i].append(j)\n                g[j].append(i)\n\n    def dfs(x, vis):\n        arr = [x]\n        vis[x] = True\n        pt = 0\n        while pt < len(arr):\n            y = arr[pt]\n            pt += 1\n            for i in g[y]:\n                if not vis[i]:\n                    vis[i] = True\n                    arr.append(i)\n        return sorted(arr)\n    for i in range(n):\n        subtree = []\n        vis = [False] * n\n        vis[i] = True\n        for j in g[i]:\n            arr = dfs(j, vis)\n            subtree.append(arr)\n        subtree.sort()\n        if subtree != sub[i]:\n            return -1\n    patch_cords = []\n    for i in range(n):\n        for j in g[i]:\n            if i < j:\n                patch_cords.append((i + 1, j + 1))\n    return (n - 1, patch_cords)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "tree = list(map(int, j.split(':')[1].split(',')))",
      "mutated_line": "tree = list(map(int, j.split(':')[0].split(',')))",
      "code": "def restore_network_topology(n, router_lists):\n    sub = [[] for _ in range(n)]\n    for i in range(n):\n        data = router_lists[i]\n        for j in data.split('-'):\n            tree = list(map(int, j.split(':')[0].split(',')))\n            for k in range(len(tree)):\n                tree[k] -= 1\n            sub[i].append(sorted(tree))\n        sub[i].sort()\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in sub[i]:\n            for k in j:\n                dp[i][k] = n - len(j)\n    g = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i < j and dp[i][j] + dp[j][i] == n:\n                g[i].append(j)\n                g[j].append(i)\n\n    def dfs(x, vis):\n        arr = [x]\n        vis[x] = True\n        pt = 0\n        while pt < len(arr):\n            y = arr[pt]\n            pt += 1\n            for i in g[y]:\n                if not vis[i]:\n                    vis[i] = True\n                    arr.append(i)\n        return sorted(arr)\n    for i in range(n):\n        subtree = []\n        vis = [False] * n\n        vis[i] = True\n        for j in g[i]:\n            arr = dfs(j, vis)\n            subtree.append(arr)\n        subtree.sort()\n        if subtree != sub[i]:\n            return -1\n    patch_cords = []\n    for i in range(n):\n        for j in g[i]:\n            if i < j:\n                patch_cords.append((i + 1, j + 1))\n    return (n - 1, patch_cords)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "tree = list(map(int, j.split(':')[1].split(',')))",
      "mutated_line": "tree = list(map(int, j.split(':')[-1].split(',')))",
      "code": "def restore_network_topology(n, router_lists):\n    sub = [[] for _ in range(n)]\n    for i in range(n):\n        data = router_lists[i]\n        for j in data.split('-'):\n            tree = list(map(int, j.split(':')[-1].split(',')))\n            for k in range(len(tree)):\n                tree[k] -= 1\n            sub[i].append(sorted(tree))\n        sub[i].sort()\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in sub[i]:\n            for k in j:\n                dp[i][k] = n - len(j)\n    g = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i < j and dp[i][j] + dp[j][i] == n:\n                g[i].append(j)\n                g[j].append(i)\n\n    def dfs(x, vis):\n        arr = [x]\n        vis[x] = True\n        pt = 0\n        while pt < len(arr):\n            y = arr[pt]\n            pt += 1\n            for i in g[y]:\n                if not vis[i]:\n                    vis[i] = True\n                    arr.append(i)\n        return sorted(arr)\n    for i in range(n):\n        subtree = []\n        vis = [False] * n\n        vis[i] = True\n        for j in g[i]:\n            arr = dfs(j, vis)\n            subtree.append(arr)\n        subtree.sort()\n        if subtree != sub[i]:\n            return -1\n    patch_cords = []\n    for i in range(n):\n        for j in g[i]:\n            if i < j:\n                patch_cords.append((i + 1, j + 1))\n    return (n - 1, patch_cords)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "tree = list(map(int, j.split(':')[1].split(',')))",
      "mutated_line": "tree = list(map(int, j.split('')[1].split(',')))",
      "code": "def restore_network_topology(n, router_lists):\n    sub = [[] for _ in range(n)]\n    for i in range(n):\n        data = router_lists[i]\n        for j in data.split('-'):\n            tree = list(map(int, j.split('')[1].split(',')))\n            for k in range(len(tree)):\n                tree[k] -= 1\n            sub[i].append(sorted(tree))\n        sub[i].sort()\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in sub[i]:\n            for k in j:\n                dp[i][k] = n - len(j)\n    g = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i < j and dp[i][j] + dp[j][i] == n:\n                g[i].append(j)\n                g[j].append(i)\n\n    def dfs(x, vis):\n        arr = [x]\n        vis[x] = True\n        pt = 0\n        while pt < len(arr):\n            y = arr[pt]\n            pt += 1\n            for i in g[y]:\n                if not vis[i]:\n                    vis[i] = True\n                    arr.append(i)\n        return sorted(arr)\n    for i in range(n):\n        subtree = []\n        vis = [False] * n\n        vis[i] = True\n        for j in g[i]:\n            arr = dfs(j, vis)\n            subtree.append(arr)\n        subtree.sort()\n        if subtree != sub[i]:\n            return -1\n    patch_cords = []\n    for i in range(n):\n        for j in g[i]:\n            if i < j:\n                patch_cords.append((i + 1, j + 1))\n    return (n - 1, patch_cords)"
    }
  ]
}