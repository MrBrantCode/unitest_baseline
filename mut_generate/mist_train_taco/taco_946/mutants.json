{
  "task_id": "taco_946",
  "entry_point": "find_min_bridges",
  "mutant_count": 44,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "visited = [False] * (N + 1)",
      "mutated_line": "visited = [False] / (N + 1)",
      "code": "from collections import deque\n\ndef find_min_bridges(N, M, bridges):\n    visited = [False] / (N + 1)\n    level = [0] * (N + 1)\n    graph = {i: [] for i in range(1, N + 1)}\n    for (x, y) in bridges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def bfs(graph, start):\n        q = deque([start])\n        visited[start] = True\n        while q:\n            p = q.popleft()\n            for neighbor in graph[p]:\n                if not visited[neighbor]:\n                    level[neighbor] = level[p] + 1\n                    q.append(neighbor)\n                    visited[neighbor] = True\n    bfs(graph, 1)\n    return level[N]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "visited = [False] * (N + 1)",
      "mutated_line": "visited = [False] + (N + 1)",
      "code": "from collections import deque\n\ndef find_min_bridges(N, M, bridges):\n    visited = [False] + (N + 1)\n    level = [0] * (N + 1)\n    graph = {i: [] for i in range(1, N + 1)}\n    for (x, y) in bridges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def bfs(graph, start):\n        q = deque([start])\n        visited[start] = True\n        while q:\n            p = q.popleft()\n            for neighbor in graph[p]:\n                if not visited[neighbor]:\n                    level[neighbor] = level[p] + 1\n                    q.append(neighbor)\n                    visited[neighbor] = True\n    bfs(graph, 1)\n    return level[N]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "visited = [False] * (N + 1)",
      "mutated_line": "visited = [False] ** (N + 1)",
      "code": "from collections import deque\n\ndef find_min_bridges(N, M, bridges):\n    visited = [False] ** (N + 1)\n    level = [0] * (N + 1)\n    graph = {i: [] for i in range(1, N + 1)}\n    for (x, y) in bridges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def bfs(graph, start):\n        q = deque([start])\n        visited[start] = True\n        while q:\n            p = q.popleft()\n            for neighbor in graph[p]:\n                if not visited[neighbor]:\n                    level[neighbor] = level[p] + 1\n                    q.append(neighbor)\n                    visited[neighbor] = True\n    bfs(graph, 1)\n    return level[N]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "level = [0] * (N + 1)",
      "mutated_line": "level = [0] / (N + 1)",
      "code": "from collections import deque\n\ndef find_min_bridges(N, M, bridges):\n    visited = [False] * (N + 1)\n    level = [0] / (N + 1)\n    graph = {i: [] for i in range(1, N + 1)}\n    for (x, y) in bridges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def bfs(graph, start):\n        q = deque([start])\n        visited[start] = True\n        while q:\n            p = q.popleft()\n            for neighbor in graph[p]:\n                if not visited[neighbor]:\n                    level[neighbor] = level[p] + 1\n                    q.append(neighbor)\n                    visited[neighbor] = True\n    bfs(graph, 1)\n    return level[N]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "level = [0] * (N + 1)",
      "mutated_line": "level = [0] + (N + 1)",
      "code": "from collections import deque\n\ndef find_min_bridges(N, M, bridges):\n    visited = [False] * (N + 1)\n    level = [0] + (N + 1)\n    graph = {i: [] for i in range(1, N + 1)}\n    for (x, y) in bridges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def bfs(graph, start):\n        q = deque([start])\n        visited[start] = True\n        while q:\n            p = q.popleft()\n            for neighbor in graph[p]:\n                if not visited[neighbor]:\n                    level[neighbor] = level[p] + 1\n                    q.append(neighbor)\n                    visited[neighbor] = True\n    bfs(graph, 1)\n    return level[N]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "level = [0] * (N + 1)",
      "mutated_line": "level = [0] ** (N + 1)",
      "code": "from collections import deque\n\ndef find_min_bridges(N, M, bridges):\n    visited = [False] * (N + 1)\n    level = [0] ** (N + 1)\n    graph = {i: [] for i in range(1, N + 1)}\n    for (x, y) in bridges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def bfs(graph, start):\n        q = deque([start])\n        visited[start] = True\n        while q:\n            p = q.popleft()\n            for neighbor in graph[p]:\n                if not visited[neighbor]:\n                    level[neighbor] = level[p] + 1\n                    q.append(neighbor)\n                    visited[neighbor] = True\n    bfs(graph, 1)\n    return level[N]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "visited = [False] * (N + 1)",
      "mutated_line": "visited = [False] * (N - 1)",
      "code": "from collections import deque\n\ndef find_min_bridges(N, M, bridges):\n    visited = [False] * (N - 1)\n    level = [0] * (N + 1)\n    graph = {i: [] for i in range(1, N + 1)}\n    for (x, y) in bridges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def bfs(graph, start):\n        q = deque([start])\n        visited[start] = True\n        while q:\n            p = q.popleft()\n            for neighbor in graph[p]:\n                if not visited[neighbor]:\n                    level[neighbor] = level[p] + 1\n                    q.append(neighbor)\n                    visited[neighbor] = True\n    bfs(graph, 1)\n    return level[N]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "visited = [False] * (N + 1)",
      "mutated_line": "visited = [False] * (N * 1)",
      "code": "from collections import deque\n\ndef find_min_bridges(N, M, bridges):\n    visited = [False] * (N * 1)\n    level = [0] * (N + 1)\n    graph = {i: [] for i in range(1, N + 1)}\n    for (x, y) in bridges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def bfs(graph, start):\n        q = deque([start])\n        visited[start] = True\n        while q:\n            p = q.popleft()\n            for neighbor in graph[p]:\n                if not visited[neighbor]:\n                    level[neighbor] = level[p] + 1\n                    q.append(neighbor)\n                    visited[neighbor] = True\n    bfs(graph, 1)\n    return level[N]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "level = [0] * (N + 1)",
      "mutated_line": "level = [0] * (N - 1)",
      "code": "from collections import deque\n\ndef find_min_bridges(N, M, bridges):\n    visited = [False] * (N + 1)\n    level = [0] * (N - 1)\n    graph = {i: [] for i in range(1, N + 1)}\n    for (x, y) in bridges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def bfs(graph, start):\n        q = deque([start])\n        visited[start] = True\n        while q:\n            p = q.popleft()\n            for neighbor in graph[p]:\n                if not visited[neighbor]:\n                    level[neighbor] = level[p] + 1\n                    q.append(neighbor)\n                    visited[neighbor] = True\n    bfs(graph, 1)\n    return level[N]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "level = [0] * (N + 1)",
      "mutated_line": "level = [0] * (N * 1)",
      "code": "from collections import deque\n\ndef find_min_bridges(N, M, bridges):\n    visited = [False] * (N + 1)\n    level = [0] * (N * 1)\n    graph = {i: [] for i in range(1, N + 1)}\n    for (x, y) in bridges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def bfs(graph, start):\n        q = deque([start])\n        visited[start] = True\n        while q:\n            p = q.popleft()\n            for neighbor in graph[p]:\n                if not visited[neighbor]:\n                    level[neighbor] = level[p] + 1\n                    q.append(neighbor)\n                    visited[neighbor] = True\n    bfs(graph, 1)\n    return level[N]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "visited[start] = True",
      "mutated_line": "visited[start] = False",
      "code": "from collections import deque\n\ndef find_min_bridges(N, M, bridges):\n    visited = [False] * (N + 1)\n    level = [0] * (N + 1)\n    graph = {i: [] for i in range(1, N + 1)}\n    for (x, y) in bridges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def bfs(graph, start):\n        q = deque([start])\n        visited[start] = False\n        while q:\n            p = q.popleft()\n            for neighbor in graph[p]:\n                if not visited[neighbor]:\n                    level[neighbor] = level[p] + 1\n                    q.append(neighbor)\n                    visited[neighbor] = True\n    bfs(graph, 1)\n    return level[N]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "bfs(graph, 1)",
      "mutated_line": "bfs(graph, 2)",
      "code": "from collections import deque\n\ndef find_min_bridges(N, M, bridges):\n    visited = [False] * (N + 1)\n    level = [0] * (N + 1)\n    graph = {i: [] for i in range(1, N + 1)}\n    for (x, y) in bridges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def bfs(graph, start):\n        q = deque([start])\n        visited[start] = True\n        while q:\n            p = q.popleft()\n            for neighbor in graph[p]:\n                if not visited[neighbor]:\n                    level[neighbor] = level[p] + 1\n                    q.append(neighbor)\n                    visited[neighbor] = True\n    bfs(graph, 2)\n    return level[N]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "bfs(graph, 1)",
      "mutated_line": "bfs(graph, 0)",
      "code": "from collections import deque\n\ndef find_min_bridges(N, M, bridges):\n    visited = [False] * (N + 1)\n    level = [0] * (N + 1)\n    graph = {i: [] for i in range(1, N + 1)}\n    for (x, y) in bridges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def bfs(graph, start):\n        q = deque([start])\n        visited[start] = True\n        while q:\n            p = q.popleft()\n            for neighbor in graph[p]:\n                if not visited[neighbor]:\n                    level[neighbor] = level[p] + 1\n                    q.append(neighbor)\n                    visited[neighbor] = True\n    bfs(graph, 0)\n    return level[N]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "bfs(graph, 1)",
      "mutated_line": "bfs(graph, 0)",
      "code": "from collections import deque\n\ndef find_min_bridges(N, M, bridges):\n    visited = [False] * (N + 1)\n    level = [0] * (N + 1)\n    graph = {i: [] for i in range(1, N + 1)}\n    for (x, y) in bridges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def bfs(graph, start):\n        q = deque([start])\n        visited[start] = True\n        while q:\n            p = q.popleft()\n            for neighbor in graph[p]:\n                if not visited[neighbor]:\n                    level[neighbor] = level[p] + 1\n                    q.append(neighbor)\n                    visited[neighbor] = True\n    bfs(graph, 0)\n    return level[N]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "bfs(graph, 1)",
      "mutated_line": "bfs(graph, -1)",
      "code": "from collections import deque\n\ndef find_min_bridges(N, M, bridges):\n    visited = [False] * (N + 1)\n    level = [0] * (N + 1)\n    graph = {i: [] for i in range(1, N + 1)}\n    for (x, y) in bridges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def bfs(graph, start):\n        q = deque([start])\n        visited[start] = True\n        while q:\n            p = q.popleft()\n            for neighbor in graph[p]:\n                if not visited[neighbor]:\n                    level[neighbor] = level[p] + 1\n                    q.append(neighbor)\n                    visited[neighbor] = True\n    bfs(graph, -1)\n    return level[N]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "visited = [False] * (N + 1)",
      "mutated_line": "visited = [True] * (N + 1)",
      "code": "from collections import deque\n\ndef find_min_bridges(N, M, bridges):\n    visited = [True] * (N + 1)\n    level = [0] * (N + 1)\n    graph = {i: [] for i in range(1, N + 1)}\n    for (x, y) in bridges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def bfs(graph, start):\n        q = deque([start])\n        visited[start] = True\n        while q:\n            p = q.popleft()\n            for neighbor in graph[p]:\n                if not visited[neighbor]:\n                    level[neighbor] = level[p] + 1\n                    q.append(neighbor)\n                    visited[neighbor] = True\n    bfs(graph, 1)\n    return level[N]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "visited = [False] * (N + 1)",
      "mutated_line": "visited = [False] * (N + 2)",
      "code": "from collections import deque\n\ndef find_min_bridges(N, M, bridges):\n    visited = [False] * (N + 2)\n    level = [0] * (N + 1)\n    graph = {i: [] for i in range(1, N + 1)}\n    for (x, y) in bridges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def bfs(graph, start):\n        q = deque([start])\n        visited[start] = True\n        while q:\n            p = q.popleft()\n            for neighbor in graph[p]:\n                if not visited[neighbor]:\n                    level[neighbor] = level[p] + 1\n                    q.append(neighbor)\n                    visited[neighbor] = True\n    bfs(graph, 1)\n    return level[N]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "visited = [False] * (N + 1)",
      "mutated_line": "visited = [False] * (N + 0)",
      "code": "from collections import deque\n\ndef find_min_bridges(N, M, bridges):\n    visited = [False] * (N + 0)\n    level = [0] * (N + 1)\n    graph = {i: [] for i in range(1, N + 1)}\n    for (x, y) in bridges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def bfs(graph, start):\n        q = deque([start])\n        visited[start] = True\n        while q:\n            p = q.popleft()\n            for neighbor in graph[p]:\n                if not visited[neighbor]:\n                    level[neighbor] = level[p] + 1\n                    q.append(neighbor)\n                    visited[neighbor] = True\n    bfs(graph, 1)\n    return level[N]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "visited = [False] * (N + 1)",
      "mutated_line": "visited = [False] * (N + 0)",
      "code": "from collections import deque\n\ndef find_min_bridges(N, M, bridges):\n    visited = [False] * (N + 0)\n    level = [0] * (N + 1)\n    graph = {i: [] for i in range(1, N + 1)}\n    for (x, y) in bridges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def bfs(graph, start):\n        q = deque([start])\n        visited[start] = True\n        while q:\n            p = q.popleft()\n            for neighbor in graph[p]:\n                if not visited[neighbor]:\n                    level[neighbor] = level[p] + 1\n                    q.append(neighbor)\n                    visited[neighbor] = True\n    bfs(graph, 1)\n    return level[N]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "visited = [False] * (N + 1)",
      "mutated_line": "visited = [False] * (N + -1)",
      "code": "from collections import deque\n\ndef find_min_bridges(N, M, bridges):\n    visited = [False] * (N + -1)\n    level = [0] * (N + 1)\n    graph = {i: [] for i in range(1, N + 1)}\n    for (x, y) in bridges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def bfs(graph, start):\n        q = deque([start])\n        visited[start] = True\n        while q:\n            p = q.popleft()\n            for neighbor in graph[p]:\n                if not visited[neighbor]:\n                    level[neighbor] = level[p] + 1\n                    q.append(neighbor)\n                    visited[neighbor] = True\n    bfs(graph, 1)\n    return level[N]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "level = [0] * (N + 1)",
      "mutated_line": "level = [1] * (N + 1)",
      "code": "from collections import deque\n\ndef find_min_bridges(N, M, bridges):\n    visited = [False] * (N + 1)\n    level = [1] * (N + 1)\n    graph = {i: [] for i in range(1, N + 1)}\n    for (x, y) in bridges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def bfs(graph, start):\n        q = deque([start])\n        visited[start] = True\n        while q:\n            p = q.popleft()\n            for neighbor in graph[p]:\n                if not visited[neighbor]:\n                    level[neighbor] = level[p] + 1\n                    q.append(neighbor)\n                    visited[neighbor] = True\n    bfs(graph, 1)\n    return level[N]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "level = [0] * (N + 1)",
      "mutated_line": "level = [-1] * (N + 1)",
      "code": "from collections import deque\n\ndef find_min_bridges(N, M, bridges):\n    visited = [False] * (N + 1)\n    level = [-1] * (N + 1)\n    graph = {i: [] for i in range(1, N + 1)}\n    for (x, y) in bridges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def bfs(graph, start):\n        q = deque([start])\n        visited[start] = True\n        while q:\n            p = q.popleft()\n            for neighbor in graph[p]:\n                if not visited[neighbor]:\n                    level[neighbor] = level[p] + 1\n                    q.append(neighbor)\n                    visited[neighbor] = True\n    bfs(graph, 1)\n    return level[N]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "level = [0] * (N + 1)",
      "mutated_line": "level = [1] * (N + 1)",
      "code": "from collections import deque\n\ndef find_min_bridges(N, M, bridges):\n    visited = [False] * (N + 1)\n    level = [1] * (N + 1)\n    graph = {i: [] for i in range(1, N + 1)}\n    for (x, y) in bridges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def bfs(graph, start):\n        q = deque([start])\n        visited[start] = True\n        while q:\n            p = q.popleft()\n            for neighbor in graph[p]:\n                if not visited[neighbor]:\n                    level[neighbor] = level[p] + 1\n                    q.append(neighbor)\n                    visited[neighbor] = True\n    bfs(graph, 1)\n    return level[N]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "level = [0] * (N + 1)",
      "mutated_line": "level = [0] * (N + 2)",
      "code": "from collections import deque\n\ndef find_min_bridges(N, M, bridges):\n    visited = [False] * (N + 1)\n    level = [0] * (N + 2)\n    graph = {i: [] for i in range(1, N + 1)}\n    for (x, y) in bridges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def bfs(graph, start):\n        q = deque([start])\n        visited[start] = True\n        while q:\n            p = q.popleft()\n            for neighbor in graph[p]:\n                if not visited[neighbor]:\n                    level[neighbor] = level[p] + 1\n                    q.append(neighbor)\n                    visited[neighbor] = True\n    bfs(graph, 1)\n    return level[N]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "level = [0] * (N + 1)",
      "mutated_line": "level = [0] * (N + 0)",
      "code": "from collections import deque\n\ndef find_min_bridges(N, M, bridges):\n    visited = [False] * (N + 1)\n    level = [0] * (N + 0)\n    graph = {i: [] for i in range(1, N + 1)}\n    for (x, y) in bridges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def bfs(graph, start):\n        q = deque([start])\n        visited[start] = True\n        while q:\n            p = q.popleft()\n            for neighbor in graph[p]:\n                if not visited[neighbor]:\n                    level[neighbor] = level[p] + 1\n                    q.append(neighbor)\n                    visited[neighbor] = True\n    bfs(graph, 1)\n    return level[N]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "level = [0] * (N + 1)",
      "mutated_line": "level = [0] * (N + 0)",
      "code": "from collections import deque\n\ndef find_min_bridges(N, M, bridges):\n    visited = [False] * (N + 1)\n    level = [0] * (N + 0)\n    graph = {i: [] for i in range(1, N + 1)}\n    for (x, y) in bridges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def bfs(graph, start):\n        q = deque([start])\n        visited[start] = True\n        while q:\n            p = q.popleft()\n            for neighbor in graph[p]:\n                if not visited[neighbor]:\n                    level[neighbor] = level[p] + 1\n                    q.append(neighbor)\n                    visited[neighbor] = True\n    bfs(graph, 1)\n    return level[N]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "level = [0] * (N + 1)",
      "mutated_line": "level = [0] * (N + -1)",
      "code": "from collections import deque\n\ndef find_min_bridges(N, M, bridges):\n    visited = [False] * (N + 1)\n    level = [0] * (N + -1)\n    graph = {i: [] for i in range(1, N + 1)}\n    for (x, y) in bridges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def bfs(graph, start):\n        q = deque([start])\n        visited[start] = True\n        while q:\n            p = q.popleft()\n            for neighbor in graph[p]:\n                if not visited[neighbor]:\n                    level[neighbor] = level[p] + 1\n                    q.append(neighbor)\n                    visited[neighbor] = True\n    bfs(graph, 1)\n    return level[N]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "graph = {i: [] for i in range(1, N + 1)}",
      "mutated_line": "for (x, y) in bridges:",
      "code": "from collections import deque\n\ndef find_min_bridges(N, M, bridges):\n    visited = [False] * (N + 1)\n    level = [0] * (N + 1)\n    graph = {i: [] for i in range(2, N + 1)}\n    for (x, y) in bridges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def bfs(graph, start):\n        q = deque([start])\n        visited[start] = True\n        while q:\n            p = q.popleft()\n            for neighbor in graph[p]:\n                if not visited[neighbor]:\n                    level[neighbor] = level[p] + 1\n                    q.append(neighbor)\n                    visited[neighbor] = True\n    bfs(graph, 1)\n    return level[N]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "graph = {i: [] for i in range(1, N + 1)}",
      "mutated_line": "for (x, y) in bridges:",
      "code": "from collections import deque\n\ndef find_min_bridges(N, M, bridges):\n    visited = [False] * (N + 1)\n    level = [0] * (N + 1)\n    graph = {i: [] for i in range(0, N + 1)}\n    for (x, y) in bridges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def bfs(graph, start):\n        q = deque([start])\n        visited[start] = True\n        while q:\n            p = q.popleft()\n            for neighbor in graph[p]:\n                if not visited[neighbor]:\n                    level[neighbor] = level[p] + 1\n                    q.append(neighbor)\n                    visited[neighbor] = True\n    bfs(graph, 1)\n    return level[N]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "graph = {i: [] for i in range(1, N + 1)}",
      "mutated_line": "for (x, y) in bridges:",
      "code": "from collections import deque\n\ndef find_min_bridges(N, M, bridges):\n    visited = [False] * (N + 1)\n    level = [0] * (N + 1)\n    graph = {i: [] for i in range(0, N + 1)}\n    for (x, y) in bridges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def bfs(graph, start):\n        q = deque([start])\n        visited[start] = True\n        while q:\n            p = q.popleft()\n            for neighbor in graph[p]:\n                if not visited[neighbor]:\n                    level[neighbor] = level[p] + 1\n                    q.append(neighbor)\n                    visited[neighbor] = True\n    bfs(graph, 1)\n    return level[N]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "graph = {i: [] for i in range(1, N + 1)}",
      "mutated_line": "for (x, y) in bridges:",
      "code": "from collections import deque\n\ndef find_min_bridges(N, M, bridges):\n    visited = [False] * (N + 1)\n    level = [0] * (N + 1)\n    graph = {i: [] for i in range(-1, N + 1)}\n    for (x, y) in bridges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def bfs(graph, start):\n        q = deque([start])\n        visited[start] = True\n        while q:\n            p = q.popleft()\n            for neighbor in graph[p]:\n                if not visited[neighbor]:\n                    level[neighbor] = level[p] + 1\n                    q.append(neighbor)\n                    visited[neighbor] = True\n    bfs(graph, 1)\n    return level[N]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "graph = {i: [] for i in range(1, N + 1)}",
      "mutated_line": "for (x, y) in bridges:",
      "code": "from collections import deque\n\ndef find_min_bridges(N, M, bridges):\n    visited = [False] * (N + 1)\n    level = [0] * (N + 1)\n    graph = {i: [] for i in range(1, N - 1)}\n    for (x, y) in bridges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def bfs(graph, start):\n        q = deque([start])\n        visited[start] = True\n        while q:\n            p = q.popleft()\n            for neighbor in graph[p]:\n                if not visited[neighbor]:\n                    level[neighbor] = level[p] + 1\n                    q.append(neighbor)\n                    visited[neighbor] = True\n    bfs(graph, 1)\n    return level[N]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "graph = {i: [] for i in range(1, N + 1)}",
      "mutated_line": "for (x, y) in bridges:",
      "code": "from collections import deque\n\ndef find_min_bridges(N, M, bridges):\n    visited = [False] * (N + 1)\n    level = [0] * (N + 1)\n    graph = {i: [] for i in range(1, N * 1)}\n    for (x, y) in bridges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def bfs(graph, start):\n        q = deque([start])\n        visited[start] = True\n        while q:\n            p = q.popleft()\n            for neighbor in graph[p]:\n                if not visited[neighbor]:\n                    level[neighbor] = level[p] + 1\n                    q.append(neighbor)\n                    visited[neighbor] = True\n    bfs(graph, 1)\n    return level[N]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "graph = {i: [] for i in range(1, N + 1)}",
      "mutated_line": "for (x, y) in bridges:",
      "code": "from collections import deque\n\ndef find_min_bridges(N, M, bridges):\n    visited = [False] * (N + 1)\n    level = [0] * (N + 1)\n    graph = {i: [] for i in range(1, N + 2)}\n    for (x, y) in bridges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def bfs(graph, start):\n        q = deque([start])\n        visited[start] = True\n        while q:\n            p = q.popleft()\n            for neighbor in graph[p]:\n                if not visited[neighbor]:\n                    level[neighbor] = level[p] + 1\n                    q.append(neighbor)\n                    visited[neighbor] = True\n    bfs(graph, 1)\n    return level[N]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "graph = {i: [] for i in range(1, N + 1)}",
      "mutated_line": "for (x, y) in bridges:",
      "code": "from collections import deque\n\ndef find_min_bridges(N, M, bridges):\n    visited = [False] * (N + 1)\n    level = [0] * (N + 1)\n    graph = {i: [] for i in range(1, N + 0)}\n    for (x, y) in bridges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def bfs(graph, start):\n        q = deque([start])\n        visited[start] = True\n        while q:\n            p = q.popleft()\n            for neighbor in graph[p]:\n                if not visited[neighbor]:\n                    level[neighbor] = level[p] + 1\n                    q.append(neighbor)\n                    visited[neighbor] = True\n    bfs(graph, 1)\n    return level[N]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "graph = {i: [] for i in range(1, N + 1)}",
      "mutated_line": "for (x, y) in bridges:",
      "code": "from collections import deque\n\ndef find_min_bridges(N, M, bridges):\n    visited = [False] * (N + 1)\n    level = [0] * (N + 1)\n    graph = {i: [] for i in range(1, N + 0)}\n    for (x, y) in bridges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def bfs(graph, start):\n        q = deque([start])\n        visited[start] = True\n        while q:\n            p = q.popleft()\n            for neighbor in graph[p]:\n                if not visited[neighbor]:\n                    level[neighbor] = level[p] + 1\n                    q.append(neighbor)\n                    visited[neighbor] = True\n    bfs(graph, 1)\n    return level[N]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "graph = {i: [] for i in range(1, N + 1)}",
      "mutated_line": "for (x, y) in bridges:",
      "code": "from collections import deque\n\ndef find_min_bridges(N, M, bridges):\n    visited = [False] * (N + 1)\n    level = [0] * (N + 1)\n    graph = {i: [] for i in range(1, N + -1)}\n    for (x, y) in bridges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def bfs(graph, start):\n        q = deque([start])\n        visited[start] = True\n        while q:\n            p = q.popleft()\n            for neighbor in graph[p]:\n                if not visited[neighbor]:\n                    level[neighbor] = level[p] + 1\n                    q.append(neighbor)\n                    visited[neighbor] = True\n    bfs(graph, 1)\n    return level[N]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "level[neighbor] = level[p] + 1",
      "mutated_line": "level[neighbor] = level[p] - 1",
      "code": "from collections import deque\n\ndef find_min_bridges(N, M, bridges):\n    visited = [False] * (N + 1)\n    level = [0] * (N + 1)\n    graph = {i: [] for i in range(1, N + 1)}\n    for (x, y) in bridges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def bfs(graph, start):\n        q = deque([start])\n        visited[start] = True\n        while q:\n            p = q.popleft()\n            for neighbor in graph[p]:\n                if not visited[neighbor]:\n                    level[neighbor] = level[p] - 1\n                    q.append(neighbor)\n                    visited[neighbor] = True\n    bfs(graph, 1)\n    return level[N]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "level[neighbor] = level[p] + 1",
      "mutated_line": "level[neighbor] = level[p] * 1",
      "code": "from collections import deque\n\ndef find_min_bridges(N, M, bridges):\n    visited = [False] * (N + 1)\n    level = [0] * (N + 1)\n    graph = {i: [] for i in range(1, N + 1)}\n    for (x, y) in bridges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def bfs(graph, start):\n        q = deque([start])\n        visited[start] = True\n        while q:\n            p = q.popleft()\n            for neighbor in graph[p]:\n                if not visited[neighbor]:\n                    level[neighbor] = level[p] * 1\n                    q.append(neighbor)\n                    visited[neighbor] = True\n    bfs(graph, 1)\n    return level[N]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "visited[neighbor] = True",
      "mutated_line": "visited[neighbor] = False",
      "code": "from collections import deque\n\ndef find_min_bridges(N, M, bridges):\n    visited = [False] * (N + 1)\n    level = [0] * (N + 1)\n    graph = {i: [] for i in range(1, N + 1)}\n    for (x, y) in bridges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def bfs(graph, start):\n        q = deque([start])\n        visited[start] = True\n        while q:\n            p = q.popleft()\n            for neighbor in graph[p]:\n                if not visited[neighbor]:\n                    level[neighbor] = level[p] + 1\n                    q.append(neighbor)\n                    visited[neighbor] = False\n    bfs(graph, 1)\n    return level[N]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "level[neighbor] = level[p] + 1",
      "mutated_line": "level[neighbor] = level[p] + 2",
      "code": "from collections import deque\n\ndef find_min_bridges(N, M, bridges):\n    visited = [False] * (N + 1)\n    level = [0] * (N + 1)\n    graph = {i: [] for i in range(1, N + 1)}\n    for (x, y) in bridges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def bfs(graph, start):\n        q = deque([start])\n        visited[start] = True\n        while q:\n            p = q.popleft()\n            for neighbor in graph[p]:\n                if not visited[neighbor]:\n                    level[neighbor] = level[p] + 2\n                    q.append(neighbor)\n                    visited[neighbor] = True\n    bfs(graph, 1)\n    return level[N]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "level[neighbor] = level[p] + 1",
      "mutated_line": "level[neighbor] = level[p] + 0",
      "code": "from collections import deque\n\ndef find_min_bridges(N, M, bridges):\n    visited = [False] * (N + 1)\n    level = [0] * (N + 1)\n    graph = {i: [] for i in range(1, N + 1)}\n    for (x, y) in bridges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def bfs(graph, start):\n        q = deque([start])\n        visited[start] = True\n        while q:\n            p = q.popleft()\n            for neighbor in graph[p]:\n                if not visited[neighbor]:\n                    level[neighbor] = level[p] + 0\n                    q.append(neighbor)\n                    visited[neighbor] = True\n    bfs(graph, 1)\n    return level[N]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "level[neighbor] = level[p] + 1",
      "mutated_line": "level[neighbor] = level[p] + 0",
      "code": "from collections import deque\n\ndef find_min_bridges(N, M, bridges):\n    visited = [False] * (N + 1)\n    level = [0] * (N + 1)\n    graph = {i: [] for i in range(1, N + 1)}\n    for (x, y) in bridges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def bfs(graph, start):\n        q = deque([start])\n        visited[start] = True\n        while q:\n            p = q.popleft()\n            for neighbor in graph[p]:\n                if not visited[neighbor]:\n                    level[neighbor] = level[p] + 0\n                    q.append(neighbor)\n                    visited[neighbor] = True\n    bfs(graph, 1)\n    return level[N]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "level[neighbor] = level[p] + 1",
      "mutated_line": "level[neighbor] = level[p] + -1",
      "code": "from collections import deque\n\ndef find_min_bridges(N, M, bridges):\n    visited = [False] * (N + 1)\n    level = [0] * (N + 1)\n    graph = {i: [] for i in range(1, N + 1)}\n    for (x, y) in bridges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def bfs(graph, start):\n        q = deque([start])\n        visited[start] = True\n        while q:\n            p = q.popleft()\n            for neighbor in graph[p]:\n                if not visited[neighbor]:\n                    level[neighbor] = level[p] + -1\n                    q.append(neighbor)\n                    visited[neighbor] = True\n    bfs(graph, 1)\n    return level[N]"
    }
  ]
}