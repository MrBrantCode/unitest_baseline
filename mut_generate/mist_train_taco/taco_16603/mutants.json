{
  "task_id": "taco_16603",
  "entry_point": "restore_original_tree",
  "mutant_count": 68,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "inc = [0] * n",
      "mutated_line": "inc = [0] / n",
      "code": "def restore_original_tree(n, m, edges):\n    inc = [0] / n\n    out = [[] for _ in range(n)]\n    parent = [[] for _ in range(n)]\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        out[a].append(b)\n        parent[b].append(a)\n        inc[b] += 1\n    S = {i for (i, c) in enumerate(inc) if c == 0}\n    L = []\n    while S:\n        k = S.pop()\n        L.append(k)\n        for m in out[k]:\n            inc[m] -= 1\n            if inc[m] == 0:\n                S.add(m)\n    A = [(float('inf'), -1) for _ in range(n)]\n    D = {j: i for (i, j) in enumerate(L)}\n    A[L[0]] = (0, -1)\n    for i in range(1, n):\n        now = L[i]\n        (d, t) = A[now]\n        for j in parent[now]:\n            if d > i - D[j]:\n                d = i - D[j]\n                t = j\n        A[now] = (d, t)\n    result = [j + 1 for (_, j) in A]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "inc = [0] * n",
      "mutated_line": "inc = [0] + n",
      "code": "def restore_original_tree(n, m, edges):\n    inc = [0] + n\n    out = [[] for _ in range(n)]\n    parent = [[] for _ in range(n)]\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        out[a].append(b)\n        parent[b].append(a)\n        inc[b] += 1\n    S = {i for (i, c) in enumerate(inc) if c == 0}\n    L = []\n    while S:\n        k = S.pop()\n        L.append(k)\n        for m in out[k]:\n            inc[m] -= 1\n            if inc[m] == 0:\n                S.add(m)\n    A = [(float('inf'), -1) for _ in range(n)]\n    D = {j: i for (i, j) in enumerate(L)}\n    A[L[0]] = (0, -1)\n    for i in range(1, n):\n        now = L[i]\n        (d, t) = A[now]\n        for j in parent[now]:\n            if d > i - D[j]:\n                d = i - D[j]\n                t = j\n        A[now] = (d, t)\n    result = [j + 1 for (_, j) in A]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "inc = [0] * n",
      "mutated_line": "inc = [0] ** n",
      "code": "def restore_original_tree(n, m, edges):\n    inc = [0] ** n\n    out = [[] for _ in range(n)]\n    parent = [[] for _ in range(n)]\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        out[a].append(b)\n        parent[b].append(a)\n        inc[b] += 1\n    S = {i for (i, c) in enumerate(inc) if c == 0}\n    L = []\n    while S:\n        k = S.pop()\n        L.append(k)\n        for m in out[k]:\n            inc[m] -= 1\n            if inc[m] == 0:\n                S.add(m)\n    A = [(float('inf'), -1) for _ in range(n)]\n    D = {j: i for (i, j) in enumerate(L)}\n    A[L[0]] = (0, -1)\n    for i in range(1, n):\n        now = L[i]\n        (d, t) = A[now]\n        for j in parent[now]:\n            if d > i - D[j]:\n                d = i - D[j]\n                t = j\n        A[now] = (d, t)\n    result = [j + 1 for (_, j) in A]\n    return result"
    },
    {
      "operator": "ASR",
      "lineno": 7,
      "original_line": "a -= 1",
      "mutated_line": "a += 1",
      "code": "def restore_original_tree(n, m, edges):\n    inc = [0] * n\n    out = [[] for _ in range(n)]\n    parent = [[] for _ in range(n)]\n    for (a, b) in edges:\n        a += 1\n        b -= 1\n        out[a].append(b)\n        parent[b].append(a)\n        inc[b] += 1\n    S = {i for (i, c) in enumerate(inc) if c == 0}\n    L = []\n    while S:\n        k = S.pop()\n        L.append(k)\n        for m in out[k]:\n            inc[m] -= 1\n            if inc[m] == 0:\n                S.add(m)\n    A = [(float('inf'), -1) for _ in range(n)]\n    D = {j: i for (i, j) in enumerate(L)}\n    A[L[0]] = (0, -1)\n    for i in range(1, n):\n        now = L[i]\n        (d, t) = A[now]\n        for j in parent[now]:\n            if d > i - D[j]:\n                d = i - D[j]\n                t = j\n        A[now] = (d, t)\n    result = [j + 1 for (_, j) in A]\n    return result"
    },
    {
      "operator": "ASR",
      "lineno": 8,
      "original_line": "b -= 1",
      "mutated_line": "b += 1",
      "code": "def restore_original_tree(n, m, edges):\n    inc = [0] * n\n    out = [[] for _ in range(n)]\n    parent = [[] for _ in range(n)]\n    for (a, b) in edges:\n        a -= 1\n        b += 1\n        out[a].append(b)\n        parent[b].append(a)\n        inc[b] += 1\n    S = {i for (i, c) in enumerate(inc) if c == 0}\n    L = []\n    while S:\n        k = S.pop()\n        L.append(k)\n        for m in out[k]:\n            inc[m] -= 1\n            if inc[m] == 0:\n                S.add(m)\n    A = [(float('inf'), -1) for _ in range(n)]\n    D = {j: i for (i, j) in enumerate(L)}\n    A[L[0]] = (0, -1)\n    for i in range(1, n):\n        now = L[i]\n        (d, t) = A[now]\n        for j in parent[now]:\n            if d > i - D[j]:\n                d = i - D[j]\n                t = j\n        A[now] = (d, t)\n    result = [j + 1 for (_, j) in A]\n    return result"
    },
    {
      "operator": "ASR",
      "lineno": 11,
      "original_line": "inc[b] += 1",
      "mutated_line": "inc[b] -= 1",
      "code": "def restore_original_tree(n, m, edges):\n    inc = [0] * n\n    out = [[] for _ in range(n)]\n    parent = [[] for _ in range(n)]\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        out[a].append(b)\n        parent[b].append(a)\n        inc[b] -= 1\n    S = {i for (i, c) in enumerate(inc) if c == 0}\n    L = []\n    while S:\n        k = S.pop()\n        L.append(k)\n        for m in out[k]:\n            inc[m] -= 1\n            if inc[m] == 0:\n                S.add(m)\n    A = [(float('inf'), -1) for _ in range(n)]\n    D = {j: i for (i, j) in enumerate(L)}\n    A[L[0]] = (0, -1)\n    for i in range(1, n):\n        now = L[i]\n        (d, t) = A[now]\n        for j in parent[now]:\n            if d > i - D[j]:\n                d = i - D[j]\n                t = j\n        A[now] = (d, t)\n    result = [j + 1 for (_, j) in A]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "a -= 1",
      "mutated_line": "a -= 2",
      "code": "def restore_original_tree(n, m, edges):\n    inc = [0] * n\n    out = [[] for _ in range(n)]\n    parent = [[] for _ in range(n)]\n    for (a, b) in edges:\n        a -= 2\n        b -= 1\n        out[a].append(b)\n        parent[b].append(a)\n        inc[b] += 1\n    S = {i for (i, c) in enumerate(inc) if c == 0}\n    L = []\n    while S:\n        k = S.pop()\n        L.append(k)\n        for m in out[k]:\n            inc[m] -= 1\n            if inc[m] == 0:\n                S.add(m)\n    A = [(float('inf'), -1) for _ in range(n)]\n    D = {j: i for (i, j) in enumerate(L)}\n    A[L[0]] = (0, -1)\n    for i in range(1, n):\n        now = L[i]\n        (d, t) = A[now]\n        for j in parent[now]:\n            if d > i - D[j]:\n                d = i - D[j]\n                t = j\n        A[now] = (d, t)\n    result = [j + 1 for (_, j) in A]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "a -= 1",
      "mutated_line": "a -= 0",
      "code": "def restore_original_tree(n, m, edges):\n    inc = [0] * n\n    out = [[] for _ in range(n)]\n    parent = [[] for _ in range(n)]\n    for (a, b) in edges:\n        a -= 0\n        b -= 1\n        out[a].append(b)\n        parent[b].append(a)\n        inc[b] += 1\n    S = {i for (i, c) in enumerate(inc) if c == 0}\n    L = []\n    while S:\n        k = S.pop()\n        L.append(k)\n        for m in out[k]:\n            inc[m] -= 1\n            if inc[m] == 0:\n                S.add(m)\n    A = [(float('inf'), -1) for _ in range(n)]\n    D = {j: i for (i, j) in enumerate(L)}\n    A[L[0]] = (0, -1)\n    for i in range(1, n):\n        now = L[i]\n        (d, t) = A[now]\n        for j in parent[now]:\n            if d > i - D[j]:\n                d = i - D[j]\n                t = j\n        A[now] = (d, t)\n    result = [j + 1 for (_, j) in A]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "a -= 1",
      "mutated_line": "a -= 0",
      "code": "def restore_original_tree(n, m, edges):\n    inc = [0] * n\n    out = [[] for _ in range(n)]\n    parent = [[] for _ in range(n)]\n    for (a, b) in edges:\n        a -= 0\n        b -= 1\n        out[a].append(b)\n        parent[b].append(a)\n        inc[b] += 1\n    S = {i for (i, c) in enumerate(inc) if c == 0}\n    L = []\n    while S:\n        k = S.pop()\n        L.append(k)\n        for m in out[k]:\n            inc[m] -= 1\n            if inc[m] == 0:\n                S.add(m)\n    A = [(float('inf'), -1) for _ in range(n)]\n    D = {j: i for (i, j) in enumerate(L)}\n    A[L[0]] = (0, -1)\n    for i in range(1, n):\n        now = L[i]\n        (d, t) = A[now]\n        for j in parent[now]:\n            if d > i - D[j]:\n                d = i - D[j]\n                t = j\n        A[now] = (d, t)\n    result = [j + 1 for (_, j) in A]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "a -= 1",
      "mutated_line": "a -= -1",
      "code": "def restore_original_tree(n, m, edges):\n    inc = [0] * n\n    out = [[] for _ in range(n)]\n    parent = [[] for _ in range(n)]\n    for (a, b) in edges:\n        a -= -1\n        b -= 1\n        out[a].append(b)\n        parent[b].append(a)\n        inc[b] += 1\n    S = {i for (i, c) in enumerate(inc) if c == 0}\n    L = []\n    while S:\n        k = S.pop()\n        L.append(k)\n        for m in out[k]:\n            inc[m] -= 1\n            if inc[m] == 0:\n                S.add(m)\n    A = [(float('inf'), -1) for _ in range(n)]\n    D = {j: i for (i, j) in enumerate(L)}\n    A[L[0]] = (0, -1)\n    for i in range(1, n):\n        now = L[i]\n        (d, t) = A[now]\n        for j in parent[now]:\n            if d > i - D[j]:\n                d = i - D[j]\n                t = j\n        A[now] = (d, t)\n    result = [j + 1 for (_, j) in A]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "b -= 1",
      "mutated_line": "b -= 2",
      "code": "def restore_original_tree(n, m, edges):\n    inc = [0] * n\n    out = [[] for _ in range(n)]\n    parent = [[] for _ in range(n)]\n    for (a, b) in edges:\n        a -= 1\n        b -= 2\n        out[a].append(b)\n        parent[b].append(a)\n        inc[b] += 1\n    S = {i for (i, c) in enumerate(inc) if c == 0}\n    L = []\n    while S:\n        k = S.pop()\n        L.append(k)\n        for m in out[k]:\n            inc[m] -= 1\n            if inc[m] == 0:\n                S.add(m)\n    A = [(float('inf'), -1) for _ in range(n)]\n    D = {j: i for (i, j) in enumerate(L)}\n    A[L[0]] = (0, -1)\n    for i in range(1, n):\n        now = L[i]\n        (d, t) = A[now]\n        for j in parent[now]:\n            if d > i - D[j]:\n                d = i - D[j]\n                t = j\n        A[now] = (d, t)\n    result = [j + 1 for (_, j) in A]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "b -= 1",
      "mutated_line": "b -= 0",
      "code": "def restore_original_tree(n, m, edges):\n    inc = [0] * n\n    out = [[] for _ in range(n)]\n    parent = [[] for _ in range(n)]\n    for (a, b) in edges:\n        a -= 1\n        b -= 0\n        out[a].append(b)\n        parent[b].append(a)\n        inc[b] += 1\n    S = {i for (i, c) in enumerate(inc) if c == 0}\n    L = []\n    while S:\n        k = S.pop()\n        L.append(k)\n        for m in out[k]:\n            inc[m] -= 1\n            if inc[m] == 0:\n                S.add(m)\n    A = [(float('inf'), -1) for _ in range(n)]\n    D = {j: i for (i, j) in enumerate(L)}\n    A[L[0]] = (0, -1)\n    for i in range(1, n):\n        now = L[i]\n        (d, t) = A[now]\n        for j in parent[now]:\n            if d > i - D[j]:\n                d = i - D[j]\n                t = j\n        A[now] = (d, t)\n    result = [j + 1 for (_, j) in A]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "b -= 1",
      "mutated_line": "b -= 0",
      "code": "def restore_original_tree(n, m, edges):\n    inc = [0] * n\n    out = [[] for _ in range(n)]\n    parent = [[] for _ in range(n)]\n    for (a, b) in edges:\n        a -= 1\n        b -= 0\n        out[a].append(b)\n        parent[b].append(a)\n        inc[b] += 1\n    S = {i for (i, c) in enumerate(inc) if c == 0}\n    L = []\n    while S:\n        k = S.pop()\n        L.append(k)\n        for m in out[k]:\n            inc[m] -= 1\n            if inc[m] == 0:\n                S.add(m)\n    A = [(float('inf'), -1) for _ in range(n)]\n    D = {j: i for (i, j) in enumerate(L)}\n    A[L[0]] = (0, -1)\n    for i in range(1, n):\n        now = L[i]\n        (d, t) = A[now]\n        for j in parent[now]:\n            if d > i - D[j]:\n                d = i - D[j]\n                t = j\n        A[now] = (d, t)\n    result = [j + 1 for (_, j) in A]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "b -= 1",
      "mutated_line": "b -= -1",
      "code": "def restore_original_tree(n, m, edges):\n    inc = [0] * n\n    out = [[] for _ in range(n)]\n    parent = [[] for _ in range(n)]\n    for (a, b) in edges:\n        a -= 1\n        b -= -1\n        out[a].append(b)\n        parent[b].append(a)\n        inc[b] += 1\n    S = {i for (i, c) in enumerate(inc) if c == 0}\n    L = []\n    while S:\n        k = S.pop()\n        L.append(k)\n        for m in out[k]:\n            inc[m] -= 1\n            if inc[m] == 0:\n                S.add(m)\n    A = [(float('inf'), -1) for _ in range(n)]\n    D = {j: i for (i, j) in enumerate(L)}\n    A[L[0]] = (0, -1)\n    for i in range(1, n):\n        now = L[i]\n        (d, t) = A[now]\n        for j in parent[now]:\n            if d > i - D[j]:\n                d = i - D[j]\n                t = j\n        A[now] = (d, t)\n    result = [j + 1 for (_, j) in A]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "inc[b] += 1",
      "mutated_line": "inc[b] += 2",
      "code": "def restore_original_tree(n, m, edges):\n    inc = [0] * n\n    out = [[] for _ in range(n)]\n    parent = [[] for _ in range(n)]\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        out[a].append(b)\n        parent[b].append(a)\n        inc[b] += 2\n    S = {i for (i, c) in enumerate(inc) if c == 0}\n    L = []\n    while S:\n        k = S.pop()\n        L.append(k)\n        for m in out[k]:\n            inc[m] -= 1\n            if inc[m] == 0:\n                S.add(m)\n    A = [(float('inf'), -1) for _ in range(n)]\n    D = {j: i for (i, j) in enumerate(L)}\n    A[L[0]] = (0, -1)\n    for i in range(1, n):\n        now = L[i]\n        (d, t) = A[now]\n        for j in parent[now]:\n            if d > i - D[j]:\n                d = i - D[j]\n                t = j\n        A[now] = (d, t)\n    result = [j + 1 for (_, j) in A]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "inc[b] += 1",
      "mutated_line": "inc[b] += 0",
      "code": "def restore_original_tree(n, m, edges):\n    inc = [0] * n\n    out = [[] for _ in range(n)]\n    parent = [[] for _ in range(n)]\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        out[a].append(b)\n        parent[b].append(a)\n        inc[b] += 0\n    S = {i for (i, c) in enumerate(inc) if c == 0}\n    L = []\n    while S:\n        k = S.pop()\n        L.append(k)\n        for m in out[k]:\n            inc[m] -= 1\n            if inc[m] == 0:\n                S.add(m)\n    A = [(float('inf'), -1) for _ in range(n)]\n    D = {j: i for (i, j) in enumerate(L)}\n    A[L[0]] = (0, -1)\n    for i in range(1, n):\n        now = L[i]\n        (d, t) = A[now]\n        for j in parent[now]:\n            if d > i - D[j]:\n                d = i - D[j]\n                t = j\n        A[now] = (d, t)\n    result = [j + 1 for (_, j) in A]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "inc[b] += 1",
      "mutated_line": "inc[b] += 0",
      "code": "def restore_original_tree(n, m, edges):\n    inc = [0] * n\n    out = [[] for _ in range(n)]\n    parent = [[] for _ in range(n)]\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        out[a].append(b)\n        parent[b].append(a)\n        inc[b] += 0\n    S = {i for (i, c) in enumerate(inc) if c == 0}\n    L = []\n    while S:\n        k = S.pop()\n        L.append(k)\n        for m in out[k]:\n            inc[m] -= 1\n            if inc[m] == 0:\n                S.add(m)\n    A = [(float('inf'), -1) for _ in range(n)]\n    D = {j: i for (i, j) in enumerate(L)}\n    A[L[0]] = (0, -1)\n    for i in range(1, n):\n        now = L[i]\n        (d, t) = A[now]\n        for j in parent[now]:\n            if d > i - D[j]:\n                d = i - D[j]\n                t = j\n        A[now] = (d, t)\n    result = [j + 1 for (_, j) in A]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "inc[b] += 1",
      "mutated_line": "inc[b] += -1",
      "code": "def restore_original_tree(n, m, edges):\n    inc = [0] * n\n    out = [[] for _ in range(n)]\n    parent = [[] for _ in range(n)]\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        out[a].append(b)\n        parent[b].append(a)\n        inc[b] += -1\n    S = {i for (i, c) in enumerate(inc) if c == 0}\n    L = []\n    while S:\n        k = S.pop()\n        L.append(k)\n        for m in out[k]:\n            inc[m] -= 1\n            if inc[m] == 0:\n                S.add(m)\n    A = [(float('inf'), -1) for _ in range(n)]\n    D = {j: i for (i, j) in enumerate(L)}\n    A[L[0]] = (0, -1)\n    for i in range(1, n):\n        now = L[i]\n        (d, t) = A[now]\n        for j in parent[now]:\n            if d > i - D[j]:\n                d = i - D[j]\n                t = j\n        A[now] = (d, t)\n    result = [j + 1 for (_, j) in A]\n    return result"
    },
    {
      "operator": "ASR",
      "lineno": 20,
      "original_line": "inc[m] -= 1",
      "mutated_line": "inc[m] += 1",
      "code": "def restore_original_tree(n, m, edges):\n    inc = [0] * n\n    out = [[] for _ in range(n)]\n    parent = [[] for _ in range(n)]\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        out[a].append(b)\n        parent[b].append(a)\n        inc[b] += 1\n    S = {i for (i, c) in enumerate(inc) if c == 0}\n    L = []\n    while S:\n        k = S.pop()\n        L.append(k)\n        for m in out[k]:\n            inc[m] += 1\n            if inc[m] == 0:\n                S.add(m)\n    A = [(float('inf'), -1) for _ in range(n)]\n    D = {j: i for (i, j) in enumerate(L)}\n    A[L[0]] = (0, -1)\n    for i in range(1, n):\n        now = L[i]\n        (d, t) = A[now]\n        for j in parent[now]:\n            if d > i - D[j]:\n                d = i - D[j]\n                t = j\n        A[now] = (d, t)\n    result = [j + 1 for (_, j) in A]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "A[L[0]] = (0, -1)",
      "mutated_line": "A[L[0]] = (1, -1)",
      "code": "def restore_original_tree(n, m, edges):\n    inc = [0] * n\n    out = [[] for _ in range(n)]\n    parent = [[] for _ in range(n)]\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        out[a].append(b)\n        parent[b].append(a)\n        inc[b] += 1\n    S = {i for (i, c) in enumerate(inc) if c == 0}\n    L = []\n    while S:\n        k = S.pop()\n        L.append(k)\n        for m in out[k]:\n            inc[m] -= 1\n            if inc[m] == 0:\n                S.add(m)\n    A = [(float('inf'), -1) for _ in range(n)]\n    D = {j: i for (i, j) in enumerate(L)}\n    A[L[0]] = (1, -1)\n    for i in range(1, n):\n        now = L[i]\n        (d, t) = A[now]\n        for j in parent[now]:\n            if d > i - D[j]:\n                d = i - D[j]\n                t = j\n        A[now] = (d, t)\n    result = [j + 1 for (_, j) in A]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "A[L[0]] = (0, -1)",
      "mutated_line": "A[L[0]] = (-1, -1)",
      "code": "def restore_original_tree(n, m, edges):\n    inc = [0] * n\n    out = [[] for _ in range(n)]\n    parent = [[] for _ in range(n)]\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        out[a].append(b)\n        parent[b].append(a)\n        inc[b] += 1\n    S = {i for (i, c) in enumerate(inc) if c == 0}\n    L = []\n    while S:\n        k = S.pop()\n        L.append(k)\n        for m in out[k]:\n            inc[m] -= 1\n            if inc[m] == 0:\n                S.add(m)\n    A = [(float('inf'), -1) for _ in range(n)]\n    D = {j: i for (i, j) in enumerate(L)}\n    A[L[0]] = (-1, -1)\n    for i in range(1, n):\n        now = L[i]\n        (d, t) = A[now]\n        for j in parent[now]:\n            if d > i - D[j]:\n                d = i - D[j]\n                t = j\n        A[now] = (d, t)\n    result = [j + 1 for (_, j) in A]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "A[L[0]] = (0, -1)",
      "mutated_line": "A[L[0]] = (1, -1)",
      "code": "def restore_original_tree(n, m, edges):\n    inc = [0] * n\n    out = [[] for _ in range(n)]\n    parent = [[] for _ in range(n)]\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        out[a].append(b)\n        parent[b].append(a)\n        inc[b] += 1\n    S = {i for (i, c) in enumerate(inc) if c == 0}\n    L = []\n    while S:\n        k = S.pop()\n        L.append(k)\n        for m in out[k]:\n            inc[m] -= 1\n            if inc[m] == 0:\n                S.add(m)\n    A = [(float('inf'), -1) for _ in range(n)]\n    D = {j: i for (i, j) in enumerate(L)}\n    A[L[0]] = (1, -1)\n    for i in range(1, n):\n        now = L[i]\n        (d, t) = A[now]\n        for j in parent[now]:\n            if d > i - D[j]:\n                d = i - D[j]\n                t = j\n        A[now] = (d, t)\n    result = [j + 1 for (_, j) in A]\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 26,
      "original_line": "A[L[0]] = (0, -1)",
      "mutated_line": "A[L[0]] = (0, +1)",
      "code": "def restore_original_tree(n, m, edges):\n    inc = [0] * n\n    out = [[] for _ in range(n)]\n    parent = [[] for _ in range(n)]\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        out[a].append(b)\n        parent[b].append(a)\n        inc[b] += 1\n    S = {i for (i, c) in enumerate(inc) if c == 0}\n    L = []\n    while S:\n        k = S.pop()\n        L.append(k)\n        for m in out[k]:\n            inc[m] -= 1\n            if inc[m] == 0:\n                S.add(m)\n    A = [(float('inf'), -1) for _ in range(n)]\n    D = {j: i for (i, j) in enumerate(L)}\n    A[L[0]] = (0, +1)\n    for i in range(1, n):\n        now = L[i]\n        (d, t) = A[now]\n        for j in parent[now]:\n            if d > i - D[j]:\n                d = i - D[j]\n                t = j\n        A[now] = (d, t)\n    result = [j + 1 for (_, j) in A]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(2, n):",
      "code": "def restore_original_tree(n, m, edges):\n    inc = [0] * n\n    out = [[] for _ in range(n)]\n    parent = [[] for _ in range(n)]\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        out[a].append(b)\n        parent[b].append(a)\n        inc[b] += 1\n    S = {i for (i, c) in enumerate(inc) if c == 0}\n    L = []\n    while S:\n        k = S.pop()\n        L.append(k)\n        for m in out[k]:\n            inc[m] -= 1\n            if inc[m] == 0:\n                S.add(m)\n    A = [(float('inf'), -1) for _ in range(n)]\n    D = {j: i for (i, j) in enumerate(L)}\n    A[L[0]] = (0, -1)\n    for i in range(2, n):\n        now = L[i]\n        (d, t) = A[now]\n        for j in parent[now]:\n            if d > i - D[j]:\n                d = i - D[j]\n                t = j\n        A[now] = (d, t)\n    result = [j + 1 for (_, j) in A]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(0, n):",
      "code": "def restore_original_tree(n, m, edges):\n    inc = [0] * n\n    out = [[] for _ in range(n)]\n    parent = [[] for _ in range(n)]\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        out[a].append(b)\n        parent[b].append(a)\n        inc[b] += 1\n    S = {i for (i, c) in enumerate(inc) if c == 0}\n    L = []\n    while S:\n        k = S.pop()\n        L.append(k)\n        for m in out[k]:\n            inc[m] -= 1\n            if inc[m] == 0:\n                S.add(m)\n    A = [(float('inf'), -1) for _ in range(n)]\n    D = {j: i for (i, j) in enumerate(L)}\n    A[L[0]] = (0, -1)\n    for i in range(0, n):\n        now = L[i]\n        (d, t) = A[now]\n        for j in parent[now]:\n            if d > i - D[j]:\n                d = i - D[j]\n                t = j\n        A[now] = (d, t)\n    result = [j + 1 for (_, j) in A]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(0, n):",
      "code": "def restore_original_tree(n, m, edges):\n    inc = [0] * n\n    out = [[] for _ in range(n)]\n    parent = [[] for _ in range(n)]\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        out[a].append(b)\n        parent[b].append(a)\n        inc[b] += 1\n    S = {i for (i, c) in enumerate(inc) if c == 0}\n    L = []\n    while S:\n        k = S.pop()\n        L.append(k)\n        for m in out[k]:\n            inc[m] -= 1\n            if inc[m] == 0:\n                S.add(m)\n    A = [(float('inf'), -1) for _ in range(n)]\n    D = {j: i for (i, j) in enumerate(L)}\n    A[L[0]] = (0, -1)\n    for i in range(0, n):\n        now = L[i]\n        (d, t) = A[now]\n        for j in parent[now]:\n            if d > i - D[j]:\n                d = i - D[j]\n                t = j\n        A[now] = (d, t)\n    result = [j + 1 for (_, j) in A]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(-1, n):",
      "code": "def restore_original_tree(n, m, edges):\n    inc = [0] * n\n    out = [[] for _ in range(n)]\n    parent = [[] for _ in range(n)]\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        out[a].append(b)\n        parent[b].append(a)\n        inc[b] += 1\n    S = {i for (i, c) in enumerate(inc) if c == 0}\n    L = []\n    while S:\n        k = S.pop()\n        L.append(k)\n        for m in out[k]:\n            inc[m] -= 1\n            if inc[m] == 0:\n                S.add(m)\n    A = [(float('inf'), -1) for _ in range(n)]\n    D = {j: i for (i, j) in enumerate(L)}\n    A[L[0]] = (0, -1)\n    for i in range(-1, n):\n        now = L[i]\n        (d, t) = A[now]\n        for j in parent[now]:\n            if d > i - D[j]:\n                d = i - D[j]\n                t = j\n        A[now] = (d, t)\n    result = [j + 1 for (_, j) in A]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "result = [j + 1 for _, j in A]",
      "mutated_line": "result = [j - 1 for (_, j) in A]",
      "code": "def restore_original_tree(n, m, edges):\n    inc = [0] * n\n    out = [[] for _ in range(n)]\n    parent = [[] for _ in range(n)]\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        out[a].append(b)\n        parent[b].append(a)\n        inc[b] += 1\n    S = {i for (i, c) in enumerate(inc) if c == 0}\n    L = []\n    while S:\n        k = S.pop()\n        L.append(k)\n        for m in out[k]:\n            inc[m] -= 1\n            if inc[m] == 0:\n                S.add(m)\n    A = [(float('inf'), -1) for _ in range(n)]\n    D = {j: i for (i, j) in enumerate(L)}\n    A[L[0]] = (0, -1)\n    for i in range(1, n):\n        now = L[i]\n        (d, t) = A[now]\n        for j in parent[now]:\n            if d > i - D[j]:\n                d = i - D[j]\n                t = j\n        A[now] = (d, t)\n    result = [j - 1 for (_, j) in A]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "result = [j + 1 for _, j in A]",
      "mutated_line": "result = [j * 1 for (_, j) in A]",
      "code": "def restore_original_tree(n, m, edges):\n    inc = [0] * n\n    out = [[] for _ in range(n)]\n    parent = [[] for _ in range(n)]\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        out[a].append(b)\n        parent[b].append(a)\n        inc[b] += 1\n    S = {i for (i, c) in enumerate(inc) if c == 0}\n    L = []\n    while S:\n        k = S.pop()\n        L.append(k)\n        for m in out[k]:\n            inc[m] -= 1\n            if inc[m] == 0:\n                S.add(m)\n    A = [(float('inf'), -1) for _ in range(n)]\n    D = {j: i for (i, j) in enumerate(L)}\n    A[L[0]] = (0, -1)\n    for i in range(1, n):\n        now = L[i]\n        (d, t) = A[now]\n        for j in parent[now]:\n            if d > i - D[j]:\n                d = i - D[j]\n                t = j\n        A[now] = (d, t)\n    result = [j * 1 for (_, j) in A]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "inc = [0] * n",
      "mutated_line": "inc = [1] * n",
      "code": "def restore_original_tree(n, m, edges):\n    inc = [1] * n\n    out = [[] for _ in range(n)]\n    parent = [[] for _ in range(n)]\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        out[a].append(b)\n        parent[b].append(a)\n        inc[b] += 1\n    S = {i for (i, c) in enumerate(inc) if c == 0}\n    L = []\n    while S:\n        k = S.pop()\n        L.append(k)\n        for m in out[k]:\n            inc[m] -= 1\n            if inc[m] == 0:\n                S.add(m)\n    A = [(float('inf'), -1) for _ in range(n)]\n    D = {j: i for (i, j) in enumerate(L)}\n    A[L[0]] = (0, -1)\n    for i in range(1, n):\n        now = L[i]\n        (d, t) = A[now]\n        for j in parent[now]:\n            if d > i - D[j]:\n                d = i - D[j]\n                t = j\n        A[now] = (d, t)\n    result = [j + 1 for (_, j) in A]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "inc = [0] * n",
      "mutated_line": "inc = [-1] * n",
      "code": "def restore_original_tree(n, m, edges):\n    inc = [-1] * n\n    out = [[] for _ in range(n)]\n    parent = [[] for _ in range(n)]\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        out[a].append(b)\n        parent[b].append(a)\n        inc[b] += 1\n    S = {i for (i, c) in enumerate(inc) if c == 0}\n    L = []\n    while S:\n        k = S.pop()\n        L.append(k)\n        for m in out[k]:\n            inc[m] -= 1\n            if inc[m] == 0:\n                S.add(m)\n    A = [(float('inf'), -1) for _ in range(n)]\n    D = {j: i for (i, j) in enumerate(L)}\n    A[L[0]] = (0, -1)\n    for i in range(1, n):\n        now = L[i]\n        (d, t) = A[now]\n        for j in parent[now]:\n            if d > i - D[j]:\n                d = i - D[j]\n                t = j\n        A[now] = (d, t)\n    result = [j + 1 for (_, j) in A]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "inc = [0] * n",
      "mutated_line": "inc = [1] * n",
      "code": "def restore_original_tree(n, m, edges):\n    inc = [1] * n\n    out = [[] for _ in range(n)]\n    parent = [[] for _ in range(n)]\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        out[a].append(b)\n        parent[b].append(a)\n        inc[b] += 1\n    S = {i for (i, c) in enumerate(inc) if c == 0}\n    L = []\n    while S:\n        k = S.pop()\n        L.append(k)\n        for m in out[k]:\n            inc[m] -= 1\n            if inc[m] == 0:\n                S.add(m)\n    A = [(float('inf'), -1) for _ in range(n)]\n    D = {j: i for (i, j) in enumerate(L)}\n    A[L[0]] = (0, -1)\n    for i in range(1, n):\n        now = L[i]\n        (d, t) = A[now]\n        for j in parent[now]:\n            if d > i - D[j]:\n                d = i - D[j]\n                t = j\n        A[now] = (d, t)\n    result = [j + 1 for (_, j) in A]\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "S = {i for i, c in enumerate(inc) if c == 0}",
      "mutated_line": "S = {i for (i, c) in enumerate(inc) if c != 0}",
      "code": "def restore_original_tree(n, m, edges):\n    inc = [0] * n\n    out = [[] for _ in range(n)]\n    parent = [[] for _ in range(n)]\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        out[a].append(b)\n        parent[b].append(a)\n        inc[b] += 1\n    S = {i for (i, c) in enumerate(inc) if c != 0}\n    L = []\n    while S:\n        k = S.pop()\n        L.append(k)\n        for m in out[k]:\n            inc[m] -= 1\n            if inc[m] == 0:\n                S.add(m)\n    A = [(float('inf'), -1) for _ in range(n)]\n    D = {j: i for (i, j) in enumerate(L)}\n    A[L[0]] = (0, -1)\n    for i in range(1, n):\n        now = L[i]\n        (d, t) = A[now]\n        for j in parent[now]:\n            if d > i - D[j]:\n                d = i - D[j]\n                t = j\n        A[now] = (d, t)\n    result = [j + 1 for (_, j) in A]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "inc[m] -= 1",
      "mutated_line": "inc[m] -= 2",
      "code": "def restore_original_tree(n, m, edges):\n    inc = [0] * n\n    out = [[] for _ in range(n)]\n    parent = [[] for _ in range(n)]\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        out[a].append(b)\n        parent[b].append(a)\n        inc[b] += 1\n    S = {i for (i, c) in enumerate(inc) if c == 0}\n    L = []\n    while S:\n        k = S.pop()\n        L.append(k)\n        for m in out[k]:\n            inc[m] -= 2\n            if inc[m] == 0:\n                S.add(m)\n    A = [(float('inf'), -1) for _ in range(n)]\n    D = {j: i for (i, j) in enumerate(L)}\n    A[L[0]] = (0, -1)\n    for i in range(1, n):\n        now = L[i]\n        (d, t) = A[now]\n        for j in parent[now]:\n            if d > i - D[j]:\n                d = i - D[j]\n                t = j\n        A[now] = (d, t)\n    result = [j + 1 for (_, j) in A]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "inc[m] -= 1",
      "mutated_line": "inc[m] -= 0",
      "code": "def restore_original_tree(n, m, edges):\n    inc = [0] * n\n    out = [[] for _ in range(n)]\n    parent = [[] for _ in range(n)]\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        out[a].append(b)\n        parent[b].append(a)\n        inc[b] += 1\n    S = {i for (i, c) in enumerate(inc) if c == 0}\n    L = []\n    while S:\n        k = S.pop()\n        L.append(k)\n        for m in out[k]:\n            inc[m] -= 0\n            if inc[m] == 0:\n                S.add(m)\n    A = [(float('inf'), -1) for _ in range(n)]\n    D = {j: i for (i, j) in enumerate(L)}\n    A[L[0]] = (0, -1)\n    for i in range(1, n):\n        now = L[i]\n        (d, t) = A[now]\n        for j in parent[now]:\n            if d > i - D[j]:\n                d = i - D[j]\n                t = j\n        A[now] = (d, t)\n    result = [j + 1 for (_, j) in A]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "inc[m] -= 1",
      "mutated_line": "inc[m] -= 0",
      "code": "def restore_original_tree(n, m, edges):\n    inc = [0] * n\n    out = [[] for _ in range(n)]\n    parent = [[] for _ in range(n)]\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        out[a].append(b)\n        parent[b].append(a)\n        inc[b] += 1\n    S = {i for (i, c) in enumerate(inc) if c == 0}\n    L = []\n    while S:\n        k = S.pop()\n        L.append(k)\n        for m in out[k]:\n            inc[m] -= 0\n            if inc[m] == 0:\n                S.add(m)\n    A = [(float('inf'), -1) for _ in range(n)]\n    D = {j: i for (i, j) in enumerate(L)}\n    A[L[0]] = (0, -1)\n    for i in range(1, n):\n        now = L[i]\n        (d, t) = A[now]\n        for j in parent[now]:\n            if d > i - D[j]:\n                d = i - D[j]\n                t = j\n        A[now] = (d, t)\n    result = [j + 1 for (_, j) in A]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "inc[m] -= 1",
      "mutated_line": "inc[m] -= -1",
      "code": "def restore_original_tree(n, m, edges):\n    inc = [0] * n\n    out = [[] for _ in range(n)]\n    parent = [[] for _ in range(n)]\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        out[a].append(b)\n        parent[b].append(a)\n        inc[b] += 1\n    S = {i for (i, c) in enumerate(inc) if c == 0}\n    L = []\n    while S:\n        k = S.pop()\n        L.append(k)\n        for m in out[k]:\n            inc[m] -= -1\n            if inc[m] == 0:\n                S.add(m)\n    A = [(float('inf'), -1) for _ in range(n)]\n    D = {j: i for (i, j) in enumerate(L)}\n    A[L[0]] = (0, -1)\n    for i in range(1, n):\n        now = L[i]\n        (d, t) = A[now]\n        for j in parent[now]:\n            if d > i - D[j]:\n                d = i - D[j]\n                t = j\n        A[now] = (d, t)\n    result = [j + 1 for (_, j) in A]\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if inc[m] == 0:",
      "mutated_line": "if inc[m] != 0:",
      "code": "def restore_original_tree(n, m, edges):\n    inc = [0] * n\n    out = [[] for _ in range(n)]\n    parent = [[] for _ in range(n)]\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        out[a].append(b)\n        parent[b].append(a)\n        inc[b] += 1\n    S = {i for (i, c) in enumerate(inc) if c == 0}\n    L = []\n    while S:\n        k = S.pop()\n        L.append(k)\n        for m in out[k]:\n            inc[m] -= 1\n            if inc[m] != 0:\n                S.add(m)\n    A = [(float('inf'), -1) for _ in range(n)]\n    D = {j: i for (i, j) in enumerate(L)}\n    A[L[0]] = (0, -1)\n    for i in range(1, n):\n        now = L[i]\n        (d, t) = A[now]\n        for j in parent[now]:\n            if d > i - D[j]:\n                d = i - D[j]\n                t = j\n        A[now] = (d, t)\n    result = [j + 1 for (_, j) in A]\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 24,
      "original_line": "A = [(float('inf'), -1) for _ in range(n)]",
      "mutated_line": "D = {j: i for (i, j) in enumerate(L)}",
      "code": "def restore_original_tree(n, m, edges):\n    inc = [0] * n\n    out = [[] for _ in range(n)]\n    parent = [[] for _ in range(n)]\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        out[a].append(b)\n        parent[b].append(a)\n        inc[b] += 1\n    S = {i for (i, c) in enumerate(inc) if c == 0}\n    L = []\n    while S:\n        k = S.pop()\n        L.append(k)\n        for m in out[k]:\n            inc[m] -= 1\n            if inc[m] == 0:\n                S.add(m)\n    A = [(float('inf'), +1) for _ in range(n)]\n    D = {j: i for (i, j) in enumerate(L)}\n    A[L[0]] = (0, -1)\n    for i in range(1, n):\n        now = L[i]\n        (d, t) = A[now]\n        for j in parent[now]:\n            if d > i - D[j]:\n                d = i - D[j]\n                t = j\n        A[now] = (d, t)\n    result = [j + 1 for (_, j) in A]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "A[L[0]] = (0, -1)",
      "mutated_line": "A[L[1]] = (0, -1)",
      "code": "def restore_original_tree(n, m, edges):\n    inc = [0] * n\n    out = [[] for _ in range(n)]\n    parent = [[] for _ in range(n)]\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        out[a].append(b)\n        parent[b].append(a)\n        inc[b] += 1\n    S = {i for (i, c) in enumerate(inc) if c == 0}\n    L = []\n    while S:\n        k = S.pop()\n        L.append(k)\n        for m in out[k]:\n            inc[m] -= 1\n            if inc[m] == 0:\n                S.add(m)\n    A = [(float('inf'), -1) for _ in range(n)]\n    D = {j: i for (i, j) in enumerate(L)}\n    A[L[1]] = (0, -1)\n    for i in range(1, n):\n        now = L[i]\n        (d, t) = A[now]\n        for j in parent[now]:\n            if d > i - D[j]:\n                d = i - D[j]\n                t = j\n        A[now] = (d, t)\n    result = [j + 1 for (_, j) in A]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "A[L[0]] = (0, -1)",
      "mutated_line": "A[L[-1]] = (0, -1)",
      "code": "def restore_original_tree(n, m, edges):\n    inc = [0] * n\n    out = [[] for _ in range(n)]\n    parent = [[] for _ in range(n)]\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        out[a].append(b)\n        parent[b].append(a)\n        inc[b] += 1\n    S = {i for (i, c) in enumerate(inc) if c == 0}\n    L = []\n    while S:\n        k = S.pop()\n        L.append(k)\n        for m in out[k]:\n            inc[m] -= 1\n            if inc[m] == 0:\n                S.add(m)\n    A = [(float('inf'), -1) for _ in range(n)]\n    D = {j: i for (i, j) in enumerate(L)}\n    A[L[-1]] = (0, -1)\n    for i in range(1, n):\n        now = L[i]\n        (d, t) = A[now]\n        for j in parent[now]:\n            if d > i - D[j]:\n                d = i - D[j]\n                t = j\n        A[now] = (d, t)\n    result = [j + 1 for (_, j) in A]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "A[L[0]] = (0, -1)",
      "mutated_line": "A[L[1]] = (0, -1)",
      "code": "def restore_original_tree(n, m, edges):\n    inc = [0] * n\n    out = [[] for _ in range(n)]\n    parent = [[] for _ in range(n)]\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        out[a].append(b)\n        parent[b].append(a)\n        inc[b] += 1\n    S = {i for (i, c) in enumerate(inc) if c == 0}\n    L = []\n    while S:\n        k = S.pop()\n        L.append(k)\n        for m in out[k]:\n            inc[m] -= 1\n            if inc[m] == 0:\n                S.add(m)\n    A = [(float('inf'), -1) for _ in range(n)]\n    D = {j: i for (i, j) in enumerate(L)}\n    A[L[1]] = (0, -1)\n    for i in range(1, n):\n        now = L[i]\n        (d, t) = A[now]\n        for j in parent[now]:\n            if d > i - D[j]:\n                d = i - D[j]\n                t = j\n        A[now] = (d, t)\n    result = [j + 1 for (_, j) in A]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "A[L[0]] = (0, -1)",
      "mutated_line": "A[L[0]] = (0, -2)",
      "code": "def restore_original_tree(n, m, edges):\n    inc = [0] * n\n    out = [[] for _ in range(n)]\n    parent = [[] for _ in range(n)]\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        out[a].append(b)\n        parent[b].append(a)\n        inc[b] += 1\n    S = {i for (i, c) in enumerate(inc) if c == 0}\n    L = []\n    while S:\n        k = S.pop()\n        L.append(k)\n        for m in out[k]:\n            inc[m] -= 1\n            if inc[m] == 0:\n                S.add(m)\n    A = [(float('inf'), -1) for _ in range(n)]\n    D = {j: i for (i, j) in enumerate(L)}\n    A[L[0]] = (0, -2)\n    for i in range(1, n):\n        now = L[i]\n        (d, t) = A[now]\n        for j in parent[now]:\n            if d > i - D[j]:\n                d = i - D[j]\n                t = j\n        A[now] = (d, t)\n    result = [j + 1 for (_, j) in A]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "A[L[0]] = (0, -1)",
      "mutated_line": "A[L[0]] = (0, -0)",
      "code": "def restore_original_tree(n, m, edges):\n    inc = [0] * n\n    out = [[] for _ in range(n)]\n    parent = [[] for _ in range(n)]\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        out[a].append(b)\n        parent[b].append(a)\n        inc[b] += 1\n    S = {i for (i, c) in enumerate(inc) if c == 0}\n    L = []\n    while S:\n        k = S.pop()\n        L.append(k)\n        for m in out[k]:\n            inc[m] -= 1\n            if inc[m] == 0:\n                S.add(m)\n    A = [(float('inf'), -1) for _ in range(n)]\n    D = {j: i for (i, j) in enumerate(L)}\n    A[L[0]] = (0, -0)\n    for i in range(1, n):\n        now = L[i]\n        (d, t) = A[now]\n        for j in parent[now]:\n            if d > i - D[j]:\n                d = i - D[j]\n                t = j\n        A[now] = (d, t)\n    result = [j + 1 for (_, j) in A]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "A[L[0]] = (0, -1)",
      "mutated_line": "A[L[0]] = (0, -0)",
      "code": "def restore_original_tree(n, m, edges):\n    inc = [0] * n\n    out = [[] for _ in range(n)]\n    parent = [[] for _ in range(n)]\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        out[a].append(b)\n        parent[b].append(a)\n        inc[b] += 1\n    S = {i for (i, c) in enumerate(inc) if c == 0}\n    L = []\n    while S:\n        k = S.pop()\n        L.append(k)\n        for m in out[k]:\n            inc[m] -= 1\n            if inc[m] == 0:\n                S.add(m)\n    A = [(float('inf'), -1) for _ in range(n)]\n    D = {j: i for (i, j) in enumerate(L)}\n    A[L[0]] = (0, -0)\n    for i in range(1, n):\n        now = L[i]\n        (d, t) = A[now]\n        for j in parent[now]:\n            if d > i - D[j]:\n                d = i - D[j]\n                t = j\n        A[now] = (d, t)\n    result = [j + 1 for (_, j) in A]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "A[L[0]] = (0, -1)",
      "mutated_line": "A[L[0]] = (0, --1)",
      "code": "def restore_original_tree(n, m, edges):\n    inc = [0] * n\n    out = [[] for _ in range(n)]\n    parent = [[] for _ in range(n)]\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        out[a].append(b)\n        parent[b].append(a)\n        inc[b] += 1\n    S = {i for (i, c) in enumerate(inc) if c == 0}\n    L = []\n    while S:\n        k = S.pop()\n        L.append(k)\n        for m in out[k]:\n            inc[m] -= 1\n            if inc[m] == 0:\n                S.add(m)\n    A = [(float('inf'), -1) for _ in range(n)]\n    D = {j: i for (i, j) in enumerate(L)}\n    A[L[0]] = (0, --1)\n    for i in range(1, n):\n        now = L[i]\n        (d, t) = A[now]\n        for j in parent[now]:\n            if d > i - D[j]:\n                d = i - D[j]\n                t = j\n        A[now] = (d, t)\n    result = [j + 1 for (_, j) in A]\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if d > i - D[j]:",
      "mutated_line": "if d >= i - D[j]:",
      "code": "def restore_original_tree(n, m, edges):\n    inc = [0] * n\n    out = [[] for _ in range(n)]\n    parent = [[] for _ in range(n)]\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        out[a].append(b)\n        parent[b].append(a)\n        inc[b] += 1\n    S = {i for (i, c) in enumerate(inc) if c == 0}\n    L = []\n    while S:\n        k = S.pop()\n        L.append(k)\n        for m in out[k]:\n            inc[m] -= 1\n            if inc[m] == 0:\n                S.add(m)\n    A = [(float('inf'), -1) for _ in range(n)]\n    D = {j: i for (i, j) in enumerate(L)}\n    A[L[0]] = (0, -1)\n    for i in range(1, n):\n        now = L[i]\n        (d, t) = A[now]\n        for j in parent[now]:\n            if d >= i - D[j]:\n                d = i - D[j]\n                t = j\n        A[now] = (d, t)\n    result = [j + 1 for (_, j) in A]\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if d > i - D[j]:",
      "mutated_line": "if d <= i - D[j]:",
      "code": "def restore_original_tree(n, m, edges):\n    inc = [0] * n\n    out = [[] for _ in range(n)]\n    parent = [[] for _ in range(n)]\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        out[a].append(b)\n        parent[b].append(a)\n        inc[b] += 1\n    S = {i for (i, c) in enumerate(inc) if c == 0}\n    L = []\n    while S:\n        k = S.pop()\n        L.append(k)\n        for m in out[k]:\n            inc[m] -= 1\n            if inc[m] == 0:\n                S.add(m)\n    A = [(float('inf'), -1) for _ in range(n)]\n    D = {j: i for (i, j) in enumerate(L)}\n    A[L[0]] = (0, -1)\n    for i in range(1, n):\n        now = L[i]\n        (d, t) = A[now]\n        for j in parent[now]:\n            if d <= i - D[j]:\n                d = i - D[j]\n                t = j\n        A[now] = (d, t)\n    result = [j + 1 for (_, j) in A]\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if d > i - D[j]:",
      "mutated_line": "if d != i - D[j]:",
      "code": "def restore_original_tree(n, m, edges):\n    inc = [0] * n\n    out = [[] for _ in range(n)]\n    parent = [[] for _ in range(n)]\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        out[a].append(b)\n        parent[b].append(a)\n        inc[b] += 1\n    S = {i for (i, c) in enumerate(inc) if c == 0}\n    L = []\n    while S:\n        k = S.pop()\n        L.append(k)\n        for m in out[k]:\n            inc[m] -= 1\n            if inc[m] == 0:\n                S.add(m)\n    A = [(float('inf'), -1) for _ in range(n)]\n    D = {j: i for (i, j) in enumerate(L)}\n    A[L[0]] = (0, -1)\n    for i in range(1, n):\n        now = L[i]\n        (d, t) = A[now]\n        for j in parent[now]:\n            if d != i - D[j]:\n                d = i - D[j]\n                t = j\n        A[now] = (d, t)\n    result = [j + 1 for (_, j) in A]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "result = [j + 1 for _, j in A]",
      "mutated_line": "result = [j + 2 for (_, j) in A]",
      "code": "def restore_original_tree(n, m, edges):\n    inc = [0] * n\n    out = [[] for _ in range(n)]\n    parent = [[] for _ in range(n)]\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        out[a].append(b)\n        parent[b].append(a)\n        inc[b] += 1\n    S = {i for (i, c) in enumerate(inc) if c == 0}\n    L = []\n    while S:\n        k = S.pop()\n        L.append(k)\n        for m in out[k]:\n            inc[m] -= 1\n            if inc[m] == 0:\n                S.add(m)\n    A = [(float('inf'), -1) for _ in range(n)]\n    D = {j: i for (i, j) in enumerate(L)}\n    A[L[0]] = (0, -1)\n    for i in range(1, n):\n        now = L[i]\n        (d, t) = A[now]\n        for j in parent[now]:\n            if d > i - D[j]:\n                d = i - D[j]\n                t = j\n        A[now] = (d, t)\n    result = [j + 2 for (_, j) in A]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "result = [j + 1 for _, j in A]",
      "mutated_line": "result = [j + 0 for (_, j) in A]",
      "code": "def restore_original_tree(n, m, edges):\n    inc = [0] * n\n    out = [[] for _ in range(n)]\n    parent = [[] for _ in range(n)]\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        out[a].append(b)\n        parent[b].append(a)\n        inc[b] += 1\n    S = {i for (i, c) in enumerate(inc) if c == 0}\n    L = []\n    while S:\n        k = S.pop()\n        L.append(k)\n        for m in out[k]:\n            inc[m] -= 1\n            if inc[m] == 0:\n                S.add(m)\n    A = [(float('inf'), -1) for _ in range(n)]\n    D = {j: i for (i, j) in enumerate(L)}\n    A[L[0]] = (0, -1)\n    for i in range(1, n):\n        now = L[i]\n        (d, t) = A[now]\n        for j in parent[now]:\n            if d > i - D[j]:\n                d = i - D[j]\n                t = j\n        A[now] = (d, t)\n    result = [j + 0 for (_, j) in A]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "result = [j + 1 for _, j in A]",
      "mutated_line": "result = [j + 0 for (_, j) in A]",
      "code": "def restore_original_tree(n, m, edges):\n    inc = [0] * n\n    out = [[] for _ in range(n)]\n    parent = [[] for _ in range(n)]\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        out[a].append(b)\n        parent[b].append(a)\n        inc[b] += 1\n    S = {i for (i, c) in enumerate(inc) if c == 0}\n    L = []\n    while S:\n        k = S.pop()\n        L.append(k)\n        for m in out[k]:\n            inc[m] -= 1\n            if inc[m] == 0:\n                S.add(m)\n    A = [(float('inf'), -1) for _ in range(n)]\n    D = {j: i for (i, j) in enumerate(L)}\n    A[L[0]] = (0, -1)\n    for i in range(1, n):\n        now = L[i]\n        (d, t) = A[now]\n        for j in parent[now]:\n            if d > i - D[j]:\n                d = i - D[j]\n                t = j\n        A[now] = (d, t)\n    result = [j + 0 for (_, j) in A]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "result = [j + 1 for _, j in A]",
      "mutated_line": "result = [j + -1 for (_, j) in A]",
      "code": "def restore_original_tree(n, m, edges):\n    inc = [0] * n\n    out = [[] for _ in range(n)]\n    parent = [[] for _ in range(n)]\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        out[a].append(b)\n        parent[b].append(a)\n        inc[b] += 1\n    S = {i for (i, c) in enumerate(inc) if c == 0}\n    L = []\n    while S:\n        k = S.pop()\n        L.append(k)\n        for m in out[k]:\n            inc[m] -= 1\n            if inc[m] == 0:\n                S.add(m)\n    A = [(float('inf'), -1) for _ in range(n)]\n    D = {j: i for (i, j) in enumerate(L)}\n    A[L[0]] = (0, -1)\n    for i in range(1, n):\n        now = L[i]\n        (d, t) = A[now]\n        for j in parent[now]:\n            if d > i - D[j]:\n                d = i - D[j]\n                t = j\n        A[now] = (d, t)\n    result = [j + -1 for (_, j) in A]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "S = {i for i, c in enumerate(inc) if c == 0}",
      "mutated_line": "S = {i for (i, c) in enumerate(inc) if c == 1}",
      "code": "def restore_original_tree(n, m, edges):\n    inc = [0] * n\n    out = [[] for _ in range(n)]\n    parent = [[] for _ in range(n)]\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        out[a].append(b)\n        parent[b].append(a)\n        inc[b] += 1\n    S = {i for (i, c) in enumerate(inc) if c == 1}\n    L = []\n    while S:\n        k = S.pop()\n        L.append(k)\n        for m in out[k]:\n            inc[m] -= 1\n            if inc[m] == 0:\n                S.add(m)\n    A = [(float('inf'), -1) for _ in range(n)]\n    D = {j: i for (i, j) in enumerate(L)}\n    A[L[0]] = (0, -1)\n    for i in range(1, n):\n        now = L[i]\n        (d, t) = A[now]\n        for j in parent[now]:\n            if d > i - D[j]:\n                d = i - D[j]\n                t = j\n        A[now] = (d, t)\n    result = [j + 1 for (_, j) in A]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "S = {i for i, c in enumerate(inc) if c == 0}",
      "mutated_line": "S = {i for (i, c) in enumerate(inc) if c == -1}",
      "code": "def restore_original_tree(n, m, edges):\n    inc = [0] * n\n    out = [[] for _ in range(n)]\n    parent = [[] for _ in range(n)]\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        out[a].append(b)\n        parent[b].append(a)\n        inc[b] += 1\n    S = {i for (i, c) in enumerate(inc) if c == -1}\n    L = []\n    while S:\n        k = S.pop()\n        L.append(k)\n        for m in out[k]:\n            inc[m] -= 1\n            if inc[m] == 0:\n                S.add(m)\n    A = [(float('inf'), -1) for _ in range(n)]\n    D = {j: i for (i, j) in enumerate(L)}\n    A[L[0]] = (0, -1)\n    for i in range(1, n):\n        now = L[i]\n        (d, t) = A[now]\n        for j in parent[now]:\n            if d > i - D[j]:\n                d = i - D[j]\n                t = j\n        A[now] = (d, t)\n    result = [j + 1 for (_, j) in A]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "S = {i for i, c in enumerate(inc) if c == 0}",
      "mutated_line": "S = {i for (i, c) in enumerate(inc) if c == 1}",
      "code": "def restore_original_tree(n, m, edges):\n    inc = [0] * n\n    out = [[] for _ in range(n)]\n    parent = [[] for _ in range(n)]\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        out[a].append(b)\n        parent[b].append(a)\n        inc[b] += 1\n    S = {i for (i, c) in enumerate(inc) if c == 1}\n    L = []\n    while S:\n        k = S.pop()\n        L.append(k)\n        for m in out[k]:\n            inc[m] -= 1\n            if inc[m] == 0:\n                S.add(m)\n    A = [(float('inf'), -1) for _ in range(n)]\n    D = {j: i for (i, j) in enumerate(L)}\n    A[L[0]] = (0, -1)\n    for i in range(1, n):\n        now = L[i]\n        (d, t) = A[now]\n        for j in parent[now]:\n            if d > i - D[j]:\n                d = i - D[j]\n                t = j\n        A[now] = (d, t)\n    result = [j + 1 for (_, j) in A]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if inc[m] == 0:",
      "mutated_line": "if inc[m] == 1:",
      "code": "def restore_original_tree(n, m, edges):\n    inc = [0] * n\n    out = [[] for _ in range(n)]\n    parent = [[] for _ in range(n)]\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        out[a].append(b)\n        parent[b].append(a)\n        inc[b] += 1\n    S = {i for (i, c) in enumerate(inc) if c == 0}\n    L = []\n    while S:\n        k = S.pop()\n        L.append(k)\n        for m in out[k]:\n            inc[m] -= 1\n            if inc[m] == 1:\n                S.add(m)\n    A = [(float('inf'), -1) for _ in range(n)]\n    D = {j: i for (i, j) in enumerate(L)}\n    A[L[0]] = (0, -1)\n    for i in range(1, n):\n        now = L[i]\n        (d, t) = A[now]\n        for j in parent[now]:\n            if d > i - D[j]:\n                d = i - D[j]\n                t = j\n        A[now] = (d, t)\n    result = [j + 1 for (_, j) in A]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if inc[m] == 0:",
      "mutated_line": "if inc[m] == -1:",
      "code": "def restore_original_tree(n, m, edges):\n    inc = [0] * n\n    out = [[] for _ in range(n)]\n    parent = [[] for _ in range(n)]\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        out[a].append(b)\n        parent[b].append(a)\n        inc[b] += 1\n    S = {i for (i, c) in enumerate(inc) if c == 0}\n    L = []\n    while S:\n        k = S.pop()\n        L.append(k)\n        for m in out[k]:\n            inc[m] -= 1\n            if inc[m] == -1:\n                S.add(m)\n    A = [(float('inf'), -1) for _ in range(n)]\n    D = {j: i for (i, j) in enumerate(L)}\n    A[L[0]] = (0, -1)\n    for i in range(1, n):\n        now = L[i]\n        (d, t) = A[now]\n        for j in parent[now]:\n            if d > i - D[j]:\n                d = i - D[j]\n                t = j\n        A[now] = (d, t)\n    result = [j + 1 for (_, j) in A]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if inc[m] == 0:",
      "mutated_line": "if inc[m] == 1:",
      "code": "def restore_original_tree(n, m, edges):\n    inc = [0] * n\n    out = [[] for _ in range(n)]\n    parent = [[] for _ in range(n)]\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        out[a].append(b)\n        parent[b].append(a)\n        inc[b] += 1\n    S = {i for (i, c) in enumerate(inc) if c == 0}\n    L = []\n    while S:\n        k = S.pop()\n        L.append(k)\n        for m in out[k]:\n            inc[m] -= 1\n            if inc[m] == 1:\n                S.add(m)\n    A = [(float('inf'), -1) for _ in range(n)]\n    D = {j: i for (i, j) in enumerate(L)}\n    A[L[0]] = (0, -1)\n    for i in range(1, n):\n        now = L[i]\n        (d, t) = A[now]\n        for j in parent[now]:\n            if d > i - D[j]:\n                d = i - D[j]\n                t = j\n        A[now] = (d, t)\n    result = [j + 1 for (_, j) in A]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "A = [(float('inf'), -1) for _ in range(n)]",
      "mutated_line": "D = {j: i for (i, j) in enumerate(L)}",
      "code": "def restore_original_tree(n, m, edges):\n    inc = [0] * n\n    out = [[] for _ in range(n)]\n    parent = [[] for _ in range(n)]\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        out[a].append(b)\n        parent[b].append(a)\n        inc[b] += 1\n    S = {i for (i, c) in enumerate(inc) if c == 0}\n    L = []\n    while S:\n        k = S.pop()\n        L.append(k)\n        for m in out[k]:\n            inc[m] -= 1\n            if inc[m] == 0:\n                S.add(m)\n    A = [(float(''), -1) for _ in range(n)]\n    D = {j: i for (i, j) in enumerate(L)}\n    A[L[0]] = (0, -1)\n    for i in range(1, n):\n        now = L[i]\n        (d, t) = A[now]\n        for j in parent[now]:\n            if d > i - D[j]:\n                d = i - D[j]\n                t = j\n        A[now] = (d, t)\n    result = [j + 1 for (_, j) in A]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "A = [(float('inf'), -1) for _ in range(n)]",
      "mutated_line": "D = {j: i for (i, j) in enumerate(L)}",
      "code": "def restore_original_tree(n, m, edges):\n    inc = [0] * n\n    out = [[] for _ in range(n)]\n    parent = [[] for _ in range(n)]\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        out[a].append(b)\n        parent[b].append(a)\n        inc[b] += 1\n    S = {i for (i, c) in enumerate(inc) if c == 0}\n    L = []\n    while S:\n        k = S.pop()\n        L.append(k)\n        for m in out[k]:\n            inc[m] -= 1\n            if inc[m] == 0:\n                S.add(m)\n    A = [(float('inf'), -2) for _ in range(n)]\n    D = {j: i for (i, j) in enumerate(L)}\n    A[L[0]] = (0, -1)\n    for i in range(1, n):\n        now = L[i]\n        (d, t) = A[now]\n        for j in parent[now]:\n            if d > i - D[j]:\n                d = i - D[j]\n                t = j\n        A[now] = (d, t)\n    result = [j + 1 for (_, j) in A]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "A = [(float('inf'), -1) for _ in range(n)]",
      "mutated_line": "D = {j: i for (i, j) in enumerate(L)}",
      "code": "def restore_original_tree(n, m, edges):\n    inc = [0] * n\n    out = [[] for _ in range(n)]\n    parent = [[] for _ in range(n)]\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        out[a].append(b)\n        parent[b].append(a)\n        inc[b] += 1\n    S = {i for (i, c) in enumerate(inc) if c == 0}\n    L = []\n    while S:\n        k = S.pop()\n        L.append(k)\n        for m in out[k]:\n            inc[m] -= 1\n            if inc[m] == 0:\n                S.add(m)\n    A = [(float('inf'), -0) for _ in range(n)]\n    D = {j: i for (i, j) in enumerate(L)}\n    A[L[0]] = (0, -1)\n    for i in range(1, n):\n        now = L[i]\n        (d, t) = A[now]\n        for j in parent[now]:\n            if d > i - D[j]:\n                d = i - D[j]\n                t = j\n        A[now] = (d, t)\n    result = [j + 1 for (_, j) in A]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "A = [(float('inf'), -1) for _ in range(n)]",
      "mutated_line": "D = {j: i for (i, j) in enumerate(L)}",
      "code": "def restore_original_tree(n, m, edges):\n    inc = [0] * n\n    out = [[] for _ in range(n)]\n    parent = [[] for _ in range(n)]\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        out[a].append(b)\n        parent[b].append(a)\n        inc[b] += 1\n    S = {i for (i, c) in enumerate(inc) if c == 0}\n    L = []\n    while S:\n        k = S.pop()\n        L.append(k)\n        for m in out[k]:\n            inc[m] -= 1\n            if inc[m] == 0:\n                S.add(m)\n    A = [(float('inf'), -0) for _ in range(n)]\n    D = {j: i for (i, j) in enumerate(L)}\n    A[L[0]] = (0, -1)\n    for i in range(1, n):\n        now = L[i]\n        (d, t) = A[now]\n        for j in parent[now]:\n            if d > i - D[j]:\n                d = i - D[j]\n                t = j\n        A[now] = (d, t)\n    result = [j + 1 for (_, j) in A]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "A = [(float('inf'), -1) for _ in range(n)]",
      "mutated_line": "D = {j: i for (i, j) in enumerate(L)}",
      "code": "def restore_original_tree(n, m, edges):\n    inc = [0] * n\n    out = [[] for _ in range(n)]\n    parent = [[] for _ in range(n)]\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        out[a].append(b)\n        parent[b].append(a)\n        inc[b] += 1\n    S = {i for (i, c) in enumerate(inc) if c == 0}\n    L = []\n    while S:\n        k = S.pop()\n        L.append(k)\n        for m in out[k]:\n            inc[m] -= 1\n            if inc[m] == 0:\n                S.add(m)\n    A = [(float('inf'), --1) for _ in range(n)]\n    D = {j: i for (i, j) in enumerate(L)}\n    A[L[0]] = (0, -1)\n    for i in range(1, n):\n        now = L[i]\n        (d, t) = A[now]\n        for j in parent[now]:\n            if d > i - D[j]:\n                d = i - D[j]\n                t = j\n        A[now] = (d, t)\n    result = [j + 1 for (_, j) in A]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "if d > i - D[j]:",
      "mutated_line": "if d > i + D[j]:",
      "code": "def restore_original_tree(n, m, edges):\n    inc = [0] * n\n    out = [[] for _ in range(n)]\n    parent = [[] for _ in range(n)]\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        out[a].append(b)\n        parent[b].append(a)\n        inc[b] += 1\n    S = {i for (i, c) in enumerate(inc) if c == 0}\n    L = []\n    while S:\n        k = S.pop()\n        L.append(k)\n        for m in out[k]:\n            inc[m] -= 1\n            if inc[m] == 0:\n                S.add(m)\n    A = [(float('inf'), -1) for _ in range(n)]\n    D = {j: i for (i, j) in enumerate(L)}\n    A[L[0]] = (0, -1)\n    for i in range(1, n):\n        now = L[i]\n        (d, t) = A[now]\n        for j in parent[now]:\n            if d > i + D[j]:\n                d = i - D[j]\n                t = j\n        A[now] = (d, t)\n    result = [j + 1 for (_, j) in A]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "if d > i - D[j]:",
      "mutated_line": "if d > i * D[j]:",
      "code": "def restore_original_tree(n, m, edges):\n    inc = [0] * n\n    out = [[] for _ in range(n)]\n    parent = [[] for _ in range(n)]\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        out[a].append(b)\n        parent[b].append(a)\n        inc[b] += 1\n    S = {i for (i, c) in enumerate(inc) if c == 0}\n    L = []\n    while S:\n        k = S.pop()\n        L.append(k)\n        for m in out[k]:\n            inc[m] -= 1\n            if inc[m] == 0:\n                S.add(m)\n    A = [(float('inf'), -1) for _ in range(n)]\n    D = {j: i for (i, j) in enumerate(L)}\n    A[L[0]] = (0, -1)\n    for i in range(1, n):\n        now = L[i]\n        (d, t) = A[now]\n        for j in parent[now]:\n            if d > i * D[j]:\n                d = i - D[j]\n                t = j\n        A[now] = (d, t)\n    result = [j + 1 for (_, j) in A]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "d = i - D[j]",
      "mutated_line": "d = i + D[j]",
      "code": "def restore_original_tree(n, m, edges):\n    inc = [0] * n\n    out = [[] for _ in range(n)]\n    parent = [[] for _ in range(n)]\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        out[a].append(b)\n        parent[b].append(a)\n        inc[b] += 1\n    S = {i for (i, c) in enumerate(inc) if c == 0}\n    L = []\n    while S:\n        k = S.pop()\n        L.append(k)\n        for m in out[k]:\n            inc[m] -= 1\n            if inc[m] == 0:\n                S.add(m)\n    A = [(float('inf'), -1) for _ in range(n)]\n    D = {j: i for (i, j) in enumerate(L)}\n    A[L[0]] = (0, -1)\n    for i in range(1, n):\n        now = L[i]\n        (d, t) = A[now]\n        for j in parent[now]:\n            if d > i - D[j]:\n                d = i + D[j]\n                t = j\n        A[now] = (d, t)\n    result = [j + 1 for (_, j) in A]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "d = i - D[j]",
      "mutated_line": "d = i * D[j]",
      "code": "def restore_original_tree(n, m, edges):\n    inc = [0] * n\n    out = [[] for _ in range(n)]\n    parent = [[] for _ in range(n)]\n    for (a, b) in edges:\n        a -= 1\n        b -= 1\n        out[a].append(b)\n        parent[b].append(a)\n        inc[b] += 1\n    S = {i for (i, c) in enumerate(inc) if c == 0}\n    L = []\n    while S:\n        k = S.pop()\n        L.append(k)\n        for m in out[k]:\n            inc[m] -= 1\n            if inc[m] == 0:\n                S.add(m)\n    A = [(float('inf'), -1) for _ in range(n)]\n    D = {j: i for (i, j) in enumerate(L)}\n    A[L[0]] = (0, -1)\n    for i in range(1, n):\n        now = L[i]\n        (d, t) = A[now]\n        for j in parent[now]:\n            if d > i - D[j]:\n                d = i * D[j]\n                t = j\n        A[now] = (d, t)\n    result = [j + 1 for (_, j) in A]\n    return result"
    }
  ]
}