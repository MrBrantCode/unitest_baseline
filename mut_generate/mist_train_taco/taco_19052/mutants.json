{
  "task_id": "taco_19052",
  "entry_point": "factorize",
  "mutant_count": 320,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if n > 1:",
      "mutated_line": "if n >= 1:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n >= 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if n > 1:",
      "mutated_line": "if n <= 1:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n <= 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if n > 1:",
      "mutated_line": "if n != 1:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n != 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if i == len(lpfs):",
      "mutated_line": "if i != len(lpfs):",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i != len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if p == 2:",
      "mutated_line": "if p != 2:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p != 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "ok = True",
      "mutated_line": "ok = False",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = False\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if n % k == 0:",
      "mutated_line": "if n % k != 0:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k != 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "n = try_divisor(n, 2, pfs)",
      "mutated_line": "n = try_divisor(n, 3, pfs)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 3, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "n = try_divisor(n, 2, pfs)",
      "mutated_line": "n = try_divisor(n, 1, pfs)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 1, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "n = try_divisor(n, 2, pfs)",
      "mutated_line": "n = try_divisor(n, 0, pfs)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 0, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "n = try_divisor(n, 2, pfs)",
      "mutated_line": "n = try_divisor(n, 1, pfs)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 1, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "n = try_divisor(n, 2, pfs)",
      "mutated_line": "n = try_divisor(n, -2, pfs)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, -2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "n = try_divisor(n, 3, pfs)",
      "mutated_line": "n = try_divisor(n, 4, pfs)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 4, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "n = try_divisor(n, 3, pfs)",
      "mutated_line": "n = try_divisor(n, 2, pfs)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 2, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "n = try_divisor(n, 3, pfs)",
      "mutated_line": "n = try_divisor(n, 0, pfs)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 0, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "n = try_divisor(n, 3, pfs)",
      "mutated_line": "n = try_divisor(n, 1, pfs)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 1, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "n = try_divisor(n, 3, pfs)",
      "mutated_line": "n = try_divisor(n, -3, pfs)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, -3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if (6 * i + 1) ** 2 > n:",
      "mutated_line": "if (6 * i + 1) ** 2 >= n:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 >= n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if (6 * i + 1) ** 2 > n:",
      "mutated_line": "if (6 * i + 1) ** 2 <= n:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 <= n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if (6 * i + 1) ** 2 > n:",
      "mutated_line": "if (6 * i + 1) ** 2 != n:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 != n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if n > 1:",
      "mutated_line": "if n > 2:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 2:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if n > 1:",
      "mutated_line": "if n > 0:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 0:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if n > 1:",
      "mutated_line": "if n > 0:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 0:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if n > 1:",
      "mutated_line": "if n > -1:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > -1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "pfs[n] = 1",
      "mutated_line": "pfs[n] = 2",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 2\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "pfs[n] = 1",
      "mutated_line": "pfs[n] = 0",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 0\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "pfs[n] = 1",
      "mutated_line": "pfs[n] = 0",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 0\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "pfs[n] = 1",
      "mutated_line": "pfs[n] = -1",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = -1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "LCR",
      "lineno": 30,
      "original_line": "if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):",
      "mutated_line": "if a > 0 or b > 0 or a * a + 1 == aa or (b * b + 1 == bb) or (math.gcd(a, b) == 1):",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 or b > 0 or a * a + 1 == aa or (b * b + 1 == bb) or (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if p == 2:",
      "mutated_line": "if p == 3:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 3:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if p == 2:",
      "mutated_line": "if p == 1:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 1:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if p == 2:",
      "mutated_line": "if p == 0:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 0:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if p == 2:",
      "mutated_line": "if p == 1:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 1:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if p == 2:",
      "mutated_line": "if p == -2:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == -2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if e % 2 == 1:",
      "mutated_line": "if e % 2 != 1:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 != 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "if p % 4 == 3:",
      "mutated_line": "if p % 4 != 3:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 != 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return recurse(lpfs, 0, 1, 1) if ok else 0",
      "mutated_line": "return recurse(lpfs, 0, 1, 1) if ok else 1",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 1"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return recurse(lpfs, 0, 1, 1) if ok else 0",
      "mutated_line": "return recurse(lpfs, 0, 1, 1) if ok else -1",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else -1"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return recurse(lpfs, 0, 1, 1) if ok else 0",
      "mutated_line": "return recurse(lpfs, 0, 1, 1) if ok else 1",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 1"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "if n % k == 0:",
      "mutated_line": "if n * k == 0:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n * k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "if n % k == 0:",
      "mutated_line": "if n + k == 0:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n + k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if n % k == 0:",
      "mutated_line": "if n % k == 1:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 1:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if n % k == 0:",
      "mutated_line": "if n % k == -1:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == -1:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if n % k == 0:",
      "mutated_line": "if n % k == 1:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 1:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "pfs[k] = 1",
      "mutated_line": "pfs[k] = 2",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 2\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "pfs[k] = 1",
      "mutated_line": "pfs[k] = 0",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 0\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "pfs[k] = 1",
      "mutated_line": "pfs[k] = 0",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 0\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "pfs[k] = 1",
      "mutated_line": "pfs[k] = -1",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = -1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "while n % k == 0:",
      "mutated_line": "while n % k != 0:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k != 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "ASR",
      "lineno": 10,
      "original_line": "pfs[k] += 1",
      "mutated_line": "pfs[k] -= 1",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] -= 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in itertools.count(start=1):",
      "mutated_line": "for i in itertools.count(start=2):",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=2):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in itertools.count(start=1):",
      "mutated_line": "for i in itertools.count(start=0):",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=0):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in itertools.count(start=1):",
      "mutated_line": "for i in itertools.count(start=0):",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=0):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in itertools.count(start=1):",
      "mutated_line": "for i in itertools.count(start=-1):",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=-1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "n = try_divisor(n, 6 * i - 1, pfs)",
      "mutated_line": "n = try_divisor(n, 6 * i + 1, pfs)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i + 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "n = try_divisor(n, 6 * i - 1, pfs)",
      "mutated_line": "n = try_divisor(n, 6 * i * 1, pfs)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i * 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "n = try_divisor(n, 6 * i + 1, pfs)",
      "mutated_line": "n = try_divisor(n, 6 * i - 1, pfs)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i - 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "n = try_divisor(n, 6 * i + 1, pfs)",
      "mutated_line": "n = try_divisor(n, 6 * i * 1, pfs)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i * 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if (6 * i + 1) ** 2 > n:",
      "mutated_line": "if (6 * i + 1) * 2 > n:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) * 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if (6 * i + 1) ** 2 > n:",
      "mutated_line": "if 6 * i + 1 + 2 > n:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if 6 * i + 1 + 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "a = math.isqrt(aa - 1)",
      "mutated_line": "a = math.isqrt(aa + 1)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa + 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "a = math.isqrt(aa - 1)",
      "mutated_line": "a = math.isqrt(aa * 1)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa * 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "b = math.isqrt(bb - 1)",
      "mutated_line": "b = math.isqrt(bb + 1)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb + 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "b = math.isqrt(bb - 1)",
      "mutated_line": "b = math.isqrt(bb * 1)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb * 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):",
      "mutated_line": "if a >= 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a >= 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):",
      "mutated_line": "if a <= 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a <= 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):",
      "mutated_line": "if a != 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a != 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):",
      "mutated_line": "if a > 0 and b >= 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b >= 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):",
      "mutated_line": "if a > 0 and b <= 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b <= 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):",
      "mutated_line": "if a > 0 and b != 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b != 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):",
      "mutated_line": "if a > 0 and b > 0 and (a * a + 1 != aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 != aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):",
      "mutated_line": "if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 != bb) and (math.gcd(a, b) == 1):",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 != bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):",
      "mutated_line": "if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) != 1):",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) != 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return 1",
      "mutated_line": "return 2",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 2\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 0\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 0\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return 1",
      "mutated_line": "return -1",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return -1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 1\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return -1\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 1\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "if e % 2 == 1:",
      "mutated_line": "if e * 2 == 1:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e * 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "if e % 2 == 1:",
      "mutated_line": "if e + 2 == 1:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e + 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if e % 2 == 1:",
      "mutated_line": "if e % 2 == 2:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 2:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if e % 2 == 1:",
      "mutated_line": "if e % 2 == 0:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 0:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if e % 2 == 1:",
      "mutated_line": "if e % 2 == 0:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 0:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if e % 2 == 1:",
      "mutated_line": "if e % 2 == -1:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == -1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)",
      "mutated_line": "return recurse(lpfs, i + 1, 2 * aa, bb) - recurse(lpfs, i + 1, aa, 2 * bb)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) - recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)",
      "mutated_line": "return recurse(lpfs, i + 1, 2 * aa, bb) * recurse(lpfs, i + 1, aa, 2 * bb)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) * recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)",
      "mutated_line": "return recurse(lpfs, i + 1, aa, bb) - recurse(lpfs, i + 1, 2 * aa, 2 * bb)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) - recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)",
      "mutated_line": "return recurse(lpfs, i + 1, aa, bb) * recurse(lpfs, i + 1, 2 * aa, 2 * bb)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) * recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "if p % 4 == 3:",
      "mutated_line": "if p * 4 == 3:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p * 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "if p % 4 == 3:",
      "mutated_line": "if p + 4 == 3:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p + 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if p % 4 == 3:",
      "mutated_line": "if p % 4 == 4:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 4:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if p % 4 == 3:",
      "mutated_line": "if p % 4 == 2:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 2:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if p % 4 == 3:",
      "mutated_line": "if p % 4 == 0:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 0:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if p % 4 == 3:",
      "mutated_line": "if p % 4 == 1:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 1:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if p % 4 == 3:",
      "mutated_line": "if p % 4 == -3:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == -3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "ROR",
      "lineno": 50,
      "original_line": "if e % 2 == 1:",
      "mutated_line": "if e % 2 != 1:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 != 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return recurse(lpfs, 0, 1, 1) if ok else 0",
      "mutated_line": "return recurse(lpfs, 1, 1, 1) if ok else 0",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 1, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return recurse(lpfs, 0, 1, 1) if ok else 0",
      "mutated_line": "return recurse(lpfs, -1, 1, 1) if ok else 0",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, -1, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return recurse(lpfs, 0, 1, 1) if ok else 0",
      "mutated_line": "return recurse(lpfs, 1, 1, 1) if ok else 0",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 1, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return recurse(lpfs, 0, 1, 1) if ok else 0",
      "mutated_line": "return recurse(lpfs, 0, 2, 1) if ok else 0",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 2, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return recurse(lpfs, 0, 1, 1) if ok else 0",
      "mutated_line": "return recurse(lpfs, 0, 0, 1) if ok else 0",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 0, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return recurse(lpfs, 0, 1, 1) if ok else 0",
      "mutated_line": "return recurse(lpfs, 0, 0, 1) if ok else 0",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 0, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return recurse(lpfs, 0, 1, 1) if ok else 0",
      "mutated_line": "return recurse(lpfs, 0, -1, 1) if ok else 0",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, -1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return recurse(lpfs, 0, 1, 1) if ok else 0",
      "mutated_line": "return recurse(lpfs, 0, 1, 2) if ok else 0",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 2) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return recurse(lpfs, 0, 1, 1) if ok else 0",
      "mutated_line": "return recurse(lpfs, 0, 1, 0) if ok else 0",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 0) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return recurse(lpfs, 0, 1, 1) if ok else 0",
      "mutated_line": "return recurse(lpfs, 0, 1, 0) if ok else 0",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 0) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return recurse(lpfs, 0, 1, 1) if ok else 0",
      "mutated_line": "return recurse(lpfs, 0, 1, -1) if ok else 0",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, -1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "while n % k == 0:",
      "mutated_line": "while n * k == 0:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n * k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "while n % k == 0:",
      "mutated_line": "while n + k == 0:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n + k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "while n % k == 0:",
      "mutated_line": "while n % k == 1:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 1:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "while n % k == 0:",
      "mutated_line": "while n % k == -1:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == -1:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "while n % k == 0:",
      "mutated_line": "while n % k == 1:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 1:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "pfs[k] += 1",
      "mutated_line": "pfs[k] += 2",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 2\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "pfs[k] += 1",
      "mutated_line": "pfs[k] += 0",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 0\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "pfs[k] += 1",
      "mutated_line": "pfs[k] += 0",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 0\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "pfs[k] += 1",
      "mutated_line": "pfs[k] += -1",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += -1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "n = try_divisor(n, 6 * i - 1, pfs)",
      "mutated_line": "n = try_divisor(n, 6 / i - 1, pfs)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 / i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "n = try_divisor(n, 6 * i - 1, pfs)",
      "mutated_line": "n = try_divisor(n, 6 + i - 1, pfs)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 + i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "n = try_divisor(n, 6 * i - 1, pfs)",
      "mutated_line": "n = try_divisor(n, 6 ** i - 1, pfs)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 ** i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "n = try_divisor(n, 6 * i - 1, pfs)",
      "mutated_line": "n = try_divisor(n, 6 * i - 2, pfs)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 2, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "n = try_divisor(n, 6 * i - 1, pfs)",
      "mutated_line": "n = try_divisor(n, 6 * i - 0, pfs)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 0, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "n = try_divisor(n, 6 * i - 1, pfs)",
      "mutated_line": "n = try_divisor(n, 6 * i - 0, pfs)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 0, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "n = try_divisor(n, 6 * i - 1, pfs)",
      "mutated_line": "n = try_divisor(n, 6 * i - -1, pfs)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - -1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "n = try_divisor(n, 6 * i + 1, pfs)",
      "mutated_line": "n = try_divisor(n, 6 / i + 1, pfs)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 / i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "n = try_divisor(n, 6 * i + 1, pfs)",
      "mutated_line": "n = try_divisor(n, 6 + i + 1, pfs)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 + i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "n = try_divisor(n, 6 * i + 1, pfs)",
      "mutated_line": "n = try_divisor(n, 6 ** i + 1, pfs)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 ** i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "n = try_divisor(n, 6 * i + 1, pfs)",
      "mutated_line": "n = try_divisor(n, 6 * i + 2, pfs)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 2, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "n = try_divisor(n, 6 * i + 1, pfs)",
      "mutated_line": "n = try_divisor(n, 6 * i + 0, pfs)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 0, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "n = try_divisor(n, 6 * i + 1, pfs)",
      "mutated_line": "n = try_divisor(n, 6 * i + 0, pfs)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 0, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "n = try_divisor(n, 6 * i + 1, pfs)",
      "mutated_line": "n = try_divisor(n, 6 * i + -1, pfs)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + -1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if (6 * i + 1) ** 2 > n:",
      "mutated_line": "if (6 * i - 1) ** 2 > n:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i - 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if (6 * i + 1) ** 2 > n:",
      "mutated_line": "if (6 * i * 1) ** 2 > n:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i * 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if (6 * i + 1) ** 2 > n:",
      "mutated_line": "if (6 * i + 1) ** 3 > n:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 3 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if (6 * i + 1) ** 2 > n:",
      "mutated_line": "if (6 * i + 1) ** 1 > n:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 1 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if (6 * i + 1) ** 2 > n:",
      "mutated_line": "if (6 * i + 1) ** 0 > n:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 0 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if (6 * i + 1) ** 2 > n:",
      "mutated_line": "if (6 * i + 1) ** 1 > n:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 1 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if (6 * i + 1) ** 2 > n:",
      "mutated_line": "if (6 * i + 1) ** -2 > n:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** -2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "a = math.isqrt(aa - 1)",
      "mutated_line": "a = math.isqrt(aa - 2)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 2)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "a = math.isqrt(aa - 1)",
      "mutated_line": "a = math.isqrt(aa - 0)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 0)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "a = math.isqrt(aa - 1)",
      "mutated_line": "a = math.isqrt(aa - 0)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 0)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "a = math.isqrt(aa - 1)",
      "mutated_line": "a = math.isqrt(aa - -1)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - -1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "b = math.isqrt(bb - 1)",
      "mutated_line": "b = math.isqrt(bb - 2)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 2)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "b = math.isqrt(bb - 1)",
      "mutated_line": "b = math.isqrt(bb - 0)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 0)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "b = math.isqrt(bb - 1)",
      "mutated_line": "b = math.isqrt(bb - 0)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 0)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "b = math.isqrt(bb - 1)",
      "mutated_line": "b = math.isqrt(bb - -1)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - -1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):",
      "mutated_line": "if a > 1 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 1 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):",
      "mutated_line": "if a > -1 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > -1 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):",
      "mutated_line": "if a > 1 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 1 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):",
      "mutated_line": "if a > 0 and b > 1 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 1 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):",
      "mutated_line": "if a > 0 and b > -1 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > -1 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):",
      "mutated_line": "if a > 0 and b > 1 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 1 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):",
      "mutated_line": "if a > 0 and b > 0 and (a * a - 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a - 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):",
      "mutated_line": "if a > 0 and b > 0 and (a * a * 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a * 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):",
      "mutated_line": "if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b - 1 == bb) and (math.gcd(a, b) == 1):",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b - 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):",
      "mutated_line": "if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b * 1 == bb) and (math.gcd(a, b) == 1):",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b * 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):",
      "mutated_line": "if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 2):",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 2):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):",
      "mutated_line": "if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 0):",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 0):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):",
      "mutated_line": "if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 0):",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 0):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):",
      "mutated_line": "if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == -1):",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == -1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if e % 2 == 1:",
      "mutated_line": "if e % 3 == 1:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 3 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if e % 2 == 1:",
      "mutated_line": "if e % 1 == 1:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 1 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if e % 2 == 1:",
      "mutated_line": "if e % 0 == 1:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 0 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if e % 2 == 1:",
      "mutated_line": "if e % 1 == 1:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 1 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if e % 2 == 1:",
      "mutated_line": "if e % -2 == 1:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % -2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if p % 4 == 3:",
      "mutated_line": "if p % 5 == 3:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 5 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if p % 4 == 3:",
      "mutated_line": "if p % 3 == 3:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 3 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if p % 4 == 3:",
      "mutated_line": "if p % 0 == 3:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 0 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if p % 4 == 3:",
      "mutated_line": "if p % 1 == 3:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 1 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if p % 4 == 3:",
      "mutated_line": "if p % -4 == 3:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % -4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "if e % 2 == 1:",
      "mutated_line": "if e * 2 == 1:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e * 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "if e % 2 == 1:",
      "mutated_line": "if e + 2 == 1:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e + 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if e % 2 == 1:",
      "mutated_line": "if e % 2 == 2:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 2:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if e % 2 == 1:",
      "mutated_line": "if e % 2 == 0:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 0:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if e % 2 == 1:",
      "mutated_line": "if e % 2 == 0:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 0:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if e % 2 == 1:",
      "mutated_line": "if e % 2 == -1:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == -1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "ok = False",
      "mutated_line": "ok = True",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = True\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "n = try_divisor(n, 6 * i - 1, pfs)",
      "mutated_line": "n = try_divisor(n, 7 * i - 1, pfs)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 7 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "n = try_divisor(n, 6 * i - 1, pfs)",
      "mutated_line": "n = try_divisor(n, 5 * i - 1, pfs)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 5 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "n = try_divisor(n, 6 * i - 1, pfs)",
      "mutated_line": "n = try_divisor(n, 0 * i - 1, pfs)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 0 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "n = try_divisor(n, 6 * i - 1, pfs)",
      "mutated_line": "n = try_divisor(n, 1 * i - 1, pfs)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 1 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "n = try_divisor(n, 6 * i - 1, pfs)",
      "mutated_line": "n = try_divisor(n, -6 * i - 1, pfs)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, -6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "n = try_divisor(n, 6 * i + 1, pfs)",
      "mutated_line": "n = try_divisor(n, 7 * i + 1, pfs)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 7 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "n = try_divisor(n, 6 * i + 1, pfs)",
      "mutated_line": "n = try_divisor(n, 5 * i + 1, pfs)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 5 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "n = try_divisor(n, 6 * i + 1, pfs)",
      "mutated_line": "n = try_divisor(n, 0 * i + 1, pfs)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 0 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "n = try_divisor(n, 6 * i + 1, pfs)",
      "mutated_line": "n = try_divisor(n, 1 * i + 1, pfs)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 1 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "n = try_divisor(n, 6 * i + 1, pfs)",
      "mutated_line": "n = try_divisor(n, -6 * i + 1, pfs)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, -6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if (6 * i + 1) ** 2 > n:",
      "mutated_line": "if (6 / i + 1) ** 2 > n:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 / i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if (6 * i + 1) ** 2 > n:",
      "mutated_line": "if (6 + i + 1) ** 2 > n:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 + i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if (6 * i + 1) ** 2 > n:",
      "mutated_line": "if (6 ** i + 1) ** 2 > n:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 ** i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if (6 * i + 1) ** 2 > n:",
      "mutated_line": "if (6 * i + 2) ** 2 > n:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 2) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if (6 * i + 1) ** 2 > n:",
      "mutated_line": "if (6 * i + 0) ** 2 > n:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 0) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if (6 * i + 1) ** 2 > n:",
      "mutated_line": "if (6 * i + 0) ** 2 > n:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 0) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if (6 * i + 1) ** 2 > n:",
      "mutated_line": "if (6 * i + -1) ** 2 > n:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + -1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):",
      "mutated_line": "if a > 0 and b > 0 and (a / a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a / a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):",
      "mutated_line": "if a > 0 and b > 0 and (a + a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a + a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):",
      "mutated_line": "if a > 0 and b > 0 and (a ** a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a ** a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):",
      "mutated_line": "if a > 0 and b > 0 and (a * a + 2 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 2 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):",
      "mutated_line": "if a > 0 and b > 0 and (a * a + 0 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 0 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):",
      "mutated_line": "if a > 0 and b > 0 and (a * a + 0 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 0 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):",
      "mutated_line": "if a > 0 and b > 0 and (a * a + -1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + -1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):",
      "mutated_line": "if a > 0 and b > 0 and (a * a + 1 == aa) and (b / b + 1 == bb) and (math.gcd(a, b) == 1):",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b / b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):",
      "mutated_line": "if a > 0 and b > 0 and (a * a + 1 == aa) and (b + b + 1 == bb) and (math.gcd(a, b) == 1):",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b + b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):",
      "mutated_line": "if a > 0 and b > 0 and (a * a + 1 == aa) and (b ** b + 1 == bb) and (math.gcd(a, b) == 1):",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b ** b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):",
      "mutated_line": "if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 2 == bb) and (math.gcd(a, b) == 1):",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 2 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):",
      "mutated_line": "if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 0 == bb) and (math.gcd(a, b) == 1):",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 0 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):",
      "mutated_line": "if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 0 == bb) and (math.gcd(a, b) == 1):",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 0 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):",
      "mutated_line": "if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + -1 == bb) and (math.gcd(a, b) == 1):",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + -1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)",
      "mutated_line": "return recurse(lpfs, i - 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i - 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)",
      "mutated_line": "return recurse(lpfs, i * 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i * 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)",
      "mutated_line": "return recurse(lpfs, i + 1, 2 / aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 / aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)",
      "mutated_line": "return recurse(lpfs, i + 1, 2 + aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 + aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)",
      "mutated_line": "return recurse(lpfs, i + 1, 2 ** aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 ** aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)",
      "mutated_line": "return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i - 1, aa, 2 * bb)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i - 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)",
      "mutated_line": "return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i * 1, aa, 2 * bb)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i * 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)",
      "mutated_line": "return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 / bb)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 / bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)",
      "mutated_line": "return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 + bb)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 + bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)",
      "mutated_line": "return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 ** bb)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 ** bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)",
      "mutated_line": "return recurse(lpfs, i - 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i - 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)",
      "mutated_line": "return recurse(lpfs, i * 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i * 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)",
      "mutated_line": "return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i - 1, 2 * aa, 2 * bb)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i - 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)",
      "mutated_line": "return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i * 1, 2 * aa, 2 * bb)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i * 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)",
      "mutated_line": "return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 / aa, 2 * bb)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 / aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)",
      "mutated_line": "return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 + aa, 2 * bb)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 + aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)",
      "mutated_line": "return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 ** aa, 2 * bb)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 ** aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)",
      "mutated_line": "return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 / bb)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 / bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)",
      "mutated_line": "return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 + bb)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 + bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)",
      "mutated_line": "return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 ** bb)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 ** bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))",
      "mutated_line": "return sum((recurse(lpfs, i - 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i - 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))",
      "mutated_line": "return sum((recurse(lpfs, i * 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i * 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))",
      "mutated_line": "return sum((recurse(lpfs, i + 1, aa / p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa / p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))",
      "mutated_line": "return sum((recurse(lpfs, i + 1, aa + p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa + p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))",
      "mutated_line": "return sum((recurse(lpfs, i + 1, aa ** p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa ** p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))",
      "mutated_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb / p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb / p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))",
      "mutated_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb + p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb + p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))",
      "mutated_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb ** p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb ** p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))",
      "mutated_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 != 0))",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 != 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if e % 2 == 1:",
      "mutated_line": "if e % 3 == 1:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 3 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if e % 2 == 1:",
      "mutated_line": "if e % 1 == 1:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 1 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if e % 2 == 1:",
      "mutated_line": "if e % 0 == 1:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 0 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if e % 2 == 1:",
      "mutated_line": "if e % 1 == 1:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 1 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if e % 2 == 1:",
      "mutated_line": "if e % -2 == 1:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % -2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if (6 * i + 1) ** 2 > n:",
      "mutated_line": "if (7 * i + 1) ** 2 > n:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (7 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if (6 * i + 1) ** 2 > n:",
      "mutated_line": "if (5 * i + 1) ** 2 > n:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (5 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if (6 * i + 1) ** 2 > n:",
      "mutated_line": "if (0 * i + 1) ** 2 > n:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (0 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if (6 * i + 1) ** 2 > n:",
      "mutated_line": "if (1 * i + 1) ** 2 > n:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (1 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if (6 * i + 1) ** 2 > n:",
      "mutated_line": "if (-6 * i + 1) ** 2 > n:",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (-6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)",
      "mutated_line": "return recurse(lpfs, i + 2, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 2, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)",
      "mutated_line": "return recurse(lpfs, i + 0, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 0, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)",
      "mutated_line": "return recurse(lpfs, i + 0, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 0, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)",
      "mutated_line": "return recurse(lpfs, i + -1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + -1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)",
      "mutated_line": "return recurse(lpfs, i + 1, 3 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 3 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)",
      "mutated_line": "return recurse(lpfs, i + 1, 1 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 1 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)",
      "mutated_line": "return recurse(lpfs, i + 1, 0 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 0 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)",
      "mutated_line": "return recurse(lpfs, i + 1, 1 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 1 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)",
      "mutated_line": "return recurse(lpfs, i + 1, -2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, -2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)",
      "mutated_line": "return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 2, aa, 2 * bb)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 2, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)",
      "mutated_line": "return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 0, aa, 2 * bb)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 0, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)",
      "mutated_line": "return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 0, aa, 2 * bb)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 0, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)",
      "mutated_line": "return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + -1, aa, 2 * bb)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + -1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)",
      "mutated_line": "return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 3 * bb)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 3 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)",
      "mutated_line": "return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 1 * bb)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 1 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)",
      "mutated_line": "return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 0 * bb)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 0 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)",
      "mutated_line": "return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 1 * bb)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 1 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)",
      "mutated_line": "return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, -2 * bb)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, -2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)",
      "mutated_line": "return recurse(lpfs, i + 2, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 2, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)",
      "mutated_line": "return recurse(lpfs, i + 0, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 0, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)",
      "mutated_line": "return recurse(lpfs, i + 0, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 0, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)",
      "mutated_line": "return recurse(lpfs, i + -1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + -1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)",
      "mutated_line": "return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 2, 2 * aa, 2 * bb)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 2, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)",
      "mutated_line": "return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 0, 2 * aa, 2 * bb)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 0, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)",
      "mutated_line": "return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 0, 2 * aa, 2 * bb)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 0, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)",
      "mutated_line": "return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + -1, 2 * aa, 2 * bb)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + -1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)",
      "mutated_line": "return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 3 * aa, 2 * bb)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 3 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)",
      "mutated_line": "return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 1 * aa, 2 * bb)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 1 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)",
      "mutated_line": "return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 0 * aa, 2 * bb)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 0 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)",
      "mutated_line": "return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 1 * aa, 2 * bb)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 1 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)",
      "mutated_line": "return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, -2 * aa, 2 * bb)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, -2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)",
      "mutated_line": "return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 3 * bb)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 3 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)",
      "mutated_line": "return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 1 * bb)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 1 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)",
      "mutated_line": "return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 0 * bb)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 0 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)",
      "mutated_line": "return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 1 * bb)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 1 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)",
      "mutated_line": "return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, -2 * bb)",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, -2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))",
      "mutated_line": "return sum((recurse(lpfs, i + 2, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 2, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))",
      "mutated_line": "return sum((recurse(lpfs, i + 0, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 0, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))",
      "mutated_line": "return sum((recurse(lpfs, i + 0, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 0, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))",
      "mutated_line": "return sum((recurse(lpfs, i + -1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + -1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))",
      "mutated_line": "return sum((recurse(lpfs, i + 1, aa * (p * j), bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * (p * j), bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))",
      "mutated_line": "return sum((recurse(lpfs, i + 1, aa * (p + j), bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * (p + j), bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))",
      "mutated_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb * (p * k)) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * (p * k)) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))",
      "mutated_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb * (p + k)) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * (p + k)) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))",
      "mutated_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e - 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e - 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))",
      "mutated_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e * 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e * 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))",
      "mutated_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j - 1) if (e - j - k) % 2 == 0))",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j - 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))",
      "mutated_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range((e - j) * 1) if (e - j - k) % 2 == 0))",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range((e - j) * 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))",
      "mutated_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) * 2 == 0))",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) * 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))",
      "mutated_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if e - j - k + 2 == 0))",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if e - j - k + 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))",
      "mutated_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 1))",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 1))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))",
      "mutated_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == -1))",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == -1))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))",
      "mutated_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 1))",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 1))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))",
      "mutated_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 2) for k in range(e - j + 1) if (e - j - k) % 2 == 0))",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 2) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))",
      "mutated_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 0) for k in range(e - j + 1) if (e - j - k) % 2 == 0))",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 0) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))",
      "mutated_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 0) for k in range(e - j + 1) if (e - j - k) % 2 == 0))",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 0) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))",
      "mutated_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + -1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + -1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))",
      "mutated_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e + j + 1) if (e - j - k) % 2 == 0))",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e + j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))",
      "mutated_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e * j + 1) if (e - j - k) % 2 == 0))",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e * j + 1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))",
      "mutated_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 2) if (e - j - k) % 2 == 0))",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 2) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))",
      "mutated_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 0) if (e - j - k) % 2 == 0))",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 0) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))",
      "mutated_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 0) if (e - j - k) % 2 == 0))",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 0) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))",
      "mutated_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + -1) if (e - j - k) % 2 == 0))",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + -1) if (e - j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))",
      "mutated_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j + k) % 2 == 0))",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j + k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))",
      "mutated_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j) * k % 2 == 0))",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j) * k % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))",
      "mutated_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 3 == 0))",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 3 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))",
      "mutated_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 1 == 0))",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 1 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))",
      "mutated_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 0 == 0))",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 0 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))",
      "mutated_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 1 == 0))",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 1 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))",
      "mutated_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % -2 == 0))",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % -2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))",
      "mutated_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e + j - k) % 2 == 0))",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e + j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e - j - k) % 2 == 0))",
      "mutated_line": "return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e * j - k) % 2 == 0))",
      "code": "import itertools\nimport math\n\ndef factorize(n):\n\n    def try_divisor(n, k, pfs):\n        if n % k == 0:\n            pfs[k] = 1\n            n //= k\n            while n % k == 0:\n                pfs[k] += 1\n                n //= k\n        return n\n    pfs = {}\n    n = try_divisor(n, 2, pfs)\n    n = try_divisor(n, 3, pfs)\n    for i in itertools.count(start=1):\n        n = try_divisor(n, 6 * i - 1, pfs)\n        n = try_divisor(n, 6 * i + 1, pfs)\n        if (6 * i + 1) ** 2 > n:\n            break\n    if n > 1:\n        pfs[n] = 1\n    return pfs\n\ndef recurse(lpfs, i, aa, bb):\n    if i == len(lpfs):\n        a = math.isqrt(aa - 1)\n        b = math.isqrt(bb - 1)\n        if a > 0 and b > 0 and (a * a + 1 == aa) and (b * b + 1 == bb) and (math.gcd(a, b) == 1):\n            return 1\n        else:\n            return 0\n    (p, e) = lpfs[i]\n    if p == 2:\n        if e % 2 == 1:\n            return recurse(lpfs, i + 1, 2 * aa, bb) + recurse(lpfs, i + 1, aa, 2 * bb)\n        else:\n            return recurse(lpfs, i + 1, aa, bb) + recurse(lpfs, i + 1, 2 * aa, 2 * bb)\n    else:\n        return sum((recurse(lpfs, i + 1, aa * p ** j, bb * p ** k) for j in range(e + 1) for k in range(e - j + 1) if (e * j - k) % 2 == 0))\n\ndef count_valid_pairs(N):\n    pfs = factorize(N)\n    ok = True\n    lpfs = []\n    while pfs:\n        (p, e) = pfs.popitem()\n        if p % 4 == 3:\n            if e % 2 == 1:\n                ok = False\n                break\n        else:\n            lpfs.append((p, e))\n    return recurse(lpfs, 0, 1, 1) if ok else 0"
    }
  ]
}