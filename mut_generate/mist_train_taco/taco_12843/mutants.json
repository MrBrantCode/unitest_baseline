{
  "task_id": "taco_12843",
  "entry_point": "count_score_assignments",
  "mutant_count": 70,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def count_score_assignments(N: int, M: int) -> int:\n    \"\"\"\"\"\"\n    A = list(range(1, N // 2 + 1)) * 2\n    if N & 1:\n        A += [(N + 1) // 2]\n    d = [1] + [0] * (N + N)\n    for x in A:\n        for i in range(N + 1):\n            d[i] %= M\n            d[i + x] += d[i]\n    return sum(d[:N]) % M"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "A = list(range(1, N // 2 + 1)) * 2",
      "mutated_line": "A = list(range(1, N // 2 + 1)) / 2",
      "code": "def count_score_assignments(N: int, M: int) -> int:\n    \"\"\"\n    Calculate the number of ways to assign scores to N problems such that:\n    - Each problem i gets an integer score A_i between 1 and N, inclusive.\n    - The problems are sorted by difficulty: A_1 <= A_2 <= ... <= A_N.\n    - For any k (1 <= k <= N-1), the sum of scores of any k problems is strictly less than the sum of scores of any k+1 problems.\n    \n    The result is returned modulo M.\n\n    Parameters:\n    - N (int): The number of problems.\n    - M (int): The prime modulo.\n\n    Returns:\n    - int: The number of ways to assign scores modulo M.\n    \"\"\"\n    A = list(range(1, N // 2 + 1)) / 2\n    if N & 1:\n        A += [(N + 1) // 2]\n    d = [1] + [0] * (N + N)\n    for x in A:\n        for i in range(N + 1):\n            d[i] %= M\n            d[i + x] += d[i]\n    return sum(d[:N]) % M"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "A = list(range(1, N // 2 + 1)) * 2",
      "mutated_line": "A = list(range(1, N // 2 + 1)) + 2",
      "code": "def count_score_assignments(N: int, M: int) -> int:\n    \"\"\"\n    Calculate the number of ways to assign scores to N problems such that:\n    - Each problem i gets an integer score A_i between 1 and N, inclusive.\n    - The problems are sorted by difficulty: A_1 <= A_2 <= ... <= A_N.\n    - For any k (1 <= k <= N-1), the sum of scores of any k problems is strictly less than the sum of scores of any k+1 problems.\n    \n    The result is returned modulo M.\n\n    Parameters:\n    - N (int): The number of problems.\n    - M (int): The prime modulo.\n\n    Returns:\n    - int: The number of ways to assign scores modulo M.\n    \"\"\"\n    A = list(range(1, N // 2 + 1)) + 2\n    if N & 1:\n        A += [(N + 1) // 2]\n    d = [1] + [0] * (N + N)\n    for x in A:\n        for i in range(N + 1):\n            d[i] %= M\n            d[i + x] += d[i]\n    return sum(d[:N]) % M"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "A = list(range(1, N // 2 + 1)) * 2",
      "mutated_line": "A = list(range(1, N // 2 + 1)) ** 2",
      "code": "def count_score_assignments(N: int, M: int) -> int:\n    \"\"\"\n    Calculate the number of ways to assign scores to N problems such that:\n    - Each problem i gets an integer score A_i between 1 and N, inclusive.\n    - The problems are sorted by difficulty: A_1 <= A_2 <= ... <= A_N.\n    - For any k (1 <= k <= N-1), the sum of scores of any k problems is strictly less than the sum of scores of any k+1 problems.\n    \n    The result is returned modulo M.\n\n    Parameters:\n    - N (int): The number of problems.\n    - M (int): The prime modulo.\n\n    Returns:\n    - int: The number of ways to assign scores modulo M.\n    \"\"\"\n    A = list(range(1, N // 2 + 1)) ** 2\n    if N & 1:\n        A += [(N + 1) // 2]\n    d = [1] + [0] * (N + N)\n    for x in A:\n        for i in range(N + 1):\n            d[i] %= M\n            d[i + x] += d[i]\n    return sum(d[:N]) % M"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if N & 1:",
      "mutated_line": "if N | 1:",
      "code": "def count_score_assignments(N: int, M: int) -> int:\n    \"\"\"\n    Calculate the number of ways to assign scores to N problems such that:\n    - Each problem i gets an integer score A_i between 1 and N, inclusive.\n    - The problems are sorted by difficulty: A_1 <= A_2 <= ... <= A_N.\n    - For any k (1 <= k <= N-1), the sum of scores of any k problems is strictly less than the sum of scores of any k+1 problems.\n    \n    The result is returned modulo M.\n\n    Parameters:\n    - N (int): The number of problems.\n    - M (int): The prime modulo.\n\n    Returns:\n    - int: The number of ways to assign scores modulo M.\n    \"\"\"\n    A = list(range(1, N // 2 + 1)) * 2\n    if N | 1:\n        A += [(N + 1) // 2]\n    d = [1] + [0] * (N + N)\n    for x in A:\n        for i in range(N + 1):\n            d[i] %= M\n            d[i + x] += d[i]\n    return sum(d[:N]) % M"
    },
    {
      "operator": "ASR",
      "lineno": 19,
      "original_line": "A += [(N + 1) // 2]",
      "mutated_line": "A -= [(N + 1) // 2]",
      "code": "def count_score_assignments(N: int, M: int) -> int:\n    \"\"\"\n    Calculate the number of ways to assign scores to N problems such that:\n    - Each problem i gets an integer score A_i between 1 and N, inclusive.\n    - The problems are sorted by difficulty: A_1 <= A_2 <= ... <= A_N.\n    - For any k (1 <= k <= N-1), the sum of scores of any k problems is strictly less than the sum of scores of any k+1 problems.\n    \n    The result is returned modulo M.\n\n    Parameters:\n    - N (int): The number of problems.\n    - M (int): The prime modulo.\n\n    Returns:\n    - int: The number of ways to assign scores modulo M.\n    \"\"\"\n    A = list(range(1, N // 2 + 1)) * 2\n    if N & 1:\n        A -= [(N + 1) // 2]\n    d = [1] + [0] * (N + N)\n    for x in A:\n        for i in range(N + 1):\n            d[i] %= M\n            d[i + x] += d[i]\n    return sum(d[:N]) % M"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "d = [1] + [0] * (N + N)",
      "mutated_line": "d = [1] - [0] * (N + N)",
      "code": "def count_score_assignments(N: int, M: int) -> int:\n    \"\"\"\n    Calculate the number of ways to assign scores to N problems such that:\n    - Each problem i gets an integer score A_i between 1 and N, inclusive.\n    - The problems are sorted by difficulty: A_1 <= A_2 <= ... <= A_N.\n    - For any k (1 <= k <= N-1), the sum of scores of any k problems is strictly less than the sum of scores of any k+1 problems.\n    \n    The result is returned modulo M.\n\n    Parameters:\n    - N (int): The number of problems.\n    - M (int): The prime modulo.\n\n    Returns:\n    - int: The number of ways to assign scores modulo M.\n    \"\"\"\n    A = list(range(1, N // 2 + 1)) * 2\n    if N & 1:\n        A += [(N + 1) // 2]\n    d = [1] - [0] * (N + N)\n    for x in A:\n        for i in range(N + 1):\n            d[i] %= M\n            d[i + x] += d[i]\n    return sum(d[:N]) % M"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "d = [1] + [0] * (N + N)",
      "mutated_line": "d = [1] * ([0] * (N + N))",
      "code": "def count_score_assignments(N: int, M: int) -> int:\n    \"\"\"\n    Calculate the number of ways to assign scores to N problems such that:\n    - Each problem i gets an integer score A_i between 1 and N, inclusive.\n    - The problems are sorted by difficulty: A_1 <= A_2 <= ... <= A_N.\n    - For any k (1 <= k <= N-1), the sum of scores of any k problems is strictly less than the sum of scores of any k+1 problems.\n    \n    The result is returned modulo M.\n\n    Parameters:\n    - N (int): The number of problems.\n    - M (int): The prime modulo.\n\n    Returns:\n    - int: The number of ways to assign scores modulo M.\n    \"\"\"\n    A = list(range(1, N // 2 + 1)) * 2\n    if N & 1:\n        A += [(N + 1) // 2]\n    d = [1] * ([0] * (N + N))\n    for x in A:\n        for i in range(N + 1):\n            d[i] %= M\n            d[i + x] += d[i]\n    return sum(d[:N]) % M"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "return sum(d[:N]) % M",
      "mutated_line": "return sum(d[:N]) * M",
      "code": "def count_score_assignments(N: int, M: int) -> int:\n    \"\"\"\n    Calculate the number of ways to assign scores to N problems such that:\n    - Each problem i gets an integer score A_i between 1 and N, inclusive.\n    - The problems are sorted by difficulty: A_1 <= A_2 <= ... <= A_N.\n    - For any k (1 <= k <= N-1), the sum of scores of any k problems is strictly less than the sum of scores of any k+1 problems.\n    \n    The result is returned modulo M.\n\n    Parameters:\n    - N (int): The number of problems.\n    - M (int): The prime modulo.\n\n    Returns:\n    - int: The number of ways to assign scores modulo M.\n    \"\"\"\n    A = list(range(1, N // 2 + 1)) * 2\n    if N & 1:\n        A += [(N + 1) // 2]\n    d = [1] + [0] * (N + N)\n    for x in A:\n        for i in range(N + 1):\n            d[i] %= M\n            d[i + x] += d[i]\n    return sum(d[:N]) * M"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "return sum(d[:N]) % M",
      "mutated_line": "return sum(d[:N]) + M",
      "code": "def count_score_assignments(N: int, M: int) -> int:\n    \"\"\"\n    Calculate the number of ways to assign scores to N problems such that:\n    - Each problem i gets an integer score A_i between 1 and N, inclusive.\n    - The problems are sorted by difficulty: A_1 <= A_2 <= ... <= A_N.\n    - For any k (1 <= k <= N-1), the sum of scores of any k problems is strictly less than the sum of scores of any k+1 problems.\n    \n    The result is returned modulo M.\n\n    Parameters:\n    - N (int): The number of problems.\n    - M (int): The prime modulo.\n\n    Returns:\n    - int: The number of ways to assign scores modulo M.\n    \"\"\"\n    A = list(range(1, N // 2 + 1)) * 2\n    if N & 1:\n        A += [(N + 1) // 2]\n    d = [1] + [0] * (N + N)\n    for x in A:\n        for i in range(N + 1):\n            d[i] %= M\n            d[i + x] += d[i]\n    return sum(d[:N]) + M"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "A = list(range(1, N // 2 + 1)) * 2",
      "mutated_line": "A = list(range(1, N // 2 + 1)) * 3",
      "code": "def count_score_assignments(N: int, M: int) -> int:\n    \"\"\"\n    Calculate the number of ways to assign scores to N problems such that:\n    - Each problem i gets an integer score A_i between 1 and N, inclusive.\n    - The problems are sorted by difficulty: A_1 <= A_2 <= ... <= A_N.\n    - For any k (1 <= k <= N-1), the sum of scores of any k problems is strictly less than the sum of scores of any k+1 problems.\n    \n    The result is returned modulo M.\n\n    Parameters:\n    - N (int): The number of problems.\n    - M (int): The prime modulo.\n\n    Returns:\n    - int: The number of ways to assign scores modulo M.\n    \"\"\"\n    A = list(range(1, N // 2 + 1)) * 3\n    if N & 1:\n        A += [(N + 1) // 2]\n    d = [1] + [0] * (N + N)\n    for x in A:\n        for i in range(N + 1):\n            d[i] %= M\n            d[i + x] += d[i]\n    return sum(d[:N]) % M"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "A = list(range(1, N // 2 + 1)) * 2",
      "mutated_line": "A = list(range(1, N // 2 + 1)) * 1",
      "code": "def count_score_assignments(N: int, M: int) -> int:\n    \"\"\"\n    Calculate the number of ways to assign scores to N problems such that:\n    - Each problem i gets an integer score A_i between 1 and N, inclusive.\n    - The problems are sorted by difficulty: A_1 <= A_2 <= ... <= A_N.\n    - For any k (1 <= k <= N-1), the sum of scores of any k problems is strictly less than the sum of scores of any k+1 problems.\n    \n    The result is returned modulo M.\n\n    Parameters:\n    - N (int): The number of problems.\n    - M (int): The prime modulo.\n\n    Returns:\n    - int: The number of ways to assign scores modulo M.\n    \"\"\"\n    A = list(range(1, N // 2 + 1)) * 1\n    if N & 1:\n        A += [(N + 1) // 2]\n    d = [1] + [0] * (N + N)\n    for x in A:\n        for i in range(N + 1):\n            d[i] %= M\n            d[i + x] += d[i]\n    return sum(d[:N]) % M"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "A = list(range(1, N // 2 + 1)) * 2",
      "mutated_line": "A = list(range(1, N // 2 + 1)) * 0",
      "code": "def count_score_assignments(N: int, M: int) -> int:\n    \"\"\"\n    Calculate the number of ways to assign scores to N problems such that:\n    - Each problem i gets an integer score A_i between 1 and N, inclusive.\n    - The problems are sorted by difficulty: A_1 <= A_2 <= ... <= A_N.\n    - For any k (1 <= k <= N-1), the sum of scores of any k problems is strictly less than the sum of scores of any k+1 problems.\n    \n    The result is returned modulo M.\n\n    Parameters:\n    - N (int): The number of problems.\n    - M (int): The prime modulo.\n\n    Returns:\n    - int: The number of ways to assign scores modulo M.\n    \"\"\"\n    A = list(range(1, N // 2 + 1)) * 0\n    if N & 1:\n        A += [(N + 1) // 2]\n    d = [1] + [0] * (N + N)\n    for x in A:\n        for i in range(N + 1):\n            d[i] %= M\n            d[i + x] += d[i]\n    return sum(d[:N]) % M"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "A = list(range(1, N // 2 + 1)) * 2",
      "mutated_line": "A = list(range(1, N // 2 + 1)) * 1",
      "code": "def count_score_assignments(N: int, M: int) -> int:\n    \"\"\"\n    Calculate the number of ways to assign scores to N problems such that:\n    - Each problem i gets an integer score A_i between 1 and N, inclusive.\n    - The problems are sorted by difficulty: A_1 <= A_2 <= ... <= A_N.\n    - For any k (1 <= k <= N-1), the sum of scores of any k problems is strictly less than the sum of scores of any k+1 problems.\n    \n    The result is returned modulo M.\n\n    Parameters:\n    - N (int): The number of problems.\n    - M (int): The prime modulo.\n\n    Returns:\n    - int: The number of ways to assign scores modulo M.\n    \"\"\"\n    A = list(range(1, N // 2 + 1)) * 1\n    if N & 1:\n        A += [(N + 1) // 2]\n    d = [1] + [0] * (N + N)\n    for x in A:\n        for i in range(N + 1):\n            d[i] %= M\n            d[i + x] += d[i]\n    return sum(d[:N]) % M"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "A = list(range(1, N // 2 + 1)) * 2",
      "mutated_line": "A = list(range(1, N // 2 + 1)) * -2",
      "code": "def count_score_assignments(N: int, M: int) -> int:\n    \"\"\"\n    Calculate the number of ways to assign scores to N problems such that:\n    - Each problem i gets an integer score A_i between 1 and N, inclusive.\n    - The problems are sorted by difficulty: A_1 <= A_2 <= ... <= A_N.\n    - For any k (1 <= k <= N-1), the sum of scores of any k problems is strictly less than the sum of scores of any k+1 problems.\n    \n    The result is returned modulo M.\n\n    Parameters:\n    - N (int): The number of problems.\n    - M (int): The prime modulo.\n\n    Returns:\n    - int: The number of ways to assign scores modulo M.\n    \"\"\"\n    A = list(range(1, N // 2 + 1)) * -2\n    if N & 1:\n        A += [(N + 1) // 2]\n    d = [1] + [0] * (N + N)\n    for x in A:\n        for i in range(N + 1):\n            d[i] %= M\n            d[i + x] += d[i]\n    return sum(d[:N]) % M"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if N & 1:",
      "mutated_line": "if N & 2:",
      "code": "def count_score_assignments(N: int, M: int) -> int:\n    \"\"\"\n    Calculate the number of ways to assign scores to N problems such that:\n    - Each problem i gets an integer score A_i between 1 and N, inclusive.\n    - The problems are sorted by difficulty: A_1 <= A_2 <= ... <= A_N.\n    - For any k (1 <= k <= N-1), the sum of scores of any k problems is strictly less than the sum of scores of any k+1 problems.\n    \n    The result is returned modulo M.\n\n    Parameters:\n    - N (int): The number of problems.\n    - M (int): The prime modulo.\n\n    Returns:\n    - int: The number of ways to assign scores modulo M.\n    \"\"\"\n    A = list(range(1, N // 2 + 1)) * 2\n    if N & 2:\n        A += [(N + 1) // 2]\n    d = [1] + [0] * (N + N)\n    for x in A:\n        for i in range(N + 1):\n            d[i] %= M\n            d[i + x] += d[i]\n    return sum(d[:N]) % M"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if N & 1:",
      "mutated_line": "if N & 0:",
      "code": "def count_score_assignments(N: int, M: int) -> int:\n    \"\"\"\n    Calculate the number of ways to assign scores to N problems such that:\n    - Each problem i gets an integer score A_i between 1 and N, inclusive.\n    - The problems are sorted by difficulty: A_1 <= A_2 <= ... <= A_N.\n    - For any k (1 <= k <= N-1), the sum of scores of any k problems is strictly less than the sum of scores of any k+1 problems.\n    \n    The result is returned modulo M.\n\n    Parameters:\n    - N (int): The number of problems.\n    - M (int): The prime modulo.\n\n    Returns:\n    - int: The number of ways to assign scores modulo M.\n    \"\"\"\n    A = list(range(1, N // 2 + 1)) * 2\n    if N & 0:\n        A += [(N + 1) // 2]\n    d = [1] + [0] * (N + N)\n    for x in A:\n        for i in range(N + 1):\n            d[i] %= M\n            d[i + x] += d[i]\n    return sum(d[:N]) % M"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if N & 1:",
      "mutated_line": "if N & 0:",
      "code": "def count_score_assignments(N: int, M: int) -> int:\n    \"\"\"\n    Calculate the number of ways to assign scores to N problems such that:\n    - Each problem i gets an integer score A_i between 1 and N, inclusive.\n    - The problems are sorted by difficulty: A_1 <= A_2 <= ... <= A_N.\n    - For any k (1 <= k <= N-1), the sum of scores of any k problems is strictly less than the sum of scores of any k+1 problems.\n    \n    The result is returned modulo M.\n\n    Parameters:\n    - N (int): The number of problems.\n    - M (int): The prime modulo.\n\n    Returns:\n    - int: The number of ways to assign scores modulo M.\n    \"\"\"\n    A = list(range(1, N // 2 + 1)) * 2\n    if N & 0:\n        A += [(N + 1) // 2]\n    d = [1] + [0] * (N + N)\n    for x in A:\n        for i in range(N + 1):\n            d[i] %= M\n            d[i + x] += d[i]\n    return sum(d[:N]) % M"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if N & 1:",
      "mutated_line": "if N & -1:",
      "code": "def count_score_assignments(N: int, M: int) -> int:\n    \"\"\"\n    Calculate the number of ways to assign scores to N problems such that:\n    - Each problem i gets an integer score A_i between 1 and N, inclusive.\n    - The problems are sorted by difficulty: A_1 <= A_2 <= ... <= A_N.\n    - For any k (1 <= k <= N-1), the sum of scores of any k problems is strictly less than the sum of scores of any k+1 problems.\n    \n    The result is returned modulo M.\n\n    Parameters:\n    - N (int): The number of problems.\n    - M (int): The prime modulo.\n\n    Returns:\n    - int: The number of ways to assign scores modulo M.\n    \"\"\"\n    A = list(range(1, N // 2 + 1)) * 2\n    if N & -1:\n        A += [(N + 1) // 2]\n    d = [1] + [0] * (N + N)\n    for x in A:\n        for i in range(N + 1):\n            d[i] %= M\n            d[i + x] += d[i]\n    return sum(d[:N]) % M"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "d = [1] + [0] * (N + N)",
      "mutated_line": "d = [1] + [0] / (N + N)",
      "code": "def count_score_assignments(N: int, M: int) -> int:\n    \"\"\"\n    Calculate the number of ways to assign scores to N problems such that:\n    - Each problem i gets an integer score A_i between 1 and N, inclusive.\n    - The problems are sorted by difficulty: A_1 <= A_2 <= ... <= A_N.\n    - For any k (1 <= k <= N-1), the sum of scores of any k problems is strictly less than the sum of scores of any k+1 problems.\n    \n    The result is returned modulo M.\n\n    Parameters:\n    - N (int): The number of problems.\n    - M (int): The prime modulo.\n\n    Returns:\n    - int: The number of ways to assign scores modulo M.\n    \"\"\"\n    A = list(range(1, N // 2 + 1)) * 2\n    if N & 1:\n        A += [(N + 1) // 2]\n    d = [1] + [0] / (N + N)\n    for x in A:\n        for i in range(N + 1):\n            d[i] %= M\n            d[i + x] += d[i]\n    return sum(d[:N]) % M"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "d = [1] + [0] * (N + N)",
      "mutated_line": "d = [1] + ([0] + (N + N))",
      "code": "def count_score_assignments(N: int, M: int) -> int:\n    \"\"\"\n    Calculate the number of ways to assign scores to N problems such that:\n    - Each problem i gets an integer score A_i between 1 and N, inclusive.\n    - The problems are sorted by difficulty: A_1 <= A_2 <= ... <= A_N.\n    - For any k (1 <= k <= N-1), the sum of scores of any k problems is strictly less than the sum of scores of any k+1 problems.\n    \n    The result is returned modulo M.\n\n    Parameters:\n    - N (int): The number of problems.\n    - M (int): The prime modulo.\n\n    Returns:\n    - int: The number of ways to assign scores modulo M.\n    \"\"\"\n    A = list(range(1, N // 2 + 1)) * 2\n    if N & 1:\n        A += [(N + 1) // 2]\n    d = [1] + ([0] + (N + N))\n    for x in A:\n        for i in range(N + 1):\n            d[i] %= M\n            d[i + x] += d[i]\n    return sum(d[:N]) % M"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "d = [1] + [0] * (N + N)",
      "mutated_line": "d = [1] + [0] ** (N + N)",
      "code": "def count_score_assignments(N: int, M: int) -> int:\n    \"\"\"\n    Calculate the number of ways to assign scores to N problems such that:\n    - Each problem i gets an integer score A_i between 1 and N, inclusive.\n    - The problems are sorted by difficulty: A_1 <= A_2 <= ... <= A_N.\n    - For any k (1 <= k <= N-1), the sum of scores of any k problems is strictly less than the sum of scores of any k+1 problems.\n    \n    The result is returned modulo M.\n\n    Parameters:\n    - N (int): The number of problems.\n    - M (int): The prime modulo.\n\n    Returns:\n    - int: The number of ways to assign scores modulo M.\n    \"\"\"\n    A = list(range(1, N // 2 + 1)) * 2\n    if N & 1:\n        A += [(N + 1) // 2]\n    d = [1] + [0] ** (N + N)\n    for x in A:\n        for i in range(N + 1):\n            d[i] %= M\n            d[i + x] += d[i]\n    return sum(d[:N]) % M"
    },
    {
      "operator": "ASR",
      "lineno": 24,
      "original_line": "d[i + x] += d[i]",
      "mutated_line": "d[i + x] -= d[i]",
      "code": "def count_score_assignments(N: int, M: int) -> int:\n    \"\"\"\n    Calculate the number of ways to assign scores to N problems such that:\n    - Each problem i gets an integer score A_i between 1 and N, inclusive.\n    - The problems are sorted by difficulty: A_1 <= A_2 <= ... <= A_N.\n    - For any k (1 <= k <= N-1), the sum of scores of any k problems is strictly less than the sum of scores of any k+1 problems.\n    \n    The result is returned modulo M.\n\n    Parameters:\n    - N (int): The number of problems.\n    - M (int): The prime modulo.\n\n    Returns:\n    - int: The number of ways to assign scores modulo M.\n    \"\"\"\n    A = list(range(1, N // 2 + 1)) * 2\n    if N & 1:\n        A += [(N + 1) // 2]\n    d = [1] + [0] * (N + N)\n    for x in A:\n        for i in range(N + 1):\n            d[i] %= M\n            d[i + x] -= d[i]\n    return sum(d[:N]) % M"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "A += [(N + 1) // 2]",
      "mutated_line": "A += [(N + 1) / 2]",
      "code": "def count_score_assignments(N: int, M: int) -> int:\n    \"\"\"\n    Calculate the number of ways to assign scores to N problems such that:\n    - Each problem i gets an integer score A_i between 1 and N, inclusive.\n    - The problems are sorted by difficulty: A_1 <= A_2 <= ... <= A_N.\n    - For any k (1 <= k <= N-1), the sum of scores of any k problems is strictly less than the sum of scores of any k+1 problems.\n    \n    The result is returned modulo M.\n\n    Parameters:\n    - N (int): The number of problems.\n    - M (int): The prime modulo.\n\n    Returns:\n    - int: The number of ways to assign scores modulo M.\n    \"\"\"\n    A = list(range(1, N // 2 + 1)) * 2\n    if N & 1:\n        A += [(N + 1) / 2]\n    d = [1] + [0] * (N + N)\n    for x in A:\n        for i in range(N + 1):\n            d[i] %= M\n            d[i + x] += d[i]\n    return sum(d[:N]) % M"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "A += [(N + 1) // 2]",
      "mutated_line": "A += [(N + 1) * 2]",
      "code": "def count_score_assignments(N: int, M: int) -> int:\n    \"\"\"\n    Calculate the number of ways to assign scores to N problems such that:\n    - Each problem i gets an integer score A_i between 1 and N, inclusive.\n    - The problems are sorted by difficulty: A_1 <= A_2 <= ... <= A_N.\n    - For any k (1 <= k <= N-1), the sum of scores of any k problems is strictly less than the sum of scores of any k+1 problems.\n    \n    The result is returned modulo M.\n\n    Parameters:\n    - N (int): The number of problems.\n    - M (int): The prime modulo.\n\n    Returns:\n    - int: The number of ways to assign scores modulo M.\n    \"\"\"\n    A = list(range(1, N // 2 + 1)) * 2\n    if N & 1:\n        A += [(N + 1) * 2]\n    d = [1] + [0] * (N + N)\n    for x in A:\n        for i in range(N + 1):\n            d[i] %= M\n            d[i + x] += d[i]\n    return sum(d[:N]) % M"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "d = [1] + [0] * (N + N)",
      "mutated_line": "d = [2] + [0] * (N + N)",
      "code": "def count_score_assignments(N: int, M: int) -> int:\n    \"\"\"\n    Calculate the number of ways to assign scores to N problems such that:\n    - Each problem i gets an integer score A_i between 1 and N, inclusive.\n    - The problems are sorted by difficulty: A_1 <= A_2 <= ... <= A_N.\n    - For any k (1 <= k <= N-1), the sum of scores of any k problems is strictly less than the sum of scores of any k+1 problems.\n    \n    The result is returned modulo M.\n\n    Parameters:\n    - N (int): The number of problems.\n    - M (int): The prime modulo.\n\n    Returns:\n    - int: The number of ways to assign scores modulo M.\n    \"\"\"\n    A = list(range(1, N // 2 + 1)) * 2\n    if N & 1:\n        A += [(N + 1) // 2]\n    d = [2] + [0] * (N + N)\n    for x in A:\n        for i in range(N + 1):\n            d[i] %= M\n            d[i + x] += d[i]\n    return sum(d[:N]) % M"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "d = [1] + [0] * (N + N)",
      "mutated_line": "d = [0] + [0] * (N + N)",
      "code": "def count_score_assignments(N: int, M: int) -> int:\n    \"\"\"\n    Calculate the number of ways to assign scores to N problems such that:\n    - Each problem i gets an integer score A_i between 1 and N, inclusive.\n    - The problems are sorted by difficulty: A_1 <= A_2 <= ... <= A_N.\n    - For any k (1 <= k <= N-1), the sum of scores of any k problems is strictly less than the sum of scores of any k+1 problems.\n    \n    The result is returned modulo M.\n\n    Parameters:\n    - N (int): The number of problems.\n    - M (int): The prime modulo.\n\n    Returns:\n    - int: The number of ways to assign scores modulo M.\n    \"\"\"\n    A = list(range(1, N // 2 + 1)) * 2\n    if N & 1:\n        A += [(N + 1) // 2]\n    d = [0] + [0] * (N + N)\n    for x in A:\n        for i in range(N + 1):\n            d[i] %= M\n            d[i + x] += d[i]\n    return sum(d[:N]) % M"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "d = [1] + [0] * (N + N)",
      "mutated_line": "d = [0] + [0] * (N + N)",
      "code": "def count_score_assignments(N: int, M: int) -> int:\n    \"\"\"\n    Calculate the number of ways to assign scores to N problems such that:\n    - Each problem i gets an integer score A_i between 1 and N, inclusive.\n    - The problems are sorted by difficulty: A_1 <= A_2 <= ... <= A_N.\n    - For any k (1 <= k <= N-1), the sum of scores of any k problems is strictly less than the sum of scores of any k+1 problems.\n    \n    The result is returned modulo M.\n\n    Parameters:\n    - N (int): The number of problems.\n    - M (int): The prime modulo.\n\n    Returns:\n    - int: The number of ways to assign scores modulo M.\n    \"\"\"\n    A = list(range(1, N // 2 + 1)) * 2\n    if N & 1:\n        A += [(N + 1) // 2]\n    d = [0] + [0] * (N + N)\n    for x in A:\n        for i in range(N + 1):\n            d[i] %= M\n            d[i + x] += d[i]\n    return sum(d[:N]) % M"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "d = [1] + [0] * (N + N)",
      "mutated_line": "d = [-1] + [0] * (N + N)",
      "code": "def count_score_assignments(N: int, M: int) -> int:\n    \"\"\"\n    Calculate the number of ways to assign scores to N problems such that:\n    - Each problem i gets an integer score A_i between 1 and N, inclusive.\n    - The problems are sorted by difficulty: A_1 <= A_2 <= ... <= A_N.\n    - For any k (1 <= k <= N-1), the sum of scores of any k problems is strictly less than the sum of scores of any k+1 problems.\n    \n    The result is returned modulo M.\n\n    Parameters:\n    - N (int): The number of problems.\n    - M (int): The prime modulo.\n\n    Returns:\n    - int: The number of ways to assign scores modulo M.\n    \"\"\"\n    A = list(range(1, N // 2 + 1)) * 2\n    if N & 1:\n        A += [(N + 1) // 2]\n    d = [-1] + [0] * (N + N)\n    for x in A:\n        for i in range(N + 1):\n            d[i] %= M\n            d[i + x] += d[i]\n    return sum(d[:N]) % M"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "d = [1] + [0] * (N + N)",
      "mutated_line": "d = [1] + [0] * (N - N)",
      "code": "def count_score_assignments(N: int, M: int) -> int:\n    \"\"\"\n    Calculate the number of ways to assign scores to N problems such that:\n    - Each problem i gets an integer score A_i between 1 and N, inclusive.\n    - The problems are sorted by difficulty: A_1 <= A_2 <= ... <= A_N.\n    - For any k (1 <= k <= N-1), the sum of scores of any k problems is strictly less than the sum of scores of any k+1 problems.\n    \n    The result is returned modulo M.\n\n    Parameters:\n    - N (int): The number of problems.\n    - M (int): The prime modulo.\n\n    Returns:\n    - int: The number of ways to assign scores modulo M.\n    \"\"\"\n    A = list(range(1, N // 2 + 1)) * 2\n    if N & 1:\n        A += [(N + 1) // 2]\n    d = [1] + [0] * (N - N)\n    for x in A:\n        for i in range(N + 1):\n            d[i] %= M\n            d[i + x] += d[i]\n    return sum(d[:N]) % M"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "d = [1] + [0] * (N + N)",
      "mutated_line": "d = [1] + [0] * (N * N)",
      "code": "def count_score_assignments(N: int, M: int) -> int:\n    \"\"\"\n    Calculate the number of ways to assign scores to N problems such that:\n    - Each problem i gets an integer score A_i between 1 and N, inclusive.\n    - The problems are sorted by difficulty: A_1 <= A_2 <= ... <= A_N.\n    - For any k (1 <= k <= N-1), the sum of scores of any k problems is strictly less than the sum of scores of any k+1 problems.\n    \n    The result is returned modulo M.\n\n    Parameters:\n    - N (int): The number of problems.\n    - M (int): The prime modulo.\n\n    Returns:\n    - int: The number of ways to assign scores modulo M.\n    \"\"\"\n    A = list(range(1, N // 2 + 1)) * 2\n    if N & 1:\n        A += [(N + 1) // 2]\n    d = [1] + [0] * (N * N)\n    for x in A:\n        for i in range(N + 1):\n            d[i] %= M\n            d[i + x] += d[i]\n    return sum(d[:N]) % M"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "for i in range(N + 1):",
      "mutated_line": "for i in range(N - 1):",
      "code": "def count_score_assignments(N: int, M: int) -> int:\n    \"\"\"\n    Calculate the number of ways to assign scores to N problems such that:\n    - Each problem i gets an integer score A_i between 1 and N, inclusive.\n    - The problems are sorted by difficulty: A_1 <= A_2 <= ... <= A_N.\n    - For any k (1 <= k <= N-1), the sum of scores of any k problems is strictly less than the sum of scores of any k+1 problems.\n    \n    The result is returned modulo M.\n\n    Parameters:\n    - N (int): The number of problems.\n    - M (int): The prime modulo.\n\n    Returns:\n    - int: The number of ways to assign scores modulo M.\n    \"\"\"\n    A = list(range(1, N // 2 + 1)) * 2\n    if N & 1:\n        A += [(N + 1) // 2]\n    d = [1] + [0] * (N + N)\n    for x in A:\n        for i in range(N - 1):\n            d[i] %= M\n            d[i + x] += d[i]\n    return sum(d[:N]) % M"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "for i in range(N + 1):",
      "mutated_line": "for i in range(N * 1):",
      "code": "def count_score_assignments(N: int, M: int) -> int:\n    \"\"\"\n    Calculate the number of ways to assign scores to N problems such that:\n    - Each problem i gets an integer score A_i between 1 and N, inclusive.\n    - The problems are sorted by difficulty: A_1 <= A_2 <= ... <= A_N.\n    - For any k (1 <= k <= N-1), the sum of scores of any k problems is strictly less than the sum of scores of any k+1 problems.\n    \n    The result is returned modulo M.\n\n    Parameters:\n    - N (int): The number of problems.\n    - M (int): The prime modulo.\n\n    Returns:\n    - int: The number of ways to assign scores modulo M.\n    \"\"\"\n    A = list(range(1, N // 2 + 1)) * 2\n    if N & 1:\n        A += [(N + 1) // 2]\n    d = [1] + [0] * (N + N)\n    for x in A:\n        for i in range(N * 1):\n            d[i] %= M\n            d[i + x] += d[i]\n    return sum(d[:N]) % M"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "A = list(range(1, N // 2 + 1)) * 2",
      "mutated_line": "A = list(range(2, N // 2 + 1)) * 2",
      "code": "def count_score_assignments(N: int, M: int) -> int:\n    \"\"\"\n    Calculate the number of ways to assign scores to N problems such that:\n    - Each problem i gets an integer score A_i between 1 and N, inclusive.\n    - The problems are sorted by difficulty: A_1 <= A_2 <= ... <= A_N.\n    - For any k (1 <= k <= N-1), the sum of scores of any k problems is strictly less than the sum of scores of any k+1 problems.\n    \n    The result is returned modulo M.\n\n    Parameters:\n    - N (int): The number of problems.\n    - M (int): The prime modulo.\n\n    Returns:\n    - int: The number of ways to assign scores modulo M.\n    \"\"\"\n    A = list(range(2, N // 2 + 1)) * 2\n    if N & 1:\n        A += [(N + 1) // 2]\n    d = [1] + [0] * (N + N)\n    for x in A:\n        for i in range(N + 1):\n            d[i] %= M\n            d[i + x] += d[i]\n    return sum(d[:N]) % M"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "A = list(range(1, N // 2 + 1)) * 2",
      "mutated_line": "A = list(range(0, N // 2 + 1)) * 2",
      "code": "def count_score_assignments(N: int, M: int) -> int:\n    \"\"\"\n    Calculate the number of ways to assign scores to N problems such that:\n    - Each problem i gets an integer score A_i between 1 and N, inclusive.\n    - The problems are sorted by difficulty: A_1 <= A_2 <= ... <= A_N.\n    - For any k (1 <= k <= N-1), the sum of scores of any k problems is strictly less than the sum of scores of any k+1 problems.\n    \n    The result is returned modulo M.\n\n    Parameters:\n    - N (int): The number of problems.\n    - M (int): The prime modulo.\n\n    Returns:\n    - int: The number of ways to assign scores modulo M.\n    \"\"\"\n    A = list(range(0, N // 2 + 1)) * 2\n    if N & 1:\n        A += [(N + 1) // 2]\n    d = [1] + [0] * (N + N)\n    for x in A:\n        for i in range(N + 1):\n            d[i] %= M\n            d[i + x] += d[i]\n    return sum(d[:N]) % M"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "A = list(range(1, N // 2 + 1)) * 2",
      "mutated_line": "A = list(range(0, N // 2 + 1)) * 2",
      "code": "def count_score_assignments(N: int, M: int) -> int:\n    \"\"\"\n    Calculate the number of ways to assign scores to N problems such that:\n    - Each problem i gets an integer score A_i between 1 and N, inclusive.\n    - The problems are sorted by difficulty: A_1 <= A_2 <= ... <= A_N.\n    - For any k (1 <= k <= N-1), the sum of scores of any k problems is strictly less than the sum of scores of any k+1 problems.\n    \n    The result is returned modulo M.\n\n    Parameters:\n    - N (int): The number of problems.\n    - M (int): The prime modulo.\n\n    Returns:\n    - int: The number of ways to assign scores modulo M.\n    \"\"\"\n    A = list(range(0, N // 2 + 1)) * 2\n    if N & 1:\n        A += [(N + 1) // 2]\n    d = [1] + [0] * (N + N)\n    for x in A:\n        for i in range(N + 1):\n            d[i] %= M\n            d[i + x] += d[i]\n    return sum(d[:N]) % M"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "A = list(range(1, N // 2 + 1)) * 2",
      "mutated_line": "A = list(range(-1, N // 2 + 1)) * 2",
      "code": "def count_score_assignments(N: int, M: int) -> int:\n    \"\"\"\n    Calculate the number of ways to assign scores to N problems such that:\n    - Each problem i gets an integer score A_i between 1 and N, inclusive.\n    - The problems are sorted by difficulty: A_1 <= A_2 <= ... <= A_N.\n    - For any k (1 <= k <= N-1), the sum of scores of any k problems is strictly less than the sum of scores of any k+1 problems.\n    \n    The result is returned modulo M.\n\n    Parameters:\n    - N (int): The number of problems.\n    - M (int): The prime modulo.\n\n    Returns:\n    - int: The number of ways to assign scores modulo M.\n    \"\"\"\n    A = list(range(-1, N // 2 + 1)) * 2\n    if N & 1:\n        A += [(N + 1) // 2]\n    d = [1] + [0] * (N + N)\n    for x in A:\n        for i in range(N + 1):\n            d[i] %= M\n            d[i + x] += d[i]\n    return sum(d[:N]) % M"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "A = list(range(1, N // 2 + 1)) * 2",
      "mutated_line": "A = list(range(1, N // 2 - 1)) * 2",
      "code": "def count_score_assignments(N: int, M: int) -> int:\n    \"\"\"\n    Calculate the number of ways to assign scores to N problems such that:\n    - Each problem i gets an integer score A_i between 1 and N, inclusive.\n    - The problems are sorted by difficulty: A_1 <= A_2 <= ... <= A_N.\n    - For any k (1 <= k <= N-1), the sum of scores of any k problems is strictly less than the sum of scores of any k+1 problems.\n    \n    The result is returned modulo M.\n\n    Parameters:\n    - N (int): The number of problems.\n    - M (int): The prime modulo.\n\n    Returns:\n    - int: The number of ways to assign scores modulo M.\n    \"\"\"\n    A = list(range(1, N // 2 - 1)) * 2\n    if N & 1:\n        A += [(N + 1) // 2]\n    d = [1] + [0] * (N + N)\n    for x in A:\n        for i in range(N + 1):\n            d[i] %= M\n            d[i + x] += d[i]\n    return sum(d[:N]) % M"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "A = list(range(1, N // 2 + 1)) * 2",
      "mutated_line": "A = list(range(1, N // 2 * 1)) * 2",
      "code": "def count_score_assignments(N: int, M: int) -> int:\n    \"\"\"\n    Calculate the number of ways to assign scores to N problems such that:\n    - Each problem i gets an integer score A_i between 1 and N, inclusive.\n    - The problems are sorted by difficulty: A_1 <= A_2 <= ... <= A_N.\n    - For any k (1 <= k <= N-1), the sum of scores of any k problems is strictly less than the sum of scores of any k+1 problems.\n    \n    The result is returned modulo M.\n\n    Parameters:\n    - N (int): The number of problems.\n    - M (int): The prime modulo.\n\n    Returns:\n    - int: The number of ways to assign scores modulo M.\n    \"\"\"\n    A = list(range(1, N // 2 * 1)) * 2\n    if N & 1:\n        A += [(N + 1) // 2]\n    d = [1] + [0] * (N + N)\n    for x in A:\n        for i in range(N + 1):\n            d[i] %= M\n            d[i + x] += d[i]\n    return sum(d[:N]) % M"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "A += [(N + 1) // 2]",
      "mutated_line": "A += [(N - 1) // 2]",
      "code": "def count_score_assignments(N: int, M: int) -> int:\n    \"\"\"\n    Calculate the number of ways to assign scores to N problems such that:\n    - Each problem i gets an integer score A_i between 1 and N, inclusive.\n    - The problems are sorted by difficulty: A_1 <= A_2 <= ... <= A_N.\n    - For any k (1 <= k <= N-1), the sum of scores of any k problems is strictly less than the sum of scores of any k+1 problems.\n    \n    The result is returned modulo M.\n\n    Parameters:\n    - N (int): The number of problems.\n    - M (int): The prime modulo.\n\n    Returns:\n    - int: The number of ways to assign scores modulo M.\n    \"\"\"\n    A = list(range(1, N // 2 + 1)) * 2\n    if N & 1:\n        A += [(N - 1) // 2]\n    d = [1] + [0] * (N + N)\n    for x in A:\n        for i in range(N + 1):\n            d[i] %= M\n            d[i + x] += d[i]\n    return sum(d[:N]) % M"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "A += [(N + 1) // 2]",
      "mutated_line": "A += [N * 1 // 2]",
      "code": "def count_score_assignments(N: int, M: int) -> int:\n    \"\"\"\n    Calculate the number of ways to assign scores to N problems such that:\n    - Each problem i gets an integer score A_i between 1 and N, inclusive.\n    - The problems are sorted by difficulty: A_1 <= A_2 <= ... <= A_N.\n    - For any k (1 <= k <= N-1), the sum of scores of any k problems is strictly less than the sum of scores of any k+1 problems.\n    \n    The result is returned modulo M.\n\n    Parameters:\n    - N (int): The number of problems.\n    - M (int): The prime modulo.\n\n    Returns:\n    - int: The number of ways to assign scores modulo M.\n    \"\"\"\n    A = list(range(1, N // 2 + 1)) * 2\n    if N & 1:\n        A += [N * 1 // 2]\n    d = [1] + [0] * (N + N)\n    for x in A:\n        for i in range(N + 1):\n            d[i] %= M\n            d[i + x] += d[i]\n    return sum(d[:N]) % M"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "A += [(N + 1) // 2]",
      "mutated_line": "A += [(N + 1) // 3]",
      "code": "def count_score_assignments(N: int, M: int) -> int:\n    \"\"\"\n    Calculate the number of ways to assign scores to N problems such that:\n    - Each problem i gets an integer score A_i between 1 and N, inclusive.\n    - The problems are sorted by difficulty: A_1 <= A_2 <= ... <= A_N.\n    - For any k (1 <= k <= N-1), the sum of scores of any k problems is strictly less than the sum of scores of any k+1 problems.\n    \n    The result is returned modulo M.\n\n    Parameters:\n    - N (int): The number of problems.\n    - M (int): The prime modulo.\n\n    Returns:\n    - int: The number of ways to assign scores modulo M.\n    \"\"\"\n    A = list(range(1, N // 2 + 1)) * 2\n    if N & 1:\n        A += [(N + 1) // 3]\n    d = [1] + [0] * (N + N)\n    for x in A:\n        for i in range(N + 1):\n            d[i] %= M\n            d[i + x] += d[i]\n    return sum(d[:N]) % M"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "A += [(N + 1) // 2]",
      "mutated_line": "A += [(N + 1) // 1]",
      "code": "def count_score_assignments(N: int, M: int) -> int:\n    \"\"\"\n    Calculate the number of ways to assign scores to N problems such that:\n    - Each problem i gets an integer score A_i between 1 and N, inclusive.\n    - The problems are sorted by difficulty: A_1 <= A_2 <= ... <= A_N.\n    - For any k (1 <= k <= N-1), the sum of scores of any k problems is strictly less than the sum of scores of any k+1 problems.\n    \n    The result is returned modulo M.\n\n    Parameters:\n    - N (int): The number of problems.\n    - M (int): The prime modulo.\n\n    Returns:\n    - int: The number of ways to assign scores modulo M.\n    \"\"\"\n    A = list(range(1, N // 2 + 1)) * 2\n    if N & 1:\n        A += [(N + 1) // 1]\n    d = [1] + [0] * (N + N)\n    for x in A:\n        for i in range(N + 1):\n            d[i] %= M\n            d[i + x] += d[i]\n    return sum(d[:N]) % M"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "A += [(N + 1) // 2]",
      "mutated_line": "A += [(N + 1) // 0]",
      "code": "def count_score_assignments(N: int, M: int) -> int:\n    \"\"\"\n    Calculate the number of ways to assign scores to N problems such that:\n    - Each problem i gets an integer score A_i between 1 and N, inclusive.\n    - The problems are sorted by difficulty: A_1 <= A_2 <= ... <= A_N.\n    - For any k (1 <= k <= N-1), the sum of scores of any k problems is strictly less than the sum of scores of any k+1 problems.\n    \n    The result is returned modulo M.\n\n    Parameters:\n    - N (int): The number of problems.\n    - M (int): The prime modulo.\n\n    Returns:\n    - int: The number of ways to assign scores modulo M.\n    \"\"\"\n    A = list(range(1, N // 2 + 1)) * 2\n    if N & 1:\n        A += [(N + 1) // 0]\n    d = [1] + [0] * (N + N)\n    for x in A:\n        for i in range(N + 1):\n            d[i] %= M\n            d[i + x] += d[i]\n    return sum(d[:N]) % M"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "A += [(N + 1) // 2]",
      "mutated_line": "A += [(N + 1) // 1]",
      "code": "def count_score_assignments(N: int, M: int) -> int:\n    \"\"\"\n    Calculate the number of ways to assign scores to N problems such that:\n    - Each problem i gets an integer score A_i between 1 and N, inclusive.\n    - The problems are sorted by difficulty: A_1 <= A_2 <= ... <= A_N.\n    - For any k (1 <= k <= N-1), the sum of scores of any k problems is strictly less than the sum of scores of any k+1 problems.\n    \n    The result is returned modulo M.\n\n    Parameters:\n    - N (int): The number of problems.\n    - M (int): The prime modulo.\n\n    Returns:\n    - int: The number of ways to assign scores modulo M.\n    \"\"\"\n    A = list(range(1, N // 2 + 1)) * 2\n    if N & 1:\n        A += [(N + 1) // 1]\n    d = [1] + [0] * (N + N)\n    for x in A:\n        for i in range(N + 1):\n            d[i] %= M\n            d[i + x] += d[i]\n    return sum(d[:N]) % M"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "A += [(N + 1) // 2]",
      "mutated_line": "A += [(N + 1) // -2]",
      "code": "def count_score_assignments(N: int, M: int) -> int:\n    \"\"\"\n    Calculate the number of ways to assign scores to N problems such that:\n    - Each problem i gets an integer score A_i between 1 and N, inclusive.\n    - The problems are sorted by difficulty: A_1 <= A_2 <= ... <= A_N.\n    - For any k (1 <= k <= N-1), the sum of scores of any k problems is strictly less than the sum of scores of any k+1 problems.\n    \n    The result is returned modulo M.\n\n    Parameters:\n    - N (int): The number of problems.\n    - M (int): The prime modulo.\n\n    Returns:\n    - int: The number of ways to assign scores modulo M.\n    \"\"\"\n    A = list(range(1, N // 2 + 1)) * 2\n    if N & 1:\n        A += [(N + 1) // -2]\n    d = [1] + [0] * (N + N)\n    for x in A:\n        for i in range(N + 1):\n            d[i] %= M\n            d[i + x] += d[i]\n    return sum(d[:N]) % M"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "d = [1] + [0] * (N + N)",
      "mutated_line": "d = [1] + [1] * (N + N)",
      "code": "def count_score_assignments(N: int, M: int) -> int:\n    \"\"\"\n    Calculate the number of ways to assign scores to N problems such that:\n    - Each problem i gets an integer score A_i between 1 and N, inclusive.\n    - The problems are sorted by difficulty: A_1 <= A_2 <= ... <= A_N.\n    - For any k (1 <= k <= N-1), the sum of scores of any k problems is strictly less than the sum of scores of any k+1 problems.\n    \n    The result is returned modulo M.\n\n    Parameters:\n    - N (int): The number of problems.\n    - M (int): The prime modulo.\n\n    Returns:\n    - int: The number of ways to assign scores modulo M.\n    \"\"\"\n    A = list(range(1, N // 2 + 1)) * 2\n    if N & 1:\n        A += [(N + 1) // 2]\n    d = [1] + [1] * (N + N)\n    for x in A:\n        for i in range(N + 1):\n            d[i] %= M\n            d[i + x] += d[i]\n    return sum(d[:N]) % M"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "d = [1] + [0] * (N + N)",
      "mutated_line": "d = [1] + [-1] * (N + N)",
      "code": "def count_score_assignments(N: int, M: int) -> int:\n    \"\"\"\n    Calculate the number of ways to assign scores to N problems such that:\n    - Each problem i gets an integer score A_i between 1 and N, inclusive.\n    - The problems are sorted by difficulty: A_1 <= A_2 <= ... <= A_N.\n    - For any k (1 <= k <= N-1), the sum of scores of any k problems is strictly less than the sum of scores of any k+1 problems.\n    \n    The result is returned modulo M.\n\n    Parameters:\n    - N (int): The number of problems.\n    - M (int): The prime modulo.\n\n    Returns:\n    - int: The number of ways to assign scores modulo M.\n    \"\"\"\n    A = list(range(1, N // 2 + 1)) * 2\n    if N & 1:\n        A += [(N + 1) // 2]\n    d = [1] + [-1] * (N + N)\n    for x in A:\n        for i in range(N + 1):\n            d[i] %= M\n            d[i + x] += d[i]\n    return sum(d[:N]) % M"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "d = [1] + [0] * (N + N)",
      "mutated_line": "d = [1] + [1] * (N + N)",
      "code": "def count_score_assignments(N: int, M: int) -> int:\n    \"\"\"\n    Calculate the number of ways to assign scores to N problems such that:\n    - Each problem i gets an integer score A_i between 1 and N, inclusive.\n    - The problems are sorted by difficulty: A_1 <= A_2 <= ... <= A_N.\n    - For any k (1 <= k <= N-1), the sum of scores of any k problems is strictly less than the sum of scores of any k+1 problems.\n    \n    The result is returned modulo M.\n\n    Parameters:\n    - N (int): The number of problems.\n    - M (int): The prime modulo.\n\n    Returns:\n    - int: The number of ways to assign scores modulo M.\n    \"\"\"\n    A = list(range(1, N // 2 + 1)) * 2\n    if N & 1:\n        A += [(N + 1) // 2]\n    d = [1] + [1] * (N + N)\n    for x in A:\n        for i in range(N + 1):\n            d[i] %= M\n            d[i + x] += d[i]\n    return sum(d[:N]) % M"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(N + 1):",
      "mutated_line": "for i in range(N + 2):",
      "code": "def count_score_assignments(N: int, M: int) -> int:\n    \"\"\"\n    Calculate the number of ways to assign scores to N problems such that:\n    - Each problem i gets an integer score A_i between 1 and N, inclusive.\n    - The problems are sorted by difficulty: A_1 <= A_2 <= ... <= A_N.\n    - For any k (1 <= k <= N-1), the sum of scores of any k problems is strictly less than the sum of scores of any k+1 problems.\n    \n    The result is returned modulo M.\n\n    Parameters:\n    - N (int): The number of problems.\n    - M (int): The prime modulo.\n\n    Returns:\n    - int: The number of ways to assign scores modulo M.\n    \"\"\"\n    A = list(range(1, N // 2 + 1)) * 2\n    if N & 1:\n        A += [(N + 1) // 2]\n    d = [1] + [0] * (N + N)\n    for x in A:\n        for i in range(N + 2):\n            d[i] %= M\n            d[i + x] += d[i]\n    return sum(d[:N]) % M"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(N + 1):",
      "mutated_line": "for i in range(N + 0):",
      "code": "def count_score_assignments(N: int, M: int) -> int:\n    \"\"\"\n    Calculate the number of ways to assign scores to N problems such that:\n    - Each problem i gets an integer score A_i between 1 and N, inclusive.\n    - The problems are sorted by difficulty: A_1 <= A_2 <= ... <= A_N.\n    - For any k (1 <= k <= N-1), the sum of scores of any k problems is strictly less than the sum of scores of any k+1 problems.\n    \n    The result is returned modulo M.\n\n    Parameters:\n    - N (int): The number of problems.\n    - M (int): The prime modulo.\n\n    Returns:\n    - int: The number of ways to assign scores modulo M.\n    \"\"\"\n    A = list(range(1, N // 2 + 1)) * 2\n    if N & 1:\n        A += [(N + 1) // 2]\n    d = [1] + [0] * (N + N)\n    for x in A:\n        for i in range(N + 0):\n            d[i] %= M\n            d[i + x] += d[i]\n    return sum(d[:N]) % M"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(N + 1):",
      "mutated_line": "for i in range(N + 0):",
      "code": "def count_score_assignments(N: int, M: int) -> int:\n    \"\"\"\n    Calculate the number of ways to assign scores to N problems such that:\n    - Each problem i gets an integer score A_i between 1 and N, inclusive.\n    - The problems are sorted by difficulty: A_1 <= A_2 <= ... <= A_N.\n    - For any k (1 <= k <= N-1), the sum of scores of any k problems is strictly less than the sum of scores of any k+1 problems.\n    \n    The result is returned modulo M.\n\n    Parameters:\n    - N (int): The number of problems.\n    - M (int): The prime modulo.\n\n    Returns:\n    - int: The number of ways to assign scores modulo M.\n    \"\"\"\n    A = list(range(1, N // 2 + 1)) * 2\n    if N & 1:\n        A += [(N + 1) // 2]\n    d = [1] + [0] * (N + N)\n    for x in A:\n        for i in range(N + 0):\n            d[i] %= M\n            d[i + x] += d[i]\n    return sum(d[:N]) % M"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(N + 1):",
      "mutated_line": "for i in range(N + -1):",
      "code": "def count_score_assignments(N: int, M: int) -> int:\n    \"\"\"\n    Calculate the number of ways to assign scores to N problems such that:\n    - Each problem i gets an integer score A_i between 1 and N, inclusive.\n    - The problems are sorted by difficulty: A_1 <= A_2 <= ... <= A_N.\n    - For any k (1 <= k <= N-1), the sum of scores of any k problems is strictly less than the sum of scores of any k+1 problems.\n    \n    The result is returned modulo M.\n\n    Parameters:\n    - N (int): The number of problems.\n    - M (int): The prime modulo.\n\n    Returns:\n    - int: The number of ways to assign scores modulo M.\n    \"\"\"\n    A = list(range(1, N // 2 + 1)) * 2\n    if N & 1:\n        A += [(N + 1) // 2]\n    d = [1] + [0] * (N + N)\n    for x in A:\n        for i in range(N + -1):\n            d[i] %= M\n            d[i + x] += d[i]\n    return sum(d[:N]) % M"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "d[i + x] += d[i]",
      "mutated_line": "d[i - x] += d[i]",
      "code": "def count_score_assignments(N: int, M: int) -> int:\n    \"\"\"\n    Calculate the number of ways to assign scores to N problems such that:\n    - Each problem i gets an integer score A_i between 1 and N, inclusive.\n    - The problems are sorted by difficulty: A_1 <= A_2 <= ... <= A_N.\n    - For any k (1 <= k <= N-1), the sum of scores of any k problems is strictly less than the sum of scores of any k+1 problems.\n    \n    The result is returned modulo M.\n\n    Parameters:\n    - N (int): The number of problems.\n    - M (int): The prime modulo.\n\n    Returns:\n    - int: The number of ways to assign scores modulo M.\n    \"\"\"\n    A = list(range(1, N // 2 + 1)) * 2\n    if N & 1:\n        A += [(N + 1) // 2]\n    d = [1] + [0] * (N + N)\n    for x in A:\n        for i in range(N + 1):\n            d[i] %= M\n            d[i - x] += d[i]\n    return sum(d[:N]) % M"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "d[i + x] += d[i]",
      "mutated_line": "d[i * x] += d[i]",
      "code": "def count_score_assignments(N: int, M: int) -> int:\n    \"\"\"\n    Calculate the number of ways to assign scores to N problems such that:\n    - Each problem i gets an integer score A_i between 1 and N, inclusive.\n    - The problems are sorted by difficulty: A_1 <= A_2 <= ... <= A_N.\n    - For any k (1 <= k <= N-1), the sum of scores of any k problems is strictly less than the sum of scores of any k+1 problems.\n    \n    The result is returned modulo M.\n\n    Parameters:\n    - N (int): The number of problems.\n    - M (int): The prime modulo.\n\n    Returns:\n    - int: The number of ways to assign scores modulo M.\n    \"\"\"\n    A = list(range(1, N // 2 + 1)) * 2\n    if N & 1:\n        A += [(N + 1) // 2]\n    d = [1] + [0] * (N + N)\n    for x in A:\n        for i in range(N + 1):\n            d[i] %= M\n            d[i * x] += d[i]\n    return sum(d[:N]) % M"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "A = list(range(1, N // 2 + 1)) * 2",
      "mutated_line": "A = list(range(1, N / 2 + 1)) * 2",
      "code": "def count_score_assignments(N: int, M: int) -> int:\n    \"\"\"\n    Calculate the number of ways to assign scores to N problems such that:\n    - Each problem i gets an integer score A_i between 1 and N, inclusive.\n    - The problems are sorted by difficulty: A_1 <= A_2 <= ... <= A_N.\n    - For any k (1 <= k <= N-1), the sum of scores of any k problems is strictly less than the sum of scores of any k+1 problems.\n    \n    The result is returned modulo M.\n\n    Parameters:\n    - N (int): The number of problems.\n    - M (int): The prime modulo.\n\n    Returns:\n    - int: The number of ways to assign scores modulo M.\n    \"\"\"\n    A = list(range(1, N / 2 + 1)) * 2\n    if N & 1:\n        A += [(N + 1) // 2]\n    d = [1] + [0] * (N + N)\n    for x in A:\n        for i in range(N + 1):\n            d[i] %= M\n            d[i + x] += d[i]\n    return sum(d[:N]) % M"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "A = list(range(1, N // 2 + 1)) * 2",
      "mutated_line": "A = list(range(1, N * 2 + 1)) * 2",
      "code": "def count_score_assignments(N: int, M: int) -> int:\n    \"\"\"\n    Calculate the number of ways to assign scores to N problems such that:\n    - Each problem i gets an integer score A_i between 1 and N, inclusive.\n    - The problems are sorted by difficulty: A_1 <= A_2 <= ... <= A_N.\n    - For any k (1 <= k <= N-1), the sum of scores of any k problems is strictly less than the sum of scores of any k+1 problems.\n    \n    The result is returned modulo M.\n\n    Parameters:\n    - N (int): The number of problems.\n    - M (int): The prime modulo.\n\n    Returns:\n    - int: The number of ways to assign scores modulo M.\n    \"\"\"\n    A = list(range(1, N * 2 + 1)) * 2\n    if N & 1:\n        A += [(N + 1) // 2]\n    d = [1] + [0] * (N + N)\n    for x in A:\n        for i in range(N + 1):\n            d[i] %= M\n            d[i + x] += d[i]\n    return sum(d[:N]) % M"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "A = list(range(1, N // 2 + 1)) * 2",
      "mutated_line": "A = list(range(1, N // 2 + 2)) * 2",
      "code": "def count_score_assignments(N: int, M: int) -> int:\n    \"\"\"\n    Calculate the number of ways to assign scores to N problems such that:\n    - Each problem i gets an integer score A_i between 1 and N, inclusive.\n    - The problems are sorted by difficulty: A_1 <= A_2 <= ... <= A_N.\n    - For any k (1 <= k <= N-1), the sum of scores of any k problems is strictly less than the sum of scores of any k+1 problems.\n    \n    The result is returned modulo M.\n\n    Parameters:\n    - N (int): The number of problems.\n    - M (int): The prime modulo.\n\n    Returns:\n    - int: The number of ways to assign scores modulo M.\n    \"\"\"\n    A = list(range(1, N // 2 + 2)) * 2\n    if N & 1:\n        A += [(N + 1) // 2]\n    d = [1] + [0] * (N + N)\n    for x in A:\n        for i in range(N + 1):\n            d[i] %= M\n            d[i + x] += d[i]\n    return sum(d[:N]) % M"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "A = list(range(1, N // 2 + 1)) * 2",
      "mutated_line": "A = list(range(1, N // 2 + 0)) * 2",
      "code": "def count_score_assignments(N: int, M: int) -> int:\n    \"\"\"\n    Calculate the number of ways to assign scores to N problems such that:\n    - Each problem i gets an integer score A_i between 1 and N, inclusive.\n    - The problems are sorted by difficulty: A_1 <= A_2 <= ... <= A_N.\n    - For any k (1 <= k <= N-1), the sum of scores of any k problems is strictly less than the sum of scores of any k+1 problems.\n    \n    The result is returned modulo M.\n\n    Parameters:\n    - N (int): The number of problems.\n    - M (int): The prime modulo.\n\n    Returns:\n    - int: The number of ways to assign scores modulo M.\n    \"\"\"\n    A = list(range(1, N // 2 + 0)) * 2\n    if N & 1:\n        A += [(N + 1) // 2]\n    d = [1] + [0] * (N + N)\n    for x in A:\n        for i in range(N + 1):\n            d[i] %= M\n            d[i + x] += d[i]\n    return sum(d[:N]) % M"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "A = list(range(1, N // 2 + 1)) * 2",
      "mutated_line": "A = list(range(1, N // 2 + 0)) * 2",
      "code": "def count_score_assignments(N: int, M: int) -> int:\n    \"\"\"\n    Calculate the number of ways to assign scores to N problems such that:\n    - Each problem i gets an integer score A_i between 1 and N, inclusive.\n    - The problems are sorted by difficulty: A_1 <= A_2 <= ... <= A_N.\n    - For any k (1 <= k <= N-1), the sum of scores of any k problems is strictly less than the sum of scores of any k+1 problems.\n    \n    The result is returned modulo M.\n\n    Parameters:\n    - N (int): The number of problems.\n    - M (int): The prime modulo.\n\n    Returns:\n    - int: The number of ways to assign scores modulo M.\n    \"\"\"\n    A = list(range(1, N // 2 + 0)) * 2\n    if N & 1:\n        A += [(N + 1) // 2]\n    d = [1] + [0] * (N + N)\n    for x in A:\n        for i in range(N + 1):\n            d[i] %= M\n            d[i + x] += d[i]\n    return sum(d[:N]) % M"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "A = list(range(1, N // 2 + 1)) * 2",
      "mutated_line": "A = list(range(1, N // 2 + -1)) * 2",
      "code": "def count_score_assignments(N: int, M: int) -> int:\n    \"\"\"\n    Calculate the number of ways to assign scores to N problems such that:\n    - Each problem i gets an integer score A_i between 1 and N, inclusive.\n    - The problems are sorted by difficulty: A_1 <= A_2 <= ... <= A_N.\n    - For any k (1 <= k <= N-1), the sum of scores of any k problems is strictly less than the sum of scores of any k+1 problems.\n    \n    The result is returned modulo M.\n\n    Parameters:\n    - N (int): The number of problems.\n    - M (int): The prime modulo.\n\n    Returns:\n    - int: The number of ways to assign scores modulo M.\n    \"\"\"\n    A = list(range(1, N // 2 + -1)) * 2\n    if N & 1:\n        A += [(N + 1) // 2]\n    d = [1] + [0] * (N + N)\n    for x in A:\n        for i in range(N + 1):\n            d[i] %= M\n            d[i + x] += d[i]\n    return sum(d[:N]) % M"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "A += [(N + 1) // 2]",
      "mutated_line": "A += [(N + 2) // 2]",
      "code": "def count_score_assignments(N: int, M: int) -> int:\n    \"\"\"\n    Calculate the number of ways to assign scores to N problems such that:\n    - Each problem i gets an integer score A_i between 1 and N, inclusive.\n    - The problems are sorted by difficulty: A_1 <= A_2 <= ... <= A_N.\n    - For any k (1 <= k <= N-1), the sum of scores of any k problems is strictly less than the sum of scores of any k+1 problems.\n    \n    The result is returned modulo M.\n\n    Parameters:\n    - N (int): The number of problems.\n    - M (int): The prime modulo.\n\n    Returns:\n    - int: The number of ways to assign scores modulo M.\n    \"\"\"\n    A = list(range(1, N // 2 + 1)) * 2\n    if N & 1:\n        A += [(N + 2) // 2]\n    d = [1] + [0] * (N + N)\n    for x in A:\n        for i in range(N + 1):\n            d[i] %= M\n            d[i + x] += d[i]\n    return sum(d[:N]) % M"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "A += [(N + 1) // 2]",
      "mutated_line": "A += [(N + 0) // 2]",
      "code": "def count_score_assignments(N: int, M: int) -> int:\n    \"\"\"\n    Calculate the number of ways to assign scores to N problems such that:\n    - Each problem i gets an integer score A_i between 1 and N, inclusive.\n    - The problems are sorted by difficulty: A_1 <= A_2 <= ... <= A_N.\n    - For any k (1 <= k <= N-1), the sum of scores of any k problems is strictly less than the sum of scores of any k+1 problems.\n    \n    The result is returned modulo M.\n\n    Parameters:\n    - N (int): The number of problems.\n    - M (int): The prime modulo.\n\n    Returns:\n    - int: The number of ways to assign scores modulo M.\n    \"\"\"\n    A = list(range(1, N // 2 + 1)) * 2\n    if N & 1:\n        A += [(N + 0) // 2]\n    d = [1] + [0] * (N + N)\n    for x in A:\n        for i in range(N + 1):\n            d[i] %= M\n            d[i + x] += d[i]\n    return sum(d[:N]) % M"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "A += [(N + 1) // 2]",
      "mutated_line": "A += [(N + 0) // 2]",
      "code": "def count_score_assignments(N: int, M: int) -> int:\n    \"\"\"\n    Calculate the number of ways to assign scores to N problems such that:\n    - Each problem i gets an integer score A_i between 1 and N, inclusive.\n    - The problems are sorted by difficulty: A_1 <= A_2 <= ... <= A_N.\n    - For any k (1 <= k <= N-1), the sum of scores of any k problems is strictly less than the sum of scores of any k+1 problems.\n    \n    The result is returned modulo M.\n\n    Parameters:\n    - N (int): The number of problems.\n    - M (int): The prime modulo.\n\n    Returns:\n    - int: The number of ways to assign scores modulo M.\n    \"\"\"\n    A = list(range(1, N // 2 + 1)) * 2\n    if N & 1:\n        A += [(N + 0) // 2]\n    d = [1] + [0] * (N + N)\n    for x in A:\n        for i in range(N + 1):\n            d[i] %= M\n            d[i + x] += d[i]\n    return sum(d[:N]) % M"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "A += [(N + 1) // 2]",
      "mutated_line": "A += [(N + -1) // 2]",
      "code": "def count_score_assignments(N: int, M: int) -> int:\n    \"\"\"\n    Calculate the number of ways to assign scores to N problems such that:\n    - Each problem i gets an integer score A_i between 1 and N, inclusive.\n    - The problems are sorted by difficulty: A_1 <= A_2 <= ... <= A_N.\n    - For any k (1 <= k <= N-1), the sum of scores of any k problems is strictly less than the sum of scores of any k+1 problems.\n    \n    The result is returned modulo M.\n\n    Parameters:\n    - N (int): The number of problems.\n    - M (int): The prime modulo.\n\n    Returns:\n    - int: The number of ways to assign scores modulo M.\n    \"\"\"\n    A = list(range(1, N // 2 + 1)) * 2\n    if N & 1:\n        A += [(N + -1) // 2]\n    d = [1] + [0] * (N + N)\n    for x in A:\n        for i in range(N + 1):\n            d[i] %= M\n            d[i + x] += d[i]\n    return sum(d[:N]) % M"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "A = list(range(1, N // 2 + 1)) * 2",
      "mutated_line": "A = list(range(1, N // 3 + 1)) * 2",
      "code": "def count_score_assignments(N: int, M: int) -> int:\n    \"\"\"\n    Calculate the number of ways to assign scores to N problems such that:\n    - Each problem i gets an integer score A_i between 1 and N, inclusive.\n    - The problems are sorted by difficulty: A_1 <= A_2 <= ... <= A_N.\n    - For any k (1 <= k <= N-1), the sum of scores of any k problems is strictly less than the sum of scores of any k+1 problems.\n    \n    The result is returned modulo M.\n\n    Parameters:\n    - N (int): The number of problems.\n    - M (int): The prime modulo.\n\n    Returns:\n    - int: The number of ways to assign scores modulo M.\n    \"\"\"\n    A = list(range(1, N // 3 + 1)) * 2\n    if N & 1:\n        A += [(N + 1) // 2]\n    d = [1] + [0] * (N + N)\n    for x in A:\n        for i in range(N + 1):\n            d[i] %= M\n            d[i + x] += d[i]\n    return sum(d[:N]) % M"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "A = list(range(1, N // 2 + 1)) * 2",
      "mutated_line": "A = list(range(1, N // 1 + 1)) * 2",
      "code": "def count_score_assignments(N: int, M: int) -> int:\n    \"\"\"\n    Calculate the number of ways to assign scores to N problems such that:\n    - Each problem i gets an integer score A_i between 1 and N, inclusive.\n    - The problems are sorted by difficulty: A_1 <= A_2 <= ... <= A_N.\n    - For any k (1 <= k <= N-1), the sum of scores of any k problems is strictly less than the sum of scores of any k+1 problems.\n    \n    The result is returned modulo M.\n\n    Parameters:\n    - N (int): The number of problems.\n    - M (int): The prime modulo.\n\n    Returns:\n    - int: The number of ways to assign scores modulo M.\n    \"\"\"\n    A = list(range(1, N // 1 + 1)) * 2\n    if N & 1:\n        A += [(N + 1) // 2]\n    d = [1] + [0] * (N + N)\n    for x in A:\n        for i in range(N + 1):\n            d[i] %= M\n            d[i + x] += d[i]\n    return sum(d[:N]) % M"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "A = list(range(1, N // 2 + 1)) * 2",
      "mutated_line": "A = list(range(1, N // 0 + 1)) * 2",
      "code": "def count_score_assignments(N: int, M: int) -> int:\n    \"\"\"\n    Calculate the number of ways to assign scores to N problems such that:\n    - Each problem i gets an integer score A_i between 1 and N, inclusive.\n    - The problems are sorted by difficulty: A_1 <= A_2 <= ... <= A_N.\n    - For any k (1 <= k <= N-1), the sum of scores of any k problems is strictly less than the sum of scores of any k+1 problems.\n    \n    The result is returned modulo M.\n\n    Parameters:\n    - N (int): The number of problems.\n    - M (int): The prime modulo.\n\n    Returns:\n    - int: The number of ways to assign scores modulo M.\n    \"\"\"\n    A = list(range(1, N // 0 + 1)) * 2\n    if N & 1:\n        A += [(N + 1) // 2]\n    d = [1] + [0] * (N + N)\n    for x in A:\n        for i in range(N + 1):\n            d[i] %= M\n            d[i + x] += d[i]\n    return sum(d[:N]) % M"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "A = list(range(1, N // 2 + 1)) * 2",
      "mutated_line": "A = list(range(1, N // 1 + 1)) * 2",
      "code": "def count_score_assignments(N: int, M: int) -> int:\n    \"\"\"\n    Calculate the number of ways to assign scores to N problems such that:\n    - Each problem i gets an integer score A_i between 1 and N, inclusive.\n    - The problems are sorted by difficulty: A_1 <= A_2 <= ... <= A_N.\n    - For any k (1 <= k <= N-1), the sum of scores of any k problems is strictly less than the sum of scores of any k+1 problems.\n    \n    The result is returned modulo M.\n\n    Parameters:\n    - N (int): The number of problems.\n    - M (int): The prime modulo.\n\n    Returns:\n    - int: The number of ways to assign scores modulo M.\n    \"\"\"\n    A = list(range(1, N // 1 + 1)) * 2\n    if N & 1:\n        A += [(N + 1) // 2]\n    d = [1] + [0] * (N + N)\n    for x in A:\n        for i in range(N + 1):\n            d[i] %= M\n            d[i + x] += d[i]\n    return sum(d[:N]) % M"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "A = list(range(1, N // 2 + 1)) * 2",
      "mutated_line": "A = list(range(1, N // -2 + 1)) * 2",
      "code": "def count_score_assignments(N: int, M: int) -> int:\n    \"\"\"\n    Calculate the number of ways to assign scores to N problems such that:\n    - Each problem i gets an integer score A_i between 1 and N, inclusive.\n    - The problems are sorted by difficulty: A_1 <= A_2 <= ... <= A_N.\n    - For any k (1 <= k <= N-1), the sum of scores of any k problems is strictly less than the sum of scores of any k+1 problems.\n    \n    The result is returned modulo M.\n\n    Parameters:\n    - N (int): The number of problems.\n    - M (int): The prime modulo.\n\n    Returns:\n    - int: The number of ways to assign scores modulo M.\n    \"\"\"\n    A = list(range(1, N // -2 + 1)) * 2\n    if N & 1:\n        A += [(N + 1) // 2]\n    d = [1] + [0] * (N + N)\n    for x in A:\n        for i in range(N + 1):\n            d[i] %= M\n            d[i + x] += d[i]\n    return sum(d[:N]) % M"
    }
  ]
}