{
  "task_id": "taco_14813",
  "entry_point": "find_optimal_provinces",
  "mutant_count": 51,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "visited = [False] * N",
      "mutated_line": "visited = [False] / N",
      "code": "def find_optimal_provinces(N, M, A, B, roads):\n    from collections import deque\n    adjacency_list = [[] for _ in range(N)]\n    for (u, v) in roads:\n        adjacency_list[u - 1].append(v - 1)\n        adjacency_list[v - 1].append(u - 1)\n    per_capita_income = [A[i] / B[i] for i in range(N)]\n    max_per_capita = max(per_capita_income)\n    final = []\n    visited = [False] / N\n    for i in range(N):\n        if per_capita_income[i] == max_per_capita and (not visited[i]):\n            visited[i] = True\n            temp = [i + 1]\n            queue = deque([i])\n            while queue:\n                t = queue.popleft()\n                for j in adjacency_list[t]:\n                    if per_capita_income[j] == max_per_capita and (not visited[j]):\n                        visited[j] = True\n                        temp.append(j + 1)\n                        queue.append(j)\n            if len(temp) > len(final):\n                final = temp.copy()\n    K = len(final)\n    chosen_provinces = final\n    return (K, chosen_provinces)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "visited = [False] * N",
      "mutated_line": "visited = [False] + N",
      "code": "def find_optimal_provinces(N, M, A, B, roads):\n    from collections import deque\n    adjacency_list = [[] for _ in range(N)]\n    for (u, v) in roads:\n        adjacency_list[u - 1].append(v - 1)\n        adjacency_list[v - 1].append(u - 1)\n    per_capita_income = [A[i] / B[i] for i in range(N)]\n    max_per_capita = max(per_capita_income)\n    final = []\n    visited = [False] + N\n    for i in range(N):\n        if per_capita_income[i] == max_per_capita and (not visited[i]):\n            visited[i] = True\n            temp = [i + 1]\n            queue = deque([i])\n            while queue:\n                t = queue.popleft()\n                for j in adjacency_list[t]:\n                    if per_capita_income[j] == max_per_capita and (not visited[j]):\n                        visited[j] = True\n                        temp.append(j + 1)\n                        queue.append(j)\n            if len(temp) > len(final):\n                final = temp.copy()\n    K = len(final)\n    chosen_provinces = final\n    return (K, chosen_provinces)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "visited = [False] * N",
      "mutated_line": "visited = [False] ** N",
      "code": "def find_optimal_provinces(N, M, A, B, roads):\n    from collections import deque\n    adjacency_list = [[] for _ in range(N)]\n    for (u, v) in roads:\n        adjacency_list[u - 1].append(v - 1)\n        adjacency_list[v - 1].append(u - 1)\n    per_capita_income = [A[i] / B[i] for i in range(N)]\n    max_per_capita = max(per_capita_income)\n    final = []\n    visited = [False] ** N\n    for i in range(N):\n        if per_capita_income[i] == max_per_capita and (not visited[i]):\n            visited[i] = True\n            temp = [i + 1]\n            queue = deque([i])\n            while queue:\n                t = queue.popleft()\n                for j in adjacency_list[t]:\n                    if per_capita_income[j] == max_per_capita and (not visited[j]):\n                        visited[j] = True\n                        temp.append(j + 1)\n                        queue.append(j)\n            if len(temp) > len(final):\n                final = temp.copy()\n    K = len(final)\n    chosen_provinces = final\n    return (K, chosen_provinces)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "per_capita_income = [A[i] / B[i] for i in range(N)]",
      "mutated_line": "per_capita_income = [A[i] * B[i] for i in range(N)]",
      "code": "def find_optimal_provinces(N, M, A, B, roads):\n    from collections import deque\n    adjacency_list = [[] for _ in range(N)]\n    for (u, v) in roads:\n        adjacency_list[u - 1].append(v - 1)\n        adjacency_list[v - 1].append(u - 1)\n    per_capita_income = [A[i] * B[i] for i in range(N)]\n    max_per_capita = max(per_capita_income)\n    final = []\n    visited = [False] * N\n    for i in range(N):\n        if per_capita_income[i] == max_per_capita and (not visited[i]):\n            visited[i] = True\n            temp = [i + 1]\n            queue = deque([i])\n            while queue:\n                t = queue.popleft()\n                for j in adjacency_list[t]:\n                    if per_capita_income[j] == max_per_capita and (not visited[j]):\n                        visited[j] = True\n                        temp.append(j + 1)\n                        queue.append(j)\n            if len(temp) > len(final):\n                final = temp.copy()\n    K = len(final)\n    chosen_provinces = final\n    return (K, chosen_provinces)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "per_capita_income = [A[i] / B[i] for i in range(N)]",
      "mutated_line": "per_capita_income = [A[i] // B[i] for i in range(N)]",
      "code": "def find_optimal_provinces(N, M, A, B, roads):\n    from collections import deque\n    adjacency_list = [[] for _ in range(N)]\n    for (u, v) in roads:\n        adjacency_list[u - 1].append(v - 1)\n        adjacency_list[v - 1].append(u - 1)\n    per_capita_income = [A[i] // B[i] for i in range(N)]\n    max_per_capita = max(per_capita_income)\n    final = []\n    visited = [False] * N\n    for i in range(N):\n        if per_capita_income[i] == max_per_capita and (not visited[i]):\n            visited[i] = True\n            temp = [i + 1]\n            queue = deque([i])\n            while queue:\n                t = queue.popleft()\n                for j in adjacency_list[t]:\n                    if per_capita_income[j] == max_per_capita and (not visited[j]):\n                        visited[j] = True\n                        temp.append(j + 1)\n                        queue.append(j)\n            if len(temp) > len(final):\n                final = temp.copy()\n    K = len(final)\n    chosen_provinces = final\n    return (K, chosen_provinces)"
    },
    {
      "operator": "LCR",
      "lineno": 22,
      "original_line": "if per_capita_income[i] == max_per_capita and not visited[i]:",
      "mutated_line": "if per_capita_income[i] == max_per_capita or not visited[i]:",
      "code": "def find_optimal_provinces(N, M, A, B, roads):\n    from collections import deque\n    adjacency_list = [[] for _ in range(N)]\n    for (u, v) in roads:\n        adjacency_list[u - 1].append(v - 1)\n        adjacency_list[v - 1].append(u - 1)\n    per_capita_income = [A[i] / B[i] for i in range(N)]\n    max_per_capita = max(per_capita_income)\n    final = []\n    visited = [False] * N\n    for i in range(N):\n        if per_capita_income[i] == max_per_capita or not visited[i]:\n            visited[i] = True\n            temp = [i + 1]\n            queue = deque([i])\n            while queue:\n                t = queue.popleft()\n                for j in adjacency_list[t]:\n                    if per_capita_income[j] == max_per_capita and (not visited[j]):\n                        visited[j] = True\n                        temp.append(j + 1)\n                        queue.append(j)\n            if len(temp) > len(final):\n                final = temp.copy()\n    K = len(final)\n    chosen_provinces = final\n    return (K, chosen_provinces)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "adjacency_list[u - 1].append(v - 1)",
      "mutated_line": "adjacency_list[u - 1].append(v + 1)",
      "code": "def find_optimal_provinces(N, M, A, B, roads):\n    from collections import deque\n    adjacency_list = [[] for _ in range(N)]\n    for (u, v) in roads:\n        adjacency_list[u - 1].append(v + 1)\n        adjacency_list[v - 1].append(u - 1)\n    per_capita_income = [A[i] / B[i] for i in range(N)]\n    max_per_capita = max(per_capita_income)\n    final = []\n    visited = [False] * N\n    for i in range(N):\n        if per_capita_income[i] == max_per_capita and (not visited[i]):\n            visited[i] = True\n            temp = [i + 1]\n            queue = deque([i])\n            while queue:\n                t = queue.popleft()\n                for j in adjacency_list[t]:\n                    if per_capita_income[j] == max_per_capita and (not visited[j]):\n                        visited[j] = True\n                        temp.append(j + 1)\n                        queue.append(j)\n            if len(temp) > len(final):\n                final = temp.copy()\n    K = len(final)\n    chosen_provinces = final\n    return (K, chosen_provinces)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "adjacency_list[u - 1].append(v - 1)",
      "mutated_line": "adjacency_list[u - 1].append(v * 1)",
      "code": "def find_optimal_provinces(N, M, A, B, roads):\n    from collections import deque\n    adjacency_list = [[] for _ in range(N)]\n    for (u, v) in roads:\n        adjacency_list[u - 1].append(v * 1)\n        adjacency_list[v - 1].append(u - 1)\n    per_capita_income = [A[i] / B[i] for i in range(N)]\n    max_per_capita = max(per_capita_income)\n    final = []\n    visited = [False] * N\n    for i in range(N):\n        if per_capita_income[i] == max_per_capita and (not visited[i]):\n            visited[i] = True\n            temp = [i + 1]\n            queue = deque([i])\n            while queue:\n                t = queue.popleft()\n                for j in adjacency_list[t]:\n                    if per_capita_income[j] == max_per_capita and (not visited[j]):\n                        visited[j] = True\n                        temp.append(j + 1)\n                        queue.append(j)\n            if len(temp) > len(final):\n                final = temp.copy()\n    K = len(final)\n    chosen_provinces = final\n    return (K, chosen_provinces)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "adjacency_list[v - 1].append(u - 1)",
      "mutated_line": "adjacency_list[v - 1].append(u + 1)",
      "code": "def find_optimal_provinces(N, M, A, B, roads):\n    from collections import deque\n    adjacency_list = [[] for _ in range(N)]\n    for (u, v) in roads:\n        adjacency_list[u - 1].append(v - 1)\n        adjacency_list[v - 1].append(u + 1)\n    per_capita_income = [A[i] / B[i] for i in range(N)]\n    max_per_capita = max(per_capita_income)\n    final = []\n    visited = [False] * N\n    for i in range(N):\n        if per_capita_income[i] == max_per_capita and (not visited[i]):\n            visited[i] = True\n            temp = [i + 1]\n            queue = deque([i])\n            while queue:\n                t = queue.popleft()\n                for j in adjacency_list[t]:\n                    if per_capita_income[j] == max_per_capita and (not visited[j]):\n                        visited[j] = True\n                        temp.append(j + 1)\n                        queue.append(j)\n            if len(temp) > len(final):\n                final = temp.copy()\n    K = len(final)\n    chosen_provinces = final\n    return (K, chosen_provinces)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "adjacency_list[v - 1].append(u - 1)",
      "mutated_line": "adjacency_list[v - 1].append(u * 1)",
      "code": "def find_optimal_provinces(N, M, A, B, roads):\n    from collections import deque\n    adjacency_list = [[] for _ in range(N)]\n    for (u, v) in roads:\n        adjacency_list[u - 1].append(v - 1)\n        adjacency_list[v - 1].append(u * 1)\n    per_capita_income = [A[i] / B[i] for i in range(N)]\n    max_per_capita = max(per_capita_income)\n    final = []\n    visited = [False] * N\n    for i in range(N):\n        if per_capita_income[i] == max_per_capita and (not visited[i]):\n            visited[i] = True\n            temp = [i + 1]\n            queue = deque([i])\n            while queue:\n                t = queue.popleft()\n                for j in adjacency_list[t]:\n                    if per_capita_income[j] == max_per_capita and (not visited[j]):\n                        visited[j] = True\n                        temp.append(j + 1)\n                        queue.append(j)\n            if len(temp) > len(final):\n                final = temp.copy()\n    K = len(final)\n    chosen_provinces = final\n    return (K, chosen_provinces)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "visited = [False] * N",
      "mutated_line": "visited = [True] * N",
      "code": "def find_optimal_provinces(N, M, A, B, roads):\n    from collections import deque\n    adjacency_list = [[] for _ in range(N)]\n    for (u, v) in roads:\n        adjacency_list[u - 1].append(v - 1)\n        adjacency_list[v - 1].append(u - 1)\n    per_capita_income = [A[i] / B[i] for i in range(N)]\n    max_per_capita = max(per_capita_income)\n    final = []\n    visited = [True] * N\n    for i in range(N):\n        if per_capita_income[i] == max_per_capita and (not visited[i]):\n            visited[i] = True\n            temp = [i + 1]\n            queue = deque([i])\n            while queue:\n                t = queue.popleft()\n                for j in adjacency_list[t]:\n                    if per_capita_income[j] == max_per_capita and (not visited[j]):\n                        visited[j] = True\n                        temp.append(j + 1)\n                        queue.append(j)\n            if len(temp) > len(final):\n                final = temp.copy()\n    K = len(final)\n    chosen_provinces = final\n    return (K, chosen_provinces)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if per_capita_income[i] == max_per_capita and not visited[i]:",
      "mutated_line": "if per_capita_income[i] != max_per_capita and (not visited[i]):",
      "code": "def find_optimal_provinces(N, M, A, B, roads):\n    from collections import deque\n    adjacency_list = [[] for _ in range(N)]\n    for (u, v) in roads:\n        adjacency_list[u - 1].append(v - 1)\n        adjacency_list[v - 1].append(u - 1)\n    per_capita_income = [A[i] / B[i] for i in range(N)]\n    max_per_capita = max(per_capita_income)\n    final = []\n    visited = [False] * N\n    for i in range(N):\n        if per_capita_income[i] != max_per_capita and (not visited[i]):\n            visited[i] = True\n            temp = [i + 1]\n            queue = deque([i])\n            while queue:\n                t = queue.popleft()\n                for j in adjacency_list[t]:\n                    if per_capita_income[j] == max_per_capita and (not visited[j]):\n                        visited[j] = True\n                        temp.append(j + 1)\n                        queue.append(j)\n            if len(temp) > len(final):\n                final = temp.copy()\n    K = len(final)\n    chosen_provinces = final\n    return (K, chosen_provinces)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "visited[i] = True",
      "mutated_line": "visited[i] = False",
      "code": "def find_optimal_provinces(N, M, A, B, roads):\n    from collections import deque\n    adjacency_list = [[] for _ in range(N)]\n    for (u, v) in roads:\n        adjacency_list[u - 1].append(v - 1)\n        adjacency_list[v - 1].append(u - 1)\n    per_capita_income = [A[i] / B[i] for i in range(N)]\n    max_per_capita = max(per_capita_income)\n    final = []\n    visited = [False] * N\n    for i in range(N):\n        if per_capita_income[i] == max_per_capita and (not visited[i]):\n            visited[i] = False\n            temp = [i + 1]\n            queue = deque([i])\n            while queue:\n                t = queue.popleft()\n                for j in adjacency_list[t]:\n                    if per_capita_income[j] == max_per_capita and (not visited[j]):\n                        visited[j] = True\n                        temp.append(j + 1)\n                        queue.append(j)\n            if len(temp) > len(final):\n                final = temp.copy()\n    K = len(final)\n    chosen_provinces = final\n    return (K, chosen_provinces)"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if len(temp) > len(final):",
      "mutated_line": "if len(temp) >= len(final):",
      "code": "def find_optimal_provinces(N, M, A, B, roads):\n    from collections import deque\n    adjacency_list = [[] for _ in range(N)]\n    for (u, v) in roads:\n        adjacency_list[u - 1].append(v - 1)\n        adjacency_list[v - 1].append(u - 1)\n    per_capita_income = [A[i] / B[i] for i in range(N)]\n    max_per_capita = max(per_capita_income)\n    final = []\n    visited = [False] * N\n    for i in range(N):\n        if per_capita_income[i] == max_per_capita and (not visited[i]):\n            visited[i] = True\n            temp = [i + 1]\n            queue = deque([i])\n            while queue:\n                t = queue.popleft()\n                for j in adjacency_list[t]:\n                    if per_capita_income[j] == max_per_capita and (not visited[j]):\n                        visited[j] = True\n                        temp.append(j + 1)\n                        queue.append(j)\n            if len(temp) >= len(final):\n                final = temp.copy()\n    K = len(final)\n    chosen_provinces = final\n    return (K, chosen_provinces)"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if len(temp) > len(final):",
      "mutated_line": "if len(temp) <= len(final):",
      "code": "def find_optimal_provinces(N, M, A, B, roads):\n    from collections import deque\n    adjacency_list = [[] for _ in range(N)]\n    for (u, v) in roads:\n        adjacency_list[u - 1].append(v - 1)\n        adjacency_list[v - 1].append(u - 1)\n    per_capita_income = [A[i] / B[i] for i in range(N)]\n    max_per_capita = max(per_capita_income)\n    final = []\n    visited = [False] * N\n    for i in range(N):\n        if per_capita_income[i] == max_per_capita and (not visited[i]):\n            visited[i] = True\n            temp = [i + 1]\n            queue = deque([i])\n            while queue:\n                t = queue.popleft()\n                for j in adjacency_list[t]:\n                    if per_capita_income[j] == max_per_capita and (not visited[j]):\n                        visited[j] = True\n                        temp.append(j + 1)\n                        queue.append(j)\n            if len(temp) <= len(final):\n                final = temp.copy()\n    K = len(final)\n    chosen_provinces = final\n    return (K, chosen_provinces)"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if len(temp) > len(final):",
      "mutated_line": "if len(temp) != len(final):",
      "code": "def find_optimal_provinces(N, M, A, B, roads):\n    from collections import deque\n    adjacency_list = [[] for _ in range(N)]\n    for (u, v) in roads:\n        adjacency_list[u - 1].append(v - 1)\n        adjacency_list[v - 1].append(u - 1)\n    per_capita_income = [A[i] / B[i] for i in range(N)]\n    max_per_capita = max(per_capita_income)\n    final = []\n    visited = [False] * N\n    for i in range(N):\n        if per_capita_income[i] == max_per_capita and (not visited[i]):\n            visited[i] = True\n            temp = [i + 1]\n            queue = deque([i])\n            while queue:\n                t = queue.popleft()\n                for j in adjacency_list[t]:\n                    if per_capita_income[j] == max_per_capita and (not visited[j]):\n                        visited[j] = True\n                        temp.append(j + 1)\n                        queue.append(j)\n            if len(temp) != len(final):\n                final = temp.copy()\n    K = len(final)\n    chosen_provinces = final\n    return (K, chosen_provinces)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "adjacency_list[u - 1].append(v - 1)",
      "mutated_line": "adjacency_list[u - 1].append(v - 2)",
      "code": "def find_optimal_provinces(N, M, A, B, roads):\n    from collections import deque\n    adjacency_list = [[] for _ in range(N)]\n    for (u, v) in roads:\n        adjacency_list[u - 1].append(v - 2)\n        adjacency_list[v - 1].append(u - 1)\n    per_capita_income = [A[i] / B[i] for i in range(N)]\n    max_per_capita = max(per_capita_income)\n    final = []\n    visited = [False] * N\n    for i in range(N):\n        if per_capita_income[i] == max_per_capita and (not visited[i]):\n            visited[i] = True\n            temp = [i + 1]\n            queue = deque([i])\n            while queue:\n                t = queue.popleft()\n                for j in adjacency_list[t]:\n                    if per_capita_income[j] == max_per_capita and (not visited[j]):\n                        visited[j] = True\n                        temp.append(j + 1)\n                        queue.append(j)\n            if len(temp) > len(final):\n                final = temp.copy()\n    K = len(final)\n    chosen_provinces = final\n    return (K, chosen_provinces)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "adjacency_list[u - 1].append(v - 1)",
      "mutated_line": "adjacency_list[u - 1].append(v - 0)",
      "code": "def find_optimal_provinces(N, M, A, B, roads):\n    from collections import deque\n    adjacency_list = [[] for _ in range(N)]\n    for (u, v) in roads:\n        adjacency_list[u - 1].append(v - 0)\n        adjacency_list[v - 1].append(u - 1)\n    per_capita_income = [A[i] / B[i] for i in range(N)]\n    max_per_capita = max(per_capita_income)\n    final = []\n    visited = [False] * N\n    for i in range(N):\n        if per_capita_income[i] == max_per_capita and (not visited[i]):\n            visited[i] = True\n            temp = [i + 1]\n            queue = deque([i])\n            while queue:\n                t = queue.popleft()\n                for j in adjacency_list[t]:\n                    if per_capita_income[j] == max_per_capita and (not visited[j]):\n                        visited[j] = True\n                        temp.append(j + 1)\n                        queue.append(j)\n            if len(temp) > len(final):\n                final = temp.copy()\n    K = len(final)\n    chosen_provinces = final\n    return (K, chosen_provinces)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "adjacency_list[u - 1].append(v - 1)",
      "mutated_line": "adjacency_list[u - 1].append(v - 0)",
      "code": "def find_optimal_provinces(N, M, A, B, roads):\n    from collections import deque\n    adjacency_list = [[] for _ in range(N)]\n    for (u, v) in roads:\n        adjacency_list[u - 1].append(v - 0)\n        adjacency_list[v - 1].append(u - 1)\n    per_capita_income = [A[i] / B[i] for i in range(N)]\n    max_per_capita = max(per_capita_income)\n    final = []\n    visited = [False] * N\n    for i in range(N):\n        if per_capita_income[i] == max_per_capita and (not visited[i]):\n            visited[i] = True\n            temp = [i + 1]\n            queue = deque([i])\n            while queue:\n                t = queue.popleft()\n                for j in adjacency_list[t]:\n                    if per_capita_income[j] == max_per_capita and (not visited[j]):\n                        visited[j] = True\n                        temp.append(j + 1)\n                        queue.append(j)\n            if len(temp) > len(final):\n                final = temp.copy()\n    K = len(final)\n    chosen_provinces = final\n    return (K, chosen_provinces)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "adjacency_list[u - 1].append(v - 1)",
      "mutated_line": "adjacency_list[u - 1].append(v - -1)",
      "code": "def find_optimal_provinces(N, M, A, B, roads):\n    from collections import deque\n    adjacency_list = [[] for _ in range(N)]\n    for (u, v) in roads:\n        adjacency_list[u - 1].append(v - -1)\n        adjacency_list[v - 1].append(u - 1)\n    per_capita_income = [A[i] / B[i] for i in range(N)]\n    max_per_capita = max(per_capita_income)\n    final = []\n    visited = [False] * N\n    for i in range(N):\n        if per_capita_income[i] == max_per_capita and (not visited[i]):\n            visited[i] = True\n            temp = [i + 1]\n            queue = deque([i])\n            while queue:\n                t = queue.popleft()\n                for j in adjacency_list[t]:\n                    if per_capita_income[j] == max_per_capita and (not visited[j]):\n                        visited[j] = True\n                        temp.append(j + 1)\n                        queue.append(j)\n            if len(temp) > len(final):\n                final = temp.copy()\n    K = len(final)\n    chosen_provinces = final\n    return (K, chosen_provinces)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "adjacency_list[v - 1].append(u - 1)",
      "mutated_line": "adjacency_list[v - 1].append(u - 2)",
      "code": "def find_optimal_provinces(N, M, A, B, roads):\n    from collections import deque\n    adjacency_list = [[] for _ in range(N)]\n    for (u, v) in roads:\n        adjacency_list[u - 1].append(v - 1)\n        adjacency_list[v - 1].append(u - 2)\n    per_capita_income = [A[i] / B[i] for i in range(N)]\n    max_per_capita = max(per_capita_income)\n    final = []\n    visited = [False] * N\n    for i in range(N):\n        if per_capita_income[i] == max_per_capita and (not visited[i]):\n            visited[i] = True\n            temp = [i + 1]\n            queue = deque([i])\n            while queue:\n                t = queue.popleft()\n                for j in adjacency_list[t]:\n                    if per_capita_income[j] == max_per_capita and (not visited[j]):\n                        visited[j] = True\n                        temp.append(j + 1)\n                        queue.append(j)\n            if len(temp) > len(final):\n                final = temp.copy()\n    K = len(final)\n    chosen_provinces = final\n    return (K, chosen_provinces)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "adjacency_list[v - 1].append(u - 1)",
      "mutated_line": "adjacency_list[v - 1].append(u - 0)",
      "code": "def find_optimal_provinces(N, M, A, B, roads):\n    from collections import deque\n    adjacency_list = [[] for _ in range(N)]\n    for (u, v) in roads:\n        adjacency_list[u - 1].append(v - 1)\n        adjacency_list[v - 1].append(u - 0)\n    per_capita_income = [A[i] / B[i] for i in range(N)]\n    max_per_capita = max(per_capita_income)\n    final = []\n    visited = [False] * N\n    for i in range(N):\n        if per_capita_income[i] == max_per_capita and (not visited[i]):\n            visited[i] = True\n            temp = [i + 1]\n            queue = deque([i])\n            while queue:\n                t = queue.popleft()\n                for j in adjacency_list[t]:\n                    if per_capita_income[j] == max_per_capita and (not visited[j]):\n                        visited[j] = True\n                        temp.append(j + 1)\n                        queue.append(j)\n            if len(temp) > len(final):\n                final = temp.copy()\n    K = len(final)\n    chosen_provinces = final\n    return (K, chosen_provinces)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "adjacency_list[v - 1].append(u - 1)",
      "mutated_line": "adjacency_list[v - 1].append(u - 0)",
      "code": "def find_optimal_provinces(N, M, A, B, roads):\n    from collections import deque\n    adjacency_list = [[] for _ in range(N)]\n    for (u, v) in roads:\n        adjacency_list[u - 1].append(v - 1)\n        adjacency_list[v - 1].append(u - 0)\n    per_capita_income = [A[i] / B[i] for i in range(N)]\n    max_per_capita = max(per_capita_income)\n    final = []\n    visited = [False] * N\n    for i in range(N):\n        if per_capita_income[i] == max_per_capita and (not visited[i]):\n            visited[i] = True\n            temp = [i + 1]\n            queue = deque([i])\n            while queue:\n                t = queue.popleft()\n                for j in adjacency_list[t]:\n                    if per_capita_income[j] == max_per_capita and (not visited[j]):\n                        visited[j] = True\n                        temp.append(j + 1)\n                        queue.append(j)\n            if len(temp) > len(final):\n                final = temp.copy()\n    K = len(final)\n    chosen_provinces = final\n    return (K, chosen_provinces)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "adjacency_list[v - 1].append(u - 1)",
      "mutated_line": "adjacency_list[v - 1].append(u - -1)",
      "code": "def find_optimal_provinces(N, M, A, B, roads):\n    from collections import deque\n    adjacency_list = [[] for _ in range(N)]\n    for (u, v) in roads:\n        adjacency_list[u - 1].append(v - 1)\n        adjacency_list[v - 1].append(u - -1)\n    per_capita_income = [A[i] / B[i] for i in range(N)]\n    max_per_capita = max(per_capita_income)\n    final = []\n    visited = [False] * N\n    for i in range(N):\n        if per_capita_income[i] == max_per_capita and (not visited[i]):\n            visited[i] = True\n            temp = [i + 1]\n            queue = deque([i])\n            while queue:\n                t = queue.popleft()\n                for j in adjacency_list[t]:\n                    if per_capita_income[j] == max_per_capita and (not visited[j]):\n                        visited[j] = True\n                        temp.append(j + 1)\n                        queue.append(j)\n            if len(temp) > len(final):\n                final = temp.copy()\n    K = len(final)\n    chosen_provinces = final\n    return (K, chosen_provinces)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "temp = [i + 1]",
      "mutated_line": "temp = [i - 1]",
      "code": "def find_optimal_provinces(N, M, A, B, roads):\n    from collections import deque\n    adjacency_list = [[] for _ in range(N)]\n    for (u, v) in roads:\n        adjacency_list[u - 1].append(v - 1)\n        adjacency_list[v - 1].append(u - 1)\n    per_capita_income = [A[i] / B[i] for i in range(N)]\n    max_per_capita = max(per_capita_income)\n    final = []\n    visited = [False] * N\n    for i in range(N):\n        if per_capita_income[i] == max_per_capita and (not visited[i]):\n            visited[i] = True\n            temp = [i - 1]\n            queue = deque([i])\n            while queue:\n                t = queue.popleft()\n                for j in adjacency_list[t]:\n                    if per_capita_income[j] == max_per_capita and (not visited[j]):\n                        visited[j] = True\n                        temp.append(j + 1)\n                        queue.append(j)\n            if len(temp) > len(final):\n                final = temp.copy()\n    K = len(final)\n    chosen_provinces = final\n    return (K, chosen_provinces)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "temp = [i + 1]",
      "mutated_line": "temp = [i * 1]",
      "code": "def find_optimal_provinces(N, M, A, B, roads):\n    from collections import deque\n    adjacency_list = [[] for _ in range(N)]\n    for (u, v) in roads:\n        adjacency_list[u - 1].append(v - 1)\n        adjacency_list[v - 1].append(u - 1)\n    per_capita_income = [A[i] / B[i] for i in range(N)]\n    max_per_capita = max(per_capita_income)\n    final = []\n    visited = [False] * N\n    for i in range(N):\n        if per_capita_income[i] == max_per_capita and (not visited[i]):\n            visited[i] = True\n            temp = [i * 1]\n            queue = deque([i])\n            while queue:\n                t = queue.popleft()\n                for j in adjacency_list[t]:\n                    if per_capita_income[j] == max_per_capita and (not visited[j]):\n                        visited[j] = True\n                        temp.append(j + 1)\n                        queue.append(j)\n            if len(temp) > len(final):\n                final = temp.copy()\n    K = len(final)\n    chosen_provinces = final\n    return (K, chosen_provinces)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "adjacency_list[u - 1].append(v - 1)",
      "mutated_line": "adjacency_list[u + 1].append(v - 1)",
      "code": "def find_optimal_provinces(N, M, A, B, roads):\n    from collections import deque\n    adjacency_list = [[] for _ in range(N)]\n    for (u, v) in roads:\n        adjacency_list[u + 1].append(v - 1)\n        adjacency_list[v - 1].append(u - 1)\n    per_capita_income = [A[i] / B[i] for i in range(N)]\n    max_per_capita = max(per_capita_income)\n    final = []\n    visited = [False] * N\n    for i in range(N):\n        if per_capita_income[i] == max_per_capita and (not visited[i]):\n            visited[i] = True\n            temp = [i + 1]\n            queue = deque([i])\n            while queue:\n                t = queue.popleft()\n                for j in adjacency_list[t]:\n                    if per_capita_income[j] == max_per_capita and (not visited[j]):\n                        visited[j] = True\n                        temp.append(j + 1)\n                        queue.append(j)\n            if len(temp) > len(final):\n                final = temp.copy()\n    K = len(final)\n    chosen_provinces = final\n    return (K, chosen_provinces)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "adjacency_list[u - 1].append(v - 1)",
      "mutated_line": "adjacency_list[u * 1].append(v - 1)",
      "code": "def find_optimal_provinces(N, M, A, B, roads):\n    from collections import deque\n    adjacency_list = [[] for _ in range(N)]\n    for (u, v) in roads:\n        adjacency_list[u * 1].append(v - 1)\n        adjacency_list[v - 1].append(u - 1)\n    per_capita_income = [A[i] / B[i] for i in range(N)]\n    max_per_capita = max(per_capita_income)\n    final = []\n    visited = [False] * N\n    for i in range(N):\n        if per_capita_income[i] == max_per_capita and (not visited[i]):\n            visited[i] = True\n            temp = [i + 1]\n            queue = deque([i])\n            while queue:\n                t = queue.popleft()\n                for j in adjacency_list[t]:\n                    if per_capita_income[j] == max_per_capita and (not visited[j]):\n                        visited[j] = True\n                        temp.append(j + 1)\n                        queue.append(j)\n            if len(temp) > len(final):\n                final = temp.copy()\n    K = len(final)\n    chosen_provinces = final\n    return (K, chosen_provinces)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "adjacency_list[v - 1].append(u - 1)",
      "mutated_line": "adjacency_list[v + 1].append(u - 1)",
      "code": "def find_optimal_provinces(N, M, A, B, roads):\n    from collections import deque\n    adjacency_list = [[] for _ in range(N)]\n    for (u, v) in roads:\n        adjacency_list[u - 1].append(v - 1)\n        adjacency_list[v + 1].append(u - 1)\n    per_capita_income = [A[i] / B[i] for i in range(N)]\n    max_per_capita = max(per_capita_income)\n    final = []\n    visited = [False] * N\n    for i in range(N):\n        if per_capita_income[i] == max_per_capita and (not visited[i]):\n            visited[i] = True\n            temp = [i + 1]\n            queue = deque([i])\n            while queue:\n                t = queue.popleft()\n                for j in adjacency_list[t]:\n                    if per_capita_income[j] == max_per_capita and (not visited[j]):\n                        visited[j] = True\n                        temp.append(j + 1)\n                        queue.append(j)\n            if len(temp) > len(final):\n                final = temp.copy()\n    K = len(final)\n    chosen_provinces = final\n    return (K, chosen_provinces)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "adjacency_list[v - 1].append(u - 1)",
      "mutated_line": "adjacency_list[v * 1].append(u - 1)",
      "code": "def find_optimal_provinces(N, M, A, B, roads):\n    from collections import deque\n    adjacency_list = [[] for _ in range(N)]\n    for (u, v) in roads:\n        adjacency_list[u - 1].append(v - 1)\n        adjacency_list[v * 1].append(u - 1)\n    per_capita_income = [A[i] / B[i] for i in range(N)]\n    max_per_capita = max(per_capita_income)\n    final = []\n    visited = [False] * N\n    for i in range(N):\n        if per_capita_income[i] == max_per_capita and (not visited[i]):\n            visited[i] = True\n            temp = [i + 1]\n            queue = deque([i])\n            while queue:\n                t = queue.popleft()\n                for j in adjacency_list[t]:\n                    if per_capita_income[j] == max_per_capita and (not visited[j]):\n                        visited[j] = True\n                        temp.append(j + 1)\n                        queue.append(j)\n            if len(temp) > len(final):\n                final = temp.copy()\n    K = len(final)\n    chosen_provinces = final\n    return (K, chosen_provinces)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "temp = [i + 1]",
      "mutated_line": "temp = [i + 2]",
      "code": "def find_optimal_provinces(N, M, A, B, roads):\n    from collections import deque\n    adjacency_list = [[] for _ in range(N)]\n    for (u, v) in roads:\n        adjacency_list[u - 1].append(v - 1)\n        adjacency_list[v - 1].append(u - 1)\n    per_capita_income = [A[i] / B[i] for i in range(N)]\n    max_per_capita = max(per_capita_income)\n    final = []\n    visited = [False] * N\n    for i in range(N):\n        if per_capita_income[i] == max_per_capita and (not visited[i]):\n            visited[i] = True\n            temp = [i + 2]\n            queue = deque([i])\n            while queue:\n                t = queue.popleft()\n                for j in adjacency_list[t]:\n                    if per_capita_income[j] == max_per_capita and (not visited[j]):\n                        visited[j] = True\n                        temp.append(j + 1)\n                        queue.append(j)\n            if len(temp) > len(final):\n                final = temp.copy()\n    K = len(final)\n    chosen_provinces = final\n    return (K, chosen_provinces)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "temp = [i + 1]",
      "mutated_line": "temp = [i + 0]",
      "code": "def find_optimal_provinces(N, M, A, B, roads):\n    from collections import deque\n    adjacency_list = [[] for _ in range(N)]\n    for (u, v) in roads:\n        adjacency_list[u - 1].append(v - 1)\n        adjacency_list[v - 1].append(u - 1)\n    per_capita_income = [A[i] / B[i] for i in range(N)]\n    max_per_capita = max(per_capita_income)\n    final = []\n    visited = [False] * N\n    for i in range(N):\n        if per_capita_income[i] == max_per_capita and (not visited[i]):\n            visited[i] = True\n            temp = [i + 0]\n            queue = deque([i])\n            while queue:\n                t = queue.popleft()\n                for j in adjacency_list[t]:\n                    if per_capita_income[j] == max_per_capita and (not visited[j]):\n                        visited[j] = True\n                        temp.append(j + 1)\n                        queue.append(j)\n            if len(temp) > len(final):\n                final = temp.copy()\n    K = len(final)\n    chosen_provinces = final\n    return (K, chosen_provinces)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "temp = [i + 1]",
      "mutated_line": "temp = [i + 0]",
      "code": "def find_optimal_provinces(N, M, A, B, roads):\n    from collections import deque\n    adjacency_list = [[] for _ in range(N)]\n    for (u, v) in roads:\n        adjacency_list[u - 1].append(v - 1)\n        adjacency_list[v - 1].append(u - 1)\n    per_capita_income = [A[i] / B[i] for i in range(N)]\n    max_per_capita = max(per_capita_income)\n    final = []\n    visited = [False] * N\n    for i in range(N):\n        if per_capita_income[i] == max_per_capita and (not visited[i]):\n            visited[i] = True\n            temp = [i + 0]\n            queue = deque([i])\n            while queue:\n                t = queue.popleft()\n                for j in adjacency_list[t]:\n                    if per_capita_income[j] == max_per_capita and (not visited[j]):\n                        visited[j] = True\n                        temp.append(j + 1)\n                        queue.append(j)\n            if len(temp) > len(final):\n                final = temp.copy()\n    K = len(final)\n    chosen_provinces = final\n    return (K, chosen_provinces)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "temp = [i + 1]",
      "mutated_line": "temp = [i + -1]",
      "code": "def find_optimal_provinces(N, M, A, B, roads):\n    from collections import deque\n    adjacency_list = [[] for _ in range(N)]\n    for (u, v) in roads:\n        adjacency_list[u - 1].append(v - 1)\n        adjacency_list[v - 1].append(u - 1)\n    per_capita_income = [A[i] / B[i] for i in range(N)]\n    max_per_capita = max(per_capita_income)\n    final = []\n    visited = [False] * N\n    for i in range(N):\n        if per_capita_income[i] == max_per_capita and (not visited[i]):\n            visited[i] = True\n            temp = [i + -1]\n            queue = deque([i])\n            while queue:\n                t = queue.popleft()\n                for j in adjacency_list[t]:\n                    if per_capita_income[j] == max_per_capita and (not visited[j]):\n                        visited[j] = True\n                        temp.append(j + 1)\n                        queue.append(j)\n            if len(temp) > len(final):\n                final = temp.copy()\n    K = len(final)\n    chosen_provinces = final\n    return (K, chosen_provinces)"
    },
    {
      "operator": "LCR",
      "lineno": 29,
      "original_line": "if per_capita_income[j] == max_per_capita and not visited[j]:",
      "mutated_line": "if per_capita_income[j] == max_per_capita or not visited[j]:",
      "code": "def find_optimal_provinces(N, M, A, B, roads):\n    from collections import deque\n    adjacency_list = [[] for _ in range(N)]\n    for (u, v) in roads:\n        adjacency_list[u - 1].append(v - 1)\n        adjacency_list[v - 1].append(u - 1)\n    per_capita_income = [A[i] / B[i] for i in range(N)]\n    max_per_capita = max(per_capita_income)\n    final = []\n    visited = [False] * N\n    for i in range(N):\n        if per_capita_income[i] == max_per_capita and (not visited[i]):\n            visited[i] = True\n            temp = [i + 1]\n            queue = deque([i])\n            while queue:\n                t = queue.popleft()\n                for j in adjacency_list[t]:\n                    if per_capita_income[j] == max_per_capita or not visited[j]:\n                        visited[j] = True\n                        temp.append(j + 1)\n                        queue.append(j)\n            if len(temp) > len(final):\n                final = temp.copy()\n    K = len(final)\n    chosen_provinces = final\n    return (K, chosen_provinces)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "adjacency_list[u - 1].append(v - 1)",
      "mutated_line": "adjacency_list[u - 2].append(v - 1)",
      "code": "def find_optimal_provinces(N, M, A, B, roads):\n    from collections import deque\n    adjacency_list = [[] for _ in range(N)]\n    for (u, v) in roads:\n        adjacency_list[u - 2].append(v - 1)\n        adjacency_list[v - 1].append(u - 1)\n    per_capita_income = [A[i] / B[i] for i in range(N)]\n    max_per_capita = max(per_capita_income)\n    final = []\n    visited = [False] * N\n    for i in range(N):\n        if per_capita_income[i] == max_per_capita and (not visited[i]):\n            visited[i] = True\n            temp = [i + 1]\n            queue = deque([i])\n            while queue:\n                t = queue.popleft()\n                for j in adjacency_list[t]:\n                    if per_capita_income[j] == max_per_capita and (not visited[j]):\n                        visited[j] = True\n                        temp.append(j + 1)\n                        queue.append(j)\n            if len(temp) > len(final):\n                final = temp.copy()\n    K = len(final)\n    chosen_provinces = final\n    return (K, chosen_provinces)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "adjacency_list[u - 1].append(v - 1)",
      "mutated_line": "adjacency_list[u - 0].append(v - 1)",
      "code": "def find_optimal_provinces(N, M, A, B, roads):\n    from collections import deque\n    adjacency_list = [[] for _ in range(N)]\n    for (u, v) in roads:\n        adjacency_list[u - 0].append(v - 1)\n        adjacency_list[v - 1].append(u - 1)\n    per_capita_income = [A[i] / B[i] for i in range(N)]\n    max_per_capita = max(per_capita_income)\n    final = []\n    visited = [False] * N\n    for i in range(N):\n        if per_capita_income[i] == max_per_capita and (not visited[i]):\n            visited[i] = True\n            temp = [i + 1]\n            queue = deque([i])\n            while queue:\n                t = queue.popleft()\n                for j in adjacency_list[t]:\n                    if per_capita_income[j] == max_per_capita and (not visited[j]):\n                        visited[j] = True\n                        temp.append(j + 1)\n                        queue.append(j)\n            if len(temp) > len(final):\n                final = temp.copy()\n    K = len(final)\n    chosen_provinces = final\n    return (K, chosen_provinces)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "adjacency_list[u - 1].append(v - 1)",
      "mutated_line": "adjacency_list[u - 0].append(v - 1)",
      "code": "def find_optimal_provinces(N, M, A, B, roads):\n    from collections import deque\n    adjacency_list = [[] for _ in range(N)]\n    for (u, v) in roads:\n        adjacency_list[u - 0].append(v - 1)\n        adjacency_list[v - 1].append(u - 1)\n    per_capita_income = [A[i] / B[i] for i in range(N)]\n    max_per_capita = max(per_capita_income)\n    final = []\n    visited = [False] * N\n    for i in range(N):\n        if per_capita_income[i] == max_per_capita and (not visited[i]):\n            visited[i] = True\n            temp = [i + 1]\n            queue = deque([i])\n            while queue:\n                t = queue.popleft()\n                for j in adjacency_list[t]:\n                    if per_capita_income[j] == max_per_capita and (not visited[j]):\n                        visited[j] = True\n                        temp.append(j + 1)\n                        queue.append(j)\n            if len(temp) > len(final):\n                final = temp.copy()\n    K = len(final)\n    chosen_provinces = final\n    return (K, chosen_provinces)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "adjacency_list[u - 1].append(v - 1)",
      "mutated_line": "adjacency_list[u - -1].append(v - 1)",
      "code": "def find_optimal_provinces(N, M, A, B, roads):\n    from collections import deque\n    adjacency_list = [[] for _ in range(N)]\n    for (u, v) in roads:\n        adjacency_list[u - -1].append(v - 1)\n        adjacency_list[v - 1].append(u - 1)\n    per_capita_income = [A[i] / B[i] for i in range(N)]\n    max_per_capita = max(per_capita_income)\n    final = []\n    visited = [False] * N\n    for i in range(N):\n        if per_capita_income[i] == max_per_capita and (not visited[i]):\n            visited[i] = True\n            temp = [i + 1]\n            queue = deque([i])\n            while queue:\n                t = queue.popleft()\n                for j in adjacency_list[t]:\n                    if per_capita_income[j] == max_per_capita and (not visited[j]):\n                        visited[j] = True\n                        temp.append(j + 1)\n                        queue.append(j)\n            if len(temp) > len(final):\n                final = temp.copy()\n    K = len(final)\n    chosen_provinces = final\n    return (K, chosen_provinces)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "adjacency_list[v - 1].append(u - 1)",
      "mutated_line": "adjacency_list[v - 2].append(u - 1)",
      "code": "def find_optimal_provinces(N, M, A, B, roads):\n    from collections import deque\n    adjacency_list = [[] for _ in range(N)]\n    for (u, v) in roads:\n        adjacency_list[u - 1].append(v - 1)\n        adjacency_list[v - 2].append(u - 1)\n    per_capita_income = [A[i] / B[i] for i in range(N)]\n    max_per_capita = max(per_capita_income)\n    final = []\n    visited = [False] * N\n    for i in range(N):\n        if per_capita_income[i] == max_per_capita and (not visited[i]):\n            visited[i] = True\n            temp = [i + 1]\n            queue = deque([i])\n            while queue:\n                t = queue.popleft()\n                for j in adjacency_list[t]:\n                    if per_capita_income[j] == max_per_capita and (not visited[j]):\n                        visited[j] = True\n                        temp.append(j + 1)\n                        queue.append(j)\n            if len(temp) > len(final):\n                final = temp.copy()\n    K = len(final)\n    chosen_provinces = final\n    return (K, chosen_provinces)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "adjacency_list[v - 1].append(u - 1)",
      "mutated_line": "adjacency_list[v - 0].append(u - 1)",
      "code": "def find_optimal_provinces(N, M, A, B, roads):\n    from collections import deque\n    adjacency_list = [[] for _ in range(N)]\n    for (u, v) in roads:\n        adjacency_list[u - 1].append(v - 1)\n        adjacency_list[v - 0].append(u - 1)\n    per_capita_income = [A[i] / B[i] for i in range(N)]\n    max_per_capita = max(per_capita_income)\n    final = []\n    visited = [False] * N\n    for i in range(N):\n        if per_capita_income[i] == max_per_capita and (not visited[i]):\n            visited[i] = True\n            temp = [i + 1]\n            queue = deque([i])\n            while queue:\n                t = queue.popleft()\n                for j in adjacency_list[t]:\n                    if per_capita_income[j] == max_per_capita and (not visited[j]):\n                        visited[j] = True\n                        temp.append(j + 1)\n                        queue.append(j)\n            if len(temp) > len(final):\n                final = temp.copy()\n    K = len(final)\n    chosen_provinces = final\n    return (K, chosen_provinces)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "adjacency_list[v - 1].append(u - 1)",
      "mutated_line": "adjacency_list[v - 0].append(u - 1)",
      "code": "def find_optimal_provinces(N, M, A, B, roads):\n    from collections import deque\n    adjacency_list = [[] for _ in range(N)]\n    for (u, v) in roads:\n        adjacency_list[u - 1].append(v - 1)\n        adjacency_list[v - 0].append(u - 1)\n    per_capita_income = [A[i] / B[i] for i in range(N)]\n    max_per_capita = max(per_capita_income)\n    final = []\n    visited = [False] * N\n    for i in range(N):\n        if per_capita_income[i] == max_per_capita and (not visited[i]):\n            visited[i] = True\n            temp = [i + 1]\n            queue = deque([i])\n            while queue:\n                t = queue.popleft()\n                for j in adjacency_list[t]:\n                    if per_capita_income[j] == max_per_capita and (not visited[j]):\n                        visited[j] = True\n                        temp.append(j + 1)\n                        queue.append(j)\n            if len(temp) > len(final):\n                final = temp.copy()\n    K = len(final)\n    chosen_provinces = final\n    return (K, chosen_provinces)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "adjacency_list[v - 1].append(u - 1)",
      "mutated_line": "adjacency_list[v - -1].append(u - 1)",
      "code": "def find_optimal_provinces(N, M, A, B, roads):\n    from collections import deque\n    adjacency_list = [[] for _ in range(N)]\n    for (u, v) in roads:\n        adjacency_list[u - 1].append(v - 1)\n        adjacency_list[v - -1].append(u - 1)\n    per_capita_income = [A[i] / B[i] for i in range(N)]\n    max_per_capita = max(per_capita_income)\n    final = []\n    visited = [False] * N\n    for i in range(N):\n        if per_capita_income[i] == max_per_capita and (not visited[i]):\n            visited[i] = True\n            temp = [i + 1]\n            queue = deque([i])\n            while queue:\n                t = queue.popleft()\n                for j in adjacency_list[t]:\n                    if per_capita_income[j] == max_per_capita and (not visited[j]):\n                        visited[j] = True\n                        temp.append(j + 1)\n                        queue.append(j)\n            if len(temp) > len(final):\n                final = temp.copy()\n    K = len(final)\n    chosen_provinces = final\n    return (K, chosen_provinces)"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if per_capita_income[j] == max_per_capita and not visited[j]:",
      "mutated_line": "if per_capita_income[j] != max_per_capita and (not visited[j]):",
      "code": "def find_optimal_provinces(N, M, A, B, roads):\n    from collections import deque\n    adjacency_list = [[] for _ in range(N)]\n    for (u, v) in roads:\n        adjacency_list[u - 1].append(v - 1)\n        adjacency_list[v - 1].append(u - 1)\n    per_capita_income = [A[i] / B[i] for i in range(N)]\n    max_per_capita = max(per_capita_income)\n    final = []\n    visited = [False] * N\n    for i in range(N):\n        if per_capita_income[i] == max_per_capita and (not visited[i]):\n            visited[i] = True\n            temp = [i + 1]\n            queue = deque([i])\n            while queue:\n                t = queue.popleft()\n                for j in adjacency_list[t]:\n                    if per_capita_income[j] != max_per_capita and (not visited[j]):\n                        visited[j] = True\n                        temp.append(j + 1)\n                        queue.append(j)\n            if len(temp) > len(final):\n                final = temp.copy()\n    K = len(final)\n    chosen_provinces = final\n    return (K, chosen_provinces)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "visited[j] = True",
      "mutated_line": "visited[j] = False",
      "code": "def find_optimal_provinces(N, M, A, B, roads):\n    from collections import deque\n    adjacency_list = [[] for _ in range(N)]\n    for (u, v) in roads:\n        adjacency_list[u - 1].append(v - 1)\n        adjacency_list[v - 1].append(u - 1)\n    per_capita_income = [A[i] / B[i] for i in range(N)]\n    max_per_capita = max(per_capita_income)\n    final = []\n    visited = [False] * N\n    for i in range(N):\n        if per_capita_income[i] == max_per_capita and (not visited[i]):\n            visited[i] = True\n            temp = [i + 1]\n            queue = deque([i])\n            while queue:\n                t = queue.popleft()\n                for j in adjacency_list[t]:\n                    if per_capita_income[j] == max_per_capita and (not visited[j]):\n                        visited[j] = False\n                        temp.append(j + 1)\n                        queue.append(j)\n            if len(temp) > len(final):\n                final = temp.copy()\n    K = len(final)\n    chosen_provinces = final\n    return (K, chosen_provinces)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "temp.append(j + 1)",
      "mutated_line": "temp.append(j - 1)",
      "code": "def find_optimal_provinces(N, M, A, B, roads):\n    from collections import deque\n    adjacency_list = [[] for _ in range(N)]\n    for (u, v) in roads:\n        adjacency_list[u - 1].append(v - 1)\n        adjacency_list[v - 1].append(u - 1)\n    per_capita_income = [A[i] / B[i] for i in range(N)]\n    max_per_capita = max(per_capita_income)\n    final = []\n    visited = [False] * N\n    for i in range(N):\n        if per_capita_income[i] == max_per_capita and (not visited[i]):\n            visited[i] = True\n            temp = [i + 1]\n            queue = deque([i])\n            while queue:\n                t = queue.popleft()\n                for j in adjacency_list[t]:\n                    if per_capita_income[j] == max_per_capita and (not visited[j]):\n                        visited[j] = True\n                        temp.append(j - 1)\n                        queue.append(j)\n            if len(temp) > len(final):\n                final = temp.copy()\n    K = len(final)\n    chosen_provinces = final\n    return (K, chosen_provinces)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "temp.append(j + 1)",
      "mutated_line": "temp.append(j * 1)",
      "code": "def find_optimal_provinces(N, M, A, B, roads):\n    from collections import deque\n    adjacency_list = [[] for _ in range(N)]\n    for (u, v) in roads:\n        adjacency_list[u - 1].append(v - 1)\n        adjacency_list[v - 1].append(u - 1)\n    per_capita_income = [A[i] / B[i] for i in range(N)]\n    max_per_capita = max(per_capita_income)\n    final = []\n    visited = [False] * N\n    for i in range(N):\n        if per_capita_income[i] == max_per_capita and (not visited[i]):\n            visited[i] = True\n            temp = [i + 1]\n            queue = deque([i])\n            while queue:\n                t = queue.popleft()\n                for j in adjacency_list[t]:\n                    if per_capita_income[j] == max_per_capita and (not visited[j]):\n                        visited[j] = True\n                        temp.append(j * 1)\n                        queue.append(j)\n            if len(temp) > len(final):\n                final = temp.copy()\n    K = len(final)\n    chosen_provinces = final\n    return (K, chosen_provinces)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "temp.append(j + 1)",
      "mutated_line": "temp.append(j + 2)",
      "code": "def find_optimal_provinces(N, M, A, B, roads):\n    from collections import deque\n    adjacency_list = [[] for _ in range(N)]\n    for (u, v) in roads:\n        adjacency_list[u - 1].append(v - 1)\n        adjacency_list[v - 1].append(u - 1)\n    per_capita_income = [A[i] / B[i] for i in range(N)]\n    max_per_capita = max(per_capita_income)\n    final = []\n    visited = [False] * N\n    for i in range(N):\n        if per_capita_income[i] == max_per_capita and (not visited[i]):\n            visited[i] = True\n            temp = [i + 1]\n            queue = deque([i])\n            while queue:\n                t = queue.popleft()\n                for j in adjacency_list[t]:\n                    if per_capita_income[j] == max_per_capita and (not visited[j]):\n                        visited[j] = True\n                        temp.append(j + 2)\n                        queue.append(j)\n            if len(temp) > len(final):\n                final = temp.copy()\n    K = len(final)\n    chosen_provinces = final\n    return (K, chosen_provinces)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "temp.append(j + 1)",
      "mutated_line": "temp.append(j + 0)",
      "code": "def find_optimal_provinces(N, M, A, B, roads):\n    from collections import deque\n    adjacency_list = [[] for _ in range(N)]\n    for (u, v) in roads:\n        adjacency_list[u - 1].append(v - 1)\n        adjacency_list[v - 1].append(u - 1)\n    per_capita_income = [A[i] / B[i] for i in range(N)]\n    max_per_capita = max(per_capita_income)\n    final = []\n    visited = [False] * N\n    for i in range(N):\n        if per_capita_income[i] == max_per_capita and (not visited[i]):\n            visited[i] = True\n            temp = [i + 1]\n            queue = deque([i])\n            while queue:\n                t = queue.popleft()\n                for j in adjacency_list[t]:\n                    if per_capita_income[j] == max_per_capita and (not visited[j]):\n                        visited[j] = True\n                        temp.append(j + 0)\n                        queue.append(j)\n            if len(temp) > len(final):\n                final = temp.copy()\n    K = len(final)\n    chosen_provinces = final\n    return (K, chosen_provinces)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "temp.append(j + 1)",
      "mutated_line": "temp.append(j + 0)",
      "code": "def find_optimal_provinces(N, M, A, B, roads):\n    from collections import deque\n    adjacency_list = [[] for _ in range(N)]\n    for (u, v) in roads:\n        adjacency_list[u - 1].append(v - 1)\n        adjacency_list[v - 1].append(u - 1)\n    per_capita_income = [A[i] / B[i] for i in range(N)]\n    max_per_capita = max(per_capita_income)\n    final = []\n    visited = [False] * N\n    for i in range(N):\n        if per_capita_income[i] == max_per_capita and (not visited[i]):\n            visited[i] = True\n            temp = [i + 1]\n            queue = deque([i])\n            while queue:\n                t = queue.popleft()\n                for j in adjacency_list[t]:\n                    if per_capita_income[j] == max_per_capita and (not visited[j]):\n                        visited[j] = True\n                        temp.append(j + 0)\n                        queue.append(j)\n            if len(temp) > len(final):\n                final = temp.copy()\n    K = len(final)\n    chosen_provinces = final\n    return (K, chosen_provinces)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "temp.append(j + 1)",
      "mutated_line": "temp.append(j + -1)",
      "code": "def find_optimal_provinces(N, M, A, B, roads):\n    from collections import deque\n    adjacency_list = [[] for _ in range(N)]\n    for (u, v) in roads:\n        adjacency_list[u - 1].append(v - 1)\n        adjacency_list[v - 1].append(u - 1)\n    per_capita_income = [A[i] / B[i] for i in range(N)]\n    max_per_capita = max(per_capita_income)\n    final = []\n    visited = [False] * N\n    for i in range(N):\n        if per_capita_income[i] == max_per_capita and (not visited[i]):\n            visited[i] = True\n            temp = [i + 1]\n            queue = deque([i])\n            while queue:\n                t = queue.popleft()\n                for j in adjacency_list[t]:\n                    if per_capita_income[j] == max_per_capita and (not visited[j]):\n                        visited[j] = True\n                        temp.append(j + -1)\n                        queue.append(j)\n            if len(temp) > len(final):\n                final = temp.copy()\n    K = len(final)\n    chosen_provinces = final\n    return (K, chosen_provinces)"
    }
  ]
}