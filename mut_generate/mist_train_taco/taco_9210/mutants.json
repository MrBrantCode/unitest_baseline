{
  "task_id": "taco_9210",
  "entry_point": "determine_road_placement",
  "mutant_count": 238,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "result = ''",
      "mutated_line": "result = 'MUTATED'",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = 'MUTATED'\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "mark = [0] * m",
      "mutated_line": "mark = [0] / m",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] / m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "mark = [0] * m",
      "mutated_line": "mark = [0] + m",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] + m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "mark = [0] * m",
      "mutated_line": "mark = [0] ** m",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] ** m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "while sum(mark) != m:",
      "mutated_line": "while sum(mark) == m:",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) == m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "ASR",
      "lineno": 47,
      "original_line": "result += i[3]",
      "mutated_line": "result -= i[3]",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result -= i[3]\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if i[2] < i[1]:",
      "mutated_line": "if i[2] <= i[1]:",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] <= i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if i[2] < i[1]:",
      "mutated_line": "if i[2] >= i[1]:",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] >= i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if i[2] < i[1]:",
      "mutated_line": "if i[2] != i[1]:",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] != i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "mark[index] = 1",
      "mutated_line": "mark[index] = 2",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 2\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "mark[index] = 1",
      "mutated_line": "mark[index] = 0",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 0\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "mark[index] = 1",
      "mutated_line": "mark[index] = 0",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 0\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "mark[index] = 1",
      "mutated_line": "mark[index] = -1",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = -1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if road[index][3] == 'NONE':",
      "mutated_line": "if road[index][3] != 'NONE':",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] != 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]",
      "mutated_line": "road = [[i, roads[i][0], roads[i][1], ''] for i in range(m)]",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], ''] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "(i[1], i[2]) = (i[1] - 1, i[2] - 1)",
      "mutated_line": "(i[1], i[2]) = (i[1] + 1, i[2] - 1)",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] + 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "(i[1], i[2]) = (i[1] - 1, i[2] - 1)",
      "mutated_line": "(i[1], i[2]) = (i[1] * 1, i[2] - 1)",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] * 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "(i[1], i[2]) = (i[1] - 1, i[2] - 1)",
      "mutated_line": "(i[1], i[2]) = (i[1] - 1, i[2] + 1)",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] + 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "(i[1], i[2]) = (i[1] - 1, i[2] - 1)",
      "mutated_line": "(i[1], i[2]) = (i[1] - 1, i[2] * 1)",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] * 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "for j in range(i + 1, len(road)):",
      "mutated_line": "for j in range(i - 1, len(road)):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i - 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "for j in range(i + 1, len(road)):",
      "mutated_line": "for j in range(i * 1, len(road)):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i * 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):",
      "mutated_line": "if (road[j][1] < road[i][1] < road[j][2]) | (road[j][1] < road[i][2] < road[j][2]):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) | (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "mark = [0] * m",
      "mutated_line": "mark = [1] * m",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [1] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "mark = [0] * m",
      "mutated_line": "mark = [-1] * m",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [-1] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "mark = [0] * m",
      "mutated_line": "mark = [1] * m",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [1] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if road[index][3] == 'NONE':",
      "mutated_line": "if road[index][3] == '':",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == '':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "road[index][3] = 'i'",
      "mutated_line": "road[index][3] = ''",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = ''\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if road[i][3] == road[index][3]:",
      "mutated_line": "if road[i][3] != road[index][3]:",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] != road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "result += i[3]",
      "mutated_line": "result += i[4]",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[4]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "result += i[3]",
      "mutated_line": "result += i[2]",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[2]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "result += i[3]",
      "mutated_line": "result += i[0]",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[0]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "result += i[3]",
      "mutated_line": "result += i[1]",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[1]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "result += i[3]",
      "mutated_line": "result += i[-3]",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[-3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]",
      "mutated_line": "road = [[i, roads[i][1], roads[i][1], 'NONE'] for i in range(m)]",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][1], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]",
      "mutated_line": "road = [[i, roads[i][-1], roads[i][1], 'NONE'] for i in range(m)]",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][-1], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]",
      "mutated_line": "road = [[i, roads[i][1], roads[i][1], 'NONE'] for i in range(m)]",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][1], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]",
      "mutated_line": "road = [[i, roads[i][0], roads[i][2], 'NONE'] for i in range(m)]",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][2], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]",
      "mutated_line": "road = [[i, roads[i][0], roads[i][0], 'NONE'] for i in range(m)]",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][0], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]",
      "mutated_line": "road = [[i, roads[i][0], roads[i][0], 'NONE'] for i in range(m)]",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][0], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]",
      "mutated_line": "road = [[i, roads[i][0], roads[i][-1], 'NONE'] for i in range(m)]",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][-1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if i[2] < i[1]:",
      "mutated_line": "if i[3] < i[1]:",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[3] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if i[2] < i[1]:",
      "mutated_line": "if i[1] < i[1]:",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[1] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if i[2] < i[1]:",
      "mutated_line": "if i[0] < i[1]:",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[0] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if i[2] < i[1]:",
      "mutated_line": "if i[1] < i[1]:",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[1] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if i[2] < i[1]:",
      "mutated_line": "if i[-2] < i[1]:",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[-2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if i[2] < i[1]:",
      "mutated_line": "if i[2] < i[2]:",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[2]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if i[2] < i[1]:",
      "mutated_line": "if i[2] < i[0]:",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[0]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if i[2] < i[1]:",
      "mutated_line": "if i[2] < i[0]:",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[0]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if i[2] < i[1]:",
      "mutated_line": "if i[2] < i[-1]:",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[-1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "(i[1], i[2]) = (i[1] - 1, i[2] - 1)",
      "mutated_line": "(i[2], i[2]) = (i[1] - 1, i[2] - 1)",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[2], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "(i[1], i[2]) = (i[1] - 1, i[2] - 1)",
      "mutated_line": "(i[0], i[2]) = (i[1] - 1, i[2] - 1)",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[0], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "(i[1], i[2]) = (i[1] - 1, i[2] - 1)",
      "mutated_line": "(i[0], i[2]) = (i[1] - 1, i[2] - 1)",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[0], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "(i[1], i[2]) = (i[1] - 1, i[2] - 1)",
      "mutated_line": "(i[-1], i[2]) = (i[1] - 1, i[2] - 1)",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[-1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "(i[1], i[2]) = (i[1] - 1, i[2] - 1)",
      "mutated_line": "(i[1], i[3]) = (i[1] - 1, i[2] - 1)",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[3]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "(i[1], i[2]) = (i[1] - 1, i[2] - 1)",
      "mutated_line": "(i[1], i[1]) = (i[1] - 1, i[2] - 1)",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[1]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "(i[1], i[2]) = (i[1] - 1, i[2] - 1)",
      "mutated_line": "(i[1], i[0]) = (i[1] - 1, i[2] - 1)",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[0]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "(i[1], i[2]) = (i[1] - 1, i[2] - 1)",
      "mutated_line": "(i[1], i[1]) = (i[1] - 1, i[2] - 1)",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[1]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "(i[1], i[2]) = (i[1] - 1, i[2] - 1)",
      "mutated_line": "(i[1], i[-2]) = (i[1] - 1, i[2] - 1)",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[-2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "(i[1], i[2]) = (i[1] - 1, i[2] - 1)",
      "mutated_line": "(i[1], i[2]) = (i[1] - 2, i[2] - 1)",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 2, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "(i[1], i[2]) = (i[1] - 1, i[2] - 1)",
      "mutated_line": "(i[1], i[2]) = (i[1] - 0, i[2] - 1)",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 0, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "(i[1], i[2]) = (i[1] - 1, i[2] - 1)",
      "mutated_line": "(i[1], i[2]) = (i[1] - 0, i[2] - 1)",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 0, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "(i[1], i[2]) = (i[1] - 1, i[2] - 1)",
      "mutated_line": "(i[1], i[2]) = (i[1] - -1, i[2] - 1)",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - -1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "(i[1], i[2]) = (i[1] - 1, i[2] - 1)",
      "mutated_line": "(i[1], i[2]) = (i[1] - 1, i[2] - 2)",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 2)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "(i[1], i[2]) = (i[1] - 1, i[2] - 1)",
      "mutated_line": "(i[1], i[2]) = (i[1] - 1, i[2] - 0)",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 0)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "(i[1], i[2]) = (i[1] - 1, i[2] - 1)",
      "mutated_line": "(i[1], i[2]) = (i[1] - 1, i[2] - 0)",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 0)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "(i[1], i[2]) = (i[1] - 1, i[2] - 1)",
      "mutated_line": "(i[1], i[2]) = (i[1] - 1, i[2] - -1)",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - -1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for j in range(i + 1, len(road)):",
      "mutated_line": "for j in range(i + 2, len(road)):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 2, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for j in range(i + 1, len(road)):",
      "mutated_line": "for j in range(i + 0, len(road)):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 0, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for j in range(i + 1, len(road)):",
      "mutated_line": "for j in range(i + 0, len(road)):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 0, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for j in range(i + 1, len(road)):",
      "mutated_line": "for j in range(i + -1, len(road)):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + -1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):",
      "mutated_line": "if (road[j][1] <= road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] <= road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):",
      "mutated_line": "if (road[j][1] >= road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] >= road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):",
      "mutated_line": "if (road[j][1] != road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] != road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):",
      "mutated_line": "if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] <= road[i][2] < road[j][2]):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] <= road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):",
      "mutated_line": "if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] >= road[i][2] < road[j][2]):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] >= road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):",
      "mutated_line": "if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] != road[i][2] < road[j][2]):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] != road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "LCR",
      "lineno": 16,
      "original_line": "if road[j][1] != road[i][1] and road[j][2] != road[i][1] and road[j][1] != road[i][2] and road[j][2] != road[i][2]:",
      "mutated_line": "if road[j][1] != road[i][1] or road[j][2] != road[i][1] or road[j][1] != road[i][2] or (road[j][2] != road[i][2]):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] or road[j][2] != road[i][1] or road[j][1] != road[i][2] or (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if mark[i] == 0:",
      "mutated_line": "if mark[i] != 0:",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] != 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if road[index][3] == 'NONE':",
      "mutated_line": "if road[index][4] == 'NONE':",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][4] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if road[index][3] == 'NONE':",
      "mutated_line": "if road[index][2] == 'NONE':",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][2] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if road[index][3] == 'NONE':",
      "mutated_line": "if road[index][0] == 'NONE':",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][0] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if road[index][3] == 'NONE':",
      "mutated_line": "if road[index][1] == 'NONE':",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][1] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if road[index][3] == 'NONE':",
      "mutated_line": "if road[index][-3] == 'NONE':",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][-3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "road[index][3] = 'i'",
      "mutated_line": "road[index][4] = 'i'",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][4] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "road[index][3] = 'i'",
      "mutated_line": "road[index][2] = 'i'",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][2] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "road[index][3] = 'i'",
      "mutated_line": "road[index][0] = 'i'",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][0] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "road[index][3] = 'i'",
      "mutated_line": "road[index][1] = 'i'",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][1] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "road[index][3] = 'i'",
      "mutated_line": "road[index][-3] = 'i'",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][-3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return 'Impossible'",
      "mutated_line": "return ''",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return ''\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "LCR",
      "lineno": 38,
      "original_line": "elif road[index][3] != 'i' and road[i][3] == 'NONE':",
      "mutated_line": "elif road[index][3] != 'i' or road[i][3] == 'NONE':",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' or road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "(i[1], i[2]) = (i[2], i[1])",
      "mutated_line": "(i[2], i[2]) = (i[2], i[1])",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[2], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "(i[1], i[2]) = (i[2], i[1])",
      "mutated_line": "(i[0], i[2]) = (i[2], i[1])",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[0], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "(i[1], i[2]) = (i[2], i[1])",
      "mutated_line": "(i[0], i[2]) = (i[2], i[1])",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[0], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "(i[1], i[2]) = (i[2], i[1])",
      "mutated_line": "(i[-1], i[2]) = (i[2], i[1])",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[-1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "(i[1], i[2]) = (i[2], i[1])",
      "mutated_line": "(i[1], i[3]) = (i[2], i[1])",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[3]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "(i[1], i[2]) = (i[2], i[1])",
      "mutated_line": "(i[1], i[1]) = (i[2], i[1])",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[1]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "(i[1], i[2]) = (i[2], i[1])",
      "mutated_line": "(i[1], i[0]) = (i[2], i[1])",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[0]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "(i[1], i[2]) = (i[2], i[1])",
      "mutated_line": "(i[1], i[1]) = (i[2], i[1])",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[1]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "(i[1], i[2]) = (i[2], i[1])",
      "mutated_line": "(i[1], i[-2]) = (i[2], i[1])",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[-2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "(i[1], i[2]) = (i[2], i[1])",
      "mutated_line": "(i[1], i[2]) = (i[3], i[1])",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[3], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "(i[1], i[2]) = (i[2], i[1])",
      "mutated_line": "(i[1], i[2]) = (i[1], i[1])",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[1], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "(i[1], i[2]) = (i[2], i[1])",
      "mutated_line": "(i[1], i[2]) = (i[0], i[1])",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[0], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "(i[1], i[2]) = (i[2], i[1])",
      "mutated_line": "(i[1], i[2]) = (i[1], i[1])",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[1], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "(i[1], i[2]) = (i[2], i[1])",
      "mutated_line": "(i[1], i[2]) = (i[-2], i[1])",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[-2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "(i[1], i[2]) = (i[2], i[1])",
      "mutated_line": "(i[1], i[2]) = (i[2], i[2])",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[2])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "(i[1], i[2]) = (i[2], i[1])",
      "mutated_line": "(i[1], i[2]) = (i[2], i[0])",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[0])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "(i[1], i[2]) = (i[2], i[1])",
      "mutated_line": "(i[1], i[2]) = (i[2], i[0])",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[0])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "(i[1], i[2]) = (i[2], i[1])",
      "mutated_line": "(i[1], i[2]) = (i[2], i[-1])",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[-1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "(i[1], i[2]) = (i[1] - 1, i[2] - 1)",
      "mutated_line": "(i[1], i[2]) = (i[2] - 1, i[2] - 1)",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[2] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "(i[1], i[2]) = (i[1] - 1, i[2] - 1)",
      "mutated_line": "(i[1], i[2]) = (i[0] - 1, i[2] - 1)",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[0] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "(i[1], i[2]) = (i[1] - 1, i[2] - 1)",
      "mutated_line": "(i[1], i[2]) = (i[0] - 1, i[2] - 1)",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[0] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "(i[1], i[2]) = (i[1] - 1, i[2] - 1)",
      "mutated_line": "(i[1], i[2]) = (i[-1] - 1, i[2] - 1)",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[-1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "(i[1], i[2]) = (i[1] - 1, i[2] - 1)",
      "mutated_line": "(i[1], i[2]) = (i[1] - 1, i[3] - 1)",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[3] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "(i[1], i[2]) = (i[1] - 1, i[2] - 1)",
      "mutated_line": "(i[1], i[2]) = (i[1] - 1, i[1] - 1)",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[1] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "(i[1], i[2]) = (i[1] - 1, i[2] - 1)",
      "mutated_line": "(i[1], i[2]) = (i[1] - 1, i[0] - 1)",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[0] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "(i[1], i[2]) = (i[1] - 1, i[2] - 1)",
      "mutated_line": "(i[1], i[2]) = (i[1] - 1, i[1] - 1)",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[1] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "(i[1], i[2]) = (i[1] - 1, i[2] - 1)",
      "mutated_line": "(i[1], i[2]) = (i[1] - 1, i[-2] - 1)",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[-2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if road[j][1] != road[i][1] and road[j][2] != road[i][1] and road[j][1] != road[i][2] and road[j][2] != road[i][2]:",
      "mutated_line": "if road[j][1] == road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] == road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if road[j][1] != road[i][1] and road[j][2] != road[i][1] and road[j][1] != road[i][2] and road[j][2] != road[i][2]:",
      "mutated_line": "if road[j][1] != road[i][1] and road[j][2] == road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] == road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if road[j][1] != road[i][1] and road[j][2] != road[i][1] and road[j][1] != road[i][2] and road[j][2] != road[i][2]:",
      "mutated_line": "if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] == road[i][2]) and (road[j][2] != road[i][2]):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] == road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if road[j][1] != road[i][1] and road[j][2] != road[i][1] and road[j][1] != road[i][2] and road[j][2] != road[i][2]:",
      "mutated_line": "if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] == road[i][2]):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] == road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if mark[i] == 0:",
      "mutated_line": "if mark[i] == 1:",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 1:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if mark[i] == 0:",
      "mutated_line": "if mark[i] == -1:",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == -1:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if mark[i] == 0:",
      "mutated_line": "if mark[i] == 1:",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 1:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if road[i][3] == road[index][3]:",
      "mutated_line": "if road[i][4] == road[index][3]:",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][4] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if road[i][3] == road[index][3]:",
      "mutated_line": "if road[i][2] == road[index][3]:",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][2] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if road[i][3] == road[index][3]:",
      "mutated_line": "if road[i][0] == road[index][3]:",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][0] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if road[i][3] == road[index][3]:",
      "mutated_line": "if road[i][1] == road[index][3]:",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][1] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if road[i][3] == road[index][3]:",
      "mutated_line": "if road[i][-3] == road[index][3]:",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][-3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if road[i][3] == road[index][3]:",
      "mutated_line": "if road[i][3] == road[index][4]:",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][4]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if road[i][3] == road[index][3]:",
      "mutated_line": "if road[i][3] == road[index][2]:",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][2]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if road[i][3] == road[index][3]:",
      "mutated_line": "if road[i][3] == road[index][0]:",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][0]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if road[i][3] == road[index][3]:",
      "mutated_line": "if road[i][3] == road[index][1]:",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][1]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if road[i][3] == road[index][3]:",
      "mutated_line": "if road[i][3] == road[index][-3]:",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][-3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "elif road[index][3] != 'i' and road[i][3] == 'NONE':",
      "mutated_line": "elif road[index][3] == 'i' and road[i][3] == 'NONE':",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "elif road[index][3] != 'i' and road[i][3] == 'NONE':",
      "mutated_line": "elif road[index][3] != 'i' and road[i][3] != 'NONE':",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] != 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "road[i][3] = 'i'",
      "mutated_line": "road[i][3] = ''",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = ''\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "LCR",
      "lineno": 41,
      "original_line": "elif road[index][3] == 'i' and road[i][3] == 'NONE':",
      "mutated_line": "elif road[index][3] == 'i' or road[i][3] == 'NONE':",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' or road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):",
      "mutated_line": "if (road[j][2] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][2] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):",
      "mutated_line": "if (road[j][0] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][0] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):",
      "mutated_line": "if (road[j][0] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][0] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):",
      "mutated_line": "if (road[j][-1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][-1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):",
      "mutated_line": "if (road[j][1] < road[i][2] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][2] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):",
      "mutated_line": "if (road[j][1] < road[i][0] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][0] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):",
      "mutated_line": "if (road[j][1] < road[i][0] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][0] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):",
      "mutated_line": "if (road[j][1] < road[i][-1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][-1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):",
      "mutated_line": "if (road[j][1] < road[i][1] < road[j][3]) ^ (road[j][1] < road[i][2] < road[j][2]):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][3]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):",
      "mutated_line": "if (road[j][1] < road[i][1] < road[j][1]) ^ (road[j][1] < road[i][2] < road[j][2]):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][1]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):",
      "mutated_line": "if (road[j][1] < road[i][1] < road[j][0]) ^ (road[j][1] < road[i][2] < road[j][2]):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][0]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):",
      "mutated_line": "if (road[j][1] < road[i][1] < road[j][1]) ^ (road[j][1] < road[i][2] < road[j][2]):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][1]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):",
      "mutated_line": "if (road[j][1] < road[i][1] < road[j][-2]) ^ (road[j][1] < road[i][2] < road[j][2]):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][-2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):",
      "mutated_line": "if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][2] < road[i][2] < road[j][2]):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][2] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):",
      "mutated_line": "if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][0] < road[i][2] < road[j][2]):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][0] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):",
      "mutated_line": "if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][0] < road[i][2] < road[j][2]):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][0] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):",
      "mutated_line": "if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][-1] < road[i][2] < road[j][2]):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][-1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):",
      "mutated_line": "if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][3] < road[j][2]):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][3] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):",
      "mutated_line": "if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][1] < road[j][2]):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][1] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):",
      "mutated_line": "if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][0] < road[j][2]):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][0] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):",
      "mutated_line": "if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][1] < road[j][2]):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][1] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):",
      "mutated_line": "if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][-2] < road[j][2]):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][-2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):",
      "mutated_line": "if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][3]):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][3]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):",
      "mutated_line": "if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][1]):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][1]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):",
      "mutated_line": "if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][0]):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][0]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):",
      "mutated_line": "if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][1]):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][1]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):",
      "mutated_line": "if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][-2]):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][-2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "elif road[index][3] != 'i' and road[i][3] == 'NONE':",
      "mutated_line": "elif road[index][3] != '' and road[i][3] == 'NONE':",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != '' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "elif road[index][3] != 'i' and road[i][3] == 'NONE':",
      "mutated_line": "elif road[index][3] != 'i' and road[i][3] == '':",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == '':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "road[i][3] = 'i'",
      "mutated_line": "road[i][4] = 'i'",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][4] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "road[i][3] = 'i'",
      "mutated_line": "road[i][2] = 'i'",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][2] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "road[i][3] = 'i'",
      "mutated_line": "road[i][0] = 'i'",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][0] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "road[i][3] = 'i'",
      "mutated_line": "road[i][1] = 'i'",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][1] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "road[i][3] = 'i'",
      "mutated_line": "road[i][-3] = 'i'",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][-3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "elif road[index][3] == 'i' and road[i][3] == 'NONE':",
      "mutated_line": "elif road[index][3] != 'i' and road[i][3] == 'NONE':",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "elif road[index][3] == 'i' and road[i][3] == 'NONE':",
      "mutated_line": "elif road[index][3] == 'i' and road[i][3] != 'NONE':",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] != 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "road[i][3] = 'o'",
      "mutated_line": "road[i][3] = ''",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = ''\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if road[j][1] != road[i][1] and road[j][2] != road[i][1] and road[j][1] != road[i][2] and road[j][2] != road[i][2]:",
      "mutated_line": "if road[j][2] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][2] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if road[j][1] != road[i][1] and road[j][2] != road[i][1] and road[j][1] != road[i][2] and road[j][2] != road[i][2]:",
      "mutated_line": "if road[j][0] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][0] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if road[j][1] != road[i][1] and road[j][2] != road[i][1] and road[j][1] != road[i][2] and road[j][2] != road[i][2]:",
      "mutated_line": "if road[j][0] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][0] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if road[j][1] != road[i][1] and road[j][2] != road[i][1] and road[j][1] != road[i][2] and road[j][2] != road[i][2]:",
      "mutated_line": "if road[j][-1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][-1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if road[j][1] != road[i][1] and road[j][2] != road[i][1] and road[j][1] != road[i][2] and road[j][2] != road[i][2]:",
      "mutated_line": "if road[j][1] != road[i][2] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][2] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if road[j][1] != road[i][1] and road[j][2] != road[i][1] and road[j][1] != road[i][2] and road[j][2] != road[i][2]:",
      "mutated_line": "if road[j][1] != road[i][0] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][0] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if road[j][1] != road[i][1] and road[j][2] != road[i][1] and road[j][1] != road[i][2] and road[j][2] != road[i][2]:",
      "mutated_line": "if road[j][1] != road[i][0] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][0] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if road[j][1] != road[i][1] and road[j][2] != road[i][1] and road[j][1] != road[i][2] and road[j][2] != road[i][2]:",
      "mutated_line": "if road[j][1] != road[i][-1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][-1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if road[j][1] != road[i][1] and road[j][2] != road[i][1] and road[j][1] != road[i][2] and road[j][2] != road[i][2]:",
      "mutated_line": "if road[j][1] != road[i][1] and road[j][3] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][3] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if road[j][1] != road[i][1] and road[j][2] != road[i][1] and road[j][1] != road[i][2] and road[j][2] != road[i][2]:",
      "mutated_line": "if road[j][1] != road[i][1] and road[j][1] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][1] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if road[j][1] != road[i][1] and road[j][2] != road[i][1] and road[j][1] != road[i][2] and road[j][2] != road[i][2]:",
      "mutated_line": "if road[j][1] != road[i][1] and road[j][0] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][0] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if road[j][1] != road[i][1] and road[j][2] != road[i][1] and road[j][1] != road[i][2] and road[j][2] != road[i][2]:",
      "mutated_line": "if road[j][1] != road[i][1] and road[j][1] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][1] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if road[j][1] != road[i][1] and road[j][2] != road[i][1] and road[j][1] != road[i][2] and road[j][2] != road[i][2]:",
      "mutated_line": "if road[j][1] != road[i][1] and road[j][-2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][-2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if road[j][1] != road[i][1] and road[j][2] != road[i][1] and road[j][1] != road[i][2] and road[j][2] != road[i][2]:",
      "mutated_line": "if road[j][1] != road[i][1] and road[j][2] != road[i][2] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][2] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if road[j][1] != road[i][1] and road[j][2] != road[i][1] and road[j][1] != road[i][2] and road[j][2] != road[i][2]:",
      "mutated_line": "if road[j][1] != road[i][1] and road[j][2] != road[i][0] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][0] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if road[j][1] != road[i][1] and road[j][2] != road[i][1] and road[j][1] != road[i][2] and road[j][2] != road[i][2]:",
      "mutated_line": "if road[j][1] != road[i][1] and road[j][2] != road[i][0] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][0] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if road[j][1] != road[i][1] and road[j][2] != road[i][1] and road[j][1] != road[i][2] and road[j][2] != road[i][2]:",
      "mutated_line": "if road[j][1] != road[i][1] and road[j][2] != road[i][-1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][-1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if road[j][1] != road[i][1] and road[j][2] != road[i][1] and road[j][1] != road[i][2] and road[j][2] != road[i][2]:",
      "mutated_line": "if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][2] != road[i][2]) and (road[j][2] != road[i][2]):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][2] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if road[j][1] != road[i][1] and road[j][2] != road[i][1] and road[j][1] != road[i][2] and road[j][2] != road[i][2]:",
      "mutated_line": "if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][0] != road[i][2]) and (road[j][2] != road[i][2]):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][0] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if road[j][1] != road[i][1] and road[j][2] != road[i][1] and road[j][1] != road[i][2] and road[j][2] != road[i][2]:",
      "mutated_line": "if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][0] != road[i][2]) and (road[j][2] != road[i][2]):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][0] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if road[j][1] != road[i][1] and road[j][2] != road[i][1] and road[j][1] != road[i][2] and road[j][2] != road[i][2]:",
      "mutated_line": "if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][-1] != road[i][2]) and (road[j][2] != road[i][2]):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][-1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if road[j][1] != road[i][1] and road[j][2] != road[i][1] and road[j][1] != road[i][2] and road[j][2] != road[i][2]:",
      "mutated_line": "if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][3]) and (road[j][2] != road[i][2]):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][3]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if road[j][1] != road[i][1] and road[j][2] != road[i][1] and road[j][1] != road[i][2] and road[j][2] != road[i][2]:",
      "mutated_line": "if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][1]) and (road[j][2] != road[i][2]):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][1]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if road[j][1] != road[i][1] and road[j][2] != road[i][1] and road[j][1] != road[i][2] and road[j][2] != road[i][2]:",
      "mutated_line": "if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][0]) and (road[j][2] != road[i][2]):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][0]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if road[j][1] != road[i][1] and road[j][2] != road[i][1] and road[j][1] != road[i][2] and road[j][2] != road[i][2]:",
      "mutated_line": "if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][1]) and (road[j][2] != road[i][2]):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][1]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if road[j][1] != road[i][1] and road[j][2] != road[i][1] and road[j][1] != road[i][2] and road[j][2] != road[i][2]:",
      "mutated_line": "if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][-2]) and (road[j][2] != road[i][2]):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][-2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if road[j][1] != road[i][1] and road[j][2] != road[i][1] and road[j][1] != road[i][2] and road[j][2] != road[i][2]:",
      "mutated_line": "if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][3] != road[i][2]):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][3] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if road[j][1] != road[i][1] and road[j][2] != road[i][1] and road[j][1] != road[i][2] and road[j][2] != road[i][2]:",
      "mutated_line": "if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][1] != road[i][2]):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][1] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if road[j][1] != road[i][1] and road[j][2] != road[i][1] and road[j][1] != road[i][2] and road[j][2] != road[i][2]:",
      "mutated_line": "if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][0] != road[i][2]):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][0] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if road[j][1] != road[i][1] and road[j][2] != road[i][1] and road[j][1] != road[i][2] and road[j][2] != road[i][2]:",
      "mutated_line": "if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][1] != road[i][2]):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][1] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if road[j][1] != road[i][1] and road[j][2] != road[i][1] and road[j][1] != road[i][2] and road[j][2] != road[i][2]:",
      "mutated_line": "if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][-2] != road[i][2]):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][-2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if road[j][1] != road[i][1] and road[j][2] != road[i][1] and road[j][1] != road[i][2] and road[j][2] != road[i][2]:",
      "mutated_line": "if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][3]):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][3]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if road[j][1] != road[i][1] and road[j][2] != road[i][1] and road[j][1] != road[i][2] and road[j][2] != road[i][2]:",
      "mutated_line": "if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][1]):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][1]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if road[j][1] != road[i][1] and road[j][2] != road[i][1] and road[j][1] != road[i][2] and road[j][2] != road[i][2]:",
      "mutated_line": "if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][0]):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][0]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if road[j][1] != road[i][1] and road[j][2] != road[i][1] and road[j][1] != road[i][2] and road[j][2] != road[i][2]:",
      "mutated_line": "if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][1]):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][1]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if road[j][1] != road[i][1] and road[j][2] != road[i][1] and road[j][1] != road[i][2] and road[j][2] != road[i][2]:",
      "mutated_line": "if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][-2]):",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][-2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "elif road[index][3] != 'i' and road[i][3] == 'NONE':",
      "mutated_line": "elif road[index][4] != 'i' and road[i][3] == 'NONE':",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][4] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "elif road[index][3] != 'i' and road[i][3] == 'NONE':",
      "mutated_line": "elif road[index][2] != 'i' and road[i][3] == 'NONE':",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][2] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "elif road[index][3] != 'i' and road[i][3] == 'NONE':",
      "mutated_line": "elif road[index][0] != 'i' and road[i][3] == 'NONE':",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][0] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "elif road[index][3] != 'i' and road[i][3] == 'NONE':",
      "mutated_line": "elif road[index][1] != 'i' and road[i][3] == 'NONE':",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][1] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "elif road[index][3] != 'i' and road[i][3] == 'NONE':",
      "mutated_line": "elif road[index][-3] != 'i' and road[i][3] == 'NONE':",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][-3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "elif road[index][3] != 'i' and road[i][3] == 'NONE':",
      "mutated_line": "elif road[index][3] != 'i' and road[i][4] == 'NONE':",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][4] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "elif road[index][3] != 'i' and road[i][3] == 'NONE':",
      "mutated_line": "elif road[index][3] != 'i' and road[i][2] == 'NONE':",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][2] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "elif road[index][3] != 'i' and road[i][3] == 'NONE':",
      "mutated_line": "elif road[index][3] != 'i' and road[i][0] == 'NONE':",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][0] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "elif road[index][3] != 'i' and road[i][3] == 'NONE':",
      "mutated_line": "elif road[index][3] != 'i' and road[i][1] == 'NONE':",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][1] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "elif road[index][3] != 'i' and road[i][3] == 'NONE':",
      "mutated_line": "elif road[index][3] != 'i' and road[i][-3] == 'NONE':",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][-3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "elif road[index][3] == 'i' and road[i][3] == 'NONE':",
      "mutated_line": "elif road[index][3] == '' and road[i][3] == 'NONE':",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == '' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "elif road[index][3] == 'i' and road[i][3] == 'NONE':",
      "mutated_line": "elif road[index][3] == 'i' and road[i][3] == '':",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == '':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "road[i][3] = 'o'",
      "mutated_line": "road[i][4] = 'o'",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][4] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "road[i][3] = 'o'",
      "mutated_line": "road[i][2] = 'o'",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][2] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "road[i][3] = 'o'",
      "mutated_line": "road[i][0] = 'o'",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][0] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "road[i][3] = 'o'",
      "mutated_line": "road[i][1] = 'o'",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][1] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "road[i][3] = 'o'",
      "mutated_line": "road[i][-3] = 'o'",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][3] == 'NONE':\n                road[i][-3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "elif road[index][3] == 'i' and road[i][3] == 'NONE':",
      "mutated_line": "elif road[index][4] == 'i' and road[i][3] == 'NONE':",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][4] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "elif road[index][3] == 'i' and road[i][3] == 'NONE':",
      "mutated_line": "elif road[index][2] == 'i' and road[i][3] == 'NONE':",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][2] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "elif road[index][3] == 'i' and road[i][3] == 'NONE':",
      "mutated_line": "elif road[index][0] == 'i' and road[i][3] == 'NONE':",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][0] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "elif road[index][3] == 'i' and road[i][3] == 'NONE':",
      "mutated_line": "elif road[index][1] == 'i' and road[i][3] == 'NONE':",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][1] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "elif road[index][3] == 'i' and road[i][3] == 'NONE':",
      "mutated_line": "elif road[index][-3] == 'i' and road[i][3] == 'NONE':",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][-3] == 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "elif road[index][3] == 'i' and road[i][3] == 'NONE':",
      "mutated_line": "elif road[index][3] == 'i' and road[i][4] == 'NONE':",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][4] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "elif road[index][3] == 'i' and road[i][3] == 'NONE':",
      "mutated_line": "elif road[index][3] == 'i' and road[i][2] == 'NONE':",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][2] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "elif road[index][3] == 'i' and road[i][3] == 'NONE':",
      "mutated_line": "elif road[index][3] == 'i' and road[i][0] == 'NONE':",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][0] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "elif road[index][3] == 'i' and road[i][3] == 'NONE':",
      "mutated_line": "elif road[index][3] == 'i' and road[i][1] == 'NONE':",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][1] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "elif road[index][3] == 'i' and road[i][3] == 'NONE':",
      "mutated_line": "elif road[index][3] == 'i' and road[i][-3] == 'NONE':",
      "code": "def determine_road_placement(n, m, roads):\n    road = [[i, roads[i][0], roads[i][1], 'NONE'] for i in range(m)]\n    for i in road:\n        if i[2] < i[1]:\n            (i[1], i[2]) = (i[2], i[1])\n        (i[1], i[2]) = (i[1] - 1, i[2] - 1)\n    participation = [[] for _ in range(m)]\n    for i in range(len(road)):\n        for j in range(i + 1, len(road)):\n            if (road[j][1] < road[i][1] < road[j][2]) ^ (road[j][1] < road[i][2] < road[j][2]):\n                if road[j][1] != road[i][1] and road[j][2] != road[i][1] and (road[j][1] != road[i][2]) and (road[j][2] != road[i][2]):\n                    participation[i].append(j)\n                    participation[j].append(i)\n    result = ''\n    mark = [0] * m\n    stack = []\n    while sum(mark) != m:\n        if not stack:\n            for i in range(len(mark)):\n                if mark[i] == 0:\n                    stack.append(i)\n                    break\n        index = stack.pop()\n        mark[index] = 1\n        if road[index][3] == 'NONE':\n            road[index][3] = 'i'\n        for i in participation[index]:\n            if road[i][3] == road[index][3]:\n                return 'Impossible'\n            elif road[index][3] != 'i' and road[i][3] == 'NONE':\n                road[i][3] = 'i'\n                stack.append(i)\n            elif road[index][3] == 'i' and road[i][-3] == 'NONE':\n                road[i][3] = 'o'\n                stack.append(i)\n    for i in road:\n        result += i[3]\n    return result"
    }
  ]
}