{
  "task_id": "taco_2601",
  "entry_point": "dist2",
  "mutant_count": 262,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2",
      "mutated_line": "return (x0 - x1) ** 2 + (y0 - y1) ** 2 - (z0 - z1) ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 - (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2",
      "mutated_line": "return ((x0 - x1) ** 2 + (y0 - y1) ** 2) * (z0 - z1) ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return ((x0 - x1) ** 2 + (y0 - y1) ** 2) * (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return x0 * x1 + y0 * y1 + z0 * z1",
      "mutated_line": "return x0 * x1 + y0 * y1 - z0 * z1",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 - z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return x0 * x1 + y0 * y1 + z0 * z1",
      "mutated_line": "return (x0 * x1 + y0 * y1) * (z0 * z1)",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return (x0 * x1 + y0 * y1) * (z0 * z1)\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2",
      "mutated_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 - (x0 * y1 - x1 * y0) ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 - (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2",
      "mutated_line": "return ((y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2) * (x0 * y1 - x1 * y0) ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return ((y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2) * (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "rem = [0] * M",
      "mutated_line": "rem = [0] / M",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] / M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "rem = [0] * M",
      "mutated_line": "rem = [0] + M",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] + M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "rem = [0] * M",
      "mutated_line": "rem = [0] ** M",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] ** M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 1\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = -1\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 1\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2",
      "mutated_line": "return (x0 - x1) ** 2 - (y0 - y1) ** 2 + (z0 - z1) ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 - (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2",
      "mutated_line": "return (x0 - x1) ** 2 * (y0 - y1) ** 2 + (z0 - z1) ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 * (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2",
      "mutated_line": "return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) * 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) * 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2",
      "mutated_line": "return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1 + 2)",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1 + 2)\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return x0 * x1 + y0 * y1 + z0 * z1",
      "mutated_line": "return x0 * x1 - y0 * y1 + z0 * z1",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 - y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return x0 * x1 + y0 * y1 + z0 * z1",
      "mutated_line": "return x0 * x1 * (y0 * y1) + z0 * z1",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 * (y0 * y1) + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return x0 * x1 + y0 * y1 + z0 * z1",
      "mutated_line": "return x0 * x1 + y0 * y1 + z0 / z1",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 / z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return x0 * x1 + y0 * y1 + z0 * z1",
      "mutated_line": "return x0 * x1 + y0 * y1 + (z0 + z1)",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + (z0 + z1)\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return x0 * x1 + y0 * y1 + z0 * z1",
      "mutated_line": "return x0 * x1 + y0 * y1 + z0 ** z1",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 ** z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2",
      "mutated_line": "return (y0 * z1 - y1 * z0) ** 2 - (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 - (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2",
      "mutated_line": "return (y0 * z1 - y1 * z0) ** 2 * (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 * (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2",
      "mutated_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) * 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) * 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2",
      "mutated_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0 + 2)",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0 + 2)\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]",
      "mutated_line": "L = [tb * (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb * (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]",
      "mutated_line": "L = [tb // (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb // (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "ld = tx ** 2 + ty ** 2 + tz ** 2",
      "mutated_line": "ld = tx ** 2 + ty ** 2 - tz ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 - tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "ld = tx ** 2 + ty ** 2 + tz ** 2",
      "mutated_line": "ld = (tx ** 2 + ty ** 2) * tz ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = (tx ** 2 + ty ** 2) * tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "need = 0",
      "mutated_line": "need = 1",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 1\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "need = 0",
      "mutated_line": "need = -1",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = -1\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "need = 0",
      "mutated_line": "need = 1",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 1\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "if bin(need).count('1') <= R:",
      "mutated_line": "if bin(need).count('1') < R:",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') < R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "if bin(need).count('1') <= R:",
      "mutated_line": "if bin(need).count('1') > R:",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') > R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "if bin(need).count('1') <= R:",
      "mutated_line": "if bin(need).count('1') == R:",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') == R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2",
      "mutated_line": "return (x0 - x1) * 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) * 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2",
      "mutated_line": "return x0 - x1 + 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return x0 - x1 + 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2",
      "mutated_line": "return (x0 - x1) ** 2 + (y0 - y1) * 2 + (z0 - z1) ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) * 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2",
      "mutated_line": "return (x0 - x1) ** 2 + (y0 - y1 + 2) + (z0 - z1) ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1 + 2) + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2",
      "mutated_line": "return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 + z1) ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 + z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2",
      "mutated_line": "return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 * z1) ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 * z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2",
      "mutated_line": "return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 3",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 3\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2",
      "mutated_line": "return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 1",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 1\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2",
      "mutated_line": "return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 0",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 0\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2",
      "mutated_line": "return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 1",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 1\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2",
      "mutated_line": "return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** -2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** -2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return x0 * x1 + y0 * y1 + z0 * z1",
      "mutated_line": "return x0 / x1 + y0 * y1 + z0 * z1",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 / x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return x0 * x1 + y0 * y1 + z0 * z1",
      "mutated_line": "return x0 + x1 + y0 * y1 + z0 * z1",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 + x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return x0 * x1 + y0 * y1 + z0 * z1",
      "mutated_line": "return x0 ** x1 + y0 * y1 + z0 * z1",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 ** x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return x0 * x1 + y0 * y1 + z0 * z1",
      "mutated_line": "return x0 * x1 + y0 / y1 + z0 * z1",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 / y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return x0 * x1 + y0 * y1 + z0 * z1",
      "mutated_line": "return x0 * x1 + (y0 + y1) + z0 * z1",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + (y0 + y1) + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return x0 * x1 + y0 * y1 + z0 * z1",
      "mutated_line": "return x0 * x1 + y0 ** y1 + z0 * z1",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 ** y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2",
      "mutated_line": "return (y0 * z1 - y1 * z0) * 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) * 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2",
      "mutated_line": "return y0 * z1 - y1 * z0 + 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return y0 * z1 - y1 * z0 + 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2",
      "mutated_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) * 2 + (x0 * y1 - x1 * y0) ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) * 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2",
      "mutated_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0 + 2) + (x0 * y1 - x1 * y0) ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0 + 2) + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2",
      "mutated_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 + x1 * y0) ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 + x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2",
      "mutated_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 * (x1 * y0)) ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 * (x1 * y0)) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2",
      "mutated_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 3",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 3\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2",
      "mutated_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 1",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 1\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2",
      "mutated_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 0",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 0\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2",
      "mutated_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 1",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 1\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2",
      "mutated_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** -2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** -2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]",
      "mutated_line": "S = [(sx + ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx + ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]",
      "mutated_line": "S = [(sx * ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx * ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]",
      "mutated_line": "S = [(sx - ex, sy + ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy + ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]",
      "mutated_line": "S = [(sx - ex, sy * ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy * ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]",
      "mutated_line": "S = [(sx - ex, sy - ey, sz + ez, sr) for (sx, sy, sz, sr) in balloons]",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz + ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]",
      "mutated_line": "S = [(sx - ex, sy - ey, sz * ez, sr) for (sx, sy, sz, sr) in balloons]",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz * ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]",
      "mutated_line": "T = [(tx + ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx + ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]",
      "mutated_line": "T = [(tx * ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx * ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]",
      "mutated_line": "T = [(tx - ex, ty + ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty + ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]",
      "mutated_line": "T = [(tx - ex, ty * ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty * ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]",
      "mutated_line": "T = [(tx - ex, ty - ey, tz + ez, tb) for (tx, ty, tz, tb) in lights]",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz + ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]",
      "mutated_line": "T = [(tx - ex, ty - ey, tz * ez, tb) for (tx, ty, tz, tb) in lights]",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz * ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]",
      "mutated_line": "L = [tb / (tx ** 2 + ty ** 2 - tz ** 2) for (tx, ty, tz, tb) in T]",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 - tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]",
      "mutated_line": "L = [tb / ((tx ** 2 + ty ** 2) * tz ** 2) for (tx, ty, tz, tb) in T]",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / ((tx ** 2 + ty ** 2) * tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "rem = [0] * M",
      "mutated_line": "rem = [1] * M",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [1] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "rem = [0] * M",
      "mutated_line": "rem = [-1] * M",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [-1] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "rem = [0] * M",
      "mutated_line": "rem = [1] * M",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [1] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "ld = tx ** 2 + ty ** 2 + tz ** 2",
      "mutated_line": "ld = tx ** 2 - ty ** 2 + tz ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 - ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "ld = tx ** 2 + ty ** 2 + tz ** 2",
      "mutated_line": "ld = tx ** 2 * ty ** 2 + tz ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 * ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "ld = tx ** 2 + ty ** 2 + tz ** 2",
      "mutated_line": "ld = tx ** 2 + ty ** 2 + tz * 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz * 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "ld = tx ** 2 + ty ** 2 + tz ** 2",
      "mutated_line": "ld = tx ** 2 + ty ** 2 + (tz + 2)",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + (tz + 2)\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "sr2 = sr ** 2",
      "mutated_line": "sr2 = sr * 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr * 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "sr2 = sr ** 2",
      "mutated_line": "sr2 = sr + 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr + 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "ok = 1",
      "mutated_line": "ok = 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 2\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "ok = 1",
      "mutated_line": "ok = 0",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 0\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "ok = 1",
      "mutated_line": "ok = 0",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 0\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "ok = 1",
      "mutated_line": "ok = -1",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = -1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2",
      "mutated_line": "dd1 = sx ** 2 + sy ** 2 + sz ** 2 < sr2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 < sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2",
      "mutated_line": "dd1 = sx ** 2 + sy ** 2 + sz ** 2 > sr2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 > sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2",
      "mutated_line": "dd1 = sx ** 2 + sy ** 2 + sz ** 2 == sr2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 == sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2",
      "mutated_line": "dd2 = dist2(sx, sy, sz, tx, ty, tz) < sr2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) < sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2",
      "mutated_line": "dd2 = dist2(sx, sy, sz, tx, ty, tz) > sr2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) > sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2",
      "mutated_line": "dd2 = dist2(sx, sy, sz, tx, ty, tz) == sr2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) == sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if dd1 ^ dd2:",
      "mutated_line": "if dd1 | dd2:",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 | dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "for P in product([0, 1], repeat=M):",
      "mutated_line": "for P in product([1, 1], repeat=M):",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([1, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "for P in product([0, 1], repeat=M):",
      "mutated_line": "for P in product([-1, 1], repeat=M):",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([-1, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "for P in product([0, 1], repeat=M):",
      "mutated_line": "for P in product([1, 1], repeat=M):",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([1, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "for P in product([0, 1], repeat=M):",
      "mutated_line": "for P in product([0, 2], repeat=M):",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 2], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "for P in product([0, 1], repeat=M):",
      "mutated_line": "for P in product([0, 0], repeat=M):",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 0], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "for P in product([0, 1], repeat=M):",
      "mutated_line": "for P in product([0, 0], repeat=M):",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 0], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "for P in product([0, 1], repeat=M):",
      "mutated_line": "for P in product([0, -1], repeat=M):",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, -1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2",
      "mutated_line": "return (x0 + x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 + x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2",
      "mutated_line": "return (x0 * x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 * x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2",
      "mutated_line": "return (x0 - x1) ** 3 + (y0 - y1) ** 2 + (z0 - z1) ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 3 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2",
      "mutated_line": "return (x0 - x1) ** 1 + (y0 - y1) ** 2 + (z0 - z1) ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 1 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2",
      "mutated_line": "return (x0 - x1) ** 0 + (y0 - y1) ** 2 + (z0 - z1) ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 0 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2",
      "mutated_line": "return (x0 - x1) ** 1 + (y0 - y1) ** 2 + (z0 - z1) ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 1 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2",
      "mutated_line": "return (x0 - x1) ** -2 + (y0 - y1) ** 2 + (z0 - z1) ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** -2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2",
      "mutated_line": "return (x0 - x1) ** 2 + (y0 + y1) ** 2 + (z0 - z1) ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 + y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2",
      "mutated_line": "return (x0 - x1) ** 2 + (y0 * y1) ** 2 + (z0 - z1) ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 * y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2",
      "mutated_line": "return (x0 - x1) ** 2 + (y0 - y1) ** 3 + (z0 - z1) ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 3 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2",
      "mutated_line": "return (x0 - x1) ** 2 + (y0 - y1) ** 1 + (z0 - z1) ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 1 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2",
      "mutated_line": "return (x0 - x1) ** 2 + (y0 - y1) ** 0 + (z0 - z1) ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 0 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2",
      "mutated_line": "return (x0 - x1) ** 2 + (y0 - y1) ** 1 + (z0 - z1) ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 1 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2",
      "mutated_line": "return (x0 - x1) ** 2 + (y0 - y1) ** -2 + (z0 - z1) ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** -2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2",
      "mutated_line": "return (y0 * z1 + y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 + y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2",
      "mutated_line": "return (y0 * z1 * (y1 * z0)) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 * (y1 * z0)) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2",
      "mutated_line": "return (y0 * z1 - y1 * z0) ** 3 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 3 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2",
      "mutated_line": "return (y0 * z1 - y1 * z0) ** 1 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 1 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2",
      "mutated_line": "return (y0 * z1 - y1 * z0) ** 0 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 0 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2",
      "mutated_line": "return (y0 * z1 - y1 * z0) ** 1 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 1 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2",
      "mutated_line": "return (y0 * z1 - y1 * z0) ** -2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** -2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2",
      "mutated_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 + z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 + z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2",
      "mutated_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 * (z1 * x0)) ** 2 + (x0 * y1 - x1 * y0) ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 * (z1 * x0)) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2",
      "mutated_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 3 + (x0 * y1 - x1 * y0) ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 3 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2",
      "mutated_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 1 + (x0 * y1 - x1 * y0) ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 1 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2",
      "mutated_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 0 + (x0 * y1 - x1 * y0) ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 0 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2",
      "mutated_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 1 + (x0 * y1 - x1 * y0) ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 1 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2",
      "mutated_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** -2 + (x0 * y1 - x1 * y0) ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** -2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2",
      "mutated_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 / y1 - x1 * y0) ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 / y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2",
      "mutated_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 + y1 - x1 * y0) ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 + y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2",
      "mutated_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 ** y1 - x1 * y0) ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 ** y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2",
      "mutated_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 / y0) ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 / y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2",
      "mutated_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - (x1 + y0)) ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - (x1 + y0)) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2",
      "mutated_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 ** y0) ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 ** y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]",
      "mutated_line": "L = [tb / (tx ** 2 - ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 - ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]",
      "mutated_line": "L = [tb / (tx ** 2 * ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 * ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]",
      "mutated_line": "L = [tb / (tx ** 2 + ty ** 2 + tz * 2) for (tx, ty, tz, tb) in T]",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz * 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]",
      "mutated_line": "L = [tb / (tx ** 2 + ty ** 2 + (tz + 2)) for (tx, ty, tz, tb) in T]",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + (tz + 2)) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "ld = tx ** 2 + ty ** 2 + tz ** 2",
      "mutated_line": "ld = tx * 2 + ty ** 2 + tz ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx * 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "ld = tx ** 2 + ty ** 2 + tz ** 2",
      "mutated_line": "ld = tx + 2 + ty ** 2 + tz ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx + 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "ld = tx ** 2 + ty ** 2 + tz ** 2",
      "mutated_line": "ld = tx ** 2 + ty * 2 + tz ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty * 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "ld = tx ** 2 + ty ** 2 + tz ** 2",
      "mutated_line": "ld = tx ** 2 + (ty + 2) + tz ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + (ty + 2) + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ld = tx ** 2 + ty ** 2 + tz ** 2",
      "mutated_line": "ld = tx ** 2 + ty ** 2 + tz ** 3",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 3\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ld = tx ** 2 + ty ** 2 + tz ** 2",
      "mutated_line": "ld = tx ** 2 + ty ** 2 + tz ** 1",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 1\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ld = tx ** 2 + ty ** 2 + tz ** 2",
      "mutated_line": "ld = tx ** 2 + ty ** 2 + tz ** 0",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 0\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ld = tx ** 2 + ty ** 2 + tz ** 2",
      "mutated_line": "ld = tx ** 2 + ty ** 2 + tz ** 1",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 1\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ld = tx ** 2 + ty ** 2 + tz ** 2",
      "mutated_line": "ld = tx ** 2 + ty ** 2 + tz ** -2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** -2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "sr2 = sr ** 2",
      "mutated_line": "sr2 = sr ** 3",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 3\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "sr2 = sr ** 2",
      "mutated_line": "sr2 = sr ** 1",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 1\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "sr2 = sr ** 2",
      "mutated_line": "sr2 = sr ** 0",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 0\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "sr2 = sr ** 2",
      "mutated_line": "sr2 = sr ** 1",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 1\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "sr2 = sr ** 2",
      "mutated_line": "sr2 = sr ** -2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** -2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2",
      "mutated_line": "dd1 = sx ** 2 + sy ** 2 - sz ** 2 <= sr2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 - sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2",
      "mutated_line": "dd1 = (sx ** 2 + sy ** 2) * sz ** 2 <= sr2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = (sx ** 2 + sy ** 2) * sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "ok = 0",
      "mutated_line": "ok = 1",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 1\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "ok = 0",
      "mutated_line": "ok = -1",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = -1\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "ok = 0",
      "mutated_line": "ok = 1",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 1\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "elif dd1 == dd2 == 0:",
      "mutated_line": "elif dd1 != dd2 == 0:",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 != dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if bin(need).count('1') <= R:",
      "mutated_line": "if bin(need).count('') <= R:",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2",
      "mutated_line": "return (y0 / z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 / z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2",
      "mutated_line": "return (y0 + z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 + z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2",
      "mutated_line": "return (y0 ** z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 ** z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2",
      "mutated_line": "return (y0 * z1 - y1 / z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 / z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2",
      "mutated_line": "return (y0 * z1 - (y1 + z0)) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - (y1 + z0)) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2",
      "mutated_line": "return (y0 * z1 - y1 ** z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 ** z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2",
      "mutated_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 / x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 / x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2",
      "mutated_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 + x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 + x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2",
      "mutated_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 ** x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 ** x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2",
      "mutated_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 / x0) ** 2 + (x0 * y1 - x1 * y0) ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 / x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2",
      "mutated_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - (z1 + x0)) ** 2 + (x0 * y1 - x1 * y0) ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - (z1 + x0)) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2",
      "mutated_line": "return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 ** x0) ** 2 + (x0 * y1 - x1 * y0) ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 ** x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]",
      "mutated_line": "L = [tb / (tx * 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx * 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]",
      "mutated_line": "L = [tb / (tx + 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx + 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]",
      "mutated_line": "L = [tb / (tx ** 2 + ty * 2 + tz ** 2) for (tx, ty, tz, tb) in T]",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty * 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]",
      "mutated_line": "L = [tb / (tx ** 2 + (ty + 2) + tz ** 2) for (tx, ty, tz, tb) in T]",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + (ty + 2) + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]",
      "mutated_line": "L = [tb / (tx ** 2 + ty ** 2 + tz ** 3) for (tx, ty, tz, tb) in T]",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 3) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]",
      "mutated_line": "L = [tb / (tx ** 2 + ty ** 2 + tz ** 1) for (tx, ty, tz, tb) in T]",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 1) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]",
      "mutated_line": "L = [tb / (tx ** 2 + ty ** 2 + tz ** 0) for (tx, ty, tz, tb) in T]",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 0) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]",
      "mutated_line": "L = [tb / (tx ** 2 + ty ** 2 + tz ** 1) for (tx, ty, tz, tb) in T]",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 1) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]",
      "mutated_line": "L = [tb / (tx ** 2 + ty ** 2 + tz ** -2) for (tx, ty, tz, tb) in T]",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** -2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ld = tx ** 2 + ty ** 2 + tz ** 2",
      "mutated_line": "ld = tx ** 3 + ty ** 2 + tz ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 3 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ld = tx ** 2 + ty ** 2 + tz ** 2",
      "mutated_line": "ld = tx ** 1 + ty ** 2 + tz ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 1 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ld = tx ** 2 + ty ** 2 + tz ** 2",
      "mutated_line": "ld = tx ** 0 + ty ** 2 + tz ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 0 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ld = tx ** 2 + ty ** 2 + tz ** 2",
      "mutated_line": "ld = tx ** 1 + ty ** 2 + tz ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 1 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ld = tx ** 2 + ty ** 2 + tz ** 2",
      "mutated_line": "ld = tx ** -2 + ty ** 2 + tz ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** -2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ld = tx ** 2 + ty ** 2 + tz ** 2",
      "mutated_line": "ld = tx ** 2 + ty ** 3 + tz ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 3 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ld = tx ** 2 + ty ** 2 + tz ** 2",
      "mutated_line": "ld = tx ** 2 + ty ** 1 + tz ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 1 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ld = tx ** 2 + ty ** 2 + tz ** 2",
      "mutated_line": "ld = tx ** 2 + ty ** 0 + tz ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 0 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ld = tx ** 2 + ty ** 2 + tz ** 2",
      "mutated_line": "ld = tx ** 2 + ty ** 1 + tz ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 1 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ld = tx ** 2 + ty ** 2 + tz ** 2",
      "mutated_line": "ld = tx ** 2 + ty ** -2 + tz ** 2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** -2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2",
      "mutated_line": "dd1 = sx ** 2 - sy ** 2 + sz ** 2 <= sr2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 - sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2",
      "mutated_line": "dd1 = sx ** 2 * sy ** 2 + sz ** 2 <= sr2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 * sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2",
      "mutated_line": "dd1 = sx ** 2 + sy ** 2 + sz * 2 <= sr2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz * 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2",
      "mutated_line": "dd1 = sx ** 2 + sy ** 2 + (sz + 2) <= sr2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + (sz + 2) <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "elif dd1 == dd2 == 0:",
      "mutated_line": "elif dd1 == dd2 == 1:",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 1:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "elif dd1 == dd2 == 0:",
      "mutated_line": "elif dd1 == dd2 == -1:",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == -1:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "elif dd1 == dd2 == 0:",
      "mutated_line": "elif dd1 == dd2 == 1:",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 1:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:",
      "mutated_line": "if cross2(sx, sy, sz, tx, ty, tz) < sr2 * ld:",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) < sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:",
      "mutated_line": "if cross2(sx, sy, sz, tx, ty, tz) > sr2 * ld:",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) > sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:",
      "mutated_line": "if cross2(sx, sy, sz, tx, ty, tz) == sr2 * ld:",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) == sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "rem[i] |= 1 << j",
      "mutated_line": "rem[i] |= 2 << j",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 2 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "rem[i] |= 1 << j",
      "mutated_line": "rem[i] |= 0 << j",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 0 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "rem[i] |= 1 << j",
      "mutated_line": "rem[i] |= 0 << j",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 0 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "rem[i] |= 1 << j",
      "mutated_line": "rem[i] |= -1 << j",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= -1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]",
      "mutated_line": "L = [tb / (tx ** 3 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 3 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]",
      "mutated_line": "L = [tb / (tx ** 1 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 1 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]",
      "mutated_line": "L = [tb / (tx ** 0 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 0 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]",
      "mutated_line": "L = [tb / (tx ** 1 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 1 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]",
      "mutated_line": "L = [tb / (tx ** -2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** -2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]",
      "mutated_line": "L = [tb / (tx ** 2 + ty ** 3 + tz ** 2) for (tx, ty, tz, tb) in T]",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 3 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]",
      "mutated_line": "L = [tb / (tx ** 2 + ty ** 1 + tz ** 2) for (tx, ty, tz, tb) in T]",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 1 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]",
      "mutated_line": "L = [tb / (tx ** 2 + ty ** 0 + tz ** 2) for (tx, ty, tz, tb) in T]",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 0 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]",
      "mutated_line": "L = [tb / (tx ** 2 + ty ** 1 + tz ** 2) for (tx, ty, tz, tb) in T]",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 1 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]",
      "mutated_line": "L = [tb / (tx ** 2 + ty ** -2 + tz ** 2) for (tx, ty, tz, tb) in T]",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** -2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2",
      "mutated_line": "dd1 = sx * 2 + sy ** 2 + sz ** 2 <= sr2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx * 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2",
      "mutated_line": "dd1 = sx + 2 + sy ** 2 + sz ** 2 <= sr2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx + 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2",
      "mutated_line": "dd1 = sx ** 2 + sy * 2 + sz ** 2 <= sr2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy * 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2",
      "mutated_line": "dd1 = sx ** 2 + (sy + 2) + sz ** 2 <= sr2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + (sy + 2) + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2",
      "mutated_line": "dd1 = sx ** 2 + sy ** 2 + sz ** 3 <= sr2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 3 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2",
      "mutated_line": "dd1 = sx ** 2 + sy ** 2 + sz ** 1 <= sr2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 1 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2",
      "mutated_line": "dd1 = sx ** 2 + sy ** 2 + sz ** 0 <= sr2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 0 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2",
      "mutated_line": "dd1 = sx ** 2 + sy ** 2 + sz ** 1 <= sr2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 1 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2",
      "mutated_line": "dd1 = sx ** 2 + sy ** 2 + sz ** -2 <= sr2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** -2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:",
      "mutated_line": "if cross2(sx, sy, sz, tx, ty, tz) <= sr2 / ld:",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 / ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:",
      "mutated_line": "if cross2(sx, sy, sz, tx, ty, tz) <= sr2 + ld:",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 + ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:",
      "mutated_line": "if cross2(sx, sy, sz, tx, ty, tz) <= sr2 ** ld:",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 ** ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 37,
      "original_line": "if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:",
      "mutated_line": "if dot(sx, sy, sz, tx, ty, tz) >= 0 or dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 or dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2",
      "mutated_line": "dd1 = sx ** 3 + sy ** 2 + sz ** 2 <= sr2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 3 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2",
      "mutated_line": "dd1 = sx ** 1 + sy ** 2 + sz ** 2 <= sr2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 1 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2",
      "mutated_line": "dd1 = sx ** 0 + sy ** 2 + sz ** 2 <= sr2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 0 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2",
      "mutated_line": "dd1 = sx ** 1 + sy ** 2 + sz ** 2 <= sr2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 1 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2",
      "mutated_line": "dd1 = sx ** -2 + sy ** 2 + sz ** 2 <= sr2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** -2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2",
      "mutated_line": "dd1 = sx ** 2 + sy ** 3 + sz ** 2 <= sr2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 3 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2",
      "mutated_line": "dd1 = sx ** 2 + sy ** 1 + sz ** 2 <= sr2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 1 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2",
      "mutated_line": "dd1 = sx ** 2 + sy ** 0 + sz ** 2 <= sr2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 0 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2",
      "mutated_line": "dd1 = sx ** 2 + sy ** 1 + sz ** 2 <= sr2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 1 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2",
      "mutated_line": "dd1 = sx ** 2 + sy ** -2 + sz ** 2 <= sr2",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** -2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:",
      "mutated_line": "if dot(sx, sy, sz, tx, ty, tz) > 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) > 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:",
      "mutated_line": "if dot(sx, sy, sz, tx, ty, tz) < 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) < 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:",
      "mutated_line": "if dot(sx, sy, sz, tx, ty, tz) == 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) == 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:",
      "mutated_line": "if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) > 0:",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) > 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:",
      "mutated_line": "if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) < 0:",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) < 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:",
      "mutated_line": "if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) == 0:",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) == 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "ok = 0",
      "mutated_line": "ok = 1",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 1\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "ok = 0",
      "mutated_line": "ok = -1",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = -1\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "ok = 0",
      "mutated_line": "ok = 1",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 1\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:",
      "mutated_line": "if dot(sx, sy, sz, tx, ty, tz) >= 1 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 1 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:",
      "mutated_line": "if dot(sx, sy, sz, tx, ty, tz) >= -1 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= -1 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:",
      "mutated_line": "if dot(sx, sy, sz, tx, ty, tz) >= 1 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 1 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:",
      "mutated_line": "if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 1:",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 1:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:",
      "mutated_line": "if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= -1:",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= -1:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:",
      "mutated_line": "if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 1:",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 1:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:",
      "mutated_line": "if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx + sx, ty - sy, tz - sz, tx, ty, tz) >= 0:",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx + sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:",
      "mutated_line": "if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx * sx, ty - sy, tz - sz, tx, ty, tz) >= 0:",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx * sx, ty - sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:",
      "mutated_line": "if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty + sy, tz - sz, tx, ty, tz) >= 0:",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty + sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:",
      "mutated_line": "if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty * sy, tz - sz, tx, ty, tz) >= 0:",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty * sy, tz - sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:",
      "mutated_line": "if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz + sz, tx, ty, tz) >= 0:",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz + sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz - sz, tx, ty, tz) >= 0:",
      "mutated_line": "if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz * sz, tx, ty, tz) >= 0:",
      "code": "from itertools import product\n\ndef dist2(x0, y0, z0, x1, y1, z1):\n    return (x0 - x1) ** 2 + (y0 - y1) ** 2 + (z0 - z1) ** 2\n\ndef dot(x0, y0, z0, x1, y1, z1):\n    return x0 * x1 + y0 * y1 + z0 * z1\n\ndef cross2(x0, y0, z0, x1, y1, z1):\n    return (y0 * z1 - y1 * z0) ** 2 + (z0 * x1 - z1 * x0) ** 2 + (x0 * y1 - x1 * y0) ** 2\n\ndef maximize_illumination(N, M, R, balloons, lights, objective_point):\n    (ex, ey, ez) = objective_point\n    S = [(sx - ex, sy - ey, sz - ez, sr) for (sx, sy, sz, sr) in balloons]\n    T = [(tx - ex, ty - ey, tz - ez, tb) for (tx, ty, tz, tb) in lights]\n    L = [tb / (tx ** 2 + ty ** 2 + tz ** 2) for (tx, ty, tz, tb) in T]\n    rem = [0] * M\n    for i in range(M):\n        (tx, ty, tz, tb) = T[i]\n        ld = tx ** 2 + ty ** 2 + tz ** 2\n        for j in range(N):\n            (sx, sy, sz, sr) = S[j]\n            sr2 = sr ** 2\n            ok = 1\n            dd1 = sx ** 2 + sy ** 2 + sz ** 2 <= sr2\n            dd2 = dist2(sx, sy, sz, tx, ty, tz) <= sr2\n            if dd1 ^ dd2:\n                ok = 0\n            elif dd1 == dd2 == 0:\n                if cross2(sx, sy, sz, tx, ty, tz) <= sr2 * ld:\n                    if dot(sx, sy, sz, tx, ty, tz) >= 0 and dot(tx - sx, ty - sy, tz * sz, tx, ty, tz) >= 0:\n                        ok = 0\n            if not ok:\n                rem[i] |= 1 << j\n    ans = 0\n    for P in product([0, 1], repeat=M):\n        need = 0\n        for i in range(M):\n            if P[i]:\n                need |= rem[i]\n        if bin(need).count('1') <= R:\n            ans = max(ans, sum((L[i] for i in range(M) if P[i])))\n    return ans"
    }
  ]
}