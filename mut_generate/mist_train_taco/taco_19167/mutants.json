{
  "task_id": "taco_19167",
  "entry_point": "min_jumps_to_end",
  "mutant_count": 78,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if len(arr) == 1:",
      "mutated_line": "if len(arr) != 1:",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) != 1:\n        return 0\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [0]\n    other = [len(arr) - 1]\n    visited = {0}\n    visited2 = {len(arr) - 1}\n    step = 0\n    while curs:\n        if len(curs) > len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step + 1\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node - 1, node + 1]:\n                if child in visited2:\n                    return step + 1\n                if 0 <= child < len(arr) and child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "step = 0",
      "mutated_line": "step = 1",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == 1:\n        return 0\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [0]\n    other = [len(arr) - 1]\n    visited = {0}\n    visited2 = {len(arr) - 1}\n    step = 1\n    while curs:\n        if len(curs) > len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step + 1\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node - 1, node + 1]:\n                if child in visited2:\n                    return step + 1\n                if 0 <= child < len(arr) and child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "step = 0",
      "mutated_line": "step = -1",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == 1:\n        return 0\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [0]\n    other = [len(arr) - 1]\n    visited = {0}\n    visited2 = {len(arr) - 1}\n    step = -1\n    while curs:\n        if len(curs) > len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step + 1\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node - 1, node + 1]:\n                if child in visited2:\n                    return step + 1\n                if 0 <= child < len(arr) and child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "step = 0",
      "mutated_line": "step = 1",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == 1:\n        return 0\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [0]\n    other = [len(arr) - 1]\n    visited = {0}\n    visited2 = {len(arr) - 1}\n    step = 1\n    while curs:\n        if len(curs) > len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step + 1\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node - 1, node + 1]:\n                if child in visited2:\n                    return step + 1\n                if 0 <= child < len(arr) and child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += 1\n    return -1"
    },
    {
      "operator": "ASR",
      "lineno": 42,
      "original_line": "step += 1",
      "mutated_line": "step -= 1",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == 1:\n        return 0\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [0]\n    other = [len(arr) - 1]\n    visited = {0}\n    visited2 = {len(arr) - 1}\n    step = 0\n    while curs:\n        if len(curs) > len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step + 1\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node - 1, node + 1]:\n                if child in visited2:\n                    return step + 1\n                if 0 <= child < len(arr) and child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step -= 1\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 44,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == 1:\n        return 0\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [0]\n    other = [len(arr) - 1]\n    visited = {0}\n    visited2 = {len(arr) - 1}\n    step = 0\n    while curs:\n        if len(curs) > len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step + 1\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node - 1, node + 1]:\n                if child in visited2:\n                    return step + 1\n                if 0 <= child < len(arr) and child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += 1\n    return +1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if len(arr) == 1:",
      "mutated_line": "if len(arr) == 2:",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == 2:\n        return 0\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [0]\n    other = [len(arr) - 1]\n    visited = {0}\n    visited2 = {len(arr) - 1}\n    step = 0\n    while curs:\n        if len(curs) > len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step + 1\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node - 1, node + 1]:\n                if child in visited2:\n                    return step + 1\n                if 0 <= child < len(arr) and child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if len(arr) == 1:",
      "mutated_line": "if len(arr) == 0:",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == 0:\n        return 0\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [0]\n    other = [len(arr) - 1]\n    visited = {0}\n    visited2 = {len(arr) - 1}\n    step = 0\n    while curs:\n        if len(curs) > len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step + 1\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node - 1, node + 1]:\n                if child in visited2:\n                    return step + 1\n                if 0 <= child < len(arr) and child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if len(arr) == 1:",
      "mutated_line": "if len(arr) == 0:",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == 0:\n        return 0\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [0]\n    other = [len(arr) - 1]\n    visited = {0}\n    visited2 = {len(arr) - 1}\n    step = 0\n    while curs:\n        if len(curs) > len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step + 1\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node - 1, node + 1]:\n                if child in visited2:\n                    return step + 1\n                if 0 <= child < len(arr) and child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if len(arr) == 1:",
      "mutated_line": "if len(arr) == -1:",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == -1:\n        return 0\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [0]\n    other = [len(arr) - 1]\n    visited = {0}\n    visited2 = {len(arr) - 1}\n    step = 0\n    while curs:\n        if len(curs) > len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step + 1\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node - 1, node + 1]:\n                if child in visited2:\n                    return step + 1\n                if 0 <= child < len(arr) and child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == 1:\n        return 1\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [0]\n    other = [len(arr) - 1]\n    visited = {0}\n    visited2 = {len(arr) - 1}\n    step = 0\n    while curs:\n        if len(curs) > len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step + 1\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node - 1, node + 1]:\n                if child in visited2:\n                    return step + 1\n                if 0 <= child < len(arr) and child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == 1:\n        return -1\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [0]\n    other = [len(arr) - 1]\n    visited = {0}\n    visited2 = {len(arr) - 1}\n    step = 0\n    while curs:\n        if len(curs) > len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step + 1\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node - 1, node + 1]:\n                if child in visited2:\n                    return step + 1\n                if 0 <= child < len(arr) and child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == 1:\n        return 1\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [0]\n    other = [len(arr) - 1]\n    visited = {0}\n    visited2 = {len(arr) - 1}\n    step = 0\n    while curs:\n        if len(curs) > len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step + 1\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node - 1, node + 1]:\n                if child in visited2:\n                    return step + 1\n                if 0 <= child < len(arr) and child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if n in graph:",
      "mutated_line": "if n not in graph:",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == 1:\n        return 0\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n not in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [0]\n    other = [len(arr) - 1]\n    visited = {0}\n    visited2 = {len(arr) - 1}\n    step = 0\n    while curs:\n        if len(curs) > len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step + 1\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node - 1, node + 1]:\n                if child in visited2:\n                    return step + 1\n                if 0 <= child < len(arr) and child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "curs = [0]",
      "mutated_line": "curs = [1]",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == 1:\n        return 0\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [1]\n    other = [len(arr) - 1]\n    visited = {0}\n    visited2 = {len(arr) - 1}\n    step = 0\n    while curs:\n        if len(curs) > len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step + 1\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node - 1, node + 1]:\n                if child in visited2:\n                    return step + 1\n                if 0 <= child < len(arr) and child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "curs = [0]",
      "mutated_line": "curs = [-1]",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == 1:\n        return 0\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [-1]\n    other = [len(arr) - 1]\n    visited = {0}\n    visited2 = {len(arr) - 1}\n    step = 0\n    while curs:\n        if len(curs) > len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step + 1\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node - 1, node + 1]:\n                if child in visited2:\n                    return step + 1\n                if 0 <= child < len(arr) and child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "curs = [0]",
      "mutated_line": "curs = [1]",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == 1:\n        return 0\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [1]\n    other = [len(arr) - 1]\n    visited = {0}\n    visited2 = {len(arr) - 1}\n    step = 0\n    while curs:\n        if len(curs) > len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step + 1\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node - 1, node + 1]:\n                if child in visited2:\n                    return step + 1\n                if 0 <= child < len(arr) and child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "other = [len(arr) - 1]",
      "mutated_line": "other = [len(arr) + 1]",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == 1:\n        return 0\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [0]\n    other = [len(arr) + 1]\n    visited = {0}\n    visited2 = {len(arr) - 1}\n    step = 0\n    while curs:\n        if len(curs) > len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step + 1\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node - 1, node + 1]:\n                if child in visited2:\n                    return step + 1\n                if 0 <= child < len(arr) and child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "other = [len(arr) - 1]",
      "mutated_line": "other = [len(arr) * 1]",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == 1:\n        return 0\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [0]\n    other = [len(arr) * 1]\n    visited = {0}\n    visited2 = {len(arr) - 1}\n    step = 0\n    while curs:\n        if len(curs) > len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step + 1\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node - 1, node + 1]:\n                if child in visited2:\n                    return step + 1\n                if 0 <= child < len(arr) and child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "visited = {0}",
      "mutated_line": "visited = {1}",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == 1:\n        return 0\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [0]\n    other = [len(arr) - 1]\n    visited = {1}\n    visited2 = {len(arr) - 1}\n    step = 0\n    while curs:\n        if len(curs) > len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step + 1\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node - 1, node + 1]:\n                if child in visited2:\n                    return step + 1\n                if 0 <= child < len(arr) and child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "visited = {0}",
      "mutated_line": "visited = {-1}",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == 1:\n        return 0\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [0]\n    other = [len(arr) - 1]\n    visited = {-1}\n    visited2 = {len(arr) - 1}\n    step = 0\n    while curs:\n        if len(curs) > len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step + 1\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node - 1, node + 1]:\n                if child in visited2:\n                    return step + 1\n                if 0 <= child < len(arr) and child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "visited = {0}",
      "mutated_line": "visited = {1}",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == 1:\n        return 0\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [0]\n    other = [len(arr) - 1]\n    visited = {1}\n    visited2 = {len(arr) - 1}\n    step = 0\n    while curs:\n        if len(curs) > len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step + 1\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node - 1, node + 1]:\n                if child in visited2:\n                    return step + 1\n                if 0 <= child < len(arr) and child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "visited2 = {len(arr) - 1}",
      "mutated_line": "visited2 = {len(arr) + 1}",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == 1:\n        return 0\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [0]\n    other = [len(arr) - 1]\n    visited = {0}\n    visited2 = {len(arr) + 1}\n    step = 0\n    while curs:\n        if len(curs) > len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step + 1\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node - 1, node + 1]:\n                if child in visited2:\n                    return step + 1\n                if 0 <= child < len(arr) and child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "visited2 = {len(arr) - 1}",
      "mutated_line": "visited2 = {len(arr) * 1}",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == 1:\n        return 0\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [0]\n    other = [len(arr) - 1]\n    visited = {0}\n    visited2 = {len(arr) * 1}\n    step = 0\n    while curs:\n        if len(curs) > len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step + 1\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node - 1, node + 1]:\n                if child in visited2:\n                    return step + 1\n                if 0 <= child < len(arr) and child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if len(curs) > len(other):",
      "mutated_line": "if len(curs) >= len(other):",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == 1:\n        return 0\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [0]\n    other = [len(arr) - 1]\n    visited = {0}\n    visited2 = {len(arr) - 1}\n    step = 0\n    while curs:\n        if len(curs) >= len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step + 1\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node - 1, node + 1]:\n                if child in visited2:\n                    return step + 1\n                if 0 <= child < len(arr) and child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if len(curs) > len(other):",
      "mutated_line": "if len(curs) <= len(other):",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == 1:\n        return 0\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [0]\n    other = [len(arr) - 1]\n    visited = {0}\n    visited2 = {len(arr) - 1}\n    step = 0\n    while curs:\n        if len(curs) <= len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step + 1\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node - 1, node + 1]:\n                if child in visited2:\n                    return step + 1\n                if 0 <= child < len(arr) and child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if len(curs) > len(other):",
      "mutated_line": "if len(curs) != len(other):",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == 1:\n        return 0\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [0]\n    other = [len(arr) - 1]\n    visited = {0}\n    visited2 = {len(arr) - 1}\n    step = 0\n    while curs:\n        if len(curs) != len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step + 1\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node - 1, node + 1]:\n                if child in visited2:\n                    return step + 1\n                if 0 <= child < len(arr) and child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "step += 1",
      "mutated_line": "step += 2",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == 1:\n        return 0\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [0]\n    other = [len(arr) - 1]\n    visited = {0}\n    visited2 = {len(arr) - 1}\n    step = 0\n    while curs:\n        if len(curs) > len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step + 1\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node - 1, node + 1]:\n                if child in visited2:\n                    return step + 1\n                if 0 <= child < len(arr) and child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += 2\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "step += 1",
      "mutated_line": "step += 0",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == 1:\n        return 0\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [0]\n    other = [len(arr) - 1]\n    visited = {0}\n    visited2 = {len(arr) - 1}\n    step = 0\n    while curs:\n        if len(curs) > len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step + 1\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node - 1, node + 1]:\n                if child in visited2:\n                    return step + 1\n                if 0 <= child < len(arr) and child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "step += 1",
      "mutated_line": "step += 0",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == 1:\n        return 0\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [0]\n    other = [len(arr) - 1]\n    visited = {0}\n    visited2 = {len(arr) - 1}\n    step = 0\n    while curs:\n        if len(curs) > len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step + 1\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node - 1, node + 1]:\n                if child in visited2:\n                    return step + 1\n                if 0 <= child < len(arr) and child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "step += 1",
      "mutated_line": "step += -1",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == 1:\n        return 0\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [0]\n    other = [len(arr) - 1]\n    visited = {0}\n    visited2 = {len(arr) - 1}\n    step = 0\n    while curs:\n        if len(curs) > len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step + 1\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node - 1, node + 1]:\n                if child in visited2:\n                    return step + 1\n                if 0 <= child < len(arr) and child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += -1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == 1:\n        return 0\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [0]\n    other = [len(arr) - 1]\n    visited = {0}\n    visited2 = {len(arr) - 1}\n    step = 0\n    while curs:\n        if len(curs) > len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step + 1\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node - 1, node + 1]:\n                if child in visited2:\n                    return step + 1\n                if 0 <= child < len(arr) and child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += 1\n    return -2"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == 1:\n        return 0\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [0]\n    other = [len(arr) - 1]\n    visited = {0}\n    visited2 = {len(arr) - 1}\n    step = 0\n    while curs:\n        if len(curs) > len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step + 1\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node - 1, node + 1]:\n                if child in visited2:\n                    return step + 1\n                if 0 <= child < len(arr) and child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += 1\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == 1:\n        return 0\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [0]\n    other = [len(arr) - 1]\n    visited = {0}\n    visited2 = {len(arr) - 1}\n    step = 0\n    while curs:\n        if len(curs) > len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step + 1\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node - 1, node + 1]:\n                if child in visited2:\n                    return step + 1\n                if 0 <= child < len(arr) and child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += 1\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == 1:\n        return 0\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [0]\n    other = [len(arr) - 1]\n    visited = {0}\n    visited2 = {len(arr) - 1}\n    step = 0\n    while curs:\n        if len(curs) > len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step + 1\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node - 1, node + 1]:\n                if child in visited2:\n                    return step + 1\n                if 0 <= child < len(arr) and child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += 1\n    return --1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "other = [len(arr) - 1]",
      "mutated_line": "other = [len(arr) - 2]",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == 1:\n        return 0\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [0]\n    other = [len(arr) - 2]\n    visited = {0}\n    visited2 = {len(arr) - 1}\n    step = 0\n    while curs:\n        if len(curs) > len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step + 1\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node - 1, node + 1]:\n                if child in visited2:\n                    return step + 1\n                if 0 <= child < len(arr) and child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "other = [len(arr) - 1]",
      "mutated_line": "other = [len(arr) - 0]",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == 1:\n        return 0\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [0]\n    other = [len(arr) - 0]\n    visited = {0}\n    visited2 = {len(arr) - 1}\n    step = 0\n    while curs:\n        if len(curs) > len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step + 1\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node - 1, node + 1]:\n                if child in visited2:\n                    return step + 1\n                if 0 <= child < len(arr) and child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "other = [len(arr) - 1]",
      "mutated_line": "other = [len(arr) - 0]",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == 1:\n        return 0\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [0]\n    other = [len(arr) - 0]\n    visited = {0}\n    visited2 = {len(arr) - 1}\n    step = 0\n    while curs:\n        if len(curs) > len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step + 1\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node - 1, node + 1]:\n                if child in visited2:\n                    return step + 1\n                if 0 <= child < len(arr) and child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "other = [len(arr) - 1]",
      "mutated_line": "other = [len(arr) - -1]",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == 1:\n        return 0\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [0]\n    other = [len(arr) - -1]\n    visited = {0}\n    visited2 = {len(arr) - 1}\n    step = 0\n    while curs:\n        if len(curs) > len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step + 1\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node - 1, node + 1]:\n                if child in visited2:\n                    return step + 1\n                if 0 <= child < len(arr) and child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "visited2 = {len(arr) - 1}",
      "mutated_line": "visited2 = {len(arr) - 2}",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == 1:\n        return 0\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [0]\n    other = [len(arr) - 1]\n    visited = {0}\n    visited2 = {len(arr) - 2}\n    step = 0\n    while curs:\n        if len(curs) > len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step + 1\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node - 1, node + 1]:\n                if child in visited2:\n                    return step + 1\n                if 0 <= child < len(arr) and child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "visited2 = {len(arr) - 1}",
      "mutated_line": "visited2 = {len(arr) - 0}",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == 1:\n        return 0\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [0]\n    other = [len(arr) - 1]\n    visited = {0}\n    visited2 = {len(arr) - 0}\n    step = 0\n    while curs:\n        if len(curs) > len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step + 1\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node - 1, node + 1]:\n                if child in visited2:\n                    return step + 1\n                if 0 <= child < len(arr) and child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "visited2 = {len(arr) - 1}",
      "mutated_line": "visited2 = {len(arr) - 0}",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == 1:\n        return 0\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [0]\n    other = [len(arr) - 1]\n    visited = {0}\n    visited2 = {len(arr) - 0}\n    step = 0\n    while curs:\n        if len(curs) > len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step + 1\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node - 1, node + 1]:\n                if child in visited2:\n                    return step + 1\n                if 0 <= child < len(arr) and child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "visited2 = {len(arr) - 1}",
      "mutated_line": "visited2 = {len(arr) - -1}",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == 1:\n        return 0\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [0]\n    other = [len(arr) - 1]\n    visited = {0}\n    visited2 = {len(arr) - -1}\n    step = 0\n    while curs:\n        if len(curs) > len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step + 1\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node - 1, node + 1]:\n                if child in visited2:\n                    return step + 1\n                if 0 <= child < len(arr) and child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if child in visited2:",
      "mutated_line": "if child not in visited2:",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == 1:\n        return 0\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [0]\n    other = [len(arr) - 1]\n    visited = {0}\n    visited2 = {len(arr) - 1}\n    step = 0\n    while curs:\n        if len(curs) > len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child not in visited2:\n                    return step + 1\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node - 1, node + 1]:\n                if child in visited2:\n                    return step + 1\n                if 0 <= child < len(arr) and child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if child not in visited:",
      "mutated_line": "if child in visited:",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == 1:\n        return 0\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [0]\n    other = [len(arr) - 1]\n    visited = {0}\n    visited2 = {len(arr) - 1}\n    step = 0\n    while curs:\n        if len(curs) > len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step + 1\n                if child in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node - 1, node + 1]:\n                if child in visited2:\n                    return step + 1\n                if 0 <= child < len(arr) and child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "for child in [node - 1, node + 1]:",
      "mutated_line": "for child in [node + 1, node + 1]:",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == 1:\n        return 0\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [0]\n    other = [len(arr) - 1]\n    visited = {0}\n    visited2 = {len(arr) - 1}\n    step = 0\n    while curs:\n        if len(curs) > len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step + 1\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node + 1, node + 1]:\n                if child in visited2:\n                    return step + 1\n                if 0 <= child < len(arr) and child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "for child in [node - 1, node + 1]:",
      "mutated_line": "for child in [node * 1, node + 1]:",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == 1:\n        return 0\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [0]\n    other = [len(arr) - 1]\n    visited = {0}\n    visited2 = {len(arr) - 1}\n    step = 0\n    while curs:\n        if len(curs) > len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step + 1\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node * 1, node + 1]:\n                if child in visited2:\n                    return step + 1\n                if 0 <= child < len(arr) and child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "for child in [node - 1, node + 1]:",
      "mutated_line": "for child in [node - 1, node - 1]:",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == 1:\n        return 0\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [0]\n    other = [len(arr) - 1]\n    visited = {0}\n    visited2 = {len(arr) - 1}\n    step = 0\n    while curs:\n        if len(curs) > len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step + 1\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node - 1, node - 1]:\n                if child in visited2:\n                    return step + 1\n                if 0 <= child < len(arr) and child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "for child in [node - 1, node + 1]:",
      "mutated_line": "for child in [node - 1, node * 1]:",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == 1:\n        return 0\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [0]\n    other = [len(arr) - 1]\n    visited = {0}\n    visited2 = {len(arr) - 1}\n    step = 0\n    while curs:\n        if len(curs) > len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step + 1\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node - 1, node * 1]:\n                if child in visited2:\n                    return step + 1\n                if 0 <= child < len(arr) and child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if child in visited2:",
      "mutated_line": "if child not in visited2:",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == 1:\n        return 0\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [0]\n    other = [len(arr) - 1]\n    visited = {0}\n    visited2 = {len(arr) - 1}\n    step = 0\n    while curs:\n        if len(curs) > len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step + 1\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node - 1, node + 1]:\n                if child not in visited2:\n                    return step + 1\n                if 0 <= child < len(arr) and child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += 1\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 37,
      "original_line": "if 0 <= child < len(arr) and child not in visited:",
      "mutated_line": "if 0 <= child < len(arr) or child not in visited:",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == 1:\n        return 0\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [0]\n    other = [len(arr) - 1]\n    visited = {0}\n    visited2 = {len(arr) - 1}\n    step = 0\n    while curs:\n        if len(curs) > len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step + 1\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node - 1, node + 1]:\n                if child in visited2:\n                    return step + 1\n                if 0 <= child < len(arr) or child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return step + 1",
      "mutated_line": "return step - 1",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == 1:\n        return 0\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [0]\n    other = [len(arr) - 1]\n    visited = {0}\n    visited2 = {len(arr) - 1}\n    step = 0\n    while curs:\n        if len(curs) > len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step - 1\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node - 1, node + 1]:\n                if child in visited2:\n                    return step + 1\n                if 0 <= child < len(arr) and child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return step + 1",
      "mutated_line": "return step * 1",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == 1:\n        return 0\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [0]\n    other = [len(arr) - 1]\n    visited = {0}\n    visited2 = {len(arr) - 1}\n    step = 0\n    while curs:\n        if len(curs) > len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step * 1\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node - 1, node + 1]:\n                if child in visited2:\n                    return step + 1\n                if 0 <= child < len(arr) and child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for child in [node - 1, node + 1]:",
      "mutated_line": "for child in [node - 2, node + 1]:",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == 1:\n        return 0\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [0]\n    other = [len(arr) - 1]\n    visited = {0}\n    visited2 = {len(arr) - 1}\n    step = 0\n    while curs:\n        if len(curs) > len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step + 1\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node - 2, node + 1]:\n                if child in visited2:\n                    return step + 1\n                if 0 <= child < len(arr) and child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for child in [node - 1, node + 1]:",
      "mutated_line": "for child in [node - 0, node + 1]:",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == 1:\n        return 0\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [0]\n    other = [len(arr) - 1]\n    visited = {0}\n    visited2 = {len(arr) - 1}\n    step = 0\n    while curs:\n        if len(curs) > len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step + 1\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node - 0, node + 1]:\n                if child in visited2:\n                    return step + 1\n                if 0 <= child < len(arr) and child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for child in [node - 1, node + 1]:",
      "mutated_line": "for child in [node - 0, node + 1]:",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == 1:\n        return 0\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [0]\n    other = [len(arr) - 1]\n    visited = {0}\n    visited2 = {len(arr) - 1}\n    step = 0\n    while curs:\n        if len(curs) > len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step + 1\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node - 0, node + 1]:\n                if child in visited2:\n                    return step + 1\n                if 0 <= child < len(arr) and child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for child in [node - 1, node + 1]:",
      "mutated_line": "for child in [node - -1, node + 1]:",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == 1:\n        return 0\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [0]\n    other = [len(arr) - 1]\n    visited = {0}\n    visited2 = {len(arr) - 1}\n    step = 0\n    while curs:\n        if len(curs) > len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step + 1\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node - -1, node + 1]:\n                if child in visited2:\n                    return step + 1\n                if 0 <= child < len(arr) and child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for child in [node - 1, node + 1]:",
      "mutated_line": "for child in [node - 1, node + 2]:",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == 1:\n        return 0\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [0]\n    other = [len(arr) - 1]\n    visited = {0}\n    visited2 = {len(arr) - 1}\n    step = 0\n    while curs:\n        if len(curs) > len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step + 1\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node - 1, node + 2]:\n                if child in visited2:\n                    return step + 1\n                if 0 <= child < len(arr) and child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for child in [node - 1, node + 1]:",
      "mutated_line": "for child in [node - 1, node + 0]:",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == 1:\n        return 0\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [0]\n    other = [len(arr) - 1]\n    visited = {0}\n    visited2 = {len(arr) - 1}\n    step = 0\n    while curs:\n        if len(curs) > len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step + 1\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node - 1, node + 0]:\n                if child in visited2:\n                    return step + 1\n                if 0 <= child < len(arr) and child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for child in [node - 1, node + 1]:",
      "mutated_line": "for child in [node - 1, node + 0]:",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == 1:\n        return 0\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [0]\n    other = [len(arr) - 1]\n    visited = {0}\n    visited2 = {len(arr) - 1}\n    step = 0\n    while curs:\n        if len(curs) > len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step + 1\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node - 1, node + 0]:\n                if child in visited2:\n                    return step + 1\n                if 0 <= child < len(arr) and child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for child in [node - 1, node + 1]:",
      "mutated_line": "for child in [node - 1, node + -1]:",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == 1:\n        return 0\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [0]\n    other = [len(arr) - 1]\n    visited = {0}\n    visited2 = {len(arr) - 1}\n    step = 0\n    while curs:\n        if len(curs) > len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step + 1\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node - 1, node + -1]:\n                if child in visited2:\n                    return step + 1\n                if 0 <= child < len(arr) and child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "return step + 1",
      "mutated_line": "return step - 1",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == 1:\n        return 0\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [0]\n    other = [len(arr) - 1]\n    visited = {0}\n    visited2 = {len(arr) - 1}\n    step = 0\n    while curs:\n        if len(curs) > len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step + 1\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node - 1, node + 1]:\n                if child in visited2:\n                    return step - 1\n                if 0 <= child < len(arr) and child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "return step + 1",
      "mutated_line": "return step * 1",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == 1:\n        return 0\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [0]\n    other = [len(arr) - 1]\n    visited = {0}\n    visited2 = {len(arr) - 1}\n    step = 0\n    while curs:\n        if len(curs) > len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step + 1\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node - 1, node + 1]:\n                if child in visited2:\n                    return step * 1\n                if 0 <= child < len(arr) and child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if 0 <= child < len(arr) and child not in visited:",
      "mutated_line": "if 0 < child < len(arr) and child not in visited:",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == 1:\n        return 0\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [0]\n    other = [len(arr) - 1]\n    visited = {0}\n    visited2 = {len(arr) - 1}\n    step = 0\n    while curs:\n        if len(curs) > len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step + 1\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node - 1, node + 1]:\n                if child in visited2:\n                    return step + 1\n                if 0 < child < len(arr) and child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if 0 <= child < len(arr) and child not in visited:",
      "mutated_line": "if 0 > child < len(arr) and child not in visited:",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == 1:\n        return 0\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [0]\n    other = [len(arr) - 1]\n    visited = {0}\n    visited2 = {len(arr) - 1}\n    step = 0\n    while curs:\n        if len(curs) > len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step + 1\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node - 1, node + 1]:\n                if child in visited2:\n                    return step + 1\n                if 0 > child < len(arr) and child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if 0 <= child < len(arr) and child not in visited:",
      "mutated_line": "if 0 == child < len(arr) and child not in visited:",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == 1:\n        return 0\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [0]\n    other = [len(arr) - 1]\n    visited = {0}\n    visited2 = {len(arr) - 1}\n    step = 0\n    while curs:\n        if len(curs) > len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step + 1\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node - 1, node + 1]:\n                if child in visited2:\n                    return step + 1\n                if 0 == child < len(arr) and child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if 0 <= child < len(arr) and child not in visited:",
      "mutated_line": "if 0 <= child < len(arr) and child in visited:",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == 1:\n        return 0\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [0]\n    other = [len(arr) - 1]\n    visited = {0}\n    visited2 = {len(arr) - 1}\n    step = 0\n    while curs:\n        if len(curs) > len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step + 1\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node - 1, node + 1]:\n                if child in visited2:\n                    return step + 1\n                if 0 <= child < len(arr) and child in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return step + 1",
      "mutated_line": "return step + 2",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == 1:\n        return 0\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [0]\n    other = [len(arr) - 1]\n    visited = {0}\n    visited2 = {len(arr) - 1}\n    step = 0\n    while curs:\n        if len(curs) > len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step + 2\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node - 1, node + 1]:\n                if child in visited2:\n                    return step + 1\n                if 0 <= child < len(arr) and child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return step + 1",
      "mutated_line": "return step + 0",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == 1:\n        return 0\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [0]\n    other = [len(arr) - 1]\n    visited = {0}\n    visited2 = {len(arr) - 1}\n    step = 0\n    while curs:\n        if len(curs) > len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step + 0\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node - 1, node + 1]:\n                if child in visited2:\n                    return step + 1\n                if 0 <= child < len(arr) and child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return step + 1",
      "mutated_line": "return step + 0",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == 1:\n        return 0\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [0]\n    other = [len(arr) - 1]\n    visited = {0}\n    visited2 = {len(arr) - 1}\n    step = 0\n    while curs:\n        if len(curs) > len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step + 0\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node - 1, node + 1]:\n                if child in visited2:\n                    return step + 1\n                if 0 <= child < len(arr) and child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return step + 1",
      "mutated_line": "return step + -1",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == 1:\n        return 0\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [0]\n    other = [len(arr) - 1]\n    visited = {0}\n    visited2 = {len(arr) - 1}\n    step = 0\n    while curs:\n        if len(curs) > len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step + -1\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node - 1, node + 1]:\n                if child in visited2:\n                    return step + 1\n                if 0 <= child < len(arr) and child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return step + 1",
      "mutated_line": "return step + 2",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == 1:\n        return 0\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [0]\n    other = [len(arr) - 1]\n    visited = {0}\n    visited2 = {len(arr) - 1}\n    step = 0\n    while curs:\n        if len(curs) > len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step + 1\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node - 1, node + 1]:\n                if child in visited2:\n                    return step + 2\n                if 0 <= child < len(arr) and child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return step + 1",
      "mutated_line": "return step + 0",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == 1:\n        return 0\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [0]\n    other = [len(arr) - 1]\n    visited = {0}\n    visited2 = {len(arr) - 1}\n    step = 0\n    while curs:\n        if len(curs) > len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step + 1\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node - 1, node + 1]:\n                if child in visited2:\n                    return step + 0\n                if 0 <= child < len(arr) and child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return step + 1",
      "mutated_line": "return step + 0",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == 1:\n        return 0\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [0]\n    other = [len(arr) - 1]\n    visited = {0}\n    visited2 = {len(arr) - 1}\n    step = 0\n    while curs:\n        if len(curs) > len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step + 1\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node - 1, node + 1]:\n                if child in visited2:\n                    return step + 0\n                if 0 <= child < len(arr) and child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return step + 1",
      "mutated_line": "return step + -1",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == 1:\n        return 0\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [0]\n    other = [len(arr) - 1]\n    visited = {0}\n    visited2 = {len(arr) - 1}\n    step = 0\n    while curs:\n        if len(curs) > len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step + 1\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node - 1, node + 1]:\n                if child in visited2:\n                    return step + -1\n                if 0 <= child < len(arr) and child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if 0 <= child < len(arr) and child not in visited:",
      "mutated_line": "if 1 <= child < len(arr) and child not in visited:",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == 1:\n        return 0\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [0]\n    other = [len(arr) - 1]\n    visited = {0}\n    visited2 = {len(arr) - 1}\n    step = 0\n    while curs:\n        if len(curs) > len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step + 1\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node - 1, node + 1]:\n                if child in visited2:\n                    return step + 1\n                if 1 <= child < len(arr) and child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if 0 <= child < len(arr) and child not in visited:",
      "mutated_line": "if -1 <= child < len(arr) and child not in visited:",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == 1:\n        return 0\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [0]\n    other = [len(arr) - 1]\n    visited = {0}\n    visited2 = {len(arr) - 1}\n    step = 0\n    while curs:\n        if len(curs) > len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step + 1\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node - 1, node + 1]:\n                if child in visited2:\n                    return step + 1\n                if -1 <= child < len(arr) and child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if 0 <= child < len(arr) and child not in visited:",
      "mutated_line": "if 1 <= child < len(arr) and child not in visited:",
      "code": "from collections import deque\n\ndef min_jumps_to_end(arr: list) -> int:\n    if len(arr) == 1:\n        return 0\n    graph = {}\n    for (i, n) in enumerate(arr):\n        if n in graph:\n            graph[n].append(i)\n        else:\n            graph[n] = [i]\n    curs = [0]\n    other = [len(arr) - 1]\n    visited = {0}\n    visited2 = {len(arr) - 1}\n    step = 0\n    while curs:\n        if len(curs) > len(other):\n            (curs, other) = (other, curs)\n            (visited, visited2) = (visited2, visited)\n        nex = []\n        for node in curs:\n            for child in graph[arr[node]]:\n                if child in visited2:\n                    return step + 1\n                if child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n            for child in [node - 1, node + 1]:\n                if child in visited2:\n                    return step + 1\n                if 1 <= child < len(arr) and child not in visited:\n                    visited.add(child)\n                    nex.append(child)\n        curs = nex\n        step += 1\n    return -1"
    }
  ]
}