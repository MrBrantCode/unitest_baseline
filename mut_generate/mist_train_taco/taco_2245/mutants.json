{
  "task_id": "taco_2245",
  "entry_point": "getsum",
  "mutant_count": 117,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 9 - 7",
      "code": "import collections\nmod = 10 ** 9 - 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 9 * 7",
      "code": "import collections\nmod = 10 ** 9 * 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "ASR",
      "lineno": 14,
      "original_line": "i += 1",
      "mutated_line": "i -= 1",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i -= 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 * 9 + 7",
      "code": "import collections\nmod = 10 * 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 + 9 + 7",
      "code": "import collections\nmod = 10 + 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 9 + 8",
      "code": "import collections\nmod = 10 ** 9 + 8\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 9 + 6",
      "code": "import collections\nmod = 10 ** 9 + 6\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 9 + 0",
      "code": "import collections\nmod = 10 ** 9 + 0\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 9 + 1",
      "code": "import collections\nmod = 10 ** 9 + 1\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 9 + -7",
      "code": "import collections\nmod = 10 ** 9 + -7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "s = 0",
      "mutated_line": "s = 1",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 1\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "s = 0",
      "mutated_line": "s = -1",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = -1\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "s = 0",
      "mutated_line": "s = 1",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 1\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "i = i + 1",
      "mutated_line": "i = i - 1",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i - 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "i = i + 1",
      "mutated_line": "i = i * 1",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i * 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "while i > 0:",
      "mutated_line": "while i >= 0:",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i >= 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "while i > 0:",
      "mutated_line": "while i <= 0:",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i <= 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "while i > 0:",
      "mutated_line": "while i != 0:",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i != 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "ASR",
      "lineno": 9,
      "original_line": "s += BITTree[i]",
      "mutated_line": "s -= BITTree[i]",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s -= BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "ASR",
      "lineno": 10,
      "original_line": "i -= i & -i",
      "mutated_line": "i += i & -i",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i += i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "i += 1",
      "mutated_line": "i += 2",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 2\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 0\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 0\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "i += 1",
      "mutated_line": "i += -1",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += -1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "while i <= n:",
      "mutated_line": "while i < n:",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i < n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "while i <= n:",
      "mutated_line": "while i > n:",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i > n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "while i <= n:",
      "mutated_line": "while i == n:",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i == n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "ASR",
      "lineno": 16,
      "original_line": "BITTree[i] += v",
      "mutated_line": "BITTree[i] -= v",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] -= v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "ASR",
      "lineno": 17,
      "original_line": "i += i & -i",
      "mutated_line": "i -= i & -i",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i -= i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "BITTree = [0] * (n + 1)",
      "mutated_line": "BITTree = [0] / (n + 1)",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] / (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "BITTree = [0] * (n + 1)",
      "mutated_line": "BITTree = [0] + (n + 1)",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] + (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "BITTree = [0] * (n + 1)",
      "mutated_line": "BITTree = [0] ** (n + 1)",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] ** (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "arr = [0] * n",
      "mutated_line": "arr = [0] / n",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] / n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "arr = [0] * n",
      "mutated_line": "arr = [0] + n",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] + n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "arr = [0] * n",
      "mutated_line": "arr = [0] ** n",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] ** n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 11 ** 9 + 7",
      "code": "import collections\nmod = 11 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 9 ** 9 + 7",
      "code": "import collections\nmod = 9 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 0 ** 9 + 7",
      "code": "import collections\nmod = 0 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 1 ** 9 + 7",
      "code": "import collections\nmod = 1 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = -10 ** 9 + 7",
      "code": "import collections\nmod = -10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 10 + 7",
      "code": "import collections\nmod = 10 ** 10 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 8 + 7",
      "code": "import collections\nmod = 10 ** 8 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 0 + 7",
      "code": "import collections\nmod = 10 ** 0 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 1 + 7",
      "code": "import collections\nmod = 10 ** 1 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** -9 + 7",
      "code": "import collections\nmod = 10 ** -9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "i = i + 1",
      "mutated_line": "i = i + 2",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 2\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "i = i + 1",
      "mutated_line": "i = i + 0",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 0\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "i = i + 1",
      "mutated_line": "i = i + 0",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 0\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "i = i + 1",
      "mutated_line": "i = i + -1",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + -1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while i > 0:",
      "mutated_line": "while i > 1:",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 1:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while i > 0:",
      "mutated_line": "while i > -1:",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > -1:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while i > 0:",
      "mutated_line": "while i > 1:",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 1:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "i -= i & -i",
      "mutated_line": "i -= i | -i",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i | -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "i += i & -i",
      "mutated_line": "i += i | -i",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i | -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "BITTree = [0] * (n + 1)",
      "mutated_line": "BITTree = [0] * (n - 1)",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n - 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "BITTree = [0] * (n + 1)",
      "mutated_line": "BITTree = [0] * (n * 1)",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n * 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if i in lh:",
      "mutated_line": "if i not in lh:",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i not in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(1, C + 1):",
      "mutated_line": "for i in range(2, C + 1):",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(2, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(1, C + 1):",
      "mutated_line": "for i in range(0, C + 1):",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(0, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(1, C + 1):",
      "mutated_line": "for i in range(0, C + 1):",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(0, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(1, C + 1):",
      "mutated_line": "for i in range(-1, C + 1):",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(-1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "for i in range(1, C + 1):",
      "mutated_line": "for i in range(1, C - 1):",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C - 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "for i in range(1, C + 1):",
      "mutated_line": "for i in range(1, C * 1):",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C * 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if i + 1 <= n:",
      "mutated_line": "if i + 1 < n:",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 < n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if i + 1 <= n:",
      "mutated_line": "if i + 1 > n:",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 > n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if i + 1 <= n:",
      "mutated_line": "if i + 1 == n:",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 == n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 10,
      "original_line": "i -= i & -i",
      "mutated_line": "i -= i & +i",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & +i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "i += i & -i",
      "mutated_line": "i += i & +i",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & +i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "BITTree = [0] * (n + 1)",
      "mutated_line": "BITTree = [1] * (n + 1)",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [1] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "BITTree = [0] * (n + 1)",
      "mutated_line": "BITTree = [-1] * (n + 1)",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [-1] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "BITTree = [0] * (n + 1)",
      "mutated_line": "BITTree = [1] * (n + 1)",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [1] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "BITTree = [0] * (n + 1)",
      "mutated_line": "BITTree = [0] * (n + 2)",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 2)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "BITTree = [0] * (n + 1)",
      "mutated_line": "BITTree = [0] * (n + 0)",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 0)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "BITTree = [0] * (n + 1)",
      "mutated_line": "BITTree = [0] * (n + 0)",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 0)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "BITTree = [0] * (n + 1)",
      "mutated_line": "BITTree = [0] * (n + -1)",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + -1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "freq = [i[1] for i in l]",
      "mutated_line": "freq = [i[2] for i in l]",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[2] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "freq = [i[1] for i in l]",
      "mutated_line": "freq = [i[0] for i in l]",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[0] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "freq = [i[1] for i in l]",
      "mutated_line": "freq = [i[0] for i in l]",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[0] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "freq = [i[1] for i in l]",
      "mutated_line": "freq = [i[-1] for i in l]",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[-1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "arr = [0] * n",
      "mutated_line": "arr = [1] * n",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [1] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "arr = [0] * n",
      "mutated_line": "arr = [-1] * n",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [-1] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "arr = [0] * n",
      "mutated_line": "arr = [1] * n",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [1] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(1, C + 1):",
      "mutated_line": "for i in range(1, C + 2):",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 2):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(1, C + 1):",
      "mutated_line": "for i in range(1, C + 0):",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 0):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(1, C + 1):",
      "mutated_line": "for i in range(1, C + 0):",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 0):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(1, C + 1):",
      "mutated_line": "for i in range(1, C + -1):",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + -1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "if i + 1 <= n:",
      "mutated_line": "if i - 1 <= n:",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i - 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "if i + 1 <= n:",
      "mutated_line": "if i * 1 <= n:",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i * 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if i + 1 <= n:",
      "mutated_line": "if i + 2 <= n:",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 2 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if i + 1 <= n:",
      "mutated_line": "if i + 0 <= n:",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 0 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if i + 1 <= n:",
      "mutated_line": "if i + 0 <= n:",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 0 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if i + 1 <= n:",
      "mutated_line": "if i + -1 <= n:",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + -1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "result.append(getsum(BITTreePresent, n - 1) % mod)",
      "mutated_line": "result.append(getsum(BITTreePresent, n - 1) * mod)",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) * mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "result.append(getsum(BITTreePresent, n - 1) % mod)",
      "mutated_line": "result.append(getsum(BITTreePresent, n - 1) + mod)",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) + mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "result.append(0)",
      "mutated_line": "result.append(1)",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "result.append(0)",
      "mutated_line": "result.append(-1)",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(-1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "result.append(0)",
      "mutated_line": "result.append(1)",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "l.append([i, uh[i] * lh[i]])",
      "mutated_line": "l.append([i, uh[i] / lh[i]])",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] / lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "l.append([i, uh[i] * lh[i]])",
      "mutated_line": "l.append([i, uh[i] + lh[i]])",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] + lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "l.append([i, uh[i] * lh[i]])",
      "mutated_line": "l.append([i, uh[i] ** lh[i]])",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] ** lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)",
      "mutated_line": "updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] * mod)",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] * mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)",
      "mutated_line": "updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] + mod)",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] + mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)",
      "mutated_line": "updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) / freq[j] % mod)",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) / freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)",
      "mutated_line": "updatebit(BITTreePresent, n, j, (getsum(BITTree, j - 1) + freq[j]) % mod)",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, (getsum(BITTree, j - 1) + freq[j]) % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)",
      "mutated_line": "updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) ** freq[j] % mod)",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) ** freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "result.append(getsum(BITTreePresent, n - 1) % mod)",
      "mutated_line": "result.append(getsum(BITTreePresent, n + 1) % mod)",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n + 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "result.append(getsum(BITTreePresent, n - 1) % mod)",
      "mutated_line": "result.append(getsum(BITTreePresent, n * 1) % mod)",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n * 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "result.append(getsum(BITTreePresent, n - 1) % mod)",
      "mutated_line": "result.append(getsum(BITTreePresent, n - 2) % mod)",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 2) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "result.append(getsum(BITTreePresent, n - 1) % mod)",
      "mutated_line": "result.append(getsum(BITTreePresent, n - 0) % mod)",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 0) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "result.append(getsum(BITTreePresent, n - 1) % mod)",
      "mutated_line": "result.append(getsum(BITTreePresent, n - 0) % mod)",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 0) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "result.append(getsum(BITTreePresent, n - 1) % mod)",
      "mutated_line": "result.append(getsum(BITTreePresent, n - -1) % mod)",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - -1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)",
      "mutated_line": "updatebit(BITTreePresent, n, j, getsum(BITTree, j + 1) * freq[j] % mod)",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j + 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)",
      "mutated_line": "updatebit(BITTreePresent, n, j, getsum(BITTree, j * 1) * freq[j] % mod)",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j * 1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)",
      "mutated_line": "updatebit(BITTreePresent, n, j, getsum(BITTree, j - 2) * freq[j] % mod)",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 2) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)",
      "mutated_line": "updatebit(BITTreePresent, n, j, getsum(BITTree, j - 0) * freq[j] % mod)",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 0) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)",
      "mutated_line": "updatebit(BITTreePresent, n, j, getsum(BITTree, j - 0) * freq[j] % mod)",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - 0) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "updatebit(BITTreePresent, n, j, getsum(BITTree, j - 1) * freq[j] % mod)",
      "mutated_line": "updatebit(BITTreePresent, n, j, getsum(BITTree, j - -1) * freq[j] % mod)",
      "code": "import collections\nmod = 10 ** 9 + 7\n\ndef getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\n\ndef count_x_sequences(N, M, C, upper_radii, lower_radii):\n    uh = collections.Counter(upper_radii)\n    lh = collections.Counter(lower_radii)\n    l = []\n    for i in uh:\n        if i in lh:\n            l.append([i, uh[i] * lh[i]])\n    l.sort()\n    freq = [i[1] for i in l]\n    n = len(freq)\n    arr = [0] * n\n    BITTree = construct(freq, n)\n    result = []\n    for i in range(1, C + 1):\n        if i + 1 <= n:\n            BITTreePresent = construct(arr, n)\n            for j in range(i, n):\n                updatebit(BITTreePresent, n, j, getsum(BITTree, j - -1) * freq[j] % mod)\n            result.append(getsum(BITTreePresent, n - 1) % mod)\n            BITTree = BITTreePresent\n        else:\n            result.append(0)\n    return result"
    }
  ]
}