{
  "task_id": "taco_1433",
  "entry_point": "form_coils",
  "mutant_count": 425,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "start = 1",
      "mutated_line": "start = 2",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 2\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "start = 1",
      "mutated_line": "start = 0",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 0\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "start = 1",
      "mutated_line": "start = 0",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 0\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "start = 1",
      "mutated_line": "start = -1",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = -1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "k = 0",
      "mutated_line": "k = 1",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 1\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "k = 0",
      "mutated_line": "k = -1",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = -1\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "k = 0",
      "mutated_line": "k = 1",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 1\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "while len(ans[0]) < 8 * n * n:",
      "mutated_line": "while len(ans[0]) <= 8 * n * n:",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) <= 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "while len(ans[0]) < 8 * n * n:",
      "mutated_line": "while len(ans[0]) >= 8 * n * n:",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) >= 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "while len(ans[0]) < 8 * n * n:",
      "mutated_line": "while len(ans[0]) != 8 * n * n:",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) != 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 21,
      "original_line": "curr[0][0] += d0[k][0]",
      "mutated_line": "curr[0][0] -= d0[k][0]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] -= d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 22,
      "original_line": "curr[0][1] += d0[k][1]",
      "mutated_line": "curr[0][1] -= d0[k][1]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] -= d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 23,
      "original_line": "curr[1][0] += d1[k][0]",
      "mutated_line": "curr[1][0] -= d1[k][0]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] -= d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 24,
      "original_line": "curr[1][1] += d1[k][1]",
      "mutated_line": "curr[1][1] -= d1[k][1]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] -= d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "for i in range(4 * n):",
      "mutated_line": "for i in range(4 / n):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 / n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "for i in range(4 * n):",
      "mutated_line": "for i in range(4 + n):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 + n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "for i in range(4 * n):",
      "mutated_line": "for i in range(4 ** n):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 ** n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 11,
      "original_line": "start += 1",
      "mutated_line": "start -= 1",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start -= 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "while len(ans[0]) < 8 * n * n:",
      "mutated_line": "while len(ans[0]) < 8 * n / n:",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n / n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "while len(ans[0]) < 8 * n * n:",
      "mutated_line": "while len(ans[0]) < 8 * n + n:",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n + n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "while len(ans[0]) < 8 * n * n:",
      "mutated_line": "while len(ans[0]) < (8 * n) ** n:",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < (8 * n) ** n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "marked[curr[0][0]][curr[0][1]] = 1",
      "mutated_line": "marked[curr[0][0]][curr[0][1]] = 2",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 2\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "marked[curr[0][0]][curr[0][1]] = 1",
      "mutated_line": "marked[curr[0][0]][curr[0][1]] = 0",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 0\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "marked[curr[0][0]][curr[0][1]] = 1",
      "mutated_line": "marked[curr[0][0]][curr[0][1]] = 0",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 0\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "marked[curr[0][0]][curr[0][1]] = 1",
      "mutated_line": "marked[curr[0][0]][curr[0][1]] = -1",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = -1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "marked[curr[1][0]][curr[1][1]] = 1",
      "mutated_line": "marked[curr[1][0]][curr[1][1]] = 2",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 2\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "marked[curr[1][0]][curr[1][1]] = 1",
      "mutated_line": "marked[curr[1][0]][curr[1][1]] = 0",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 0\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "marked[curr[1][0]][curr[1][1]] = 1",
      "mutated_line": "marked[curr[1][0]][curr[1][1]] = 0",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 0\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "marked[curr[1][0]][curr[1][1]] = 1",
      "mutated_line": "marked[curr[1][0]][curr[1][1]] = -1",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = -1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "curr = [[4 * n - 1, 4 * n - 1], [0, 0]]",
      "mutated_line": "curr = [[4 * n + 1, 4 * n - 1], [0, 0]]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n + 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "curr = [[4 * n - 1, 4 * n - 1], [0, 0]]",
      "mutated_line": "curr = [[4 * n * 1, 4 * n - 1], [0, 0]]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n * 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "curr = [[4 * n - 1, 4 * n - 1], [0, 0]]",
      "mutated_line": "curr = [[4 * n - 1, 4 * n + 1], [0, 0]]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n + 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "curr = [[4 * n - 1, 4 * n - 1], [0, 0]]",
      "mutated_line": "curr = [[4 * n - 1, 4 * n * 1], [0, 0]]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n * 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "curr = [[4 * n - 1, 4 * n - 1], [0, 0]]",
      "mutated_line": "curr = [[4 * n - 1, 4 * n - 1], [1, 0]]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [1, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "curr = [[4 * n - 1, 4 * n - 1], [0, 0]]",
      "mutated_line": "curr = [[4 * n - 1, 4 * n - 1], [-1, 0]]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [-1, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "curr = [[4 * n - 1, 4 * n - 1], [0, 0]]",
      "mutated_line": "curr = [[4 * n - 1, 4 * n - 1], [1, 0]]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [1, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "curr = [[4 * n - 1, 4 * n - 1], [0, 0]]",
      "mutated_line": "curr = [[4 * n - 1, 4 * n - 1], [0, 1]]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 1]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "curr = [[4 * n - 1, 4 * n - 1], [0, 0]]",
      "mutated_line": "curr = [[4 * n - 1, 4 * n - 1], [0, -1]]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, -1]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "curr = [[4 * n - 1, 4 * n - 1], [0, 0]]",
      "mutated_line": "curr = [[4 * n - 1, 4 * n - 1], [0, 1]]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 1]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 4,
      "original_line": "d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]",
      "mutated_line": "d0 = [(+1, 0), (0, -1), (1, 0), (0, 1)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(+1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]",
      "mutated_line": "d0 = [(-1, 1), (0, -1), (1, 0), (0, 1)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 1), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]",
      "mutated_line": "d0 = [(-1, -1), (0, -1), (1, 0), (0, 1)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, -1), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]",
      "mutated_line": "d0 = [(-1, 1), (0, -1), (1, 0), (0, 1)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 1), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]",
      "mutated_line": "d0 = [(-1, 0), (1, -1), (1, 0), (0, 1)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (1, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]",
      "mutated_line": "d0 = [(-1, 0), (-1, -1), (1, 0), (0, 1)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (-1, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]",
      "mutated_line": "d0 = [(-1, 0), (1, -1), (1, 0), (0, 1)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (1, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 4,
      "original_line": "d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]",
      "mutated_line": "d0 = [(-1, 0), (0, +1), (1, 0), (0, 1)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, +1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]",
      "mutated_line": "d0 = [(-1, 0), (0, -1), (2, 0), (0, 1)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (2, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]",
      "mutated_line": "d0 = [(-1, 0), (0, -1), (0, 0), (0, 1)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (0, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]",
      "mutated_line": "d0 = [(-1, 0), (0, -1), (0, 0), (0, 1)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (0, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]",
      "mutated_line": "d0 = [(-1, 0), (0, -1), (-1, 0), (0, 1)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (-1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]",
      "mutated_line": "d0 = [(-1, 0), (0, -1), (1, 1), (0, 1)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 1), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]",
      "mutated_line": "d0 = [(-1, 0), (0, -1), (1, -1), (0, 1)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, -1), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]",
      "mutated_line": "d0 = [(-1, 0), (0, -1), (1, 1), (0, 1)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 1), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]",
      "mutated_line": "d0 = [(-1, 0), (0, -1), (1, 0), (1, 1)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (1, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]",
      "mutated_line": "d0 = [(-1, 0), (0, -1), (1, 0), (-1, 1)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (-1, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]",
      "mutated_line": "d0 = [(-1, 0), (0, -1), (1, 0), (1, 1)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (1, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]",
      "mutated_line": "d0 = [(-1, 0), (0, -1), (1, 0), (0, 2)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 2)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]",
      "mutated_line": "d0 = [(-1, 0), (0, -1), (1, 0), (0, 0)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 0)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]",
      "mutated_line": "d0 = [(-1, 0), (0, -1), (1, 0), (0, 0)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 0)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]",
      "mutated_line": "d0 = [(-1, 0), (0, -1), (1, 0), (0, -1)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, -1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]",
      "mutated_line": "d1 = [(2, 0), (0, 1), (-1, 0), (0, -1)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(2, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]",
      "mutated_line": "d1 = [(0, 0), (0, 1), (-1, 0), (0, -1)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(0, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]",
      "mutated_line": "d1 = [(0, 0), (0, 1), (-1, 0), (0, -1)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(0, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]",
      "mutated_line": "d1 = [(-1, 0), (0, 1), (-1, 0), (0, -1)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(-1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]",
      "mutated_line": "d1 = [(1, 1), (0, 1), (-1, 0), (0, -1)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 1), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]",
      "mutated_line": "d1 = [(1, -1), (0, 1), (-1, 0), (0, -1)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, -1), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]",
      "mutated_line": "d1 = [(1, 1), (0, 1), (-1, 0), (0, -1)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 1), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]",
      "mutated_line": "d1 = [(1, 0), (1, 1), (-1, 0), (0, -1)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (1, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]",
      "mutated_line": "d1 = [(1, 0), (-1, 1), (-1, 0), (0, -1)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (-1, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]",
      "mutated_line": "d1 = [(1, 0), (1, 1), (-1, 0), (0, -1)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (1, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]",
      "mutated_line": "d1 = [(1, 0), (0, 2), (-1, 0), (0, -1)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 2), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]",
      "mutated_line": "d1 = [(1, 0), (0, 0), (-1, 0), (0, -1)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 0), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]",
      "mutated_line": "d1 = [(1, 0), (0, 0), (-1, 0), (0, -1)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 0), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]",
      "mutated_line": "d1 = [(1, 0), (0, -1), (-1, 0), (0, -1)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, -1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]",
      "mutated_line": "d1 = [(1, 0), (0, 1), (+1, 0), (0, -1)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (+1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]",
      "mutated_line": "d1 = [(1, 0), (0, 1), (-1, 1), (0, -1)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 1), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]",
      "mutated_line": "d1 = [(1, 0), (0, 1), (-1, -1), (0, -1)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, -1), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]",
      "mutated_line": "d1 = [(1, 0), (0, 1), (-1, 1), (0, -1)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 1), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]",
      "mutated_line": "d1 = [(1, 0), (0, 1), (-1, 0), (1, -1)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (1, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]",
      "mutated_line": "d1 = [(1, 0), (0, 1), (-1, 0), (-1, -1)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (-1, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]",
      "mutated_line": "d1 = [(1, 0), (0, 1), (-1, 0), (1, -1)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (1, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]",
      "mutated_line": "d1 = [(1, 0), (0, 1), (-1, 0), (0, +1)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, +1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]",
      "mutated_line": "m = [[1 for _ in range(4 * n)] for _ in range(4 * n)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[1 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]",
      "mutated_line": "m = [[-1 for _ in range(4 * n)] for _ in range(4 * n)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[-1 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]",
      "mutated_line": "m = [[1 for _ in range(4 * n)] for _ in range(4 * n)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[1 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(4 * n):",
      "mutated_line": "for i in range(5 * n):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(5 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(4 * n):",
      "mutated_line": "for i in range(3 * n):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(3 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(4 * n):",
      "mutated_line": "for i in range(0 * n):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(0 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(4 * n):",
      "mutated_line": "for i in range(1 * n):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(1 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(4 * n):",
      "mutated_line": "for i in range(-4 * n):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(-4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "for j in range(4 * n):",
      "mutated_line": "for j in range(4 / n):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 / n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "for j in range(4 * n):",
      "mutated_line": "for j in range(4 + n):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 + n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "for j in range(4 * n):",
      "mutated_line": "for j in range(4 ** n):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 ** n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "start += 1",
      "mutated_line": "start += 2",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 2\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "start += 1",
      "mutated_line": "start += 0",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 0\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "start += 1",
      "mutated_line": "start += 0",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 0\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "start += 1",
      "mutated_line": "start += -1",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += -1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]",
      "mutated_line": "marked = [[1 for _ in range(4 * n)] for _ in range(4 * n)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[1 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]",
      "mutated_line": "marked = [[-1 for _ in range(4 * n)] for _ in range(4 * n)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[-1 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]",
      "mutated_line": "marked = [[1 for _ in range(4 * n)] for _ in range(4 * n)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[1 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "while len(ans[0]) < 8 * n * n:",
      "mutated_line": "while len(ans[0]) < 8 / n * n:",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 / n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "while len(ans[0]) < 8 * n * n:",
      "mutated_line": "while len(ans[0]) < (8 + n) * n:",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < (8 + n) * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "while len(ans[0]) < 8 * n * n:",
      "mutated_line": "while len(ans[0]) < 8 ** n * n:",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 ** n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n or curr[0][0] + d0[k][0] >= 0 or curr[0][1] + d0[k][1] >= 0 or (curr[0][1] + d0[k][1] < 4 * n) or (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n or curr[0][0] + d0[k][0] >= 0 or curr[0][1] + d0[k][1] >= 0 or (curr[0][1] + d0[k][1] < 4 * n) or (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "k = (k + 1) % 4",
      "mutated_line": "k = (k + 1) * 4",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) * 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "k = (k + 1) % 4",
      "mutated_line": "k = k + 1 + 4",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = k + 1 + 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "curr[0][0] += d0[k][0]",
      "mutated_line": "curr[0][1] += d0[k][0]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][1] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "curr[0][0] += d0[k][0]",
      "mutated_line": "curr[0][-1] += d0[k][0]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][-1] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "curr[0][0] += d0[k][0]",
      "mutated_line": "curr[0][1] += d0[k][0]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][1] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "curr[0][0] += d0[k][0]",
      "mutated_line": "curr[0][0] += d0[k][1]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][1]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "curr[0][0] += d0[k][0]",
      "mutated_line": "curr[0][0] += d0[k][-1]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][-1]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "curr[0][0] += d0[k][0]",
      "mutated_line": "curr[0][0] += d0[k][1]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][1]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "curr[0][1] += d0[k][1]",
      "mutated_line": "curr[0][2] += d0[k][1]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][2] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "curr[0][1] += d0[k][1]",
      "mutated_line": "curr[0][0] += d0[k][1]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][0] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "curr[0][1] += d0[k][1]",
      "mutated_line": "curr[0][0] += d0[k][1]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][0] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "curr[0][1] += d0[k][1]",
      "mutated_line": "curr[0][-1] += d0[k][1]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][-1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "curr[0][1] += d0[k][1]",
      "mutated_line": "curr[0][1] += d0[k][2]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][2]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "curr[0][1] += d0[k][1]",
      "mutated_line": "curr[0][1] += d0[k][0]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][0]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "curr[0][1] += d0[k][1]",
      "mutated_line": "curr[0][1] += d0[k][0]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][0]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "curr[0][1] += d0[k][1]",
      "mutated_line": "curr[0][1] += d0[k][-1]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][-1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "curr[1][0] += d1[k][0]",
      "mutated_line": "curr[1][1] += d1[k][0]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][1] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "curr[1][0] += d1[k][0]",
      "mutated_line": "curr[1][-1] += d1[k][0]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][-1] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "curr[1][0] += d1[k][0]",
      "mutated_line": "curr[1][1] += d1[k][0]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][1] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "curr[1][0] += d1[k][0]",
      "mutated_line": "curr[1][0] += d1[k][1]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][1]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "curr[1][0] += d1[k][0]",
      "mutated_line": "curr[1][0] += d1[k][-1]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][-1]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "curr[1][0] += d1[k][0]",
      "mutated_line": "curr[1][0] += d1[k][1]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][1]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "curr[1][1] += d1[k][1]",
      "mutated_line": "curr[1][2] += d1[k][1]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][2] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "curr[1][1] += d1[k][1]",
      "mutated_line": "curr[1][0] += d1[k][1]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][0] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "curr[1][1] += d1[k][1]",
      "mutated_line": "curr[1][0] += d1[k][1]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][0] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "curr[1][1] += d1[k][1]",
      "mutated_line": "curr[1][-1] += d1[k][1]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][-1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "curr[1][1] += d1[k][1]",
      "mutated_line": "curr[1][1] += d1[k][2]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][2]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "curr[1][1] += d1[k][1]",
      "mutated_line": "curr[1][1] += d1[k][0]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][0]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "curr[1][1] += d1[k][1]",
      "mutated_line": "curr[1][1] += d1[k][0]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][0]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "curr[1][1] += d1[k][1]",
      "mutated_line": "curr[1][1] += d1[k][-1]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][-1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "curr = [[4 * n - 1, 4 * n - 1], [0, 0]]",
      "mutated_line": "curr = [[4 / n - 1, 4 * n - 1], [0, 0]]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 / n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "curr = [[4 * n - 1, 4 * n - 1], [0, 0]]",
      "mutated_line": "curr = [[4 + n - 1, 4 * n - 1], [0, 0]]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 + n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "curr = [[4 * n - 1, 4 * n - 1], [0, 0]]",
      "mutated_line": "curr = [[4 ** n - 1, 4 * n - 1], [0, 0]]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 ** n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "curr = [[4 * n - 1, 4 * n - 1], [0, 0]]",
      "mutated_line": "curr = [[4 * n - 2, 4 * n - 1], [0, 0]]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 2, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "curr = [[4 * n - 1, 4 * n - 1], [0, 0]]",
      "mutated_line": "curr = [[4 * n - 0, 4 * n - 1], [0, 0]]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 0, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "curr = [[4 * n - 1, 4 * n - 1], [0, 0]]",
      "mutated_line": "curr = [[4 * n - 0, 4 * n - 1], [0, 0]]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 0, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "curr = [[4 * n - 1, 4 * n - 1], [0, 0]]",
      "mutated_line": "curr = [[4 * n - -1, 4 * n - 1], [0, 0]]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - -1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "curr = [[4 * n - 1, 4 * n - 1], [0, 0]]",
      "mutated_line": "curr = [[4 * n - 1, 4 / n - 1], [0, 0]]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 / n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "curr = [[4 * n - 1, 4 * n - 1], [0, 0]]",
      "mutated_line": "curr = [[4 * n - 1, 4 + n - 1], [0, 0]]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 + n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "curr = [[4 * n - 1, 4 * n - 1], [0, 0]]",
      "mutated_line": "curr = [[4 * n - 1, 4 ** n - 1], [0, 0]]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 ** n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "curr = [[4 * n - 1, 4 * n - 1], [0, 0]]",
      "mutated_line": "curr = [[4 * n - 1, 4 * n - 2], [0, 0]]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 2], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "curr = [[4 * n - 1, 4 * n - 1], [0, 0]]",
      "mutated_line": "curr = [[4 * n - 1, 4 * n - 0], [0, 0]]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 0], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "curr = [[4 * n - 1, 4 * n - 1], [0, 0]]",
      "mutated_line": "curr = [[4 * n - 1, 4 * n - 0], [0, 0]]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 0], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "curr = [[4 * n - 1, 4 * n - 1], [0, 0]]",
      "mutated_line": "curr = [[4 * n - 1, 4 * n - -1], [0, 0]]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - -1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]",
      "mutated_line": "d0 = [(-2, 0), (0, -1), (1, 0), (0, 1)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-2, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]",
      "mutated_line": "d0 = [(-0, 0), (0, -1), (1, 0), (0, 1)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-0, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]",
      "mutated_line": "d0 = [(-0, 0), (0, -1), (1, 0), (0, 1)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-0, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]",
      "mutated_line": "d0 = [(--1, 0), (0, -1), (1, 0), (0, 1)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(--1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]",
      "mutated_line": "d0 = [(-1, 0), (0, -2), (1, 0), (0, 1)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -2), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]",
      "mutated_line": "d0 = [(-1, 0), (0, -0), (1, 0), (0, 1)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -0), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]",
      "mutated_line": "d0 = [(-1, 0), (0, -0), (1, 0), (0, 1)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -0), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]",
      "mutated_line": "d0 = [(-1, 0), (0, --1), (1, 0), (0, 1)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, --1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]",
      "mutated_line": "d1 = [(1, 0), (0, 1), (-2, 0), (0, -1)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-2, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]",
      "mutated_line": "d1 = [(1, 0), (0, 1), (-0, 0), (0, -1)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-0, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]",
      "mutated_line": "d1 = [(1, 0), (0, 1), (-0, 0), (0, -1)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-0, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]",
      "mutated_line": "d1 = [(1, 0), (0, 1), (--1, 0), (0, -1)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (--1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]",
      "mutated_line": "d1 = [(1, 0), (0, 1), (-1, 0), (0, -2)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -2)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]",
      "mutated_line": "d1 = [(1, 0), (0, 1), (-1, 0), (0, -0)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -0)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]",
      "mutated_line": "d1 = [(1, 0), (0, 1), (-1, 0), (0, -0)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -0)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]",
      "mutated_line": "d1 = [(1, 0), (0, 1), (-1, 0), (0, --1)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, --1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]",
      "mutated_line": "m = [[0 for _ in range(4 * n)] for _ in range(4 / n)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 / n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]",
      "mutated_line": "m = [[0 for _ in range(4 * n)] for _ in range(4 + n)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 + n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]",
      "mutated_line": "m = [[0 for _ in range(4 * n)] for _ in range(4 ** n)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 ** n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for j in range(4 * n):",
      "mutated_line": "for j in range(5 * n):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(5 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for j in range(4 * n):",
      "mutated_line": "for j in range(3 * n):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(3 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for j in range(4 * n):",
      "mutated_line": "for j in range(0 * n):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(0 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for j in range(4 * n):",
      "mutated_line": "for j in range(1 * n):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(1 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for j in range(4 * n):",
      "mutated_line": "for j in range(-4 * n):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(-4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]",
      "mutated_line": "marked = [[0 for _ in range(4 * n)] for _ in range(4 / n)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 / n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]",
      "mutated_line": "marked = [[0 for _ in range(4 * n)] for _ in range(4 + n)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 + n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]",
      "mutated_line": "marked = [[0 for _ in range(4 * n)] for _ in range(4 ** n)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 ** n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "while len(ans[0]) < 8 * n * n:",
      "mutated_line": "while len(ans[1]) < 8 * n * n:",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[1]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "while len(ans[0]) < 8 * n * n:",
      "mutated_line": "while len(ans[-1]) < 8 * n * n:",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[-1]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "while len(ans[0]) < 8 * n * n:",
      "mutated_line": "while len(ans[1]) < 8 * n * n:",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[1]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "while len(ans[0]) < 8 * n * n:",
      "mutated_line": "while len(ans[0]) < 9 * n * n:",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 9 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "while len(ans[0]) < 8 * n * n:",
      "mutated_line": "while len(ans[0]) < 7 * n * n:",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 7 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "while len(ans[0]) < 8 * n * n:",
      "mutated_line": "while len(ans[0]) < 0 * n * n:",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 0 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "while len(ans[0]) < 8 * n * n:",
      "mutated_line": "while len(ans[0]) < 1 * n * n:",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 1 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "while len(ans[0]) < 8 * n * n:",
      "mutated_line": "while len(ans[0]) < -8 * n * n:",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < -8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "marked[curr[0][0]][curr[0][1]] = 1",
      "mutated_line": "marked[curr[0][0]][curr[0][2]] = 1",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][2]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "marked[curr[0][0]][curr[0][1]] = 1",
      "mutated_line": "marked[curr[0][0]][curr[0][0]] = 1",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][0]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "marked[curr[0][0]][curr[0][1]] = 1",
      "mutated_line": "marked[curr[0][0]][curr[0][0]] = 1",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][0]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "marked[curr[0][0]][curr[0][1]] = 1",
      "mutated_line": "marked[curr[0][0]][curr[0][-1]] = 1",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][-1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "marked[curr[1][0]][curr[1][1]] = 1",
      "mutated_line": "marked[curr[1][0]][curr[1][2]] = 1",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][2]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "marked[curr[1][0]][curr[1][1]] = 1",
      "mutated_line": "marked[curr[1][0]][curr[1][0]] = 1",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][0]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "marked[curr[1][0]][curr[1][1]] = 1",
      "mutated_line": "marked[curr[1][0]][curr[1][0]] = 1",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][0]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "marked[curr[1][0]][curr[1][1]] = 1",
      "mutated_line": "marked[curr[1][0]][curr[1][-1]] = 1",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][-1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] <= 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] <= 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] >= 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] >= 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] != 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] != 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] > 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] > 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] < 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] < 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] == 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] == 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] > 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] > 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] < 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] < 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] == 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] == 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] <= 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] <= 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] >= 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] >= 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] != 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] != 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] != 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] != 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "k = (k + 1) % 4",
      "mutated_line": "k = (k - 1) % 4",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k - 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "k = (k + 1) % 4",
      "mutated_line": "k = k * 1 % 4",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = k * 1 % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "k = (k + 1) % 4",
      "mutated_line": "k = (k + 1) % 5",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 5\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "k = (k + 1) % 4",
      "mutated_line": "k = (k + 1) % 3",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 3\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "k = (k + 1) % 4",
      "mutated_line": "k = (k + 1) % 0",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 0\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "k = (k + 1) % 4",
      "mutated_line": "k = (k + 1) % 1",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 1\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "k = (k + 1) % 4",
      "mutated_line": "k = (k + 1) % -4",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % -4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "curr[0][0] += d0[k][0]",
      "mutated_line": "curr[1][0] += d0[k][0]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[1][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "curr[0][0] += d0[k][0]",
      "mutated_line": "curr[-1][0] += d0[k][0]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[-1][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "curr[0][0] += d0[k][0]",
      "mutated_line": "curr[1][0] += d0[k][0]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[1][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "curr[0][1] += d0[k][1]",
      "mutated_line": "curr[1][1] += d0[k][1]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[1][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "curr[0][1] += d0[k][1]",
      "mutated_line": "curr[-1][1] += d0[k][1]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[-1][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "curr[0][1] += d0[k][1]",
      "mutated_line": "curr[1][1] += d0[k][1]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[1][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "curr[1][0] += d1[k][0]",
      "mutated_line": "curr[2][0] += d1[k][0]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[2][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "curr[1][0] += d1[k][0]",
      "mutated_line": "curr[0][0] += d1[k][0]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[0][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "curr[1][0] += d1[k][0]",
      "mutated_line": "curr[0][0] += d1[k][0]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[0][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "curr[1][0] += d1[k][0]",
      "mutated_line": "curr[-1][0] += d1[k][0]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[-1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "curr[1][1] += d1[k][1]",
      "mutated_line": "curr[2][1] += d1[k][1]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[2][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "curr[1][1] += d1[k][1]",
      "mutated_line": "curr[0][1] += d1[k][1]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[0][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "curr[1][1] += d1[k][1]",
      "mutated_line": "curr[0][1] += d1[k][1]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[0][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "curr[1][1] += d1[k][1]",
      "mutated_line": "curr[-1][1] += d1[k][1]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[-1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ans[0].reverse()",
      "mutated_line": "ans[1].reverse()",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[1].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ans[0].reverse()",
      "mutated_line": "ans[-1].reverse()",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[-1].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ans[0].reverse()",
      "mutated_line": "ans[1].reverse()",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[1].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ans[1].reverse()",
      "mutated_line": "ans[2].reverse()",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[2].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ans[1].reverse()",
      "mutated_line": "ans[0].reverse()",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[0].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ans[1].reverse()",
      "mutated_line": "ans[0].reverse()",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[0].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ans[1].reverse()",
      "mutated_line": "ans[-1].reverse()",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[-1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "curr = [[4 * n - 1, 4 * n - 1], [0, 0]]",
      "mutated_line": "curr = [[5 * n - 1, 4 * n - 1], [0, 0]]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[5 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "curr = [[4 * n - 1, 4 * n - 1], [0, 0]]",
      "mutated_line": "curr = [[3 * n - 1, 4 * n - 1], [0, 0]]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[3 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "curr = [[4 * n - 1, 4 * n - 1], [0, 0]]",
      "mutated_line": "curr = [[0 * n - 1, 4 * n - 1], [0, 0]]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[0 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "curr = [[4 * n - 1, 4 * n - 1], [0, 0]]",
      "mutated_line": "curr = [[1 * n - 1, 4 * n - 1], [0, 0]]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[1 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "curr = [[4 * n - 1, 4 * n - 1], [0, 0]]",
      "mutated_line": "curr = [[-4 * n - 1, 4 * n - 1], [0, 0]]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[-4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "curr = [[4 * n - 1, 4 * n - 1], [0, 0]]",
      "mutated_line": "curr = [[4 * n - 1, 5 * n - 1], [0, 0]]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 5 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "curr = [[4 * n - 1, 4 * n - 1], [0, 0]]",
      "mutated_line": "curr = [[4 * n - 1, 3 * n - 1], [0, 0]]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 3 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "curr = [[4 * n - 1, 4 * n - 1], [0, 0]]",
      "mutated_line": "curr = [[4 * n - 1, 0 * n - 1], [0, 0]]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 0 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "curr = [[4 * n - 1, 4 * n - 1], [0, 0]]",
      "mutated_line": "curr = [[4 * n - 1, 1 * n - 1], [0, 0]]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 1 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "curr = [[4 * n - 1, 4 * n - 1], [0, 0]]",
      "mutated_line": "curr = [[4 * n - 1, -4 * n - 1], [0, 0]]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, -4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]",
      "mutated_line": "m = [[0 for _ in range(4 / n)] for _ in range(4 * n)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 / n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]",
      "mutated_line": "m = [[0 for _ in range(4 + n)] for _ in range(4 * n)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 + n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]",
      "mutated_line": "m = [[0 for _ in range(4 ** n)] for _ in range(4 * n)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 ** n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]",
      "mutated_line": "m = [[0 for _ in range(4 * n)] for _ in range(5 * n)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(5 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]",
      "mutated_line": "m = [[0 for _ in range(4 * n)] for _ in range(3 * n)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(3 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]",
      "mutated_line": "m = [[0 for _ in range(4 * n)] for _ in range(0 * n)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(0 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]",
      "mutated_line": "m = [[0 for _ in range(4 * n)] for _ in range(1 * n)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(1 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]",
      "mutated_line": "m = [[0 for _ in range(4 * n)] for _ in range(-4 * n)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(-4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]",
      "mutated_line": "marked = [[0 for _ in range(4 / n)] for _ in range(4 * n)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 / n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]",
      "mutated_line": "marked = [[0 for _ in range(4 + n)] for _ in range(4 * n)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 + n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]",
      "mutated_line": "marked = [[0 for _ in range(4 ** n)] for _ in range(4 * n)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 ** n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]",
      "mutated_line": "marked = [[0 for _ in range(4 * n)] for _ in range(5 * n)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(5 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]",
      "mutated_line": "marked = [[0 for _ in range(4 * n)] for _ in range(3 * n)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(3 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]",
      "mutated_line": "marked = [[0 for _ in range(4 * n)] for _ in range(0 * n)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(0 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]",
      "mutated_line": "marked = [[0 for _ in range(4 * n)] for _ in range(1 * n)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(1 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]",
      "mutated_line": "marked = [[0 for _ in range(4 * n)] for _ in range(-4 * n)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(-4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "marked[curr[0][0]][curr[0][1]] = 1",
      "mutated_line": "marked[curr[0][1]][curr[0][1]] = 1",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][1]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "marked[curr[0][0]][curr[0][1]] = 1",
      "mutated_line": "marked[curr[0][-1]][curr[0][1]] = 1",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][-1]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "marked[curr[0][0]][curr[0][1]] = 1",
      "mutated_line": "marked[curr[0][1]][curr[0][1]] = 1",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][1]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "marked[curr[0][0]][curr[0][1]] = 1",
      "mutated_line": "marked[curr[0][0]][curr[1][1]] = 1",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[1][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "marked[curr[0][0]][curr[0][1]] = 1",
      "mutated_line": "marked[curr[0][0]][curr[-1][1]] = 1",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[-1][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "marked[curr[0][0]][curr[0][1]] = 1",
      "mutated_line": "marked[curr[0][0]][curr[1][1]] = 1",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[1][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans[0].append(m[curr[0][0]][curr[0][1]])",
      "mutated_line": "ans[1].append(m[curr[0][0]][curr[0][1]])",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[1].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans[0].append(m[curr[0][0]][curr[0][1]])",
      "mutated_line": "ans[-1].append(m[curr[0][0]][curr[0][1]])",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[-1].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans[0].append(m[curr[0][0]][curr[0][1]])",
      "mutated_line": "ans[1].append(m[curr[0][0]][curr[0][1]])",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[1].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans[0].append(m[curr[0][0]][curr[0][1]])",
      "mutated_line": "ans[0].append(m[curr[0][0]][curr[0][2]])",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][2]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans[0].append(m[curr[0][0]][curr[0][1]])",
      "mutated_line": "ans[0].append(m[curr[0][0]][curr[0][0]])",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][0]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans[0].append(m[curr[0][0]][curr[0][1]])",
      "mutated_line": "ans[0].append(m[curr[0][0]][curr[0][0]])",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][0]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans[0].append(m[curr[0][0]][curr[0][1]])",
      "mutated_line": "ans[0].append(m[curr[0][0]][curr[0][-1]])",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][-1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "marked[curr[1][0]][curr[1][1]] = 1",
      "mutated_line": "marked[curr[1][1]][curr[1][1]] = 1",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][1]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "marked[curr[1][0]][curr[1][1]] = 1",
      "mutated_line": "marked[curr[1][-1]][curr[1][1]] = 1",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][-1]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "marked[curr[1][0]][curr[1][1]] = 1",
      "mutated_line": "marked[curr[1][1]][curr[1][1]] = 1",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][1]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "marked[curr[1][0]][curr[1][1]] = 1",
      "mutated_line": "marked[curr[1][0]][curr[2][1]] = 1",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[2][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "marked[curr[1][0]][curr[1][1]] = 1",
      "mutated_line": "marked[curr[1][0]][curr[0][1]] = 1",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[0][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "marked[curr[1][0]][curr[1][1]] = 1",
      "mutated_line": "marked[curr[1][0]][curr[0][1]] = 1",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[0][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "marked[curr[1][0]][curr[1][1]] = 1",
      "mutated_line": "marked[curr[1][0]][curr[-1][1]] = 1",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[-1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ans[1].append(m[curr[1][0]][curr[1][1]])",
      "mutated_line": "ans[2].append(m[curr[1][0]][curr[1][1]])",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[2].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ans[1].append(m[curr[1][0]][curr[1][1]])",
      "mutated_line": "ans[0].append(m[curr[1][0]][curr[1][1]])",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[0].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ans[1].append(m[curr[1][0]][curr[1][1]])",
      "mutated_line": "ans[0].append(m[curr[1][0]][curr[1][1]])",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[0].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ans[1].append(m[curr[1][0]][curr[1][1]])",
      "mutated_line": "ans[-1].append(m[curr[1][0]][curr[1][1]])",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[-1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ans[1].append(m[curr[1][0]][curr[1][1]])",
      "mutated_line": "ans[1].append(m[curr[1][0]][curr[1][2]])",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][2]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ans[1].append(m[curr[1][0]][curr[1][1]])",
      "mutated_line": "ans[1].append(m[curr[1][0]][curr[1][0]])",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][0]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ans[1].append(m[curr[1][0]][curr[1][1]])",
      "mutated_line": "ans[1].append(m[curr[1][0]][curr[1][0]])",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][0]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ans[1].append(m[curr[1][0]][curr[1][1]])",
      "mutated_line": "ans[1].append(m[curr[1][0]][curr[1][-1]])",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][-1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] - d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] - d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] * d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] * d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 / n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 / n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 + n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 + n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 ** n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 ** n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] - d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] - d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] * d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] * d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 1 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 1 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= -1 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= -1 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 1 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 1 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] - d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] - d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] * d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] * d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 1) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 1) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= -1) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= -1) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 1) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 1) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] - d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] - d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] * d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] * d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 / n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 / n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 + n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 + n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 ** n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 ** n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 1)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 1)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == -1)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == -1)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 1)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 1)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "k = (k + 1) % 4",
      "mutated_line": "k = (k + 2) % 4",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 2) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "k = (k + 1) % 4",
      "mutated_line": "k = (k + 0) % 4",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 0) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "k = (k + 1) % 4",
      "mutated_line": "k = (k + 0) % 4",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 0) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "k = (k + 1) % 4",
      "mutated_line": "k = (k + -1) % 4",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + -1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]",
      "mutated_line": "m = [[0 for _ in range(5 * n)] for _ in range(4 * n)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(5 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]",
      "mutated_line": "m = [[0 for _ in range(3 * n)] for _ in range(4 * n)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(3 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]",
      "mutated_line": "m = [[0 for _ in range(0 * n)] for _ in range(4 * n)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(0 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]",
      "mutated_line": "m = [[0 for _ in range(1 * n)] for _ in range(4 * n)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(1 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]",
      "mutated_line": "m = [[0 for _ in range(-4 * n)] for _ in range(4 * n)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(-4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]",
      "mutated_line": "marked = [[0 for _ in range(5 * n)] for _ in range(4 * n)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(5 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]",
      "mutated_line": "marked = [[0 for _ in range(3 * n)] for _ in range(4 * n)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(3 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]",
      "mutated_line": "marked = [[0 for _ in range(0 * n)] for _ in range(4 * n)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(0 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]",
      "mutated_line": "marked = [[0 for _ in range(1 * n)] for _ in range(4 * n)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(1 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]",
      "mutated_line": "marked = [[0 for _ in range(-4 * n)] for _ in range(4 * n)]",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(-4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "marked[curr[0][0]][curr[0][1]] = 1",
      "mutated_line": "marked[curr[1][0]][curr[0][1]] = 1",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[1][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "marked[curr[0][0]][curr[0][1]] = 1",
      "mutated_line": "marked[curr[-1][0]][curr[0][1]] = 1",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[-1][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "marked[curr[0][0]][curr[0][1]] = 1",
      "mutated_line": "marked[curr[1][0]][curr[0][1]] = 1",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[1][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans[0].append(m[curr[0][0]][curr[0][1]])",
      "mutated_line": "ans[0].append(m[curr[0][1]][curr[0][1]])",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][1]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans[0].append(m[curr[0][0]][curr[0][1]])",
      "mutated_line": "ans[0].append(m[curr[0][-1]][curr[0][1]])",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][-1]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans[0].append(m[curr[0][0]][curr[0][1]])",
      "mutated_line": "ans[0].append(m[curr[0][1]][curr[0][1]])",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][1]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans[0].append(m[curr[0][0]][curr[0][1]])",
      "mutated_line": "ans[0].append(m[curr[0][0]][curr[1][1]])",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[1][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans[0].append(m[curr[0][0]][curr[0][1]])",
      "mutated_line": "ans[0].append(m[curr[0][0]][curr[-1][1]])",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[-1][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans[0].append(m[curr[0][0]][curr[0][1]])",
      "mutated_line": "ans[0].append(m[curr[0][0]][curr[1][1]])",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[1][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "marked[curr[1][0]][curr[1][1]] = 1",
      "mutated_line": "marked[curr[2][0]][curr[1][1]] = 1",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[2][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "marked[curr[1][0]][curr[1][1]] = 1",
      "mutated_line": "marked[curr[0][0]][curr[1][1]] = 1",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[0][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "marked[curr[1][0]][curr[1][1]] = 1",
      "mutated_line": "marked[curr[0][0]][curr[1][1]] = 1",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[0][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "marked[curr[1][0]][curr[1][1]] = 1",
      "mutated_line": "marked[curr[-1][0]][curr[1][1]] = 1",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[-1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ans[1].append(m[curr[1][0]][curr[1][1]])",
      "mutated_line": "ans[1].append(m[curr[1][1]][curr[1][1]])",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][1]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ans[1].append(m[curr[1][0]][curr[1][1]])",
      "mutated_line": "ans[1].append(m[curr[1][-1]][curr[1][1]])",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][-1]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ans[1].append(m[curr[1][0]][curr[1][1]])",
      "mutated_line": "ans[1].append(m[curr[1][1]][curr[1][1]])",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][1]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ans[1].append(m[curr[1][0]][curr[1][1]])",
      "mutated_line": "ans[1].append(m[curr[1][0]][curr[2][1]])",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[2][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ans[1].append(m[curr[1][0]][curr[1][1]])",
      "mutated_line": "ans[1].append(m[curr[1][0]][curr[0][1]])",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[0][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ans[1].append(m[curr[1][0]][curr[1][1]])",
      "mutated_line": "ans[1].append(m[curr[1][0]][curr[0][1]])",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[0][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ans[1].append(m[curr[1][0]][curr[1][1]])",
      "mutated_line": "ans[1].append(m[curr[1][0]][curr[-1][1]])",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[-1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 5 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 5 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 3 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 3 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 0 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 0 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 1 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 1 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < -4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < -4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 5 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 5 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 3 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 3 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 0 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 0 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 1 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 1 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < -4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < -4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] - d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] - d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] * d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] * d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans[0].append(m[curr[0][0]][curr[0][1]])",
      "mutated_line": "ans[0].append(m[curr[1][0]][curr[0][1]])",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[1][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans[0].append(m[curr[0][0]][curr[0][1]])",
      "mutated_line": "ans[0].append(m[curr[-1][0]][curr[0][1]])",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[-1][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans[0].append(m[curr[0][0]][curr[0][1]])",
      "mutated_line": "ans[0].append(m[curr[1][0]][curr[0][1]])",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[1][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ans[1].append(m[curr[1][0]][curr[1][1]])",
      "mutated_line": "ans[1].append(m[curr[2][0]][curr[1][1]])",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[2][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ans[1].append(m[curr[1][0]][curr[1][1]])",
      "mutated_line": "ans[1].append(m[curr[0][0]][curr[1][1]])",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[0][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ans[1].append(m[curr[1][0]][curr[1][1]])",
      "mutated_line": "ans[1].append(m[curr[0][0]][curr[1][1]])",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[0][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ans[1].append(m[curr[1][0]][curr[1][1]])",
      "mutated_line": "ans[1].append(m[curr[-1][0]][curr[1][1]])",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[-1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][1] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][1] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][-1] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][-1] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][1] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][1] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][1] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][1] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][-1] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][-1] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][1] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][1] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][1] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][1] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][-1] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][-1] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][1] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][1] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][1] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][1] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][-1] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][-1] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][1] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][1] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][2] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][2] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][0] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][0] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][0] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][0] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][-1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][-1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][2] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][2] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][0] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][0] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][0] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][0] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][-1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][-1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][2] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][2] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][0] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][0] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][0] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][0] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][-1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][-1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][2] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][2] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][0] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][0] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][0] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][0] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][-1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][-1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] - d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] - d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] * d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] * d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[1][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[1][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[-1][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[-1][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[1][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[1][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[1][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[1][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[-1][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[-1][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[1][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[1][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[1][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[1][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[-1][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[-1][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[1][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[1][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[1][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[1][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[-1][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[-1][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[1][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[1][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][2] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][2] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][0] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][0] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][0] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][0] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][-1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][-1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][2]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][2]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][0]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][0]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][0]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][0]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][-1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][-1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][1] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][1] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][-1] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][-1] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][1] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][1] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][1]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][1]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][-1]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][-1]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][1]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][1]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[1][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[1][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[-1][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[-1][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[1][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[1][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[1][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[1][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[-1][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[-1][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[0][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "mutated_line": "if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[1][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):",
      "code": "def form_coils(n):\n    ans = [[], []]\n    curr = [[4 * n - 1, 4 * n - 1], [0, 0]]\n    d0 = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n    d1 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    m = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    start = 1\n    for i in range(4 * n):\n        for j in range(4 * n):\n            m[i][j] = start\n            start += 1\n    marked = [[0 for _ in range(4 * n)] for _ in range(4 * n)]\n    k = 0\n    while len(ans[0]) < 8 * n * n:\n        marked[curr[0][0]][curr[0][1]] = 1\n        ans[0].append(m[curr[0][0]][curr[0][1]])\n        marked[curr[1][0]][curr[1][1]] = 1\n        ans[1].append(m[curr[1][0]][curr[1][1]])\n        if not (curr[0][0] + d0[k][0] < 4 * n and curr[0][0] + d0[k][0] >= 0 and (curr[0][1] + d0[k][1] >= 0) and (curr[0][1] + d0[k][1] < 4 * n) and (marked[curr[1][0] + d0[k][0]][curr[0][1] + d0[k][1]] == 0)):\n            k = (k + 1) % 4\n        curr[0][0] += d0[k][0]\n        curr[0][1] += d0[k][1]\n        curr[1][0] += d1[k][0]\n        curr[1][1] += d1[k][1]\n    ans[0].reverse()\n    ans[1].reverse()\n    return ans"
    }
  ]
}