{
  "task_id": "taco_7581",
  "entry_point": "count_tiling_ways",
  "mutant_count": 334,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 15,
      "original_line": "mx += 3 * [0]",
      "mutated_line": "mx -= 3 * [0]",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx -= 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 1000000007",
      "mutated_line": "mod = 1000000008",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000008\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 1000000007",
      "mutated_line": "mod = 1000000006",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000006\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 1000000007",
      "mutated_line": "mod = 0",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 0\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 1000000007",
      "mutated_line": "mod = 1",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 1000000007",
      "mutated_line": "mod = -1000000007",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = -1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "mx += 3 * [0]",
      "mutated_line": "mx += 3 / [0]",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 / [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "mx += 3 * [0]",
      "mutated_line": "mx += 3 + [0]",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 + [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "mx += 3 * [0]",
      "mutated_line": "mx += 3 ** [0]",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 ** [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "full = (1 << M) - 1",
      "mutated_line": "full = (1 << M) + 1",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) + 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "full = (1 << M) - 1",
      "mutated_line": "full = (1 << M) * 1",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) * 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "mx += 3 * [0]",
      "mutated_line": "mx += 4 * [0]",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 4 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "mx += 3 * [0]",
      "mutated_line": "mx += 2 * [0]",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 2 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "mx += 3 * [0]",
      "mutated_line": "mx += 0 * [0]",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 0 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "mx += 3 * [0]",
      "mutated_line": "mx += 1 * [0]",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 1 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "mx += 3 * [0]",
      "mutated_line": "mx += -3 * [0]",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += -3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "full = (1 << M) - 1",
      "mutated_line": "full = (1 << M) - 2",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 2\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "full = (1 << M) - 1",
      "mutated_line": "full = (1 << M) - 0",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 0\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "full = (1 << M) - 1",
      "mutated_line": "full = (1 << M) - 0",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 0\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "full = (1 << M) - 1",
      "mutated_line": "full = (1 << M) - -1",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - -1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if y == N:",
      "mutated_line": "if y != N:",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y != N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if first == full:",
      "mutated_line": "if first != full:",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first != full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "free = 0",
      "mutated_line": "free = 1",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 1\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "free = 0",
      "mutated_line": "free = -1",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = -1\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "free = 0",
      "mutated_line": "free = 1",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 1\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "while first & 1 << free != 0:",
      "mutated_line": "while first & 1 << free == 0:",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free == 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "ASR",
      "lineno": 46,
      "original_line": "free += 1",
      "mutated_line": "free -= 1",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free -= 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 1\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = -1\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 1\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return rec(0, mx[0], mx[1], mx[2])",
      "mutated_line": "return rec(1, mx[0], mx[1], mx[2])",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(1, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return rec(0, mx[0], mx[1], mx[2])",
      "mutated_line": "return rec(-1, mx[0], mx[1], mx[2])",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(-1, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return rec(0, mx[0], mx[1], mx[2])",
      "mutated_line": "return rec(1, mx[0], mx[1], mx[2])",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(1, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]",
      "mutated_line": "mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 3) for row in grid]",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 3) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]",
      "mutated_line": "mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 1) for row in grid]",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 1) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]",
      "mutated_line": "mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 0) for row in grid]",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 0) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]",
      "mutated_line": "mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 1) for row in grid]",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 1) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]",
      "mutated_line": "mx = [int(''.join(('0' if c == '.' else '1' for c in row)), -2) for row in grid]",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), -2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "mx += 3 * [0]",
      "mutated_line": "mx += 3 * [1]",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [1]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "mx += 3 * [0]",
      "mutated_line": "mx += 3 * [-1]",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [-1]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "mx += 3 * [0]",
      "mutated_line": "mx += 3 * [1]",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [1]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "full = (1 << M) - 1",
      "mutated_line": "full = (2 << M) - 1",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (2 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "full = (1 << M) - 1",
      "mutated_line": "full = (0 << M) - 1",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (0 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "full = (1 << M) - 1",
      "mutated_line": "full = (0 << M) - 1",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (0 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "full = (1 << M) - 1",
      "mutated_line": "full = (-1 << M) - 1",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (-1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if arg not in pool:",
      "mutated_line": "if arg in pool:",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "ASR",
      "lineno": 36,
      "original_line": "x += x_offset",
      "mutated_line": "x -= x_offset",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x -= x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "while first & 1 << free != 0:",
      "mutated_line": "while first | 1 << free != 0:",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first | 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "while first & 1 << free != 0:",
      "mutated_line": "while first & 1 << free != 1:",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 1:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "while first & 1 << free != 0:",
      "mutated_line": "while first & 1 << free != -1:",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != -1:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "while first & 1 << free != 0:",
      "mutated_line": "while first & 1 << free != 1:",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 1:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "free += 1",
      "mutated_line": "free += 2",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 2\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "free += 1",
      "mutated_line": "free += 0",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 0\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "free += 1",
      "mutated_line": "free += 0",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 0\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "free += 1",
      "mutated_line": "free += -1",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += -1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "rows = [first | 1 << free, second, third]",
      "mutated_line": "rows = [first & 1 << free, second, third]",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first & 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "rows = [first | 1 << free, second, third]",
      "mutated_line": "rows = [first ^ 1 << free, second, third]",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first ^ 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "ROR",
      "lineno": 51,
      "original_line": "if nrows is not None:",
      "mutated_line": "if nrows is None:",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return rec(0, mx[0], mx[1], mx[2])",
      "mutated_line": "return rec(0, mx[1], mx[1], mx[2])",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[1], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return rec(0, mx[0], mx[1], mx[2])",
      "mutated_line": "return rec(0, mx[-1], mx[1], mx[2])",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[-1], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return rec(0, mx[0], mx[1], mx[2])",
      "mutated_line": "return rec(0, mx[1], mx[1], mx[2])",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[1], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return rec(0, mx[0], mx[1], mx[2])",
      "mutated_line": "return rec(0, mx[0], mx[2], mx[2])",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[2], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return rec(0, mx[0], mx[1], mx[2])",
      "mutated_line": "return rec(0, mx[0], mx[0], mx[2])",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[0], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return rec(0, mx[0], mx[1], mx[2])",
      "mutated_line": "return rec(0, mx[0], mx[0], mx[2])",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[0], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return rec(0, mx[0], mx[1], mx[2])",
      "mutated_line": "return rec(0, mx[0], mx[-1], mx[2])",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[-1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return rec(0, mx[0], mx[1], mx[2])",
      "mutated_line": "return rec(0, mx[0], mx[1], mx[3])",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[3])"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return rec(0, mx[0], mx[1], mx[2])",
      "mutated_line": "return rec(0, mx[0], mx[1], mx[1])",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[1])"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return rec(0, mx[0], mx[1], mx[2])",
      "mutated_line": "return rec(0, mx[0], mx[1], mx[0])",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[0])"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return rec(0, mx[0], mx[1], mx[2])",
      "mutated_line": "return rec(0, mx[0], mx[1], mx[1])",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[1])"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return rec(0, mx[0], mx[1], mx[2])",
      "mutated_line": "return rec(0, mx[0], mx[1], mx[-2])",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[-2])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "((1, 0), (2, 0), (2, 1)),",
      "mutated_line": "shapes = (((2, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((2, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "((1, 0), (2, 0), (2, 1)),",
      "mutated_line": "shapes = (((0, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((0, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "((1, 0), (2, 0), (2, 1)),",
      "mutated_line": "shapes = (((0, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((0, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "((1, 0), (2, 0), (2, 1)),",
      "mutated_line": "shapes = (((-1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((-1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "((1, 0), (2, 0), (2, 1)),",
      "mutated_line": "shapes = (((1, 1), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 1), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "((1, 0), (2, 0), (2, 1)),",
      "mutated_line": "shapes = (((1, -1), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, -1), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "((1, 0), (2, 0), (2, 1)),",
      "mutated_line": "shapes = (((1, 1), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 1), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "((1, 0), (2, 0), (2, 1)),",
      "mutated_line": "shapes = (((1, 0), (3, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (3, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "((1, 0), (2, 0), (2, 1)),",
      "mutated_line": "shapes = (((1, 0), (1, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (1, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "((1, 0), (2, 0), (2, 1)),",
      "mutated_line": "shapes = (((1, 0), (0, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (0, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "((1, 0), (2, 0), (2, 1)),",
      "mutated_line": "shapes = (((1, 0), (1, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (1, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "((1, 0), (2, 0), (2, 1)),",
      "mutated_line": "shapes = (((1, 0), (-2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (-2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "((1, 0), (2, 0), (2, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 1), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 1), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "((1, 0), (2, 0), (2, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, -1), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, -1), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "((1, 0), (2, 0), (2, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 1), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 1), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "((1, 0), (2, 0), (2, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (3, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (3, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "((1, 0), (2, 0), (2, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (1, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (1, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "((1, 0), (2, 0), (2, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (0, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (0, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "((1, 0), (2, 0), (2, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (1, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (1, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "((1, 0), (2, 0), (2, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (-2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (-2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "((1, 0), (2, 0), (2, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 2)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 2)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "((1, 0), (2, 0), (2, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 0)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 0)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "((1, 0), (2, 0), (2, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 0)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 0)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "((1, 0), (2, 0), (2, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, -1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, -1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "((0, 1), (0, 2), (-1, 2)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((1, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((1, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "((0, 1), (0, 2), (-1, 2)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((-1, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((-1, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "((0, 1), (0, 2), (-1, 2)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((1, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((1, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "((0, 1), (0, 2), (-1, 2)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 2), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 2), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "((0, 1), (0, 2), (-1, 2)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 0), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 0), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "((0, 1), (0, 2), (-1, 2)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 0), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 0), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "((0, 1), (0, 2), (-1, 2)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, -1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, -1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "((0, 1), (0, 2), (-1, 2)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (1, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (1, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "((0, 1), (0, 2), (-1, 2)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (-1, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (-1, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "((0, 1), (0, 2), (-1, 2)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (1, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (1, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "((0, 1), (0, 2), (-1, 2)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 3), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 3), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "((0, 1), (0, 2), (-1, 2)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 1), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 1), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "((0, 1), (0, 2), (-1, 2)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 0), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 0), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "((0, 1), (0, 2), (-1, 2)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 1), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 1), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "((0, 1), (0, 2), (-1, 2)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, -2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, -2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "((0, 1), (0, 2), (-1, 2)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (+1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (+1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "((0, 1), (0, 2), (-1, 2)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 3)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 3)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "((0, 1), (0, 2), (-1, 2)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 1)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 1)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "((0, 1), (0, 2), (-1, 2)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 0)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 0)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "((0, 1), (0, 2), (-1, 2)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 1)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 1)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "((0, 1), (0, 2), (-1, 2)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, -2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, -2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "((0, 1), (1, 1), (2, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((1, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((1, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "((0, 1), (1, 1), (2, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((-1, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((-1, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "((0, 1), (1, 1), (2, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((1, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((1, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "((0, 1), (1, 1), (2, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 2), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 2), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "((0, 1), (1, 1), (2, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 0), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 0), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "((0, 1), (1, 1), (2, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 0), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 0), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "((0, 1), (1, 1), (2, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, -1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, -1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "((0, 1), (1, 1), (2, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (2, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (2, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "((0, 1), (1, 1), (2, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (0, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (0, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "((0, 1), (1, 1), (2, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (0, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (0, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "((0, 1), (1, 1), (2, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (-1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (-1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "((0, 1), (1, 1), (2, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 2), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 2), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "((0, 1), (1, 1), (2, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 0), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 0), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "((0, 1), (1, 1), (2, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 0), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 0), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "((0, 1), (1, 1), (2, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, -1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, -1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "((0, 1), (1, 1), (2, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (3, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (3, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "((0, 1), (1, 1), (2, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (1, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (1, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "((0, 1), (1, 1), (2, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (0, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (0, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "((0, 1), (1, 1), (2, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (1, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (1, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "((0, 1), (1, 1), (2, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (-2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (-2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "((0, 1), (1, 1), (2, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 2)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 2)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "((0, 1), (1, 1), (2, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 0)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 0)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "((0, 1), (1, 1), (2, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 0)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 0)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "((0, 1), (1, 1), (2, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, -1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, -1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "((1, 0), (0, 1), (0, 2)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((2, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((2, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "((1, 0), (0, 1), (0, 2)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((0, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((0, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "((1, 0), (0, 1), (0, 2)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((0, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((0, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "((1, 0), (0, 1), (0, 2)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((-1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((-1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "((1, 0), (0, 1), (0, 2)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 1), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 1), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "((1, 0), (0, 1), (0, 2)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, -1), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, -1), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "((1, 0), (0, 1), (0, 2)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 1), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 1), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "((1, 0), (0, 1), (0, 2)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (1, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (1, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "((1, 0), (0, 1), (0, 2)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (-1, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (-1, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "((1, 0), (0, 1), (0, 2)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (1, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (1, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "((1, 0), (0, 1), (0, 2)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 2), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 2), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "((1, 0), (0, 1), (0, 2)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 0), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 0), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "((1, 0), (0, 1), (0, 2)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 0), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 0), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "((1, 0), (0, 1), (0, 2)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, -1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, -1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "((1, 0), (0, 1), (0, 2)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (1, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (1, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "((1, 0), (0, 1), (0, 2)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (-1, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (-1, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "((1, 0), (0, 1), (0, 2)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (1, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (1, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "((1, 0), (0, 1), (0, 2)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 3)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 3)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "((1, 0), (0, 1), (0, 2)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 1)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 1)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "((1, 0), (0, 1), (0, 2)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 0)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 0)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "((1, 0), (0, 1), (0, 2)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 1)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 1)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "((1, 0), (0, 1), (0, 2)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, -2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, -2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "((0, 1), (-1, 1), (-2, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((1, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((1, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "((0, 1), (-1, 1), (-2, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((-1, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((-1, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "((0, 1), (-1, 1), (-2, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((1, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((1, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "((0, 1), (-1, 1), (-2, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 2), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 2), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "((0, 1), (-1, 1), (-2, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 0), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 0), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "((0, 1), (-1, 1), (-2, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 0), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 0), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "((0, 1), (-1, 1), (-2, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, -1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, -1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "UOI",
      "lineno": 8,
      "original_line": "((0, 1), (-1, 1), (-2, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (+1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (+1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "((0, 1), (-1, 1), (-2, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 2), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 2), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "((0, 1), (-1, 1), (-2, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 0), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 0), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "((0, 1), (-1, 1), (-2, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 0), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 0), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "((0, 1), (-1, 1), (-2, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, -1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, -1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "UOI",
      "lineno": 8,
      "original_line": "((0, 1), (-1, 1), (-2, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (+2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (+2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "((0, 1), (-1, 1), (-2, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 2)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 2)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "((0, 1), (-1, 1), (-2, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 0)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 0)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "((0, 1), (-1, 1), (-2, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 0)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 0)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "((0, 1), (-1, 1), (-2, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, -1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, -1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "((0, 1), (0, 2), (1, 2)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((1, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((1, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "((0, 1), (0, 2), (1, 2)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((-1, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((-1, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "((0, 1), (0, 2), (1, 2)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((1, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((1, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "((0, 1), (0, 2), (1, 2)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 2), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 2), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "((0, 1), (0, 2), (1, 2)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 0), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 0), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "((0, 1), (0, 2), (1, 2)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 0), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 0), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "((0, 1), (0, 2), (1, 2)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, -1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, -1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "((0, 1), (0, 2), (1, 2)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (1, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (1, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "((0, 1), (0, 2), (1, 2)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (-1, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (-1, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "((0, 1), (0, 2), (1, 2)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (1, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (1, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "((0, 1), (0, 2), (1, 2)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 3), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 3), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "((0, 1), (0, 2), (1, 2)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 1), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 1), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "((0, 1), (0, 2), (1, 2)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 0), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 0), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "((0, 1), (0, 2), (1, 2)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 1), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 1), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "((0, 1), (0, 2), (1, 2)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, -2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, -2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "((0, 1), (0, 2), (1, 2)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (2, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (2, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "((0, 1), (0, 2), (1, 2)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (0, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (0, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "((0, 1), (0, 2), (1, 2)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (0, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (0, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "((0, 1), (0, 2), (1, 2)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (-1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (-1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "((0, 1), (0, 2), (1, 2)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 3)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 3)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "((0, 1), (0, 2), (1, 2)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 1)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 1)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "((0, 1), (0, 2), (1, 2)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 0)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 0)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "((0, 1), (0, 2), (1, 2)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 1)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 1)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "((0, 1), (0, 2), (1, 2)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, -2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, -2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "((1, 0), (2, 0), (0, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((2, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((2, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "((1, 0), (2, 0), (0, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((0, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((0, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "((1, 0), (2, 0), (0, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((0, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((0, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "((1, 0), (2, 0), (0, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((-1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((-1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "((1, 0), (2, 0), (0, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 1), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 1), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "((1, 0), (2, 0), (0, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, -1), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, -1), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "((1, 0), (2, 0), (0, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 1), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 1), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "((1, 0), (2, 0), (0, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (3, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (3, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "((1, 0), (2, 0), (0, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (1, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (1, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "((1, 0), (2, 0), (0, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (0, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (0, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "((1, 0), (2, 0), (0, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (1, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (1, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "((1, 0), (2, 0), (0, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (-2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (-2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "((1, 0), (2, 0), (0, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 1), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 1), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "((1, 0), (2, 0), (0, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, -1), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, -1), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "((1, 0), (2, 0), (0, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 1), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 1), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "((1, 0), (2, 0), (0, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (1, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (1, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "((1, 0), (2, 0), (0, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (-1, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (-1, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "((1, 0), (2, 0), (0, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (1, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (1, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "((1, 0), (2, 0), (0, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 2)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 2)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "((1, 0), (2, 0), (0, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 0)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 0)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "((1, 0), (2, 0), (0, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 0)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 0)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "((1, 0), (2, 0), (0, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, -1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, -1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "((1, 0), (1, 1), (1, 2))",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((2, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((2, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "((1, 0), (1, 1), (1, 2))",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((0, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((0, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "((1, 0), (1, 1), (1, 2))",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((0, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((0, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "((1, 0), (1, 1), (1, 2))",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((-1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((-1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "((1, 0), (1, 1), (1, 2))",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 1), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 1), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "((1, 0), (1, 1), (1, 2))",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, -1), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, -1), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "((1, 0), (1, 1), (1, 2))",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 1), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 1), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "((1, 0), (1, 1), (1, 2))",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (2, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (2, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "((1, 0), (1, 1), (1, 2))",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (0, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (0, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "((1, 0), (1, 1), (1, 2))",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (0, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (0, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "((1, 0), (1, 1), (1, 2))",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (-1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (-1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "((1, 0), (1, 1), (1, 2))",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 2), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 2), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "((1, 0), (1, 1), (1, 2))",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 0), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 0), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "((1, 0), (1, 1), (1, 2))",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 0), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 0), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "((1, 0), (1, 1), (1, 2))",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, -1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, -1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "((1, 0), (1, 1), (1, 2))",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (2, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (2, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "((1, 0), (1, 1), (1, 2))",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (0, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (0, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "((1, 0), (1, 1), (1, 2))",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (0, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (0, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "((1, 0), (1, 1), (1, 2))",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (-1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (-1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "((1, 0), (1, 1), (1, 2))",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 3)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 3)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "((1, 0), (1, 1), (1, 2))",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 1)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 1)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "((1, 0), (1, 1), (1, 2))",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 0)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 0)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "((1, 0), (1, 1), (1, 2))",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 1)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 1)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "((1, 0), (1, 1), (1, 2))",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, -2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, -2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "return 1 if first == second == third == 0 else 0",
      "mutated_line": "return 1 if first != second == third == 0 else 0",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first != second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return 1 if first == second == third == 0 else 0",
      "mutated_line": "return 2 if first == second == third == 0 else 0",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 2 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return 1 if first == second == third == 0 else 0",
      "mutated_line": "return 0 if first == second == third == 0 else 0",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 0 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return 1 if first == second == third == 0 else 0",
      "mutated_line": "return 0 if first == second == third == 0 else 0",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 0 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return 1 if first == second == third == 0 else 0",
      "mutated_line": "return -1 if first == second == third == 0 else 0",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return -1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return 1 if first == second == third == 0 else 0",
      "mutated_line": "return 1 if first == second == third == 0 else 1",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 1\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return 1 if first == second == third == 0 else 0",
      "mutated_line": "return 1 if first == second == third == 0 else -1",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else -1\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return 1 if first == second == third == 0 else 0",
      "mutated_line": "return 1 if first == second == third == 0 else 1",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 1\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "return rec(y + 1, second, third, mx[y + 3])",
      "mutated_line": "return rec(y - 1, second, third, mx[y + 3])",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y - 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "return rec(y + 1, second, third, mx[y + 3])",
      "mutated_line": "return rec(y * 1, second, third, mx[y + 3])",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y * 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "LCR",
      "lineno": 37,
      "original_line": "if x < 0 or x >= M or y < 0 or y >= N:",
      "mutated_line": "if x < 0 and x >= M and (y < 0) and (y >= N):",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 and x >= M and (y < 0) and (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if res[y] & 1 << x != 0:",
      "mutated_line": "if res[y] & 1 << x == 0:",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x == 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "ans = (ans + rec(y, *nrows)) % mod",
      "mutated_line": "ans = (ans + rec(y, *nrows)) * mod",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) * mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "ans = (ans + rec(y, *nrows)) % mod",
      "mutated_line": "ans = ans + rec(y, *nrows) + mod",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = ans + rec(y, *nrows) + mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "((0, 1), (0, 2), (-1, 2)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-2, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-2, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "((0, 1), (0, 2), (-1, 2)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-0, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-0, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "((0, 1), (0, 2), (-1, 2)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-0, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-0, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "((0, 1), (0, 2), (-1, 2)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (--1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (--1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "((0, 1), (-1, 1), (-2, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-2, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-2, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "((0, 1), (-1, 1), (-2, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-0, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-0, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "((0, 1), (-1, 1), (-2, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-0, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-0, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "((0, 1), (-1, 1), (-2, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (--1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (--1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "((0, 1), (-1, 1), (-2, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-3, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-3, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "((0, 1), (-1, 1), (-2, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-1, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-1, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "((0, 1), (-1, 1), (-2, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-0, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-0, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "((0, 1), (-1, 1), (-2, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-1, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-1, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "((0, 1), (-1, 1), (-2, 1)),",
      "mutated_line": "shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (--2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (--2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]",
      "mutated_line": "mx = [int('MUTATED'.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int('MUTATED'.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return 1 if first == second == third == 0 else 0",
      "mutated_line": "return 1 if first == second == third == 1 else 0",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 1 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return 1 if first == second == third == 0 else 0",
      "mutated_line": "return 1 if first == second == third == -1 else 0",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == -1 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return 1 if first == second == third == 0 else 0",
      "mutated_line": "return 1 if first == second == third == 1 else 0",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 1 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return rec(y + 1, second, third, mx[y + 3])",
      "mutated_line": "return rec(y + 2, second, third, mx[y + 3])",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 2, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return rec(y + 1, second, third, mx[y + 3])",
      "mutated_line": "return rec(y + 0, second, third, mx[y + 3])",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 0, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return rec(y + 1, second, third, mx[y + 3])",
      "mutated_line": "return rec(y + 0, second, third, mx[y + 3])",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 0, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return rec(y + 1, second, third, mx[y + 3])",
      "mutated_line": "return rec(y + -1, second, third, mx[y + 3])",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + -1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "return rec(y + 1, second, third, mx[y + 3])",
      "mutated_line": "return rec(y + 1, second, third, mx[y - 3])",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y - 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "return rec(y + 1, second, third, mx[y + 3])",
      "mutated_line": "return rec(y + 1, second, third, mx[y * 3])",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y * 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if x < 0 or x >= M or y < 0 or y >= N:",
      "mutated_line": "if x <= 0 or x >= M or y < 0 or (y >= N):",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x <= 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if x < 0 or x >= M or y < 0 or y >= N:",
      "mutated_line": "if x >= 0 or x >= M or y < 0 or (y >= N):",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x >= 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if x < 0 or x >= M or y < 0 or y >= N:",
      "mutated_line": "if x != 0 or x >= M or y < 0 or (y >= N):",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x != 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if x < 0 or x >= M or y < 0 or y >= N:",
      "mutated_line": "if x < 0 or x > M or y < 0 or (y >= N):",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x > M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if x < 0 or x >= M or y < 0 or y >= N:",
      "mutated_line": "if x < 0 or x < M or y < 0 or (y >= N):",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x < M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if x < 0 or x >= M or y < 0 or y >= N:",
      "mutated_line": "if x < 0 or x == M or y < 0 or (y >= N):",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x == M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if x < 0 or x >= M or y < 0 or y >= N:",
      "mutated_line": "if x < 0 or x >= M or y <= 0 or (y >= N):",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y <= 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if x < 0 or x >= M or y < 0 or y >= N:",
      "mutated_line": "if x < 0 or x >= M or y >= 0 or (y >= N):",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y >= 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if x < 0 or x >= M or y < 0 or y >= N:",
      "mutated_line": "if x < 0 or x >= M or y != 0 or (y >= N):",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y != 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if x < 0 or x >= M or y < 0 or y >= N:",
      "mutated_line": "if x < 0 or x >= M or y < 0 or (y > N):",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y > N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if x < 0 or x >= M or y < 0 or y >= N:",
      "mutated_line": "if x < 0 or x >= M or y < 0 or (y < N):",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y < N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if x < 0 or x >= M or y < 0 or y >= N:",
      "mutated_line": "if x < 0 or x >= M or y < 0 or (y == N):",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y == N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "if res[y] & 1 << x != 0:",
      "mutated_line": "if res[y] | 1 << x != 0:",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] | 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if res[y] & 1 << x != 0:",
      "mutated_line": "if res[y] & 1 << x != 1:",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 1:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if res[y] & 1 << x != 0:",
      "mutated_line": "if res[y] & 1 << x != -1:",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != -1:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if res[y] & 1 << x != 0:",
      "mutated_line": "if res[y] & 1 << x != 1:",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 1:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "res[y] |= 1 << x",
      "mutated_line": "res[y] |= 2 << x",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 2 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "res[y] |= 1 << x",
      "mutated_line": "res[y] |= 0 << x",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 0 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "res[y] |= 1 << x",
      "mutated_line": "res[y] |= 0 << x",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 0 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "res[y] |= 1 << x",
      "mutated_line": "res[y] |= -1 << x",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= -1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "while first & 1 << free != 0:",
      "mutated_line": "while first & 2 << free != 0:",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 2 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "while first & 1 << free != 0:",
      "mutated_line": "while first & 0 << free != 0:",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 0 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "while first & 1 << free != 0:",
      "mutated_line": "while first & 0 << free != 0:",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 0 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "while first & 1 << free != 0:",
      "mutated_line": "while first & -1 << free != 0:",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & -1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "rows = [first | 1 << free, second, third]",
      "mutated_line": "rows = [first | 2 << free, second, third]",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 2 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "rows = [first | 1 << free, second, third]",
      "mutated_line": "rows = [first | 0 << free, second, third]",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 0 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "rows = [first | 1 << free, second, third]",
      "mutated_line": "rows = [first | 0 << free, second, third]",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 0 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "rows = [first | 1 << free, second, third]",
      "mutated_line": "rows = [first | -1 << free, second, third]",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | -1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "ans = (ans + rec(y, *nrows)) % mod",
      "mutated_line": "ans = (ans - rec(y, *nrows)) % mod",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans - rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "ans = (ans + rec(y, *nrows)) % mod",
      "mutated_line": "ans = ans * rec(y, *nrows) % mod",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = ans * rec(y, *nrows) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]",
      "mutated_line": "mx = [int(''.join(('0' if c != '.' else '1' for c in row)), 2) for row in grid]",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c != '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]",
      "mutated_line": "mx = [int(''.join(('' if c == '.' else '1' for c in row)), 2) for row in grid]",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]",
      "mutated_line": "mx = [int(''.join(('0' if c == '.' else '' for c in row)), 2) for row in grid]",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return rec(y + 1, second, third, mx[y + 3])",
      "mutated_line": "return rec(y + 1, second, third, mx[y + 4])",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 4])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return rec(y + 1, second, third, mx[y + 3])",
      "mutated_line": "return rec(y + 1, second, third, mx[y + 2])",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 2])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return rec(y + 1, second, third, mx[y + 3])",
      "mutated_line": "return rec(y + 1, second, third, mx[y + 0])",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 0])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return rec(y + 1, second, third, mx[y + 3])",
      "mutated_line": "return rec(y + 1, second, third, mx[y + 1])",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 1])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return rec(y + 1, second, third, mx[y + 3])",
      "mutated_line": "return rec(y + 1, second, third, mx[y + -3])",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + -3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if x < 0 or x >= M or y < 0 or y >= N:",
      "mutated_line": "if x < 1 or x >= M or y < 0 or (y >= N):",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 1 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if x < 0 or x >= M or y < 0 or y >= N:",
      "mutated_line": "if x < -1 or x >= M or y < 0 or (y >= N):",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < -1 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if x < 0 or x >= M or y < 0 or y >= N:",
      "mutated_line": "if x < 1 or x >= M or y < 0 or (y >= N):",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 1 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if x < 0 or x >= M or y < 0 or y >= N:",
      "mutated_line": "if x < 0 or x >= M or y < 1 or (y >= N):",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 1 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if x < 0 or x >= M or y < 0 or y >= N:",
      "mutated_line": "if x < 0 or x >= M or y < -1 or (y >= N):",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < -1 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if x < 0 or x >= M or y < 0 or y >= N:",
      "mutated_line": "if x < 0 or x >= M or y < 1 or (y >= N):",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 1 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]",
      "mutated_line": "mx = [int(''.join(('0' if c == '' else '1' for c in row)), 2) for row in grid]",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if res[y] & 1 << x != 0:",
      "mutated_line": "if res[y] & 2 << x != 0:",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 2 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if res[y] & 1 << x != 0:",
      "mutated_line": "if res[y] & 0 << x != 0:",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 0 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if res[y] & 1 << x != 0:",
      "mutated_line": "if res[y] & 0 << x != 0:",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & 0 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if res[y] & 1 << x != 0:",
      "mutated_line": "if res[y] & -1 << x != 0:",
      "code": "def count_tiling_ways(grid, N, M):\n    mod = 1000000007\n    shapes = (((1, 0), (2, 0), (2, 1)), ((0, 1), (0, 2), (-1, 2)), ((0, 1), (1, 1), (2, 1)), ((1, 0), (0, 1), (0, 2)), ((0, 1), (-1, 1), (-2, 1)), ((0, 1), (0, 2), (1, 2)), ((1, 0), (2, 0), (0, 1)), ((1, 0), (1, 1), (1, 2)))\n    mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in grid]\n    mx += 3 * [0]\n    full = (1 << M) - 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    @memoize\n    def rec(y, first, second, third):\n        if y == N:\n            return 1 if first == second == third == 0 else 0\n        if first == full:\n            return rec(y + 1, second, third, mx[y + 3])\n\n        def can_fit(rows, shape, x_offset):\n            res = rows[:]\n            for (x, y) in shape:\n                x += x_offset\n                if x < 0 or x >= M or y < 0 or (y >= N):\n                    return None\n                if res[y] & -1 << x != 0:\n                    return None\n                res[y] |= 1 << x\n            return res\n        free = 0\n        while first & 1 << free != 0:\n            free += 1\n        rows = [first | 1 << free, second, third]\n        ans = 0\n        for shape in shapes:\n            nrows = can_fit(rows, shape, free)\n            if nrows is not None:\n                ans = (ans + rec(y, *nrows)) % mod\n        return ans\n    return rec(0, mx[0], mx[1], mx[2])"
    }
  ]
}