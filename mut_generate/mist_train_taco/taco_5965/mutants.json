{
  "task_id": "taco_5965",
  "entry_point": "process_interval_queries",
  "mutant_count": 64,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "count = 0",
      "mutated_line": "count = 1",
      "code": "def process_interval_queries(queries):\n\n    class Pair:\n\n        def __init__(self, x=0, y=0):\n            self.x = x\n            self.y = y\n            self.neighbors = []\n            self.visited = False\n\n    def is_median(pair1, pair2):\n        if pair1.x > pair2.x and pair1.x < pair2.y:\n            return True\n        elif pair1.y > pair2.x and pair1.y < pair2.y:\n            return True\n        else:\n            return False\n\n    def dfs(start_pair, targ_pair):\n        stack = [start_pair]\n        while stack:\n            curr_pair = stack.pop()\n            if curr_pair.visited:\n                continue\n            curr_pair.visited = True\n            if curr_pair.x == targ_pair.x and curr_pair.y == targ_pair.y:\n                return True\n            for neighbor in curr_pair.neighbors:\n                stack.append(neighbor)\n        return False\n    pairs = {}\n    count = 1\n    results = []\n    for query in queries:\n        (query_type, first, second) = query\n        if query_type == 1:\n            new_pair = Pair(first, second)\n            for key in pairs:\n                if is_median(new_pair, pairs[key]):\n                    new_pair.neighbors.append(pairs[key])\n                if is_median(pairs[key], new_pair):\n                    pairs[key].neighbors.append(new_pair)\n            pairs[count] = new_pair\n            count += 1\n        elif query_type == 2:\n            first_pair = pairs[first - 1]\n            second_pair = pairs[second - 1]\n            for key in pairs:\n                pairs[key].visited = False\n            if dfs(first_pair, second_pair):\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "count = 0",
      "mutated_line": "count = -1",
      "code": "def process_interval_queries(queries):\n\n    class Pair:\n\n        def __init__(self, x=0, y=0):\n            self.x = x\n            self.y = y\n            self.neighbors = []\n            self.visited = False\n\n    def is_median(pair1, pair2):\n        if pair1.x > pair2.x and pair1.x < pair2.y:\n            return True\n        elif pair1.y > pair2.x and pair1.y < pair2.y:\n            return True\n        else:\n            return False\n\n    def dfs(start_pair, targ_pair):\n        stack = [start_pair]\n        while stack:\n            curr_pair = stack.pop()\n            if curr_pair.visited:\n                continue\n            curr_pair.visited = True\n            if curr_pair.x == targ_pair.x and curr_pair.y == targ_pair.y:\n                return True\n            for neighbor in curr_pair.neighbors:\n                stack.append(neighbor)\n        return False\n    pairs = {}\n    count = -1\n    results = []\n    for query in queries:\n        (query_type, first, second) = query\n        if query_type == 1:\n            new_pair = Pair(first, second)\n            for key in pairs:\n                if is_median(new_pair, pairs[key]):\n                    new_pair.neighbors.append(pairs[key])\n                if is_median(pairs[key], new_pair):\n                    pairs[key].neighbors.append(new_pair)\n            pairs[count] = new_pair\n            count += 1\n        elif query_type == 2:\n            first_pair = pairs[first - 1]\n            second_pair = pairs[second - 1]\n            for key in pairs:\n                pairs[key].visited = False\n            if dfs(first_pair, second_pair):\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "count = 0",
      "mutated_line": "count = 1",
      "code": "def process_interval_queries(queries):\n\n    class Pair:\n\n        def __init__(self, x=0, y=0):\n            self.x = x\n            self.y = y\n            self.neighbors = []\n            self.visited = False\n\n    def is_median(pair1, pair2):\n        if pair1.x > pair2.x and pair1.x < pair2.y:\n            return True\n        elif pair1.y > pair2.x and pair1.y < pair2.y:\n            return True\n        else:\n            return False\n\n    def dfs(start_pair, targ_pair):\n        stack = [start_pair]\n        while stack:\n            curr_pair = stack.pop()\n            if curr_pair.visited:\n                continue\n            curr_pair.visited = True\n            if curr_pair.x == targ_pair.x and curr_pair.y == targ_pair.y:\n                return True\n            for neighbor in curr_pair.neighbors:\n                stack.append(neighbor)\n        return False\n    pairs = {}\n    count = 1\n    results = []\n    for query in queries:\n        (query_type, first, second) = query\n        if query_type == 1:\n            new_pair = Pair(first, second)\n            for key in pairs:\n                if is_median(new_pair, pairs[key]):\n                    new_pair.neighbors.append(pairs[key])\n                if is_median(pairs[key], new_pair):\n                    pairs[key].neighbors.append(new_pair)\n            pairs[count] = new_pair\n            count += 1\n        elif query_type == 2:\n            first_pair = pairs[first - 1]\n            second_pair = pairs[second - 1]\n            for key in pairs:\n                pairs[key].visited = False\n            if dfs(first_pair, second_pair):\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 10,
      "original_line": "if pair1.x > pair2.x and pair1.x < pair2.y:",
      "mutated_line": "if pair1.x > pair2.x or pair1.x < pair2.y:",
      "code": "def process_interval_queries(queries):\n\n    class Pair:\n\n        def __init__(self, x=0, y=0):\n            self.x = x\n            self.y = y\n            self.neighbors = []\n            self.visited = False\n\n    def is_median(pair1, pair2):\n        if pair1.x > pair2.x or pair1.x < pair2.y:\n            return True\n        elif pair1.y > pair2.x and pair1.y < pair2.y:\n            return True\n        else:\n            return False\n\n    def dfs(start_pair, targ_pair):\n        stack = [start_pair]\n        while stack:\n            curr_pair = stack.pop()\n            if curr_pair.visited:\n                continue\n            curr_pair.visited = True\n            if curr_pair.x == targ_pair.x and curr_pair.y == targ_pair.y:\n                return True\n            for neighbor in curr_pair.neighbors:\n                stack.append(neighbor)\n        return False\n    pairs = {}\n    count = 0\n    results = []\n    for query in queries:\n        (query_type, first, second) = query\n        if query_type == 1:\n            new_pair = Pair(first, second)\n            for key in pairs:\n                if is_median(new_pair, pairs[key]):\n                    new_pair.neighbors.append(pairs[key])\n                if is_median(pairs[key], new_pair):\n                    pairs[key].neighbors.append(new_pair)\n            pairs[count] = new_pair\n            count += 1\n        elif query_type == 2:\n            first_pair = pairs[first - 1]\n            second_pair = pairs[second - 1]\n            for key in pairs:\n                pairs[key].visited = False\n            if dfs(first_pair, second_pair):\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def process_interval_queries(queries):\n\n    class Pair:\n\n        def __init__(self, x=0, y=0):\n            self.x = x\n            self.y = y\n            self.neighbors = []\n            self.visited = False\n\n    def is_median(pair1, pair2):\n        if pair1.x > pair2.x and pair1.x < pair2.y:\n            return True\n        elif pair1.y > pair2.x and pair1.y < pair2.y:\n            return True\n        else:\n            return False\n\n    def dfs(start_pair, targ_pair):\n        stack = [start_pair]\n        while stack:\n            curr_pair = stack.pop()\n            if curr_pair.visited:\n                continue\n            curr_pair.visited = True\n            if curr_pair.x == targ_pair.x and curr_pair.y == targ_pair.y:\n                return True\n            for neighbor in curr_pair.neighbors:\n                stack.append(neighbor)\n        return True\n    pairs = {}\n    count = 0\n    results = []\n    for query in queries:\n        (query_type, first, second) = query\n        if query_type == 1:\n            new_pair = Pair(first, second)\n            for key in pairs:\n                if is_median(new_pair, pairs[key]):\n                    new_pair.neighbors.append(pairs[key])\n                if is_median(pairs[key], new_pair):\n                    pairs[key].neighbors.append(new_pair)\n            pairs[count] = new_pair\n            count += 1\n        elif query_type == 2:\n            first_pair = pairs[first - 1]\n            second_pair = pairs[second - 1]\n            for key in pairs:\n                pairs[key].visited = False\n            if dfs(first_pair, second_pair):\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if query_type == 1:",
      "mutated_line": "if query_type != 1:",
      "code": "def process_interval_queries(queries):\n\n    class Pair:\n\n        def __init__(self, x=0, y=0):\n            self.x = x\n            self.y = y\n            self.neighbors = []\n            self.visited = False\n\n    def is_median(pair1, pair2):\n        if pair1.x > pair2.x and pair1.x < pair2.y:\n            return True\n        elif pair1.y > pair2.x and pair1.y < pair2.y:\n            return True\n        else:\n            return False\n\n    def dfs(start_pair, targ_pair):\n        stack = [start_pair]\n        while stack:\n            curr_pair = stack.pop()\n            if curr_pair.visited:\n                continue\n            curr_pair.visited = True\n            if curr_pair.x == targ_pair.x and curr_pair.y == targ_pair.y:\n                return True\n            for neighbor in curr_pair.neighbors:\n                stack.append(neighbor)\n        return False\n    pairs = {}\n    count = 0\n    results = []\n    for query in queries:\n        (query_type, first, second) = query\n        if query_type != 1:\n            new_pair = Pair(first, second)\n            for key in pairs:\n                if is_median(new_pair, pairs[key]):\n                    new_pair.neighbors.append(pairs[key])\n                if is_median(pairs[key], new_pair):\n                    pairs[key].neighbors.append(new_pair)\n            pairs[count] = new_pair\n            count += 1\n        elif query_type == 2:\n            first_pair = pairs[first - 1]\n            second_pair = pairs[second - 1]\n            for key in pairs:\n                pairs[key].visited = False\n            if dfs(first_pair, second_pair):\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 44,
      "original_line": "count += 1",
      "mutated_line": "count -= 1",
      "code": "def process_interval_queries(queries):\n\n    class Pair:\n\n        def __init__(self, x=0, y=0):\n            self.x = x\n            self.y = y\n            self.neighbors = []\n            self.visited = False\n\n    def is_median(pair1, pair2):\n        if pair1.x > pair2.x and pair1.x < pair2.y:\n            return True\n        elif pair1.y > pair2.x and pair1.y < pair2.y:\n            return True\n        else:\n            return False\n\n    def dfs(start_pair, targ_pair):\n        stack = [start_pair]\n        while stack:\n            curr_pair = stack.pop()\n            if curr_pair.visited:\n                continue\n            curr_pair.visited = True\n            if curr_pair.x == targ_pair.x and curr_pair.y == targ_pair.y:\n                return True\n            for neighbor in curr_pair.neighbors:\n                stack.append(neighbor)\n        return False\n    pairs = {}\n    count = 0\n    results = []\n    for query in queries:\n        (query_type, first, second) = query\n        if query_type == 1:\n            new_pair = Pair(first, second)\n            for key in pairs:\n                if is_median(new_pair, pairs[key]):\n                    new_pair.neighbors.append(pairs[key])\n                if is_median(pairs[key], new_pair):\n                    pairs[key].neighbors.append(new_pair)\n            pairs[count] = new_pair\n            count -= 1\n        elif query_type == 2:\n            first_pair = pairs[first - 1]\n            second_pair = pairs[second - 1]\n            for key in pairs:\n                pairs[key].visited = False\n            if dfs(first_pair, second_pair):\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def __init__(self, x=0, y=0):",
      "mutated_line": "",
      "code": "def process_interval_queries(queries):\n\n    class Pair:\n\n        def __init__(self, x=1, y=0):\n            self.x = x\n            self.y = y\n            self.neighbors = []\n            self.visited = False\n\n    def is_median(pair1, pair2):\n        if pair1.x > pair2.x and pair1.x < pair2.y:\n            return True\n        elif pair1.y > pair2.x and pair1.y < pair2.y:\n            return True\n        else:\n            return False\n\n    def dfs(start_pair, targ_pair):\n        stack = [start_pair]\n        while stack:\n            curr_pair = stack.pop()\n            if curr_pair.visited:\n                continue\n            curr_pair.visited = True\n            if curr_pair.x == targ_pair.x and curr_pair.y == targ_pair.y:\n                return True\n            for neighbor in curr_pair.neighbors:\n                stack.append(neighbor)\n        return False\n    pairs = {}\n    count = 0\n    results = []\n    for query in queries:\n        (query_type, first, second) = query\n        if query_type == 1:\n            new_pair = Pair(first, second)\n            for key in pairs:\n                if is_median(new_pair, pairs[key]):\n                    new_pair.neighbors.append(pairs[key])\n                if is_median(pairs[key], new_pair):\n                    pairs[key].neighbors.append(new_pair)\n            pairs[count] = new_pair\n            count += 1\n        elif query_type == 2:\n            first_pair = pairs[first - 1]\n            second_pair = pairs[second - 1]\n            for key in pairs:\n                pairs[key].visited = False\n            if dfs(first_pair, second_pair):\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def __init__(self, x=0, y=0):",
      "mutated_line": "",
      "code": "def process_interval_queries(queries):\n\n    class Pair:\n\n        def __init__(self, x=-1, y=0):\n            self.x = x\n            self.y = y\n            self.neighbors = []\n            self.visited = False\n\n    def is_median(pair1, pair2):\n        if pair1.x > pair2.x and pair1.x < pair2.y:\n            return True\n        elif pair1.y > pair2.x and pair1.y < pair2.y:\n            return True\n        else:\n            return False\n\n    def dfs(start_pair, targ_pair):\n        stack = [start_pair]\n        while stack:\n            curr_pair = stack.pop()\n            if curr_pair.visited:\n                continue\n            curr_pair.visited = True\n            if curr_pair.x == targ_pair.x and curr_pair.y == targ_pair.y:\n                return True\n            for neighbor in curr_pair.neighbors:\n                stack.append(neighbor)\n        return False\n    pairs = {}\n    count = 0\n    results = []\n    for query in queries:\n        (query_type, first, second) = query\n        if query_type == 1:\n            new_pair = Pair(first, second)\n            for key in pairs:\n                if is_median(new_pair, pairs[key]):\n                    new_pair.neighbors.append(pairs[key])\n                if is_median(pairs[key], new_pair):\n                    pairs[key].neighbors.append(new_pair)\n            pairs[count] = new_pair\n            count += 1\n        elif query_type == 2:\n            first_pair = pairs[first - 1]\n            second_pair = pairs[second - 1]\n            for key in pairs:\n                pairs[key].visited = False\n            if dfs(first_pair, second_pair):\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def __init__(self, x=0, y=0):",
      "mutated_line": "",
      "code": "def process_interval_queries(queries):\n\n    class Pair:\n\n        def __init__(self, x=1, y=0):\n            self.x = x\n            self.y = y\n            self.neighbors = []\n            self.visited = False\n\n    def is_median(pair1, pair2):\n        if pair1.x > pair2.x and pair1.x < pair2.y:\n            return True\n        elif pair1.y > pair2.x and pair1.y < pair2.y:\n            return True\n        else:\n            return False\n\n    def dfs(start_pair, targ_pair):\n        stack = [start_pair]\n        while stack:\n            curr_pair = stack.pop()\n            if curr_pair.visited:\n                continue\n            curr_pair.visited = True\n            if curr_pair.x == targ_pair.x and curr_pair.y == targ_pair.y:\n                return True\n            for neighbor in curr_pair.neighbors:\n                stack.append(neighbor)\n        return False\n    pairs = {}\n    count = 0\n    results = []\n    for query in queries:\n        (query_type, first, second) = query\n        if query_type == 1:\n            new_pair = Pair(first, second)\n            for key in pairs:\n                if is_median(new_pair, pairs[key]):\n                    new_pair.neighbors.append(pairs[key])\n                if is_median(pairs[key], new_pair):\n                    pairs[key].neighbors.append(new_pair)\n            pairs[count] = new_pair\n            count += 1\n        elif query_type == 2:\n            first_pair = pairs[first - 1]\n            second_pair = pairs[second - 1]\n            for key in pairs:\n                pairs[key].visited = False\n            if dfs(first_pair, second_pair):\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def __init__(self, x=0, y=0):",
      "mutated_line": "",
      "code": "def process_interval_queries(queries):\n\n    class Pair:\n\n        def __init__(self, x=0, y=1):\n            self.x = x\n            self.y = y\n            self.neighbors = []\n            self.visited = False\n\n    def is_median(pair1, pair2):\n        if pair1.x > pair2.x and pair1.x < pair2.y:\n            return True\n        elif pair1.y > pair2.x and pair1.y < pair2.y:\n            return True\n        else:\n            return False\n\n    def dfs(start_pair, targ_pair):\n        stack = [start_pair]\n        while stack:\n            curr_pair = stack.pop()\n            if curr_pair.visited:\n                continue\n            curr_pair.visited = True\n            if curr_pair.x == targ_pair.x and curr_pair.y == targ_pair.y:\n                return True\n            for neighbor in curr_pair.neighbors:\n                stack.append(neighbor)\n        return False\n    pairs = {}\n    count = 0\n    results = []\n    for query in queries:\n        (query_type, first, second) = query\n        if query_type == 1:\n            new_pair = Pair(first, second)\n            for key in pairs:\n                if is_median(new_pair, pairs[key]):\n                    new_pair.neighbors.append(pairs[key])\n                if is_median(pairs[key], new_pair):\n                    pairs[key].neighbors.append(new_pair)\n            pairs[count] = new_pair\n            count += 1\n        elif query_type == 2:\n            first_pair = pairs[first - 1]\n            second_pair = pairs[second - 1]\n            for key in pairs:\n                pairs[key].visited = False\n            if dfs(first_pair, second_pair):\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def __init__(self, x=0, y=0):",
      "mutated_line": "",
      "code": "def process_interval_queries(queries):\n\n    class Pair:\n\n        def __init__(self, x=0, y=-1):\n            self.x = x\n            self.y = y\n            self.neighbors = []\n            self.visited = False\n\n    def is_median(pair1, pair2):\n        if pair1.x > pair2.x and pair1.x < pair2.y:\n            return True\n        elif pair1.y > pair2.x and pair1.y < pair2.y:\n            return True\n        else:\n            return False\n\n    def dfs(start_pair, targ_pair):\n        stack = [start_pair]\n        while stack:\n            curr_pair = stack.pop()\n            if curr_pair.visited:\n                continue\n            curr_pair.visited = True\n            if curr_pair.x == targ_pair.x and curr_pair.y == targ_pair.y:\n                return True\n            for neighbor in curr_pair.neighbors:\n                stack.append(neighbor)\n        return False\n    pairs = {}\n    count = 0\n    results = []\n    for query in queries:\n        (query_type, first, second) = query\n        if query_type == 1:\n            new_pair = Pair(first, second)\n            for key in pairs:\n                if is_median(new_pair, pairs[key]):\n                    new_pair.neighbors.append(pairs[key])\n                if is_median(pairs[key], new_pair):\n                    pairs[key].neighbors.append(new_pair)\n            pairs[count] = new_pair\n            count += 1\n        elif query_type == 2:\n            first_pair = pairs[first - 1]\n            second_pair = pairs[second - 1]\n            for key in pairs:\n                pairs[key].visited = False\n            if dfs(first_pair, second_pair):\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "def __init__(self, x=0, y=0):",
      "mutated_line": "",
      "code": "def process_interval_queries(queries):\n\n    class Pair:\n\n        def __init__(self, x=0, y=1):\n            self.x = x\n            self.y = y\n            self.neighbors = []\n            self.visited = False\n\n    def is_median(pair1, pair2):\n        if pair1.x > pair2.x and pair1.x < pair2.y:\n            return True\n        elif pair1.y > pair2.x and pair1.y < pair2.y:\n            return True\n        else:\n            return False\n\n    def dfs(start_pair, targ_pair):\n        stack = [start_pair]\n        while stack:\n            curr_pair = stack.pop()\n            if curr_pair.visited:\n                continue\n            curr_pair.visited = True\n            if curr_pair.x == targ_pair.x and curr_pair.y == targ_pair.y:\n                return True\n            for neighbor in curr_pair.neighbors:\n                stack.append(neighbor)\n        return False\n    pairs = {}\n    count = 0\n    results = []\n    for query in queries:\n        (query_type, first, second) = query\n        if query_type == 1:\n            new_pair = Pair(first, second)\n            for key in pairs:\n                if is_median(new_pair, pairs[key]):\n                    new_pair.neighbors.append(pairs[key])\n                if is_median(pairs[key], new_pair):\n                    pairs[key].neighbors.append(new_pair)\n            pairs[count] = new_pair\n            count += 1\n        elif query_type == 2:\n            first_pair = pairs[first - 1]\n            second_pair = pairs[second - 1]\n            for key in pairs:\n                pairs[key].visited = False\n            if dfs(first_pair, second_pair):\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "self.visited = False",
      "mutated_line": "self.visited = True",
      "code": "def process_interval_queries(queries):\n\n    class Pair:\n\n        def __init__(self, x=0, y=0):\n            self.x = x\n            self.y = y\n            self.neighbors = []\n            self.visited = True\n\n    def is_median(pair1, pair2):\n        if pair1.x > pair2.x and pair1.x < pair2.y:\n            return True\n        elif pair1.y > pair2.x and pair1.y < pair2.y:\n            return True\n        else:\n            return False\n\n    def dfs(start_pair, targ_pair):\n        stack = [start_pair]\n        while stack:\n            curr_pair = stack.pop()\n            if curr_pair.visited:\n                continue\n            curr_pair.visited = True\n            if curr_pair.x == targ_pair.x and curr_pair.y == targ_pair.y:\n                return True\n            for neighbor in curr_pair.neighbors:\n                stack.append(neighbor)\n        return False\n    pairs = {}\n    count = 0\n    results = []\n    for query in queries:\n        (query_type, first, second) = query\n        if query_type == 1:\n            new_pair = Pair(first, second)\n            for key in pairs:\n                if is_median(new_pair, pairs[key]):\n                    new_pair.neighbors.append(pairs[key])\n                if is_median(pairs[key], new_pair):\n                    pairs[key].neighbors.append(new_pair)\n            pairs[count] = new_pair\n            count += 1\n        elif query_type == 2:\n            first_pair = pairs[first - 1]\n            second_pair = pairs[second - 1]\n            for key in pairs:\n                pairs[key].visited = False\n            if dfs(first_pair, second_pair):\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if pair1.x > pair2.x and pair1.x < pair2.y:",
      "mutated_line": "if pair1.x >= pair2.x and pair1.x < pair2.y:",
      "code": "def process_interval_queries(queries):\n\n    class Pair:\n\n        def __init__(self, x=0, y=0):\n            self.x = x\n            self.y = y\n            self.neighbors = []\n            self.visited = False\n\n    def is_median(pair1, pair2):\n        if pair1.x >= pair2.x and pair1.x < pair2.y:\n            return True\n        elif pair1.y > pair2.x and pair1.y < pair2.y:\n            return True\n        else:\n            return False\n\n    def dfs(start_pair, targ_pair):\n        stack = [start_pair]\n        while stack:\n            curr_pair = stack.pop()\n            if curr_pair.visited:\n                continue\n            curr_pair.visited = True\n            if curr_pair.x == targ_pair.x and curr_pair.y == targ_pair.y:\n                return True\n            for neighbor in curr_pair.neighbors:\n                stack.append(neighbor)\n        return False\n    pairs = {}\n    count = 0\n    results = []\n    for query in queries:\n        (query_type, first, second) = query\n        if query_type == 1:\n            new_pair = Pair(first, second)\n            for key in pairs:\n                if is_median(new_pair, pairs[key]):\n                    new_pair.neighbors.append(pairs[key])\n                if is_median(pairs[key], new_pair):\n                    pairs[key].neighbors.append(new_pair)\n            pairs[count] = new_pair\n            count += 1\n        elif query_type == 2:\n            first_pair = pairs[first - 1]\n            second_pair = pairs[second - 1]\n            for key in pairs:\n                pairs[key].visited = False\n            if dfs(first_pair, second_pair):\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if pair1.x > pair2.x and pair1.x < pair2.y:",
      "mutated_line": "if pair1.x <= pair2.x and pair1.x < pair2.y:",
      "code": "def process_interval_queries(queries):\n\n    class Pair:\n\n        def __init__(self, x=0, y=0):\n            self.x = x\n            self.y = y\n            self.neighbors = []\n            self.visited = False\n\n    def is_median(pair1, pair2):\n        if pair1.x <= pair2.x and pair1.x < pair2.y:\n            return True\n        elif pair1.y > pair2.x and pair1.y < pair2.y:\n            return True\n        else:\n            return False\n\n    def dfs(start_pair, targ_pair):\n        stack = [start_pair]\n        while stack:\n            curr_pair = stack.pop()\n            if curr_pair.visited:\n                continue\n            curr_pair.visited = True\n            if curr_pair.x == targ_pair.x and curr_pair.y == targ_pair.y:\n                return True\n            for neighbor in curr_pair.neighbors:\n                stack.append(neighbor)\n        return False\n    pairs = {}\n    count = 0\n    results = []\n    for query in queries:\n        (query_type, first, second) = query\n        if query_type == 1:\n            new_pair = Pair(first, second)\n            for key in pairs:\n                if is_median(new_pair, pairs[key]):\n                    new_pair.neighbors.append(pairs[key])\n                if is_median(pairs[key], new_pair):\n                    pairs[key].neighbors.append(new_pair)\n            pairs[count] = new_pair\n            count += 1\n        elif query_type == 2:\n            first_pair = pairs[first - 1]\n            second_pair = pairs[second - 1]\n            for key in pairs:\n                pairs[key].visited = False\n            if dfs(first_pair, second_pair):\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if pair1.x > pair2.x and pair1.x < pair2.y:",
      "mutated_line": "if pair1.x != pair2.x and pair1.x < pair2.y:",
      "code": "def process_interval_queries(queries):\n\n    class Pair:\n\n        def __init__(self, x=0, y=0):\n            self.x = x\n            self.y = y\n            self.neighbors = []\n            self.visited = False\n\n    def is_median(pair1, pair2):\n        if pair1.x != pair2.x and pair1.x < pair2.y:\n            return True\n        elif pair1.y > pair2.x and pair1.y < pair2.y:\n            return True\n        else:\n            return False\n\n    def dfs(start_pair, targ_pair):\n        stack = [start_pair]\n        while stack:\n            curr_pair = stack.pop()\n            if curr_pair.visited:\n                continue\n            curr_pair.visited = True\n            if curr_pair.x == targ_pair.x and curr_pair.y == targ_pair.y:\n                return True\n            for neighbor in curr_pair.neighbors:\n                stack.append(neighbor)\n        return False\n    pairs = {}\n    count = 0\n    results = []\n    for query in queries:\n        (query_type, first, second) = query\n        if query_type == 1:\n            new_pair = Pair(first, second)\n            for key in pairs:\n                if is_median(new_pair, pairs[key]):\n                    new_pair.neighbors.append(pairs[key])\n                if is_median(pairs[key], new_pair):\n                    pairs[key].neighbors.append(new_pair)\n            pairs[count] = new_pair\n            count += 1\n        elif query_type == 2:\n            first_pair = pairs[first - 1]\n            second_pair = pairs[second - 1]\n            for key in pairs:\n                pairs[key].visited = False\n            if dfs(first_pair, second_pair):\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if pair1.x > pair2.x and pair1.x < pair2.y:",
      "mutated_line": "if pair1.x > pair2.x and pair1.x <= pair2.y:",
      "code": "def process_interval_queries(queries):\n\n    class Pair:\n\n        def __init__(self, x=0, y=0):\n            self.x = x\n            self.y = y\n            self.neighbors = []\n            self.visited = False\n\n    def is_median(pair1, pair2):\n        if pair1.x > pair2.x and pair1.x <= pair2.y:\n            return True\n        elif pair1.y > pair2.x and pair1.y < pair2.y:\n            return True\n        else:\n            return False\n\n    def dfs(start_pair, targ_pair):\n        stack = [start_pair]\n        while stack:\n            curr_pair = stack.pop()\n            if curr_pair.visited:\n                continue\n            curr_pair.visited = True\n            if curr_pair.x == targ_pair.x and curr_pair.y == targ_pair.y:\n                return True\n            for neighbor in curr_pair.neighbors:\n                stack.append(neighbor)\n        return False\n    pairs = {}\n    count = 0\n    results = []\n    for query in queries:\n        (query_type, first, second) = query\n        if query_type == 1:\n            new_pair = Pair(first, second)\n            for key in pairs:\n                if is_median(new_pair, pairs[key]):\n                    new_pair.neighbors.append(pairs[key])\n                if is_median(pairs[key], new_pair):\n                    pairs[key].neighbors.append(new_pair)\n            pairs[count] = new_pair\n            count += 1\n        elif query_type == 2:\n            first_pair = pairs[first - 1]\n            second_pair = pairs[second - 1]\n            for key in pairs:\n                pairs[key].visited = False\n            if dfs(first_pair, second_pair):\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if pair1.x > pair2.x and pair1.x < pair2.y:",
      "mutated_line": "if pair1.x > pair2.x and pair1.x >= pair2.y:",
      "code": "def process_interval_queries(queries):\n\n    class Pair:\n\n        def __init__(self, x=0, y=0):\n            self.x = x\n            self.y = y\n            self.neighbors = []\n            self.visited = False\n\n    def is_median(pair1, pair2):\n        if pair1.x > pair2.x and pair1.x >= pair2.y:\n            return True\n        elif pair1.y > pair2.x and pair1.y < pair2.y:\n            return True\n        else:\n            return False\n\n    def dfs(start_pair, targ_pair):\n        stack = [start_pair]\n        while stack:\n            curr_pair = stack.pop()\n            if curr_pair.visited:\n                continue\n            curr_pair.visited = True\n            if curr_pair.x == targ_pair.x and curr_pair.y == targ_pair.y:\n                return True\n            for neighbor in curr_pair.neighbors:\n                stack.append(neighbor)\n        return False\n    pairs = {}\n    count = 0\n    results = []\n    for query in queries:\n        (query_type, first, second) = query\n        if query_type == 1:\n            new_pair = Pair(first, second)\n            for key in pairs:\n                if is_median(new_pair, pairs[key]):\n                    new_pair.neighbors.append(pairs[key])\n                if is_median(pairs[key], new_pair):\n                    pairs[key].neighbors.append(new_pair)\n            pairs[count] = new_pair\n            count += 1\n        elif query_type == 2:\n            first_pair = pairs[first - 1]\n            second_pair = pairs[second - 1]\n            for key in pairs:\n                pairs[key].visited = False\n            if dfs(first_pair, second_pair):\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if pair1.x > pair2.x and pair1.x < pair2.y:",
      "mutated_line": "if pair1.x > pair2.x and pair1.x != pair2.y:",
      "code": "def process_interval_queries(queries):\n\n    class Pair:\n\n        def __init__(self, x=0, y=0):\n            self.x = x\n            self.y = y\n            self.neighbors = []\n            self.visited = False\n\n    def is_median(pair1, pair2):\n        if pair1.x > pair2.x and pair1.x != pair2.y:\n            return True\n        elif pair1.y > pair2.x and pair1.y < pair2.y:\n            return True\n        else:\n            return False\n\n    def dfs(start_pair, targ_pair):\n        stack = [start_pair]\n        while stack:\n            curr_pair = stack.pop()\n            if curr_pair.visited:\n                continue\n            curr_pair.visited = True\n            if curr_pair.x == targ_pair.x and curr_pair.y == targ_pair.y:\n                return True\n            for neighbor in curr_pair.neighbors:\n                stack.append(neighbor)\n        return False\n    pairs = {}\n    count = 0\n    results = []\n    for query in queries:\n        (query_type, first, second) = query\n        if query_type == 1:\n            new_pair = Pair(first, second)\n            for key in pairs:\n                if is_median(new_pair, pairs[key]):\n                    new_pair.neighbors.append(pairs[key])\n                if is_median(pairs[key], new_pair):\n                    pairs[key].neighbors.append(new_pair)\n            pairs[count] = new_pair\n            count += 1\n        elif query_type == 2:\n            first_pair = pairs[first - 1]\n            second_pair = pairs[second - 1]\n            for key in pairs:\n                pairs[key].visited = False\n            if dfs(first_pair, second_pair):\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def process_interval_queries(queries):\n\n    class Pair:\n\n        def __init__(self, x=0, y=0):\n            self.x = x\n            self.y = y\n            self.neighbors = []\n            self.visited = False\n\n    def is_median(pair1, pair2):\n        if pair1.x > pair2.x and pair1.x < pair2.y:\n            return False\n        elif pair1.y > pair2.x and pair1.y < pair2.y:\n            return True\n        else:\n            return False\n\n    def dfs(start_pair, targ_pair):\n        stack = [start_pair]\n        while stack:\n            curr_pair = stack.pop()\n            if curr_pair.visited:\n                continue\n            curr_pair.visited = True\n            if curr_pair.x == targ_pair.x and curr_pair.y == targ_pair.y:\n                return True\n            for neighbor in curr_pair.neighbors:\n                stack.append(neighbor)\n        return False\n    pairs = {}\n    count = 0\n    results = []\n    for query in queries:\n        (query_type, first, second) = query\n        if query_type == 1:\n            new_pair = Pair(first, second)\n            for key in pairs:\n                if is_median(new_pair, pairs[key]):\n                    new_pair.neighbors.append(pairs[key])\n                if is_median(pairs[key], new_pair):\n                    pairs[key].neighbors.append(new_pair)\n            pairs[count] = new_pair\n            count += 1\n        elif query_type == 2:\n            first_pair = pairs[first - 1]\n            second_pair = pairs[second - 1]\n            for key in pairs:\n                pairs[key].visited = False\n            if dfs(first_pair, second_pair):\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 12,
      "original_line": "elif pair1.y > pair2.x and pair1.y < pair2.y:",
      "mutated_line": "elif pair1.y > pair2.x or pair1.y < pair2.y:",
      "code": "def process_interval_queries(queries):\n\n    class Pair:\n\n        def __init__(self, x=0, y=0):\n            self.x = x\n            self.y = y\n            self.neighbors = []\n            self.visited = False\n\n    def is_median(pair1, pair2):\n        if pair1.x > pair2.x and pair1.x < pair2.y:\n            return True\n        elif pair1.y > pair2.x or pair1.y < pair2.y:\n            return True\n        else:\n            return False\n\n    def dfs(start_pair, targ_pair):\n        stack = [start_pair]\n        while stack:\n            curr_pair = stack.pop()\n            if curr_pair.visited:\n                continue\n            curr_pair.visited = True\n            if curr_pair.x == targ_pair.x and curr_pair.y == targ_pair.y:\n                return True\n            for neighbor in curr_pair.neighbors:\n                stack.append(neighbor)\n        return False\n    pairs = {}\n    count = 0\n    results = []\n    for query in queries:\n        (query_type, first, second) = query\n        if query_type == 1:\n            new_pair = Pair(first, second)\n            for key in pairs:\n                if is_median(new_pair, pairs[key]):\n                    new_pair.neighbors.append(pairs[key])\n                if is_median(pairs[key], new_pair):\n                    pairs[key].neighbors.append(new_pair)\n            pairs[count] = new_pair\n            count += 1\n        elif query_type == 2:\n            first_pair = pairs[first - 1]\n            second_pair = pairs[second - 1]\n            for key in pairs:\n                pairs[key].visited = False\n            if dfs(first_pair, second_pair):\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "curr_pair.visited = True",
      "mutated_line": "curr_pair.visited = False",
      "code": "def process_interval_queries(queries):\n\n    class Pair:\n\n        def __init__(self, x=0, y=0):\n            self.x = x\n            self.y = y\n            self.neighbors = []\n            self.visited = False\n\n    def is_median(pair1, pair2):\n        if pair1.x > pair2.x and pair1.x < pair2.y:\n            return True\n        elif pair1.y > pair2.x and pair1.y < pair2.y:\n            return True\n        else:\n            return False\n\n    def dfs(start_pair, targ_pair):\n        stack = [start_pair]\n        while stack:\n            curr_pair = stack.pop()\n            if curr_pair.visited:\n                continue\n            curr_pair.visited = False\n            if curr_pair.x == targ_pair.x and curr_pair.y == targ_pair.y:\n                return True\n            for neighbor in curr_pair.neighbors:\n                stack.append(neighbor)\n        return False\n    pairs = {}\n    count = 0\n    results = []\n    for query in queries:\n        (query_type, first, second) = query\n        if query_type == 1:\n            new_pair = Pair(first, second)\n            for key in pairs:\n                if is_median(new_pair, pairs[key]):\n                    new_pair.neighbors.append(pairs[key])\n                if is_median(pairs[key], new_pair):\n                    pairs[key].neighbors.append(new_pair)\n            pairs[count] = new_pair\n            count += 1\n        elif query_type == 2:\n            first_pair = pairs[first - 1]\n            second_pair = pairs[second - 1]\n            for key in pairs:\n                pairs[key].visited = False\n            if dfs(first_pair, second_pair):\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 24,
      "original_line": "if curr_pair.x == targ_pair.x and curr_pair.y == targ_pair.y:",
      "mutated_line": "if curr_pair.x == targ_pair.x or curr_pair.y == targ_pair.y:",
      "code": "def process_interval_queries(queries):\n\n    class Pair:\n\n        def __init__(self, x=0, y=0):\n            self.x = x\n            self.y = y\n            self.neighbors = []\n            self.visited = False\n\n    def is_median(pair1, pair2):\n        if pair1.x > pair2.x and pair1.x < pair2.y:\n            return True\n        elif pair1.y > pair2.x and pair1.y < pair2.y:\n            return True\n        else:\n            return False\n\n    def dfs(start_pair, targ_pair):\n        stack = [start_pair]\n        while stack:\n            curr_pair = stack.pop()\n            if curr_pair.visited:\n                continue\n            curr_pair.visited = True\n            if curr_pair.x == targ_pair.x or curr_pair.y == targ_pair.y:\n                return True\n            for neighbor in curr_pair.neighbors:\n                stack.append(neighbor)\n        return False\n    pairs = {}\n    count = 0\n    results = []\n    for query in queries:\n        (query_type, first, second) = query\n        if query_type == 1:\n            new_pair = Pair(first, second)\n            for key in pairs:\n                if is_median(new_pair, pairs[key]):\n                    new_pair.neighbors.append(pairs[key])\n                if is_median(pairs[key], new_pair):\n                    pairs[key].neighbors.append(new_pair)\n            pairs[count] = new_pair\n            count += 1\n        elif query_type == 2:\n            first_pair = pairs[first - 1]\n            second_pair = pairs[second - 1]\n            for key in pairs:\n                pairs[key].visited = False\n            if dfs(first_pair, second_pair):\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if query_type == 1:",
      "mutated_line": "if query_type == 2:",
      "code": "def process_interval_queries(queries):\n\n    class Pair:\n\n        def __init__(self, x=0, y=0):\n            self.x = x\n            self.y = y\n            self.neighbors = []\n            self.visited = False\n\n    def is_median(pair1, pair2):\n        if pair1.x > pair2.x and pair1.x < pair2.y:\n            return True\n        elif pair1.y > pair2.x and pair1.y < pair2.y:\n            return True\n        else:\n            return False\n\n    def dfs(start_pair, targ_pair):\n        stack = [start_pair]\n        while stack:\n            curr_pair = stack.pop()\n            if curr_pair.visited:\n                continue\n            curr_pair.visited = True\n            if curr_pair.x == targ_pair.x and curr_pair.y == targ_pair.y:\n                return True\n            for neighbor in curr_pair.neighbors:\n                stack.append(neighbor)\n        return False\n    pairs = {}\n    count = 0\n    results = []\n    for query in queries:\n        (query_type, first, second) = query\n        if query_type == 2:\n            new_pair = Pair(first, second)\n            for key in pairs:\n                if is_median(new_pair, pairs[key]):\n                    new_pair.neighbors.append(pairs[key])\n                if is_median(pairs[key], new_pair):\n                    pairs[key].neighbors.append(new_pair)\n            pairs[count] = new_pair\n            count += 1\n        elif query_type == 2:\n            first_pair = pairs[first - 1]\n            second_pair = pairs[second - 1]\n            for key in pairs:\n                pairs[key].visited = False\n            if dfs(first_pair, second_pair):\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if query_type == 1:",
      "mutated_line": "if query_type == 0:",
      "code": "def process_interval_queries(queries):\n\n    class Pair:\n\n        def __init__(self, x=0, y=0):\n            self.x = x\n            self.y = y\n            self.neighbors = []\n            self.visited = False\n\n    def is_median(pair1, pair2):\n        if pair1.x > pair2.x and pair1.x < pair2.y:\n            return True\n        elif pair1.y > pair2.x and pair1.y < pair2.y:\n            return True\n        else:\n            return False\n\n    def dfs(start_pair, targ_pair):\n        stack = [start_pair]\n        while stack:\n            curr_pair = stack.pop()\n            if curr_pair.visited:\n                continue\n            curr_pair.visited = True\n            if curr_pair.x == targ_pair.x and curr_pair.y == targ_pair.y:\n                return True\n            for neighbor in curr_pair.neighbors:\n                stack.append(neighbor)\n        return False\n    pairs = {}\n    count = 0\n    results = []\n    for query in queries:\n        (query_type, first, second) = query\n        if query_type == 0:\n            new_pair = Pair(first, second)\n            for key in pairs:\n                if is_median(new_pair, pairs[key]):\n                    new_pair.neighbors.append(pairs[key])\n                if is_median(pairs[key], new_pair):\n                    pairs[key].neighbors.append(new_pair)\n            pairs[count] = new_pair\n            count += 1\n        elif query_type == 2:\n            first_pair = pairs[first - 1]\n            second_pair = pairs[second - 1]\n            for key in pairs:\n                pairs[key].visited = False\n            if dfs(first_pair, second_pair):\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if query_type == 1:",
      "mutated_line": "if query_type == 0:",
      "code": "def process_interval_queries(queries):\n\n    class Pair:\n\n        def __init__(self, x=0, y=0):\n            self.x = x\n            self.y = y\n            self.neighbors = []\n            self.visited = False\n\n    def is_median(pair1, pair2):\n        if pair1.x > pair2.x and pair1.x < pair2.y:\n            return True\n        elif pair1.y > pair2.x and pair1.y < pair2.y:\n            return True\n        else:\n            return False\n\n    def dfs(start_pair, targ_pair):\n        stack = [start_pair]\n        while stack:\n            curr_pair = stack.pop()\n            if curr_pair.visited:\n                continue\n            curr_pair.visited = True\n            if curr_pair.x == targ_pair.x and curr_pair.y == targ_pair.y:\n                return True\n            for neighbor in curr_pair.neighbors:\n                stack.append(neighbor)\n        return False\n    pairs = {}\n    count = 0\n    results = []\n    for query in queries:\n        (query_type, first, second) = query\n        if query_type == 0:\n            new_pair = Pair(first, second)\n            for key in pairs:\n                if is_median(new_pair, pairs[key]):\n                    new_pair.neighbors.append(pairs[key])\n                if is_median(pairs[key], new_pair):\n                    pairs[key].neighbors.append(new_pair)\n            pairs[count] = new_pair\n            count += 1\n        elif query_type == 2:\n            first_pair = pairs[first - 1]\n            second_pair = pairs[second - 1]\n            for key in pairs:\n                pairs[key].visited = False\n            if dfs(first_pair, second_pair):\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if query_type == 1:",
      "mutated_line": "if query_type == -1:",
      "code": "def process_interval_queries(queries):\n\n    class Pair:\n\n        def __init__(self, x=0, y=0):\n            self.x = x\n            self.y = y\n            self.neighbors = []\n            self.visited = False\n\n    def is_median(pair1, pair2):\n        if pair1.x > pair2.x and pair1.x < pair2.y:\n            return True\n        elif pair1.y > pair2.x and pair1.y < pair2.y:\n            return True\n        else:\n            return False\n\n    def dfs(start_pair, targ_pair):\n        stack = [start_pair]\n        while stack:\n            curr_pair = stack.pop()\n            if curr_pair.visited:\n                continue\n            curr_pair.visited = True\n            if curr_pair.x == targ_pair.x and curr_pair.y == targ_pair.y:\n                return True\n            for neighbor in curr_pair.neighbors:\n                stack.append(neighbor)\n        return False\n    pairs = {}\n    count = 0\n    results = []\n    for query in queries:\n        (query_type, first, second) = query\n        if query_type == -1:\n            new_pair = Pair(first, second)\n            for key in pairs:\n                if is_median(new_pair, pairs[key]):\n                    new_pair.neighbors.append(pairs[key])\n                if is_median(pairs[key], new_pair):\n                    pairs[key].neighbors.append(new_pair)\n            pairs[count] = new_pair\n            count += 1\n        elif query_type == 2:\n            first_pair = pairs[first - 1]\n            second_pair = pairs[second - 1]\n            for key in pairs:\n                pairs[key].visited = False\n            if dfs(first_pair, second_pair):\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "count += 1",
      "mutated_line": "count += 2",
      "code": "def process_interval_queries(queries):\n\n    class Pair:\n\n        def __init__(self, x=0, y=0):\n            self.x = x\n            self.y = y\n            self.neighbors = []\n            self.visited = False\n\n    def is_median(pair1, pair2):\n        if pair1.x > pair2.x and pair1.x < pair2.y:\n            return True\n        elif pair1.y > pair2.x and pair1.y < pair2.y:\n            return True\n        else:\n            return False\n\n    def dfs(start_pair, targ_pair):\n        stack = [start_pair]\n        while stack:\n            curr_pair = stack.pop()\n            if curr_pair.visited:\n                continue\n            curr_pair.visited = True\n            if curr_pair.x == targ_pair.x and curr_pair.y == targ_pair.y:\n                return True\n            for neighbor in curr_pair.neighbors:\n                stack.append(neighbor)\n        return False\n    pairs = {}\n    count = 0\n    results = []\n    for query in queries:\n        (query_type, first, second) = query\n        if query_type == 1:\n            new_pair = Pair(first, second)\n            for key in pairs:\n                if is_median(new_pair, pairs[key]):\n                    new_pair.neighbors.append(pairs[key])\n                if is_median(pairs[key], new_pair):\n                    pairs[key].neighbors.append(new_pair)\n            pairs[count] = new_pair\n            count += 2\n        elif query_type == 2:\n            first_pair = pairs[first - 1]\n            second_pair = pairs[second - 1]\n            for key in pairs:\n                pairs[key].visited = False\n            if dfs(first_pair, second_pair):\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "count += 1",
      "mutated_line": "count += 0",
      "code": "def process_interval_queries(queries):\n\n    class Pair:\n\n        def __init__(self, x=0, y=0):\n            self.x = x\n            self.y = y\n            self.neighbors = []\n            self.visited = False\n\n    def is_median(pair1, pair2):\n        if pair1.x > pair2.x and pair1.x < pair2.y:\n            return True\n        elif pair1.y > pair2.x and pair1.y < pair2.y:\n            return True\n        else:\n            return False\n\n    def dfs(start_pair, targ_pair):\n        stack = [start_pair]\n        while stack:\n            curr_pair = stack.pop()\n            if curr_pair.visited:\n                continue\n            curr_pair.visited = True\n            if curr_pair.x == targ_pair.x and curr_pair.y == targ_pair.y:\n                return True\n            for neighbor in curr_pair.neighbors:\n                stack.append(neighbor)\n        return False\n    pairs = {}\n    count = 0\n    results = []\n    for query in queries:\n        (query_type, first, second) = query\n        if query_type == 1:\n            new_pair = Pair(first, second)\n            for key in pairs:\n                if is_median(new_pair, pairs[key]):\n                    new_pair.neighbors.append(pairs[key])\n                if is_median(pairs[key], new_pair):\n                    pairs[key].neighbors.append(new_pair)\n            pairs[count] = new_pair\n            count += 0\n        elif query_type == 2:\n            first_pair = pairs[first - 1]\n            second_pair = pairs[second - 1]\n            for key in pairs:\n                pairs[key].visited = False\n            if dfs(first_pair, second_pair):\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "count += 1",
      "mutated_line": "count += 0",
      "code": "def process_interval_queries(queries):\n\n    class Pair:\n\n        def __init__(self, x=0, y=0):\n            self.x = x\n            self.y = y\n            self.neighbors = []\n            self.visited = False\n\n    def is_median(pair1, pair2):\n        if pair1.x > pair2.x and pair1.x < pair2.y:\n            return True\n        elif pair1.y > pair2.x and pair1.y < pair2.y:\n            return True\n        else:\n            return False\n\n    def dfs(start_pair, targ_pair):\n        stack = [start_pair]\n        while stack:\n            curr_pair = stack.pop()\n            if curr_pair.visited:\n                continue\n            curr_pair.visited = True\n            if curr_pair.x == targ_pair.x and curr_pair.y == targ_pair.y:\n                return True\n            for neighbor in curr_pair.neighbors:\n                stack.append(neighbor)\n        return False\n    pairs = {}\n    count = 0\n    results = []\n    for query in queries:\n        (query_type, first, second) = query\n        if query_type == 1:\n            new_pair = Pair(first, second)\n            for key in pairs:\n                if is_median(new_pair, pairs[key]):\n                    new_pair.neighbors.append(pairs[key])\n                if is_median(pairs[key], new_pair):\n                    pairs[key].neighbors.append(new_pair)\n            pairs[count] = new_pair\n            count += 0\n        elif query_type == 2:\n            first_pair = pairs[first - 1]\n            second_pair = pairs[second - 1]\n            for key in pairs:\n                pairs[key].visited = False\n            if dfs(first_pair, second_pair):\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "count += 1",
      "mutated_line": "count += -1",
      "code": "def process_interval_queries(queries):\n\n    class Pair:\n\n        def __init__(self, x=0, y=0):\n            self.x = x\n            self.y = y\n            self.neighbors = []\n            self.visited = False\n\n    def is_median(pair1, pair2):\n        if pair1.x > pair2.x and pair1.x < pair2.y:\n            return True\n        elif pair1.y > pair2.x and pair1.y < pair2.y:\n            return True\n        else:\n            return False\n\n    def dfs(start_pair, targ_pair):\n        stack = [start_pair]\n        while stack:\n            curr_pair = stack.pop()\n            if curr_pair.visited:\n                continue\n            curr_pair.visited = True\n            if curr_pair.x == targ_pair.x and curr_pair.y == targ_pair.y:\n                return True\n            for neighbor in curr_pair.neighbors:\n                stack.append(neighbor)\n        return False\n    pairs = {}\n    count = 0\n    results = []\n    for query in queries:\n        (query_type, first, second) = query\n        if query_type == 1:\n            new_pair = Pair(first, second)\n            for key in pairs:\n                if is_median(new_pair, pairs[key]):\n                    new_pair.neighbors.append(pairs[key])\n                if is_median(pairs[key], new_pair):\n                    pairs[key].neighbors.append(new_pair)\n            pairs[count] = new_pair\n            count += -1\n        elif query_type == 2:\n            first_pair = pairs[first - 1]\n            second_pair = pairs[second - 1]\n            for key in pairs:\n                pairs[key].visited = False\n            if dfs(first_pair, second_pair):\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "elif query_type == 2:",
      "mutated_line": "elif query_type != 2:",
      "code": "def process_interval_queries(queries):\n\n    class Pair:\n\n        def __init__(self, x=0, y=0):\n            self.x = x\n            self.y = y\n            self.neighbors = []\n            self.visited = False\n\n    def is_median(pair1, pair2):\n        if pair1.x > pair2.x and pair1.x < pair2.y:\n            return True\n        elif pair1.y > pair2.x and pair1.y < pair2.y:\n            return True\n        else:\n            return False\n\n    def dfs(start_pair, targ_pair):\n        stack = [start_pair]\n        while stack:\n            curr_pair = stack.pop()\n            if curr_pair.visited:\n                continue\n            curr_pair.visited = True\n            if curr_pair.x == targ_pair.x and curr_pair.y == targ_pair.y:\n                return True\n            for neighbor in curr_pair.neighbors:\n                stack.append(neighbor)\n        return False\n    pairs = {}\n    count = 0\n    results = []\n    for query in queries:\n        (query_type, first, second) = query\n        if query_type == 1:\n            new_pair = Pair(first, second)\n            for key in pairs:\n                if is_median(new_pair, pairs[key]):\n                    new_pair.neighbors.append(pairs[key])\n                if is_median(pairs[key], new_pair):\n                    pairs[key].neighbors.append(new_pair)\n            pairs[count] = new_pair\n            count += 1\n        elif query_type != 2:\n            first_pair = pairs[first - 1]\n            second_pair = pairs[second - 1]\n            for key in pairs:\n                pairs[key].visited = False\n            if dfs(first_pair, second_pair):\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "elif pair1.y > pair2.x and pair1.y < pair2.y:",
      "mutated_line": "elif pair1.y >= pair2.x and pair1.y < pair2.y:",
      "code": "def process_interval_queries(queries):\n\n    class Pair:\n\n        def __init__(self, x=0, y=0):\n            self.x = x\n            self.y = y\n            self.neighbors = []\n            self.visited = False\n\n    def is_median(pair1, pair2):\n        if pair1.x > pair2.x and pair1.x < pair2.y:\n            return True\n        elif pair1.y >= pair2.x and pair1.y < pair2.y:\n            return True\n        else:\n            return False\n\n    def dfs(start_pair, targ_pair):\n        stack = [start_pair]\n        while stack:\n            curr_pair = stack.pop()\n            if curr_pair.visited:\n                continue\n            curr_pair.visited = True\n            if curr_pair.x == targ_pair.x and curr_pair.y == targ_pair.y:\n                return True\n            for neighbor in curr_pair.neighbors:\n                stack.append(neighbor)\n        return False\n    pairs = {}\n    count = 0\n    results = []\n    for query in queries:\n        (query_type, first, second) = query\n        if query_type == 1:\n            new_pair = Pair(first, second)\n            for key in pairs:\n                if is_median(new_pair, pairs[key]):\n                    new_pair.neighbors.append(pairs[key])\n                if is_median(pairs[key], new_pair):\n                    pairs[key].neighbors.append(new_pair)\n            pairs[count] = new_pair\n            count += 1\n        elif query_type == 2:\n            first_pair = pairs[first - 1]\n            second_pair = pairs[second - 1]\n            for key in pairs:\n                pairs[key].visited = False\n            if dfs(first_pair, second_pair):\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "elif pair1.y > pair2.x and pair1.y < pair2.y:",
      "mutated_line": "elif pair1.y <= pair2.x and pair1.y < pair2.y:",
      "code": "def process_interval_queries(queries):\n\n    class Pair:\n\n        def __init__(self, x=0, y=0):\n            self.x = x\n            self.y = y\n            self.neighbors = []\n            self.visited = False\n\n    def is_median(pair1, pair2):\n        if pair1.x > pair2.x and pair1.x < pair2.y:\n            return True\n        elif pair1.y <= pair2.x and pair1.y < pair2.y:\n            return True\n        else:\n            return False\n\n    def dfs(start_pair, targ_pair):\n        stack = [start_pair]\n        while stack:\n            curr_pair = stack.pop()\n            if curr_pair.visited:\n                continue\n            curr_pair.visited = True\n            if curr_pair.x == targ_pair.x and curr_pair.y == targ_pair.y:\n                return True\n            for neighbor in curr_pair.neighbors:\n                stack.append(neighbor)\n        return False\n    pairs = {}\n    count = 0\n    results = []\n    for query in queries:\n        (query_type, first, second) = query\n        if query_type == 1:\n            new_pair = Pair(first, second)\n            for key in pairs:\n                if is_median(new_pair, pairs[key]):\n                    new_pair.neighbors.append(pairs[key])\n                if is_median(pairs[key], new_pair):\n                    pairs[key].neighbors.append(new_pair)\n            pairs[count] = new_pair\n            count += 1\n        elif query_type == 2:\n            first_pair = pairs[first - 1]\n            second_pair = pairs[second - 1]\n            for key in pairs:\n                pairs[key].visited = False\n            if dfs(first_pair, second_pair):\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "elif pair1.y > pair2.x and pair1.y < pair2.y:",
      "mutated_line": "elif pair1.y != pair2.x and pair1.y < pair2.y:",
      "code": "def process_interval_queries(queries):\n\n    class Pair:\n\n        def __init__(self, x=0, y=0):\n            self.x = x\n            self.y = y\n            self.neighbors = []\n            self.visited = False\n\n    def is_median(pair1, pair2):\n        if pair1.x > pair2.x and pair1.x < pair2.y:\n            return True\n        elif pair1.y != pair2.x and pair1.y < pair2.y:\n            return True\n        else:\n            return False\n\n    def dfs(start_pair, targ_pair):\n        stack = [start_pair]\n        while stack:\n            curr_pair = stack.pop()\n            if curr_pair.visited:\n                continue\n            curr_pair.visited = True\n            if curr_pair.x == targ_pair.x and curr_pair.y == targ_pair.y:\n                return True\n            for neighbor in curr_pair.neighbors:\n                stack.append(neighbor)\n        return False\n    pairs = {}\n    count = 0\n    results = []\n    for query in queries:\n        (query_type, first, second) = query\n        if query_type == 1:\n            new_pair = Pair(first, second)\n            for key in pairs:\n                if is_median(new_pair, pairs[key]):\n                    new_pair.neighbors.append(pairs[key])\n                if is_median(pairs[key], new_pair):\n                    pairs[key].neighbors.append(new_pair)\n            pairs[count] = new_pair\n            count += 1\n        elif query_type == 2:\n            first_pair = pairs[first - 1]\n            second_pair = pairs[second - 1]\n            for key in pairs:\n                pairs[key].visited = False\n            if dfs(first_pair, second_pair):\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "elif pair1.y > pair2.x and pair1.y < pair2.y:",
      "mutated_line": "elif pair1.y > pair2.x and pair1.y <= pair2.y:",
      "code": "def process_interval_queries(queries):\n\n    class Pair:\n\n        def __init__(self, x=0, y=0):\n            self.x = x\n            self.y = y\n            self.neighbors = []\n            self.visited = False\n\n    def is_median(pair1, pair2):\n        if pair1.x > pair2.x and pair1.x < pair2.y:\n            return True\n        elif pair1.y > pair2.x and pair1.y <= pair2.y:\n            return True\n        else:\n            return False\n\n    def dfs(start_pair, targ_pair):\n        stack = [start_pair]\n        while stack:\n            curr_pair = stack.pop()\n            if curr_pair.visited:\n                continue\n            curr_pair.visited = True\n            if curr_pair.x == targ_pair.x and curr_pair.y == targ_pair.y:\n                return True\n            for neighbor in curr_pair.neighbors:\n                stack.append(neighbor)\n        return False\n    pairs = {}\n    count = 0\n    results = []\n    for query in queries:\n        (query_type, first, second) = query\n        if query_type == 1:\n            new_pair = Pair(first, second)\n            for key in pairs:\n                if is_median(new_pair, pairs[key]):\n                    new_pair.neighbors.append(pairs[key])\n                if is_median(pairs[key], new_pair):\n                    pairs[key].neighbors.append(new_pair)\n            pairs[count] = new_pair\n            count += 1\n        elif query_type == 2:\n            first_pair = pairs[first - 1]\n            second_pair = pairs[second - 1]\n            for key in pairs:\n                pairs[key].visited = False\n            if dfs(first_pair, second_pair):\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "elif pair1.y > pair2.x and pair1.y < pair2.y:",
      "mutated_line": "elif pair1.y > pair2.x and pair1.y >= pair2.y:",
      "code": "def process_interval_queries(queries):\n\n    class Pair:\n\n        def __init__(self, x=0, y=0):\n            self.x = x\n            self.y = y\n            self.neighbors = []\n            self.visited = False\n\n    def is_median(pair1, pair2):\n        if pair1.x > pair2.x and pair1.x < pair2.y:\n            return True\n        elif pair1.y > pair2.x and pair1.y >= pair2.y:\n            return True\n        else:\n            return False\n\n    def dfs(start_pair, targ_pair):\n        stack = [start_pair]\n        while stack:\n            curr_pair = stack.pop()\n            if curr_pair.visited:\n                continue\n            curr_pair.visited = True\n            if curr_pair.x == targ_pair.x and curr_pair.y == targ_pair.y:\n                return True\n            for neighbor in curr_pair.neighbors:\n                stack.append(neighbor)\n        return False\n    pairs = {}\n    count = 0\n    results = []\n    for query in queries:\n        (query_type, first, second) = query\n        if query_type == 1:\n            new_pair = Pair(first, second)\n            for key in pairs:\n                if is_median(new_pair, pairs[key]):\n                    new_pair.neighbors.append(pairs[key])\n                if is_median(pairs[key], new_pair):\n                    pairs[key].neighbors.append(new_pair)\n            pairs[count] = new_pair\n            count += 1\n        elif query_type == 2:\n            first_pair = pairs[first - 1]\n            second_pair = pairs[second - 1]\n            for key in pairs:\n                pairs[key].visited = False\n            if dfs(first_pair, second_pair):\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "elif pair1.y > pair2.x and pair1.y < pair2.y:",
      "mutated_line": "elif pair1.y > pair2.x and pair1.y != pair2.y:",
      "code": "def process_interval_queries(queries):\n\n    class Pair:\n\n        def __init__(self, x=0, y=0):\n            self.x = x\n            self.y = y\n            self.neighbors = []\n            self.visited = False\n\n    def is_median(pair1, pair2):\n        if pair1.x > pair2.x and pair1.x < pair2.y:\n            return True\n        elif pair1.y > pair2.x and pair1.y != pair2.y:\n            return True\n        else:\n            return False\n\n    def dfs(start_pair, targ_pair):\n        stack = [start_pair]\n        while stack:\n            curr_pair = stack.pop()\n            if curr_pair.visited:\n                continue\n            curr_pair.visited = True\n            if curr_pair.x == targ_pair.x and curr_pair.y == targ_pair.y:\n                return True\n            for neighbor in curr_pair.neighbors:\n                stack.append(neighbor)\n        return False\n    pairs = {}\n    count = 0\n    results = []\n    for query in queries:\n        (query_type, first, second) = query\n        if query_type == 1:\n            new_pair = Pair(first, second)\n            for key in pairs:\n                if is_median(new_pair, pairs[key]):\n                    new_pair.neighbors.append(pairs[key])\n                if is_median(pairs[key], new_pair):\n                    pairs[key].neighbors.append(new_pair)\n            pairs[count] = new_pair\n            count += 1\n        elif query_type == 2:\n            first_pair = pairs[first - 1]\n            second_pair = pairs[second - 1]\n            for key in pairs:\n                pairs[key].visited = False\n            if dfs(first_pair, second_pair):\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def process_interval_queries(queries):\n\n    class Pair:\n\n        def __init__(self, x=0, y=0):\n            self.x = x\n            self.y = y\n            self.neighbors = []\n            self.visited = False\n\n    def is_median(pair1, pair2):\n        if pair1.x > pair2.x and pair1.x < pair2.y:\n            return True\n        elif pair1.y > pair2.x and pair1.y < pair2.y:\n            return False\n        else:\n            return False\n\n    def dfs(start_pair, targ_pair):\n        stack = [start_pair]\n        while stack:\n            curr_pair = stack.pop()\n            if curr_pair.visited:\n                continue\n            curr_pair.visited = True\n            if curr_pair.x == targ_pair.x and curr_pair.y == targ_pair.y:\n                return True\n            for neighbor in curr_pair.neighbors:\n                stack.append(neighbor)\n        return False\n    pairs = {}\n    count = 0\n    results = []\n    for query in queries:\n        (query_type, first, second) = query\n        if query_type == 1:\n            new_pair = Pair(first, second)\n            for key in pairs:\n                if is_median(new_pair, pairs[key]):\n                    new_pair.neighbors.append(pairs[key])\n                if is_median(pairs[key], new_pair):\n                    pairs[key].neighbors.append(new_pair)\n            pairs[count] = new_pair\n            count += 1\n        elif query_type == 2:\n            first_pair = pairs[first - 1]\n            second_pair = pairs[second - 1]\n            for key in pairs:\n                pairs[key].visited = False\n            if dfs(first_pair, second_pair):\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def process_interval_queries(queries):\n\n    class Pair:\n\n        def __init__(self, x=0, y=0):\n            self.x = x\n            self.y = y\n            self.neighbors = []\n            self.visited = False\n\n    def is_median(pair1, pair2):\n        if pair1.x > pair2.x and pair1.x < pair2.y:\n            return True\n        elif pair1.y > pair2.x and pair1.y < pair2.y:\n            return True\n        else:\n            return True\n\n    def dfs(start_pair, targ_pair):\n        stack = [start_pair]\n        while stack:\n            curr_pair = stack.pop()\n            if curr_pair.visited:\n                continue\n            curr_pair.visited = True\n            if curr_pair.x == targ_pair.x and curr_pair.y == targ_pair.y:\n                return True\n            for neighbor in curr_pair.neighbors:\n                stack.append(neighbor)\n        return False\n    pairs = {}\n    count = 0\n    results = []\n    for query in queries:\n        (query_type, first, second) = query\n        if query_type == 1:\n            new_pair = Pair(first, second)\n            for key in pairs:\n                if is_median(new_pair, pairs[key]):\n                    new_pair.neighbors.append(pairs[key])\n                if is_median(pairs[key], new_pair):\n                    pairs[key].neighbors.append(new_pair)\n            pairs[count] = new_pair\n            count += 1\n        elif query_type == 2:\n            first_pair = pairs[first - 1]\n            second_pair = pairs[second - 1]\n            for key in pairs:\n                pairs[key].visited = False\n            if dfs(first_pair, second_pair):\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if curr_pair.x == targ_pair.x and curr_pair.y == targ_pair.y:",
      "mutated_line": "if curr_pair.x != targ_pair.x and curr_pair.y == targ_pair.y:",
      "code": "def process_interval_queries(queries):\n\n    class Pair:\n\n        def __init__(self, x=0, y=0):\n            self.x = x\n            self.y = y\n            self.neighbors = []\n            self.visited = False\n\n    def is_median(pair1, pair2):\n        if pair1.x > pair2.x and pair1.x < pair2.y:\n            return True\n        elif pair1.y > pair2.x and pair1.y < pair2.y:\n            return True\n        else:\n            return False\n\n    def dfs(start_pair, targ_pair):\n        stack = [start_pair]\n        while stack:\n            curr_pair = stack.pop()\n            if curr_pair.visited:\n                continue\n            curr_pair.visited = True\n            if curr_pair.x != targ_pair.x and curr_pair.y == targ_pair.y:\n                return True\n            for neighbor in curr_pair.neighbors:\n                stack.append(neighbor)\n        return False\n    pairs = {}\n    count = 0\n    results = []\n    for query in queries:\n        (query_type, first, second) = query\n        if query_type == 1:\n            new_pair = Pair(first, second)\n            for key in pairs:\n                if is_median(new_pair, pairs[key]):\n                    new_pair.neighbors.append(pairs[key])\n                if is_median(pairs[key], new_pair):\n                    pairs[key].neighbors.append(new_pair)\n            pairs[count] = new_pair\n            count += 1\n        elif query_type == 2:\n            first_pair = pairs[first - 1]\n            second_pair = pairs[second - 1]\n            for key in pairs:\n                pairs[key].visited = False\n            if dfs(first_pair, second_pair):\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if curr_pair.x == targ_pair.x and curr_pair.y == targ_pair.y:",
      "mutated_line": "if curr_pair.x == targ_pair.x and curr_pair.y != targ_pair.y:",
      "code": "def process_interval_queries(queries):\n\n    class Pair:\n\n        def __init__(self, x=0, y=0):\n            self.x = x\n            self.y = y\n            self.neighbors = []\n            self.visited = False\n\n    def is_median(pair1, pair2):\n        if pair1.x > pair2.x and pair1.x < pair2.y:\n            return True\n        elif pair1.y > pair2.x and pair1.y < pair2.y:\n            return True\n        else:\n            return False\n\n    def dfs(start_pair, targ_pair):\n        stack = [start_pair]\n        while stack:\n            curr_pair = stack.pop()\n            if curr_pair.visited:\n                continue\n            curr_pair.visited = True\n            if curr_pair.x == targ_pair.x and curr_pair.y != targ_pair.y:\n                return True\n            for neighbor in curr_pair.neighbors:\n                stack.append(neighbor)\n        return False\n    pairs = {}\n    count = 0\n    results = []\n    for query in queries:\n        (query_type, first, second) = query\n        if query_type == 1:\n            new_pair = Pair(first, second)\n            for key in pairs:\n                if is_median(new_pair, pairs[key]):\n                    new_pair.neighbors.append(pairs[key])\n                if is_median(pairs[key], new_pair):\n                    pairs[key].neighbors.append(new_pair)\n            pairs[count] = new_pair\n            count += 1\n        elif query_type == 2:\n            first_pair = pairs[first - 1]\n            second_pair = pairs[second - 1]\n            for key in pairs:\n                pairs[key].visited = False\n            if dfs(first_pair, second_pair):\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def process_interval_queries(queries):\n\n    class Pair:\n\n        def __init__(self, x=0, y=0):\n            self.x = x\n            self.y = y\n            self.neighbors = []\n            self.visited = False\n\n    def is_median(pair1, pair2):\n        if pair1.x > pair2.x and pair1.x < pair2.y:\n            return True\n        elif pair1.y > pair2.x and pair1.y < pair2.y:\n            return True\n        else:\n            return False\n\n    def dfs(start_pair, targ_pair):\n        stack = [start_pair]\n        while stack:\n            curr_pair = stack.pop()\n            if curr_pair.visited:\n                continue\n            curr_pair.visited = True\n            if curr_pair.x == targ_pair.x and curr_pair.y == targ_pair.y:\n                return False\n            for neighbor in curr_pair.neighbors:\n                stack.append(neighbor)\n        return False\n    pairs = {}\n    count = 0\n    results = []\n    for query in queries:\n        (query_type, first, second) = query\n        if query_type == 1:\n            new_pair = Pair(first, second)\n            for key in pairs:\n                if is_median(new_pair, pairs[key]):\n                    new_pair.neighbors.append(pairs[key])\n                if is_median(pairs[key], new_pair):\n                    pairs[key].neighbors.append(new_pair)\n            pairs[count] = new_pair\n            count += 1\n        elif query_type == 2:\n            first_pair = pairs[first - 1]\n            second_pair = pairs[second - 1]\n            for key in pairs:\n                pairs[key].visited = False\n            if dfs(first_pair, second_pair):\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "elif query_type == 2:",
      "mutated_line": "elif query_type == 3:",
      "code": "def process_interval_queries(queries):\n\n    class Pair:\n\n        def __init__(self, x=0, y=0):\n            self.x = x\n            self.y = y\n            self.neighbors = []\n            self.visited = False\n\n    def is_median(pair1, pair2):\n        if pair1.x > pair2.x and pair1.x < pair2.y:\n            return True\n        elif pair1.y > pair2.x and pair1.y < pair2.y:\n            return True\n        else:\n            return False\n\n    def dfs(start_pair, targ_pair):\n        stack = [start_pair]\n        while stack:\n            curr_pair = stack.pop()\n            if curr_pair.visited:\n                continue\n            curr_pair.visited = True\n            if curr_pair.x == targ_pair.x and curr_pair.y == targ_pair.y:\n                return True\n            for neighbor in curr_pair.neighbors:\n                stack.append(neighbor)\n        return False\n    pairs = {}\n    count = 0\n    results = []\n    for query in queries:\n        (query_type, first, second) = query\n        if query_type == 1:\n            new_pair = Pair(first, second)\n            for key in pairs:\n                if is_median(new_pair, pairs[key]):\n                    new_pair.neighbors.append(pairs[key])\n                if is_median(pairs[key], new_pair):\n                    pairs[key].neighbors.append(new_pair)\n            pairs[count] = new_pair\n            count += 1\n        elif query_type == 3:\n            first_pair = pairs[first - 1]\n            second_pair = pairs[second - 1]\n            for key in pairs:\n                pairs[key].visited = False\n            if dfs(first_pair, second_pair):\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "elif query_type == 2:",
      "mutated_line": "elif query_type == 1:",
      "code": "def process_interval_queries(queries):\n\n    class Pair:\n\n        def __init__(self, x=0, y=0):\n            self.x = x\n            self.y = y\n            self.neighbors = []\n            self.visited = False\n\n    def is_median(pair1, pair2):\n        if pair1.x > pair2.x and pair1.x < pair2.y:\n            return True\n        elif pair1.y > pair2.x and pair1.y < pair2.y:\n            return True\n        else:\n            return False\n\n    def dfs(start_pair, targ_pair):\n        stack = [start_pair]\n        while stack:\n            curr_pair = stack.pop()\n            if curr_pair.visited:\n                continue\n            curr_pair.visited = True\n            if curr_pair.x == targ_pair.x and curr_pair.y == targ_pair.y:\n                return True\n            for neighbor in curr_pair.neighbors:\n                stack.append(neighbor)\n        return False\n    pairs = {}\n    count = 0\n    results = []\n    for query in queries:\n        (query_type, first, second) = query\n        if query_type == 1:\n            new_pair = Pair(first, second)\n            for key in pairs:\n                if is_median(new_pair, pairs[key]):\n                    new_pair.neighbors.append(pairs[key])\n                if is_median(pairs[key], new_pair):\n                    pairs[key].neighbors.append(new_pair)\n            pairs[count] = new_pair\n            count += 1\n        elif query_type == 1:\n            first_pair = pairs[first - 1]\n            second_pair = pairs[second - 1]\n            for key in pairs:\n                pairs[key].visited = False\n            if dfs(first_pair, second_pair):\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "elif query_type == 2:",
      "mutated_line": "elif query_type == 0:",
      "code": "def process_interval_queries(queries):\n\n    class Pair:\n\n        def __init__(self, x=0, y=0):\n            self.x = x\n            self.y = y\n            self.neighbors = []\n            self.visited = False\n\n    def is_median(pair1, pair2):\n        if pair1.x > pair2.x and pair1.x < pair2.y:\n            return True\n        elif pair1.y > pair2.x and pair1.y < pair2.y:\n            return True\n        else:\n            return False\n\n    def dfs(start_pair, targ_pair):\n        stack = [start_pair]\n        while stack:\n            curr_pair = stack.pop()\n            if curr_pair.visited:\n                continue\n            curr_pair.visited = True\n            if curr_pair.x == targ_pair.x and curr_pair.y == targ_pair.y:\n                return True\n            for neighbor in curr_pair.neighbors:\n                stack.append(neighbor)\n        return False\n    pairs = {}\n    count = 0\n    results = []\n    for query in queries:\n        (query_type, first, second) = query\n        if query_type == 1:\n            new_pair = Pair(first, second)\n            for key in pairs:\n                if is_median(new_pair, pairs[key]):\n                    new_pair.neighbors.append(pairs[key])\n                if is_median(pairs[key], new_pair):\n                    pairs[key].neighbors.append(new_pair)\n            pairs[count] = new_pair\n            count += 1\n        elif query_type == 0:\n            first_pair = pairs[first - 1]\n            second_pair = pairs[second - 1]\n            for key in pairs:\n                pairs[key].visited = False\n            if dfs(first_pair, second_pair):\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "elif query_type == 2:",
      "mutated_line": "elif query_type == 1:",
      "code": "def process_interval_queries(queries):\n\n    class Pair:\n\n        def __init__(self, x=0, y=0):\n            self.x = x\n            self.y = y\n            self.neighbors = []\n            self.visited = False\n\n    def is_median(pair1, pair2):\n        if pair1.x > pair2.x and pair1.x < pair2.y:\n            return True\n        elif pair1.y > pair2.x and pair1.y < pair2.y:\n            return True\n        else:\n            return False\n\n    def dfs(start_pair, targ_pair):\n        stack = [start_pair]\n        while stack:\n            curr_pair = stack.pop()\n            if curr_pair.visited:\n                continue\n            curr_pair.visited = True\n            if curr_pair.x == targ_pair.x and curr_pair.y == targ_pair.y:\n                return True\n            for neighbor in curr_pair.neighbors:\n                stack.append(neighbor)\n        return False\n    pairs = {}\n    count = 0\n    results = []\n    for query in queries:\n        (query_type, first, second) = query\n        if query_type == 1:\n            new_pair = Pair(first, second)\n            for key in pairs:\n                if is_median(new_pair, pairs[key]):\n                    new_pair.neighbors.append(pairs[key])\n                if is_median(pairs[key], new_pair):\n                    pairs[key].neighbors.append(new_pair)\n            pairs[count] = new_pair\n            count += 1\n        elif query_type == 1:\n            first_pair = pairs[first - 1]\n            second_pair = pairs[second - 1]\n            for key in pairs:\n                pairs[key].visited = False\n            if dfs(first_pair, second_pair):\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "elif query_type == 2:",
      "mutated_line": "elif query_type == -2:",
      "code": "def process_interval_queries(queries):\n\n    class Pair:\n\n        def __init__(self, x=0, y=0):\n            self.x = x\n            self.y = y\n            self.neighbors = []\n            self.visited = False\n\n    def is_median(pair1, pair2):\n        if pair1.x > pair2.x and pair1.x < pair2.y:\n            return True\n        elif pair1.y > pair2.x and pair1.y < pair2.y:\n            return True\n        else:\n            return False\n\n    def dfs(start_pair, targ_pair):\n        stack = [start_pair]\n        while stack:\n            curr_pair = stack.pop()\n            if curr_pair.visited:\n                continue\n            curr_pair.visited = True\n            if curr_pair.x == targ_pair.x and curr_pair.y == targ_pair.y:\n                return True\n            for neighbor in curr_pair.neighbors:\n                stack.append(neighbor)\n        return False\n    pairs = {}\n    count = 0\n    results = []\n    for query in queries:\n        (query_type, first, second) = query\n        if query_type == 1:\n            new_pair = Pair(first, second)\n            for key in pairs:\n                if is_median(new_pair, pairs[key]):\n                    new_pair.neighbors.append(pairs[key])\n                if is_median(pairs[key], new_pair):\n                    pairs[key].neighbors.append(new_pair)\n            pairs[count] = new_pair\n            count += 1\n        elif query_type == -2:\n            first_pair = pairs[first - 1]\n            second_pair = pairs[second - 1]\n            for key in pairs:\n                pairs[key].visited = False\n            if dfs(first_pair, second_pair):\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "first_pair = pairs[first - 1]",
      "mutated_line": "first_pair = pairs[first + 1]",
      "code": "def process_interval_queries(queries):\n\n    class Pair:\n\n        def __init__(self, x=0, y=0):\n            self.x = x\n            self.y = y\n            self.neighbors = []\n            self.visited = False\n\n    def is_median(pair1, pair2):\n        if pair1.x > pair2.x and pair1.x < pair2.y:\n            return True\n        elif pair1.y > pair2.x and pair1.y < pair2.y:\n            return True\n        else:\n            return False\n\n    def dfs(start_pair, targ_pair):\n        stack = [start_pair]\n        while stack:\n            curr_pair = stack.pop()\n            if curr_pair.visited:\n                continue\n            curr_pair.visited = True\n            if curr_pair.x == targ_pair.x and curr_pair.y == targ_pair.y:\n                return True\n            for neighbor in curr_pair.neighbors:\n                stack.append(neighbor)\n        return False\n    pairs = {}\n    count = 0\n    results = []\n    for query in queries:\n        (query_type, first, second) = query\n        if query_type == 1:\n            new_pair = Pair(first, second)\n            for key in pairs:\n                if is_median(new_pair, pairs[key]):\n                    new_pair.neighbors.append(pairs[key])\n                if is_median(pairs[key], new_pair):\n                    pairs[key].neighbors.append(new_pair)\n            pairs[count] = new_pair\n            count += 1\n        elif query_type == 2:\n            first_pair = pairs[first + 1]\n            second_pair = pairs[second - 1]\n            for key in pairs:\n                pairs[key].visited = False\n            if dfs(first_pair, second_pair):\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "first_pair = pairs[first - 1]",
      "mutated_line": "first_pair = pairs[first * 1]",
      "code": "def process_interval_queries(queries):\n\n    class Pair:\n\n        def __init__(self, x=0, y=0):\n            self.x = x\n            self.y = y\n            self.neighbors = []\n            self.visited = False\n\n    def is_median(pair1, pair2):\n        if pair1.x > pair2.x and pair1.x < pair2.y:\n            return True\n        elif pair1.y > pair2.x and pair1.y < pair2.y:\n            return True\n        else:\n            return False\n\n    def dfs(start_pair, targ_pair):\n        stack = [start_pair]\n        while stack:\n            curr_pair = stack.pop()\n            if curr_pair.visited:\n                continue\n            curr_pair.visited = True\n            if curr_pair.x == targ_pair.x and curr_pair.y == targ_pair.y:\n                return True\n            for neighbor in curr_pair.neighbors:\n                stack.append(neighbor)\n        return False\n    pairs = {}\n    count = 0\n    results = []\n    for query in queries:\n        (query_type, first, second) = query\n        if query_type == 1:\n            new_pair = Pair(first, second)\n            for key in pairs:\n                if is_median(new_pair, pairs[key]):\n                    new_pair.neighbors.append(pairs[key])\n                if is_median(pairs[key], new_pair):\n                    pairs[key].neighbors.append(new_pair)\n            pairs[count] = new_pair\n            count += 1\n        elif query_type == 2:\n            first_pair = pairs[first * 1]\n            second_pair = pairs[second - 1]\n            for key in pairs:\n                pairs[key].visited = False\n            if dfs(first_pair, second_pair):\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "second_pair = pairs[second - 1]",
      "mutated_line": "second_pair = pairs[second + 1]",
      "code": "def process_interval_queries(queries):\n\n    class Pair:\n\n        def __init__(self, x=0, y=0):\n            self.x = x\n            self.y = y\n            self.neighbors = []\n            self.visited = False\n\n    def is_median(pair1, pair2):\n        if pair1.x > pair2.x and pair1.x < pair2.y:\n            return True\n        elif pair1.y > pair2.x and pair1.y < pair2.y:\n            return True\n        else:\n            return False\n\n    def dfs(start_pair, targ_pair):\n        stack = [start_pair]\n        while stack:\n            curr_pair = stack.pop()\n            if curr_pair.visited:\n                continue\n            curr_pair.visited = True\n            if curr_pair.x == targ_pair.x and curr_pair.y == targ_pair.y:\n                return True\n            for neighbor in curr_pair.neighbors:\n                stack.append(neighbor)\n        return False\n    pairs = {}\n    count = 0\n    results = []\n    for query in queries:\n        (query_type, first, second) = query\n        if query_type == 1:\n            new_pair = Pair(first, second)\n            for key in pairs:\n                if is_median(new_pair, pairs[key]):\n                    new_pair.neighbors.append(pairs[key])\n                if is_median(pairs[key], new_pair):\n                    pairs[key].neighbors.append(new_pair)\n            pairs[count] = new_pair\n            count += 1\n        elif query_type == 2:\n            first_pair = pairs[first - 1]\n            second_pair = pairs[second + 1]\n            for key in pairs:\n                pairs[key].visited = False\n            if dfs(first_pair, second_pair):\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "second_pair = pairs[second - 1]",
      "mutated_line": "second_pair = pairs[second * 1]",
      "code": "def process_interval_queries(queries):\n\n    class Pair:\n\n        def __init__(self, x=0, y=0):\n            self.x = x\n            self.y = y\n            self.neighbors = []\n            self.visited = False\n\n    def is_median(pair1, pair2):\n        if pair1.x > pair2.x and pair1.x < pair2.y:\n            return True\n        elif pair1.y > pair2.x and pair1.y < pair2.y:\n            return True\n        else:\n            return False\n\n    def dfs(start_pair, targ_pair):\n        stack = [start_pair]\n        while stack:\n            curr_pair = stack.pop()\n            if curr_pair.visited:\n                continue\n            curr_pair.visited = True\n            if curr_pair.x == targ_pair.x and curr_pair.y == targ_pair.y:\n                return True\n            for neighbor in curr_pair.neighbors:\n                stack.append(neighbor)\n        return False\n    pairs = {}\n    count = 0\n    results = []\n    for query in queries:\n        (query_type, first, second) = query\n        if query_type == 1:\n            new_pair = Pair(first, second)\n            for key in pairs:\n                if is_median(new_pair, pairs[key]):\n                    new_pair.neighbors.append(pairs[key])\n                if is_median(pairs[key], new_pair):\n                    pairs[key].neighbors.append(new_pair)\n            pairs[count] = new_pair\n            count += 1\n        elif query_type == 2:\n            first_pair = pairs[first - 1]\n            second_pair = pairs[second * 1]\n            for key in pairs:\n                pairs[key].visited = False\n            if dfs(first_pair, second_pair):\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "pairs[key].visited = False",
      "mutated_line": "pairs[key].visited = True",
      "code": "def process_interval_queries(queries):\n\n    class Pair:\n\n        def __init__(self, x=0, y=0):\n            self.x = x\n            self.y = y\n            self.neighbors = []\n            self.visited = False\n\n    def is_median(pair1, pair2):\n        if pair1.x > pair2.x and pair1.x < pair2.y:\n            return True\n        elif pair1.y > pair2.x and pair1.y < pair2.y:\n            return True\n        else:\n            return False\n\n    def dfs(start_pair, targ_pair):\n        stack = [start_pair]\n        while stack:\n            curr_pair = stack.pop()\n            if curr_pair.visited:\n                continue\n            curr_pair.visited = True\n            if curr_pair.x == targ_pair.x and curr_pair.y == targ_pair.y:\n                return True\n            for neighbor in curr_pair.neighbors:\n                stack.append(neighbor)\n        return False\n    pairs = {}\n    count = 0\n    results = []\n    for query in queries:\n        (query_type, first, second) = query\n        if query_type == 1:\n            new_pair = Pair(first, second)\n            for key in pairs:\n                if is_median(new_pair, pairs[key]):\n                    new_pair.neighbors.append(pairs[key])\n                if is_median(pairs[key], new_pair):\n                    pairs[key].neighbors.append(new_pair)\n            pairs[count] = new_pair\n            count += 1\n        elif query_type == 2:\n            first_pair = pairs[first - 1]\n            second_pair = pairs[second - 1]\n            for key in pairs:\n                pairs[key].visited = True\n            if dfs(first_pair, second_pair):\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "first_pair = pairs[first - 1]",
      "mutated_line": "first_pair = pairs[first - 2]",
      "code": "def process_interval_queries(queries):\n\n    class Pair:\n\n        def __init__(self, x=0, y=0):\n            self.x = x\n            self.y = y\n            self.neighbors = []\n            self.visited = False\n\n    def is_median(pair1, pair2):\n        if pair1.x > pair2.x and pair1.x < pair2.y:\n            return True\n        elif pair1.y > pair2.x and pair1.y < pair2.y:\n            return True\n        else:\n            return False\n\n    def dfs(start_pair, targ_pair):\n        stack = [start_pair]\n        while stack:\n            curr_pair = stack.pop()\n            if curr_pair.visited:\n                continue\n            curr_pair.visited = True\n            if curr_pair.x == targ_pair.x and curr_pair.y == targ_pair.y:\n                return True\n            for neighbor in curr_pair.neighbors:\n                stack.append(neighbor)\n        return False\n    pairs = {}\n    count = 0\n    results = []\n    for query in queries:\n        (query_type, first, second) = query\n        if query_type == 1:\n            new_pair = Pair(first, second)\n            for key in pairs:\n                if is_median(new_pair, pairs[key]):\n                    new_pair.neighbors.append(pairs[key])\n                if is_median(pairs[key], new_pair):\n                    pairs[key].neighbors.append(new_pair)\n            pairs[count] = new_pair\n            count += 1\n        elif query_type == 2:\n            first_pair = pairs[first - 2]\n            second_pair = pairs[second - 1]\n            for key in pairs:\n                pairs[key].visited = False\n            if dfs(first_pair, second_pair):\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "first_pair = pairs[first - 1]",
      "mutated_line": "first_pair = pairs[first - 0]",
      "code": "def process_interval_queries(queries):\n\n    class Pair:\n\n        def __init__(self, x=0, y=0):\n            self.x = x\n            self.y = y\n            self.neighbors = []\n            self.visited = False\n\n    def is_median(pair1, pair2):\n        if pair1.x > pair2.x and pair1.x < pair2.y:\n            return True\n        elif pair1.y > pair2.x and pair1.y < pair2.y:\n            return True\n        else:\n            return False\n\n    def dfs(start_pair, targ_pair):\n        stack = [start_pair]\n        while stack:\n            curr_pair = stack.pop()\n            if curr_pair.visited:\n                continue\n            curr_pair.visited = True\n            if curr_pair.x == targ_pair.x and curr_pair.y == targ_pair.y:\n                return True\n            for neighbor in curr_pair.neighbors:\n                stack.append(neighbor)\n        return False\n    pairs = {}\n    count = 0\n    results = []\n    for query in queries:\n        (query_type, first, second) = query\n        if query_type == 1:\n            new_pair = Pair(first, second)\n            for key in pairs:\n                if is_median(new_pair, pairs[key]):\n                    new_pair.neighbors.append(pairs[key])\n                if is_median(pairs[key], new_pair):\n                    pairs[key].neighbors.append(new_pair)\n            pairs[count] = new_pair\n            count += 1\n        elif query_type == 2:\n            first_pair = pairs[first - 0]\n            second_pair = pairs[second - 1]\n            for key in pairs:\n                pairs[key].visited = False\n            if dfs(first_pair, second_pair):\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "first_pair = pairs[first - 1]",
      "mutated_line": "first_pair = pairs[first - 0]",
      "code": "def process_interval_queries(queries):\n\n    class Pair:\n\n        def __init__(self, x=0, y=0):\n            self.x = x\n            self.y = y\n            self.neighbors = []\n            self.visited = False\n\n    def is_median(pair1, pair2):\n        if pair1.x > pair2.x and pair1.x < pair2.y:\n            return True\n        elif pair1.y > pair2.x and pair1.y < pair2.y:\n            return True\n        else:\n            return False\n\n    def dfs(start_pair, targ_pair):\n        stack = [start_pair]\n        while stack:\n            curr_pair = stack.pop()\n            if curr_pair.visited:\n                continue\n            curr_pair.visited = True\n            if curr_pair.x == targ_pair.x and curr_pair.y == targ_pair.y:\n                return True\n            for neighbor in curr_pair.neighbors:\n                stack.append(neighbor)\n        return False\n    pairs = {}\n    count = 0\n    results = []\n    for query in queries:\n        (query_type, first, second) = query\n        if query_type == 1:\n            new_pair = Pair(first, second)\n            for key in pairs:\n                if is_median(new_pair, pairs[key]):\n                    new_pair.neighbors.append(pairs[key])\n                if is_median(pairs[key], new_pair):\n                    pairs[key].neighbors.append(new_pair)\n            pairs[count] = new_pair\n            count += 1\n        elif query_type == 2:\n            first_pair = pairs[first - 0]\n            second_pair = pairs[second - 1]\n            for key in pairs:\n                pairs[key].visited = False\n            if dfs(first_pair, second_pair):\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "first_pair = pairs[first - 1]",
      "mutated_line": "first_pair = pairs[first - -1]",
      "code": "def process_interval_queries(queries):\n\n    class Pair:\n\n        def __init__(self, x=0, y=0):\n            self.x = x\n            self.y = y\n            self.neighbors = []\n            self.visited = False\n\n    def is_median(pair1, pair2):\n        if pair1.x > pair2.x and pair1.x < pair2.y:\n            return True\n        elif pair1.y > pair2.x and pair1.y < pair2.y:\n            return True\n        else:\n            return False\n\n    def dfs(start_pair, targ_pair):\n        stack = [start_pair]\n        while stack:\n            curr_pair = stack.pop()\n            if curr_pair.visited:\n                continue\n            curr_pair.visited = True\n            if curr_pair.x == targ_pair.x and curr_pair.y == targ_pair.y:\n                return True\n            for neighbor in curr_pair.neighbors:\n                stack.append(neighbor)\n        return False\n    pairs = {}\n    count = 0\n    results = []\n    for query in queries:\n        (query_type, first, second) = query\n        if query_type == 1:\n            new_pair = Pair(first, second)\n            for key in pairs:\n                if is_median(new_pair, pairs[key]):\n                    new_pair.neighbors.append(pairs[key])\n                if is_median(pairs[key], new_pair):\n                    pairs[key].neighbors.append(new_pair)\n            pairs[count] = new_pair\n            count += 1\n        elif query_type == 2:\n            first_pair = pairs[first - -1]\n            second_pair = pairs[second - 1]\n            for key in pairs:\n                pairs[key].visited = False\n            if dfs(first_pair, second_pair):\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "second_pair = pairs[second - 1]",
      "mutated_line": "second_pair = pairs[second - 2]",
      "code": "def process_interval_queries(queries):\n\n    class Pair:\n\n        def __init__(self, x=0, y=0):\n            self.x = x\n            self.y = y\n            self.neighbors = []\n            self.visited = False\n\n    def is_median(pair1, pair2):\n        if pair1.x > pair2.x and pair1.x < pair2.y:\n            return True\n        elif pair1.y > pair2.x and pair1.y < pair2.y:\n            return True\n        else:\n            return False\n\n    def dfs(start_pair, targ_pair):\n        stack = [start_pair]\n        while stack:\n            curr_pair = stack.pop()\n            if curr_pair.visited:\n                continue\n            curr_pair.visited = True\n            if curr_pair.x == targ_pair.x and curr_pair.y == targ_pair.y:\n                return True\n            for neighbor in curr_pair.neighbors:\n                stack.append(neighbor)\n        return False\n    pairs = {}\n    count = 0\n    results = []\n    for query in queries:\n        (query_type, first, second) = query\n        if query_type == 1:\n            new_pair = Pair(first, second)\n            for key in pairs:\n                if is_median(new_pair, pairs[key]):\n                    new_pair.neighbors.append(pairs[key])\n                if is_median(pairs[key], new_pair):\n                    pairs[key].neighbors.append(new_pair)\n            pairs[count] = new_pair\n            count += 1\n        elif query_type == 2:\n            first_pair = pairs[first - 1]\n            second_pair = pairs[second - 2]\n            for key in pairs:\n                pairs[key].visited = False\n            if dfs(first_pair, second_pair):\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "second_pair = pairs[second - 1]",
      "mutated_line": "second_pair = pairs[second - 0]",
      "code": "def process_interval_queries(queries):\n\n    class Pair:\n\n        def __init__(self, x=0, y=0):\n            self.x = x\n            self.y = y\n            self.neighbors = []\n            self.visited = False\n\n    def is_median(pair1, pair2):\n        if pair1.x > pair2.x and pair1.x < pair2.y:\n            return True\n        elif pair1.y > pair2.x and pair1.y < pair2.y:\n            return True\n        else:\n            return False\n\n    def dfs(start_pair, targ_pair):\n        stack = [start_pair]\n        while stack:\n            curr_pair = stack.pop()\n            if curr_pair.visited:\n                continue\n            curr_pair.visited = True\n            if curr_pair.x == targ_pair.x and curr_pair.y == targ_pair.y:\n                return True\n            for neighbor in curr_pair.neighbors:\n                stack.append(neighbor)\n        return False\n    pairs = {}\n    count = 0\n    results = []\n    for query in queries:\n        (query_type, first, second) = query\n        if query_type == 1:\n            new_pair = Pair(first, second)\n            for key in pairs:\n                if is_median(new_pair, pairs[key]):\n                    new_pair.neighbors.append(pairs[key])\n                if is_median(pairs[key], new_pair):\n                    pairs[key].neighbors.append(new_pair)\n            pairs[count] = new_pair\n            count += 1\n        elif query_type == 2:\n            first_pair = pairs[first - 1]\n            second_pair = pairs[second - 0]\n            for key in pairs:\n                pairs[key].visited = False\n            if dfs(first_pair, second_pair):\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "second_pair = pairs[second - 1]",
      "mutated_line": "second_pair = pairs[second - 0]",
      "code": "def process_interval_queries(queries):\n\n    class Pair:\n\n        def __init__(self, x=0, y=0):\n            self.x = x\n            self.y = y\n            self.neighbors = []\n            self.visited = False\n\n    def is_median(pair1, pair2):\n        if pair1.x > pair2.x and pair1.x < pair2.y:\n            return True\n        elif pair1.y > pair2.x and pair1.y < pair2.y:\n            return True\n        else:\n            return False\n\n    def dfs(start_pair, targ_pair):\n        stack = [start_pair]\n        while stack:\n            curr_pair = stack.pop()\n            if curr_pair.visited:\n                continue\n            curr_pair.visited = True\n            if curr_pair.x == targ_pair.x and curr_pair.y == targ_pair.y:\n                return True\n            for neighbor in curr_pair.neighbors:\n                stack.append(neighbor)\n        return False\n    pairs = {}\n    count = 0\n    results = []\n    for query in queries:\n        (query_type, first, second) = query\n        if query_type == 1:\n            new_pair = Pair(first, second)\n            for key in pairs:\n                if is_median(new_pair, pairs[key]):\n                    new_pair.neighbors.append(pairs[key])\n                if is_median(pairs[key], new_pair):\n                    pairs[key].neighbors.append(new_pair)\n            pairs[count] = new_pair\n            count += 1\n        elif query_type == 2:\n            first_pair = pairs[first - 1]\n            second_pair = pairs[second - 0]\n            for key in pairs:\n                pairs[key].visited = False\n            if dfs(first_pair, second_pair):\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "second_pair = pairs[second - 1]",
      "mutated_line": "second_pair = pairs[second - -1]",
      "code": "def process_interval_queries(queries):\n\n    class Pair:\n\n        def __init__(self, x=0, y=0):\n            self.x = x\n            self.y = y\n            self.neighbors = []\n            self.visited = False\n\n    def is_median(pair1, pair2):\n        if pair1.x > pair2.x and pair1.x < pair2.y:\n            return True\n        elif pair1.y > pair2.x and pair1.y < pair2.y:\n            return True\n        else:\n            return False\n\n    def dfs(start_pair, targ_pair):\n        stack = [start_pair]\n        while stack:\n            curr_pair = stack.pop()\n            if curr_pair.visited:\n                continue\n            curr_pair.visited = True\n            if curr_pair.x == targ_pair.x and curr_pair.y == targ_pair.y:\n                return True\n            for neighbor in curr_pair.neighbors:\n                stack.append(neighbor)\n        return False\n    pairs = {}\n    count = 0\n    results = []\n    for query in queries:\n        (query_type, first, second) = query\n        if query_type == 1:\n            new_pair = Pair(first, second)\n            for key in pairs:\n                if is_median(new_pair, pairs[key]):\n                    new_pair.neighbors.append(pairs[key])\n                if is_median(pairs[key], new_pair):\n                    pairs[key].neighbors.append(new_pair)\n            pairs[count] = new_pair\n            count += 1\n        elif query_type == 2:\n            first_pair = pairs[first - 1]\n            second_pair = pairs[second - -1]\n            for key in pairs:\n                pairs[key].visited = False\n            if dfs(first_pair, second_pair):\n                results.append('YES')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "results.append('YES')",
      "mutated_line": "results.append('')",
      "code": "def process_interval_queries(queries):\n\n    class Pair:\n\n        def __init__(self, x=0, y=0):\n            self.x = x\n            self.y = y\n            self.neighbors = []\n            self.visited = False\n\n    def is_median(pair1, pair2):\n        if pair1.x > pair2.x and pair1.x < pair2.y:\n            return True\n        elif pair1.y > pair2.x and pair1.y < pair2.y:\n            return True\n        else:\n            return False\n\n    def dfs(start_pair, targ_pair):\n        stack = [start_pair]\n        while stack:\n            curr_pair = stack.pop()\n            if curr_pair.visited:\n                continue\n            curr_pair.visited = True\n            if curr_pair.x == targ_pair.x and curr_pair.y == targ_pair.y:\n                return True\n            for neighbor in curr_pair.neighbors:\n                stack.append(neighbor)\n        return False\n    pairs = {}\n    count = 0\n    results = []\n    for query in queries:\n        (query_type, first, second) = query\n        if query_type == 1:\n            new_pair = Pair(first, second)\n            for key in pairs:\n                if is_median(new_pair, pairs[key]):\n                    new_pair.neighbors.append(pairs[key])\n                if is_median(pairs[key], new_pair):\n                    pairs[key].neighbors.append(new_pair)\n            pairs[count] = new_pair\n            count += 1\n        elif query_type == 2:\n            first_pair = pairs[first - 1]\n            second_pair = pairs[second - 1]\n            for key in pairs:\n                pairs[key].visited = False\n            if dfs(first_pair, second_pair):\n                results.append('')\n            else:\n                results.append('NO')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "results.append('NO')",
      "mutated_line": "results.append('')",
      "code": "def process_interval_queries(queries):\n\n    class Pair:\n\n        def __init__(self, x=0, y=0):\n            self.x = x\n            self.y = y\n            self.neighbors = []\n            self.visited = False\n\n    def is_median(pair1, pair2):\n        if pair1.x > pair2.x and pair1.x < pair2.y:\n            return True\n        elif pair1.y > pair2.x and pair1.y < pair2.y:\n            return True\n        else:\n            return False\n\n    def dfs(start_pair, targ_pair):\n        stack = [start_pair]\n        while stack:\n            curr_pair = stack.pop()\n            if curr_pair.visited:\n                continue\n            curr_pair.visited = True\n            if curr_pair.x == targ_pair.x and curr_pair.y == targ_pair.y:\n                return True\n            for neighbor in curr_pair.neighbors:\n                stack.append(neighbor)\n        return False\n    pairs = {}\n    count = 0\n    results = []\n    for query in queries:\n        (query_type, first, second) = query\n        if query_type == 1:\n            new_pair = Pair(first, second)\n            for key in pairs:\n                if is_median(new_pair, pairs[key]):\n                    new_pair.neighbors.append(pairs[key])\n                if is_median(pairs[key], new_pair):\n                    pairs[key].neighbors.append(new_pair)\n            pairs[count] = new_pair\n            count += 1\n        elif query_type == 2:\n            first_pair = pairs[first - 1]\n            second_pair = pairs[second - 1]\n            for key in pairs:\n                pairs[key].visited = False\n            if dfs(first_pair, second_pair):\n                results.append('YES')\n            else:\n                results.append('')\n    return results"
    }
  ]
}