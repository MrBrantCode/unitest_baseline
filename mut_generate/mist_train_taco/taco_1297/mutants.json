{
  "task_id": "taco_1297",
  "entry_point": "min_palindrome_partitions",
  "mutant_count": 72,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "while start < end:",
      "mutated_line": "while start <= end:",
      "code": "def min_palindrome_partitions(s: str) -> int:\n\n    def is_palindrome(s, start, end):\n        while start <= end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n        return True\n\n    def dfs(s, i, j, dp):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        if i >= j:\n            return 0\n        if is_palindrome(s, i, j):\n            return 0\n        mx = len(s)\n        for k in range(i, j):\n            if is_palindrome(s, i, k):\n                t = dfs(s, k + 1, j, dp) + 1\n                mx = min(mx, t)\n        dp[i][j] = mx\n        return dp[i][j]\n    n = len(s)\n    dp = [[-1] * (n + 1) for _ in range(n + 1)]\n    return dfs(s, 0, n - 1, dp)"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "while start < end:",
      "mutated_line": "while start >= end:",
      "code": "def min_palindrome_partitions(s: str) -> int:\n\n    def is_palindrome(s, start, end):\n        while start >= end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n        return True\n\n    def dfs(s, i, j, dp):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        if i >= j:\n            return 0\n        if is_palindrome(s, i, j):\n            return 0\n        mx = len(s)\n        for k in range(i, j):\n            if is_palindrome(s, i, k):\n                t = dfs(s, k + 1, j, dp) + 1\n                mx = min(mx, t)\n        dp[i][j] = mx\n        return dp[i][j]\n    n = len(s)\n    dp = [[-1] * (n + 1) for _ in range(n + 1)]\n    return dfs(s, 0, n - 1, dp)"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "while start < end:",
      "mutated_line": "while start != end:",
      "code": "def min_palindrome_partitions(s: str) -> int:\n\n    def is_palindrome(s, start, end):\n        while start != end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n        return True\n\n    def dfs(s, i, j, dp):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        if i >= j:\n            return 0\n        if is_palindrome(s, i, j):\n            return 0\n        mx = len(s)\n        for k in range(i, j):\n            if is_palindrome(s, i, k):\n                t = dfs(s, k + 1, j, dp) + 1\n                mx = min(mx, t)\n        dp[i][j] = mx\n        return dp[i][j]\n    n = len(s)\n    dp = [[-1] * (n + 1) for _ in range(n + 1)]\n    return dfs(s, 0, n - 1, dp)"
    },
    {
      "operator": "ASR",
      "lineno": 6,
      "original_line": "start += 1",
      "mutated_line": "start -= 1",
      "code": "def min_palindrome_partitions(s: str) -> int:\n\n    def is_palindrome(s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start -= 1\n            end -= 1\n        return True\n\n    def dfs(s, i, j, dp):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        if i >= j:\n            return 0\n        if is_palindrome(s, i, j):\n            return 0\n        mx = len(s)\n        for k in range(i, j):\n            if is_palindrome(s, i, k):\n                t = dfs(s, k + 1, j, dp) + 1\n                mx = min(mx, t)\n        dp[i][j] = mx\n        return dp[i][j]\n    n = len(s)\n    dp = [[-1] * (n + 1) for _ in range(n + 1)]\n    return dfs(s, 0, n - 1, dp)"
    },
    {
      "operator": "ASR",
      "lineno": 7,
      "original_line": "end -= 1",
      "mutated_line": "end += 1",
      "code": "def min_palindrome_partitions(s: str) -> int:\n\n    def is_palindrome(s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end += 1\n        return True\n\n    def dfs(s, i, j, dp):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        if i >= j:\n            return 0\n        if is_palindrome(s, i, j):\n            return 0\n        mx = len(s)\n        for k in range(i, j):\n            if is_palindrome(s, i, k):\n                t = dfs(s, k + 1, j, dp) + 1\n                mx = min(mx, t)\n        dp[i][j] = mx\n        return dp[i][j]\n    n = len(s)\n    dp = [[-1] * (n + 1) for _ in range(n + 1)]\n    return dfs(s, 0, n - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def min_palindrome_partitions(s: str) -> int:\n\n    def is_palindrome(s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n        return False\n\n    def dfs(s, i, j, dp):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        if i >= j:\n            return 0\n        if is_palindrome(s, i, j):\n            return 0\n        mx = len(s)\n        for k in range(i, j):\n            if is_palindrome(s, i, k):\n                t = dfs(s, k + 1, j, dp) + 1\n                mx = min(mx, t)\n        dp[i][j] = mx\n        return dp[i][j]\n    n = len(s)\n    dp = [[-1] * (n + 1) for _ in range(n + 1)]\n    return dfs(s, 0, n - 1, dp)"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if dp[i][j] != -1:",
      "mutated_line": "if dp[i][j] == -1:",
      "code": "def min_palindrome_partitions(s: str) -> int:\n\n    def is_palindrome(s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n        return True\n\n    def dfs(s, i, j, dp):\n        if dp[i][j] == -1:\n            return dp[i][j]\n        if i >= j:\n            return 0\n        if is_palindrome(s, i, j):\n            return 0\n        mx = len(s)\n        for k in range(i, j):\n            if is_palindrome(s, i, k):\n                t = dfs(s, k + 1, j, dp) + 1\n                mx = min(mx, t)\n        dp[i][j] = mx\n        return dp[i][j]\n    n = len(s)\n    dp = [[-1] * (n + 1) for _ in range(n + 1)]\n    return dfs(s, 0, n - 1, dp)"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if i >= j:",
      "mutated_line": "if i > j:",
      "code": "def min_palindrome_partitions(s: str) -> int:\n\n    def is_palindrome(s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n        return True\n\n    def dfs(s, i, j, dp):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        if i > j:\n            return 0\n        if is_palindrome(s, i, j):\n            return 0\n        mx = len(s)\n        for k in range(i, j):\n            if is_palindrome(s, i, k):\n                t = dfs(s, k + 1, j, dp) + 1\n                mx = min(mx, t)\n        dp[i][j] = mx\n        return dp[i][j]\n    n = len(s)\n    dp = [[-1] * (n + 1) for _ in range(n + 1)]\n    return dfs(s, 0, n - 1, dp)"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if i >= j:",
      "mutated_line": "if i < j:",
      "code": "def min_palindrome_partitions(s: str) -> int:\n\n    def is_palindrome(s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n        return True\n\n    def dfs(s, i, j, dp):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        if i < j:\n            return 0\n        if is_palindrome(s, i, j):\n            return 0\n        mx = len(s)\n        for k in range(i, j):\n            if is_palindrome(s, i, k):\n                t = dfs(s, k + 1, j, dp) + 1\n                mx = min(mx, t)\n        dp[i][j] = mx\n        return dp[i][j]\n    n = len(s)\n    dp = [[-1] * (n + 1) for _ in range(n + 1)]\n    return dfs(s, 0, n - 1, dp)"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if i >= j:",
      "mutated_line": "if i == j:",
      "code": "def min_palindrome_partitions(s: str) -> int:\n\n    def is_palindrome(s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n        return True\n\n    def dfs(s, i, j, dp):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        if i == j:\n            return 0\n        if is_palindrome(s, i, j):\n            return 0\n        mx = len(s)\n        for k in range(i, j):\n            if is_palindrome(s, i, k):\n                t = dfs(s, k + 1, j, dp) + 1\n                mx = min(mx, t)\n        dp[i][j] = mx\n        return dp[i][j]\n    n = len(s)\n    dp = [[-1] * (n + 1) for _ in range(n + 1)]\n    return dfs(s, 0, n - 1, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dp = [[-1] * (n + 1) for _ in range(n + 1)]",
      "mutated_line": "dp = [[-1] / (n + 1) for _ in range(n + 1)]",
      "code": "def min_palindrome_partitions(s: str) -> int:\n\n    def is_palindrome(s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n        return True\n\n    def dfs(s, i, j, dp):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        if i >= j:\n            return 0\n        if is_palindrome(s, i, j):\n            return 0\n        mx = len(s)\n        for k in range(i, j):\n            if is_palindrome(s, i, k):\n                t = dfs(s, k + 1, j, dp) + 1\n                mx = min(mx, t)\n        dp[i][j] = mx\n        return dp[i][j]\n    n = len(s)\n    dp = [[-1] / (n + 1) for _ in range(n + 1)]\n    return dfs(s, 0, n - 1, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dp = [[-1] * (n + 1) for _ in range(n + 1)]",
      "mutated_line": "dp = [[-1] + (n + 1) for _ in range(n + 1)]",
      "code": "def min_palindrome_partitions(s: str) -> int:\n\n    def is_palindrome(s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n        return True\n\n    def dfs(s, i, j, dp):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        if i >= j:\n            return 0\n        if is_palindrome(s, i, j):\n            return 0\n        mx = len(s)\n        for k in range(i, j):\n            if is_palindrome(s, i, k):\n                t = dfs(s, k + 1, j, dp) + 1\n                mx = min(mx, t)\n        dp[i][j] = mx\n        return dp[i][j]\n    n = len(s)\n    dp = [[-1] + (n + 1) for _ in range(n + 1)]\n    return dfs(s, 0, n - 1, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dp = [[-1] * (n + 1) for _ in range(n + 1)]",
      "mutated_line": "dp = [[-1] ** (n + 1) for _ in range(n + 1)]",
      "code": "def min_palindrome_partitions(s: str) -> int:\n\n    def is_palindrome(s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n        return True\n\n    def dfs(s, i, j, dp):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        if i >= j:\n            return 0\n        if is_palindrome(s, i, j):\n            return 0\n        mx = len(s)\n        for k in range(i, j):\n            if is_palindrome(s, i, k):\n                t = dfs(s, k + 1, j, dp) + 1\n                mx = min(mx, t)\n        dp[i][j] = mx\n        return dp[i][j]\n    n = len(s)\n    dp = [[-1] ** (n + 1) for _ in range(n + 1)]\n    return dfs(s, 0, n - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return dfs(s, 0, n - 1, dp)",
      "mutated_line": "return dfs(s, 1, n - 1, dp)",
      "code": "def min_palindrome_partitions(s: str) -> int:\n\n    def is_palindrome(s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n        return True\n\n    def dfs(s, i, j, dp):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        if i >= j:\n            return 0\n        if is_palindrome(s, i, j):\n            return 0\n        mx = len(s)\n        for k in range(i, j):\n            if is_palindrome(s, i, k):\n                t = dfs(s, k + 1, j, dp) + 1\n                mx = min(mx, t)\n        dp[i][j] = mx\n        return dp[i][j]\n    n = len(s)\n    dp = [[-1] * (n + 1) for _ in range(n + 1)]\n    return dfs(s, 1, n - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return dfs(s, 0, n - 1, dp)",
      "mutated_line": "return dfs(s, -1, n - 1, dp)",
      "code": "def min_palindrome_partitions(s: str) -> int:\n\n    def is_palindrome(s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n        return True\n\n    def dfs(s, i, j, dp):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        if i >= j:\n            return 0\n        if is_palindrome(s, i, j):\n            return 0\n        mx = len(s)\n        for k in range(i, j):\n            if is_palindrome(s, i, k):\n                t = dfs(s, k + 1, j, dp) + 1\n                mx = min(mx, t)\n        dp[i][j] = mx\n        return dp[i][j]\n    n = len(s)\n    dp = [[-1] * (n + 1) for _ in range(n + 1)]\n    return dfs(s, -1, n - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return dfs(s, 0, n - 1, dp)",
      "mutated_line": "return dfs(s, 1, n - 1, dp)",
      "code": "def min_palindrome_partitions(s: str) -> int:\n\n    def is_palindrome(s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n        return True\n\n    def dfs(s, i, j, dp):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        if i >= j:\n            return 0\n        if is_palindrome(s, i, j):\n            return 0\n        mx = len(s)\n        for k in range(i, j):\n            if is_palindrome(s, i, k):\n                t = dfs(s, k + 1, j, dp) + 1\n                mx = min(mx, t)\n        dp[i][j] = mx\n        return dp[i][j]\n    n = len(s)\n    dp = [[-1] * (n + 1) for _ in range(n + 1)]\n    return dfs(s, 1, n - 1, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "return dfs(s, 0, n - 1, dp)",
      "mutated_line": "return dfs(s, 0, n + 1, dp)",
      "code": "def min_palindrome_partitions(s: str) -> int:\n\n    def is_palindrome(s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n        return True\n\n    def dfs(s, i, j, dp):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        if i >= j:\n            return 0\n        if is_palindrome(s, i, j):\n            return 0\n        mx = len(s)\n        for k in range(i, j):\n            if is_palindrome(s, i, k):\n                t = dfs(s, k + 1, j, dp) + 1\n                mx = min(mx, t)\n        dp[i][j] = mx\n        return dp[i][j]\n    n = len(s)\n    dp = [[-1] * (n + 1) for _ in range(n + 1)]\n    return dfs(s, 0, n + 1, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "return dfs(s, 0, n - 1, dp)",
      "mutated_line": "return dfs(s, 0, n * 1, dp)",
      "code": "def min_palindrome_partitions(s: str) -> int:\n\n    def is_palindrome(s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n        return True\n\n    def dfs(s, i, j, dp):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        if i >= j:\n            return 0\n        if is_palindrome(s, i, j):\n            return 0\n        mx = len(s)\n        for k in range(i, j):\n            if is_palindrome(s, i, k):\n                t = dfs(s, k + 1, j, dp) + 1\n                mx = min(mx, t)\n        dp[i][j] = mx\n        return dp[i][j]\n    n = len(s)\n    dp = [[-1] * (n + 1) for _ in range(n + 1)]\n    return dfs(s, 0, n * 1, dp)"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if s[start] != s[end]:",
      "mutated_line": "if s[start] == s[end]:",
      "code": "def min_palindrome_partitions(s: str) -> int:\n\n    def is_palindrome(s, start, end):\n        while start < end:\n            if s[start] == s[end]:\n                return False\n            start += 1\n            end -= 1\n        return True\n\n    def dfs(s, i, j, dp):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        if i >= j:\n            return 0\n        if is_palindrome(s, i, j):\n            return 0\n        mx = len(s)\n        for k in range(i, j):\n            if is_palindrome(s, i, k):\n                t = dfs(s, k + 1, j, dp) + 1\n                mx = min(mx, t)\n        dp[i][j] = mx\n        return dp[i][j]\n    n = len(s)\n    dp = [[-1] * (n + 1) for _ in range(n + 1)]\n    return dfs(s, 0, n - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "start += 1",
      "mutated_line": "start += 2",
      "code": "def min_palindrome_partitions(s: str) -> int:\n\n    def is_palindrome(s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 2\n            end -= 1\n        return True\n\n    def dfs(s, i, j, dp):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        if i >= j:\n            return 0\n        if is_palindrome(s, i, j):\n            return 0\n        mx = len(s)\n        for k in range(i, j):\n            if is_palindrome(s, i, k):\n                t = dfs(s, k + 1, j, dp) + 1\n                mx = min(mx, t)\n        dp[i][j] = mx\n        return dp[i][j]\n    n = len(s)\n    dp = [[-1] * (n + 1) for _ in range(n + 1)]\n    return dfs(s, 0, n - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "start += 1",
      "mutated_line": "start += 0",
      "code": "def min_palindrome_partitions(s: str) -> int:\n\n    def is_palindrome(s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 0\n            end -= 1\n        return True\n\n    def dfs(s, i, j, dp):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        if i >= j:\n            return 0\n        if is_palindrome(s, i, j):\n            return 0\n        mx = len(s)\n        for k in range(i, j):\n            if is_palindrome(s, i, k):\n                t = dfs(s, k + 1, j, dp) + 1\n                mx = min(mx, t)\n        dp[i][j] = mx\n        return dp[i][j]\n    n = len(s)\n    dp = [[-1] * (n + 1) for _ in range(n + 1)]\n    return dfs(s, 0, n - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "start += 1",
      "mutated_line": "start += 0",
      "code": "def min_palindrome_partitions(s: str) -> int:\n\n    def is_palindrome(s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 0\n            end -= 1\n        return True\n\n    def dfs(s, i, j, dp):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        if i >= j:\n            return 0\n        if is_palindrome(s, i, j):\n            return 0\n        mx = len(s)\n        for k in range(i, j):\n            if is_palindrome(s, i, k):\n                t = dfs(s, k + 1, j, dp) + 1\n                mx = min(mx, t)\n        dp[i][j] = mx\n        return dp[i][j]\n    n = len(s)\n    dp = [[-1] * (n + 1) for _ in range(n + 1)]\n    return dfs(s, 0, n - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "start += 1",
      "mutated_line": "start += -1",
      "code": "def min_palindrome_partitions(s: str) -> int:\n\n    def is_palindrome(s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += -1\n            end -= 1\n        return True\n\n    def dfs(s, i, j, dp):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        if i >= j:\n            return 0\n        if is_palindrome(s, i, j):\n            return 0\n        mx = len(s)\n        for k in range(i, j):\n            if is_palindrome(s, i, k):\n                t = dfs(s, k + 1, j, dp) + 1\n                mx = min(mx, t)\n        dp[i][j] = mx\n        return dp[i][j]\n    n = len(s)\n    dp = [[-1] * (n + 1) for _ in range(n + 1)]\n    return dfs(s, 0, n - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "end -= 1",
      "mutated_line": "end -= 2",
      "code": "def min_palindrome_partitions(s: str) -> int:\n\n    def is_palindrome(s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 2\n        return True\n\n    def dfs(s, i, j, dp):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        if i >= j:\n            return 0\n        if is_palindrome(s, i, j):\n            return 0\n        mx = len(s)\n        for k in range(i, j):\n            if is_palindrome(s, i, k):\n                t = dfs(s, k + 1, j, dp) + 1\n                mx = min(mx, t)\n        dp[i][j] = mx\n        return dp[i][j]\n    n = len(s)\n    dp = [[-1] * (n + 1) for _ in range(n + 1)]\n    return dfs(s, 0, n - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "end -= 1",
      "mutated_line": "end -= 0",
      "code": "def min_palindrome_partitions(s: str) -> int:\n\n    def is_palindrome(s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 0\n        return True\n\n    def dfs(s, i, j, dp):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        if i >= j:\n            return 0\n        if is_palindrome(s, i, j):\n            return 0\n        mx = len(s)\n        for k in range(i, j):\n            if is_palindrome(s, i, k):\n                t = dfs(s, k + 1, j, dp) + 1\n                mx = min(mx, t)\n        dp[i][j] = mx\n        return dp[i][j]\n    n = len(s)\n    dp = [[-1] * (n + 1) for _ in range(n + 1)]\n    return dfs(s, 0, n - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "end -= 1",
      "mutated_line": "end -= 0",
      "code": "def min_palindrome_partitions(s: str) -> int:\n\n    def is_palindrome(s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 0\n        return True\n\n    def dfs(s, i, j, dp):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        if i >= j:\n            return 0\n        if is_palindrome(s, i, j):\n            return 0\n        mx = len(s)\n        for k in range(i, j):\n            if is_palindrome(s, i, k):\n                t = dfs(s, k + 1, j, dp) + 1\n                mx = min(mx, t)\n        dp[i][j] = mx\n        return dp[i][j]\n    n = len(s)\n    dp = [[-1] * (n + 1) for _ in range(n + 1)]\n    return dfs(s, 0, n - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "end -= 1",
      "mutated_line": "end -= -1",
      "code": "def min_palindrome_partitions(s: str) -> int:\n\n    def is_palindrome(s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= -1\n        return True\n\n    def dfs(s, i, j, dp):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        if i >= j:\n            return 0\n        if is_palindrome(s, i, j):\n            return 0\n        mx = len(s)\n        for k in range(i, j):\n            if is_palindrome(s, i, k):\n                t = dfs(s, k + 1, j, dp) + 1\n                mx = min(mx, t)\n        dp[i][j] = mx\n        return dp[i][j]\n    n = len(s)\n    dp = [[-1] * (n + 1) for _ in range(n + 1)]\n    return dfs(s, 0, n - 1, dp)"
    },
    {
      "operator": "UOI",
      "lineno": 11,
      "original_line": "if dp[i][j] != -1:",
      "mutated_line": "if dp[i][j] != +1:",
      "code": "def min_palindrome_partitions(s: str) -> int:\n\n    def is_palindrome(s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n        return True\n\n    def dfs(s, i, j, dp):\n        if dp[i][j] != +1:\n            return dp[i][j]\n        if i >= j:\n            return 0\n        if is_palindrome(s, i, j):\n            return 0\n        mx = len(s)\n        for k in range(i, j):\n            if is_palindrome(s, i, k):\n                t = dfs(s, k + 1, j, dp) + 1\n                mx = min(mx, t)\n        dp[i][j] = mx\n        return dp[i][j]\n    n = len(s)\n    dp = [[-1] * (n + 1) for _ in range(n + 1)]\n    return dfs(s, 0, n - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def min_palindrome_partitions(s: str) -> int:\n\n    def is_palindrome(s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n        return True\n\n    def dfs(s, i, j, dp):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        if i >= j:\n            return 1\n        if is_palindrome(s, i, j):\n            return 0\n        mx = len(s)\n        for k in range(i, j):\n            if is_palindrome(s, i, k):\n                t = dfs(s, k + 1, j, dp) + 1\n                mx = min(mx, t)\n        dp[i][j] = mx\n        return dp[i][j]\n    n = len(s)\n    dp = [[-1] * (n + 1) for _ in range(n + 1)]\n    return dfs(s, 0, n - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def min_palindrome_partitions(s: str) -> int:\n\n    def is_palindrome(s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n        return True\n\n    def dfs(s, i, j, dp):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        if i >= j:\n            return -1\n        if is_palindrome(s, i, j):\n            return 0\n        mx = len(s)\n        for k in range(i, j):\n            if is_palindrome(s, i, k):\n                t = dfs(s, k + 1, j, dp) + 1\n                mx = min(mx, t)\n        dp[i][j] = mx\n        return dp[i][j]\n    n = len(s)\n    dp = [[-1] * (n + 1) for _ in range(n + 1)]\n    return dfs(s, 0, n - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def min_palindrome_partitions(s: str) -> int:\n\n    def is_palindrome(s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n        return True\n\n    def dfs(s, i, j, dp):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        if i >= j:\n            return 1\n        if is_palindrome(s, i, j):\n            return 0\n        mx = len(s)\n        for k in range(i, j):\n            if is_palindrome(s, i, k):\n                t = dfs(s, k + 1, j, dp) + 1\n                mx = min(mx, t)\n        dp[i][j] = mx\n        return dp[i][j]\n    n = len(s)\n    dp = [[-1] * (n + 1) for _ in range(n + 1)]\n    return dfs(s, 0, n - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def min_palindrome_partitions(s: str) -> int:\n\n    def is_palindrome(s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n        return True\n\n    def dfs(s, i, j, dp):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        if i >= j:\n            return 0\n        if is_palindrome(s, i, j):\n            return 1\n        mx = len(s)\n        for k in range(i, j):\n            if is_palindrome(s, i, k):\n                t = dfs(s, k + 1, j, dp) + 1\n                mx = min(mx, t)\n        dp[i][j] = mx\n        return dp[i][j]\n    n = len(s)\n    dp = [[-1] * (n + 1) for _ in range(n + 1)]\n    return dfs(s, 0, n - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def min_palindrome_partitions(s: str) -> int:\n\n    def is_palindrome(s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n        return True\n\n    def dfs(s, i, j, dp):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        if i >= j:\n            return 0\n        if is_palindrome(s, i, j):\n            return -1\n        mx = len(s)\n        for k in range(i, j):\n            if is_palindrome(s, i, k):\n                t = dfs(s, k + 1, j, dp) + 1\n                mx = min(mx, t)\n        dp[i][j] = mx\n        return dp[i][j]\n    n = len(s)\n    dp = [[-1] * (n + 1) for _ in range(n + 1)]\n    return dfs(s, 0, n - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def min_palindrome_partitions(s: str) -> int:\n\n    def is_palindrome(s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n        return True\n\n    def dfs(s, i, j, dp):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        if i >= j:\n            return 0\n        if is_palindrome(s, i, j):\n            return 1\n        mx = len(s)\n        for k in range(i, j):\n            if is_palindrome(s, i, k):\n                t = dfs(s, k + 1, j, dp) + 1\n                mx = min(mx, t)\n        dp[i][j] = mx\n        return dp[i][j]\n    n = len(s)\n    dp = [[-1] * (n + 1) for _ in range(n + 1)]\n    return dfs(s, 0, n - 1, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dp = [[-1] * (n + 1) for _ in range(n + 1)]",
      "mutated_line": "dp = [[-1] * (n - 1) for _ in range(n + 1)]",
      "code": "def min_palindrome_partitions(s: str) -> int:\n\n    def is_palindrome(s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n        return True\n\n    def dfs(s, i, j, dp):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        if i >= j:\n            return 0\n        if is_palindrome(s, i, j):\n            return 0\n        mx = len(s)\n        for k in range(i, j):\n            if is_palindrome(s, i, k):\n                t = dfs(s, k + 1, j, dp) + 1\n                mx = min(mx, t)\n        dp[i][j] = mx\n        return dp[i][j]\n    n = len(s)\n    dp = [[-1] * (n - 1) for _ in range(n + 1)]\n    return dfs(s, 0, n - 1, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dp = [[-1] * (n + 1) for _ in range(n + 1)]",
      "mutated_line": "dp = [[-1] * (n * 1) for _ in range(n + 1)]",
      "code": "def min_palindrome_partitions(s: str) -> int:\n\n    def is_palindrome(s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n        return True\n\n    def dfs(s, i, j, dp):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        if i >= j:\n            return 0\n        if is_palindrome(s, i, j):\n            return 0\n        mx = len(s)\n        for k in range(i, j):\n            if is_palindrome(s, i, k):\n                t = dfs(s, k + 1, j, dp) + 1\n                mx = min(mx, t)\n        dp[i][j] = mx\n        return dp[i][j]\n    n = len(s)\n    dp = [[-1] * (n * 1) for _ in range(n + 1)]\n    return dfs(s, 0, n - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return dfs(s, 0, n - 1, dp)",
      "mutated_line": "return dfs(s, 0, n - 2, dp)",
      "code": "def min_palindrome_partitions(s: str) -> int:\n\n    def is_palindrome(s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n        return True\n\n    def dfs(s, i, j, dp):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        if i >= j:\n            return 0\n        if is_palindrome(s, i, j):\n            return 0\n        mx = len(s)\n        for k in range(i, j):\n            if is_palindrome(s, i, k):\n                t = dfs(s, k + 1, j, dp) + 1\n                mx = min(mx, t)\n        dp[i][j] = mx\n        return dp[i][j]\n    n = len(s)\n    dp = [[-1] * (n + 1) for _ in range(n + 1)]\n    return dfs(s, 0, n - 2, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return dfs(s, 0, n - 1, dp)",
      "mutated_line": "return dfs(s, 0, n - 0, dp)",
      "code": "def min_palindrome_partitions(s: str) -> int:\n\n    def is_palindrome(s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n        return True\n\n    def dfs(s, i, j, dp):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        if i >= j:\n            return 0\n        if is_palindrome(s, i, j):\n            return 0\n        mx = len(s)\n        for k in range(i, j):\n            if is_palindrome(s, i, k):\n                t = dfs(s, k + 1, j, dp) + 1\n                mx = min(mx, t)\n        dp[i][j] = mx\n        return dp[i][j]\n    n = len(s)\n    dp = [[-1] * (n + 1) for _ in range(n + 1)]\n    return dfs(s, 0, n - 0, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return dfs(s, 0, n - 1, dp)",
      "mutated_line": "return dfs(s, 0, n - 0, dp)",
      "code": "def min_palindrome_partitions(s: str) -> int:\n\n    def is_palindrome(s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n        return True\n\n    def dfs(s, i, j, dp):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        if i >= j:\n            return 0\n        if is_palindrome(s, i, j):\n            return 0\n        mx = len(s)\n        for k in range(i, j):\n            if is_palindrome(s, i, k):\n                t = dfs(s, k + 1, j, dp) + 1\n                mx = min(mx, t)\n        dp[i][j] = mx\n        return dp[i][j]\n    n = len(s)\n    dp = [[-1] * (n + 1) for _ in range(n + 1)]\n    return dfs(s, 0, n - 0, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return dfs(s, 0, n - 1, dp)",
      "mutated_line": "return dfs(s, 0, n - -1, dp)",
      "code": "def min_palindrome_partitions(s: str) -> int:\n\n    def is_palindrome(s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n        return True\n\n    def dfs(s, i, j, dp):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        if i >= j:\n            return 0\n        if is_palindrome(s, i, j):\n            return 0\n        mx = len(s)\n        for k in range(i, j):\n            if is_palindrome(s, i, k):\n                t = dfs(s, k + 1, j, dp) + 1\n                mx = min(mx, t)\n        dp[i][j] = mx\n        return dp[i][j]\n    n = len(s)\n    dp = [[-1] * (n + 1) for _ in range(n + 1)]\n    return dfs(s, 0, n - -1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def min_palindrome_partitions(s: str) -> int:\n\n    def is_palindrome(s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return True\n            start += 1\n            end -= 1\n        return True\n\n    def dfs(s, i, j, dp):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        if i >= j:\n            return 0\n        if is_palindrome(s, i, j):\n            return 0\n        mx = len(s)\n        for k in range(i, j):\n            if is_palindrome(s, i, k):\n                t = dfs(s, k + 1, j, dp) + 1\n                mx = min(mx, t)\n        dp[i][j] = mx\n        return dp[i][j]\n    n = len(s)\n    dp = [[-1] * (n + 1) for _ in range(n + 1)]\n    return dfs(s, 0, n - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if dp[i][j] != -1:",
      "mutated_line": "if dp[i][j] != -2:",
      "code": "def min_palindrome_partitions(s: str) -> int:\n\n    def is_palindrome(s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n        return True\n\n    def dfs(s, i, j, dp):\n        if dp[i][j] != -2:\n            return dp[i][j]\n        if i >= j:\n            return 0\n        if is_palindrome(s, i, j):\n            return 0\n        mx = len(s)\n        for k in range(i, j):\n            if is_palindrome(s, i, k):\n                t = dfs(s, k + 1, j, dp) + 1\n                mx = min(mx, t)\n        dp[i][j] = mx\n        return dp[i][j]\n    n = len(s)\n    dp = [[-1] * (n + 1) for _ in range(n + 1)]\n    return dfs(s, 0, n - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if dp[i][j] != -1:",
      "mutated_line": "if dp[i][j] != -0:",
      "code": "def min_palindrome_partitions(s: str) -> int:\n\n    def is_palindrome(s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n        return True\n\n    def dfs(s, i, j, dp):\n        if dp[i][j] != -0:\n            return dp[i][j]\n        if i >= j:\n            return 0\n        if is_palindrome(s, i, j):\n            return 0\n        mx = len(s)\n        for k in range(i, j):\n            if is_palindrome(s, i, k):\n                t = dfs(s, k + 1, j, dp) + 1\n                mx = min(mx, t)\n        dp[i][j] = mx\n        return dp[i][j]\n    n = len(s)\n    dp = [[-1] * (n + 1) for _ in range(n + 1)]\n    return dfs(s, 0, n - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if dp[i][j] != -1:",
      "mutated_line": "if dp[i][j] != -0:",
      "code": "def min_palindrome_partitions(s: str) -> int:\n\n    def is_palindrome(s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n        return True\n\n    def dfs(s, i, j, dp):\n        if dp[i][j] != -0:\n            return dp[i][j]\n        if i >= j:\n            return 0\n        if is_palindrome(s, i, j):\n            return 0\n        mx = len(s)\n        for k in range(i, j):\n            if is_palindrome(s, i, k):\n                t = dfs(s, k + 1, j, dp) + 1\n                mx = min(mx, t)\n        dp[i][j] = mx\n        return dp[i][j]\n    n = len(s)\n    dp = [[-1] * (n + 1) for _ in range(n + 1)]\n    return dfs(s, 0, n - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if dp[i][j] != -1:",
      "mutated_line": "if dp[i][j] != --1:",
      "code": "def min_palindrome_partitions(s: str) -> int:\n\n    def is_palindrome(s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n        return True\n\n    def dfs(s, i, j, dp):\n        if dp[i][j] != --1:\n            return dp[i][j]\n        if i >= j:\n            return 0\n        if is_palindrome(s, i, j):\n            return 0\n        mx = len(s)\n        for k in range(i, j):\n            if is_palindrome(s, i, k):\n                t = dfs(s, k + 1, j, dp) + 1\n                mx = min(mx, t)\n        dp[i][j] = mx\n        return dp[i][j]\n    n = len(s)\n    dp = [[-1] * (n + 1) for _ in range(n + 1)]\n    return dfs(s, 0, n - 1, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "t = dfs(s, k + 1, j, dp) + 1",
      "mutated_line": "t = dfs(s, k + 1, j, dp) - 1",
      "code": "def min_palindrome_partitions(s: str) -> int:\n\n    def is_palindrome(s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n        return True\n\n    def dfs(s, i, j, dp):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        if i >= j:\n            return 0\n        if is_palindrome(s, i, j):\n            return 0\n        mx = len(s)\n        for k in range(i, j):\n            if is_palindrome(s, i, k):\n                t = dfs(s, k + 1, j, dp) - 1\n                mx = min(mx, t)\n        dp[i][j] = mx\n        return dp[i][j]\n    n = len(s)\n    dp = [[-1] * (n + 1) for _ in range(n + 1)]\n    return dfs(s, 0, n - 1, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "t = dfs(s, k + 1, j, dp) + 1",
      "mutated_line": "t = dfs(s, k + 1, j, dp) * 1",
      "code": "def min_palindrome_partitions(s: str) -> int:\n\n    def is_palindrome(s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n        return True\n\n    def dfs(s, i, j, dp):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        if i >= j:\n            return 0\n        if is_palindrome(s, i, j):\n            return 0\n        mx = len(s)\n        for k in range(i, j):\n            if is_palindrome(s, i, k):\n                t = dfs(s, k + 1, j, dp) * 1\n                mx = min(mx, t)\n        dp[i][j] = mx\n        return dp[i][j]\n    n = len(s)\n    dp = [[-1] * (n + 1) for _ in range(n + 1)]\n    return dfs(s, 0, n - 1, dp)"
    },
    {
      "operator": "UOI",
      "lineno": 26,
      "original_line": "dp = [[-1] * (n + 1) for _ in range(n + 1)]",
      "mutated_line": "dp = [[+1] * (n + 1) for _ in range(n + 1)]",
      "code": "def min_palindrome_partitions(s: str) -> int:\n\n    def is_palindrome(s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n        return True\n\n    def dfs(s, i, j, dp):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        if i >= j:\n            return 0\n        if is_palindrome(s, i, j):\n            return 0\n        mx = len(s)\n        for k in range(i, j):\n            if is_palindrome(s, i, k):\n                t = dfs(s, k + 1, j, dp) + 1\n                mx = min(mx, t)\n        dp[i][j] = mx\n        return dp[i][j]\n    n = len(s)\n    dp = [[+1] * (n + 1) for _ in range(n + 1)]\n    return dfs(s, 0, n - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp = [[-1] * (n + 1) for _ in range(n + 1)]",
      "mutated_line": "dp = [[-1] * (n + 2) for _ in range(n + 1)]",
      "code": "def min_palindrome_partitions(s: str) -> int:\n\n    def is_palindrome(s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n        return True\n\n    def dfs(s, i, j, dp):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        if i >= j:\n            return 0\n        if is_palindrome(s, i, j):\n            return 0\n        mx = len(s)\n        for k in range(i, j):\n            if is_palindrome(s, i, k):\n                t = dfs(s, k + 1, j, dp) + 1\n                mx = min(mx, t)\n        dp[i][j] = mx\n        return dp[i][j]\n    n = len(s)\n    dp = [[-1] * (n + 2) for _ in range(n + 1)]\n    return dfs(s, 0, n - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp = [[-1] * (n + 1) for _ in range(n + 1)]",
      "mutated_line": "dp = [[-1] * (n + 0) for _ in range(n + 1)]",
      "code": "def min_palindrome_partitions(s: str) -> int:\n\n    def is_palindrome(s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n        return True\n\n    def dfs(s, i, j, dp):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        if i >= j:\n            return 0\n        if is_palindrome(s, i, j):\n            return 0\n        mx = len(s)\n        for k in range(i, j):\n            if is_palindrome(s, i, k):\n                t = dfs(s, k + 1, j, dp) + 1\n                mx = min(mx, t)\n        dp[i][j] = mx\n        return dp[i][j]\n    n = len(s)\n    dp = [[-1] * (n + 0) for _ in range(n + 1)]\n    return dfs(s, 0, n - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp = [[-1] * (n + 1) for _ in range(n + 1)]",
      "mutated_line": "dp = [[-1] * (n + 0) for _ in range(n + 1)]",
      "code": "def min_palindrome_partitions(s: str) -> int:\n\n    def is_palindrome(s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n        return True\n\n    def dfs(s, i, j, dp):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        if i >= j:\n            return 0\n        if is_palindrome(s, i, j):\n            return 0\n        mx = len(s)\n        for k in range(i, j):\n            if is_palindrome(s, i, k):\n                t = dfs(s, k + 1, j, dp) + 1\n                mx = min(mx, t)\n        dp[i][j] = mx\n        return dp[i][j]\n    n = len(s)\n    dp = [[-1] * (n + 0) for _ in range(n + 1)]\n    return dfs(s, 0, n - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp = [[-1] * (n + 1) for _ in range(n + 1)]",
      "mutated_line": "dp = [[-1] * (n + -1) for _ in range(n + 1)]",
      "code": "def min_palindrome_partitions(s: str) -> int:\n\n    def is_palindrome(s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n        return True\n\n    def dfs(s, i, j, dp):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        if i >= j:\n            return 0\n        if is_palindrome(s, i, j):\n            return 0\n        mx = len(s)\n        for k in range(i, j):\n            if is_palindrome(s, i, k):\n                t = dfs(s, k + 1, j, dp) + 1\n                mx = min(mx, t)\n        dp[i][j] = mx\n        return dp[i][j]\n    n = len(s)\n    dp = [[-1] * (n + -1) for _ in range(n + 1)]\n    return dfs(s, 0, n - 1, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dp = [[-1] * (n + 1) for _ in range(n + 1)]",
      "mutated_line": "dp = [[-1] * (n + 1) for _ in range(n - 1)]",
      "code": "def min_palindrome_partitions(s: str) -> int:\n\n    def is_palindrome(s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n        return True\n\n    def dfs(s, i, j, dp):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        if i >= j:\n            return 0\n        if is_palindrome(s, i, j):\n            return 0\n        mx = len(s)\n        for k in range(i, j):\n            if is_palindrome(s, i, k):\n                t = dfs(s, k + 1, j, dp) + 1\n                mx = min(mx, t)\n        dp[i][j] = mx\n        return dp[i][j]\n    n = len(s)\n    dp = [[-1] * (n + 1) for _ in range(n - 1)]\n    return dfs(s, 0, n - 1, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dp = [[-1] * (n + 1) for _ in range(n + 1)]",
      "mutated_line": "dp = [[-1] * (n + 1) for _ in range(n * 1)]",
      "code": "def min_palindrome_partitions(s: str) -> int:\n\n    def is_palindrome(s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n        return True\n\n    def dfs(s, i, j, dp):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        if i >= j:\n            return 0\n        if is_palindrome(s, i, j):\n            return 0\n        mx = len(s)\n        for k in range(i, j):\n            if is_palindrome(s, i, k):\n                t = dfs(s, k + 1, j, dp) + 1\n                mx = min(mx, t)\n        dp[i][j] = mx\n        return dp[i][j]\n    n = len(s)\n    dp = [[-1] * (n + 1) for _ in range(n * 1)]\n    return dfs(s, 0, n - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "t = dfs(s, k + 1, j, dp) + 1",
      "mutated_line": "t = dfs(s, k + 1, j, dp) + 2",
      "code": "def min_palindrome_partitions(s: str) -> int:\n\n    def is_palindrome(s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n        return True\n\n    def dfs(s, i, j, dp):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        if i >= j:\n            return 0\n        if is_palindrome(s, i, j):\n            return 0\n        mx = len(s)\n        for k in range(i, j):\n            if is_palindrome(s, i, k):\n                t = dfs(s, k + 1, j, dp) + 2\n                mx = min(mx, t)\n        dp[i][j] = mx\n        return dp[i][j]\n    n = len(s)\n    dp = [[-1] * (n + 1) for _ in range(n + 1)]\n    return dfs(s, 0, n - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "t = dfs(s, k + 1, j, dp) + 1",
      "mutated_line": "t = dfs(s, k + 1, j, dp) + 0",
      "code": "def min_palindrome_partitions(s: str) -> int:\n\n    def is_palindrome(s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n        return True\n\n    def dfs(s, i, j, dp):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        if i >= j:\n            return 0\n        if is_palindrome(s, i, j):\n            return 0\n        mx = len(s)\n        for k in range(i, j):\n            if is_palindrome(s, i, k):\n                t = dfs(s, k + 1, j, dp) + 0\n                mx = min(mx, t)\n        dp[i][j] = mx\n        return dp[i][j]\n    n = len(s)\n    dp = [[-1] * (n + 1) for _ in range(n + 1)]\n    return dfs(s, 0, n - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "t = dfs(s, k + 1, j, dp) + 1",
      "mutated_line": "t = dfs(s, k + 1, j, dp) + 0",
      "code": "def min_palindrome_partitions(s: str) -> int:\n\n    def is_palindrome(s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n        return True\n\n    def dfs(s, i, j, dp):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        if i >= j:\n            return 0\n        if is_palindrome(s, i, j):\n            return 0\n        mx = len(s)\n        for k in range(i, j):\n            if is_palindrome(s, i, k):\n                t = dfs(s, k + 1, j, dp) + 0\n                mx = min(mx, t)\n        dp[i][j] = mx\n        return dp[i][j]\n    n = len(s)\n    dp = [[-1] * (n + 1) for _ in range(n + 1)]\n    return dfs(s, 0, n - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "t = dfs(s, k + 1, j, dp) + 1",
      "mutated_line": "t = dfs(s, k + 1, j, dp) + -1",
      "code": "def min_palindrome_partitions(s: str) -> int:\n\n    def is_palindrome(s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n        return True\n\n    def dfs(s, i, j, dp):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        if i >= j:\n            return 0\n        if is_palindrome(s, i, j):\n            return 0\n        mx = len(s)\n        for k in range(i, j):\n            if is_palindrome(s, i, k):\n                t = dfs(s, k + 1, j, dp) + -1\n                mx = min(mx, t)\n        dp[i][j] = mx\n        return dp[i][j]\n    n = len(s)\n    dp = [[-1] * (n + 1) for _ in range(n + 1)]\n    return dfs(s, 0, n - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp = [[-1] * (n + 1) for _ in range(n + 1)]",
      "mutated_line": "dp = [[-2] * (n + 1) for _ in range(n + 1)]",
      "code": "def min_palindrome_partitions(s: str) -> int:\n\n    def is_palindrome(s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n        return True\n\n    def dfs(s, i, j, dp):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        if i >= j:\n            return 0\n        if is_palindrome(s, i, j):\n            return 0\n        mx = len(s)\n        for k in range(i, j):\n            if is_palindrome(s, i, k):\n                t = dfs(s, k + 1, j, dp) + 1\n                mx = min(mx, t)\n        dp[i][j] = mx\n        return dp[i][j]\n    n = len(s)\n    dp = [[-2] * (n + 1) for _ in range(n + 1)]\n    return dfs(s, 0, n - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp = [[-1] * (n + 1) for _ in range(n + 1)]",
      "mutated_line": "dp = [[-0] * (n + 1) for _ in range(n + 1)]",
      "code": "def min_palindrome_partitions(s: str) -> int:\n\n    def is_palindrome(s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n        return True\n\n    def dfs(s, i, j, dp):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        if i >= j:\n            return 0\n        if is_palindrome(s, i, j):\n            return 0\n        mx = len(s)\n        for k in range(i, j):\n            if is_palindrome(s, i, k):\n                t = dfs(s, k + 1, j, dp) + 1\n                mx = min(mx, t)\n        dp[i][j] = mx\n        return dp[i][j]\n    n = len(s)\n    dp = [[-0] * (n + 1) for _ in range(n + 1)]\n    return dfs(s, 0, n - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp = [[-1] * (n + 1) for _ in range(n + 1)]",
      "mutated_line": "dp = [[-0] * (n + 1) for _ in range(n + 1)]",
      "code": "def min_palindrome_partitions(s: str) -> int:\n\n    def is_palindrome(s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n        return True\n\n    def dfs(s, i, j, dp):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        if i >= j:\n            return 0\n        if is_palindrome(s, i, j):\n            return 0\n        mx = len(s)\n        for k in range(i, j):\n            if is_palindrome(s, i, k):\n                t = dfs(s, k + 1, j, dp) + 1\n                mx = min(mx, t)\n        dp[i][j] = mx\n        return dp[i][j]\n    n = len(s)\n    dp = [[-0] * (n + 1) for _ in range(n + 1)]\n    return dfs(s, 0, n - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp = [[-1] * (n + 1) for _ in range(n + 1)]",
      "mutated_line": "dp = [[--1] * (n + 1) for _ in range(n + 1)]",
      "code": "def min_palindrome_partitions(s: str) -> int:\n\n    def is_palindrome(s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n        return True\n\n    def dfs(s, i, j, dp):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        if i >= j:\n            return 0\n        if is_palindrome(s, i, j):\n            return 0\n        mx = len(s)\n        for k in range(i, j):\n            if is_palindrome(s, i, k):\n                t = dfs(s, k + 1, j, dp) + 1\n                mx = min(mx, t)\n        dp[i][j] = mx\n        return dp[i][j]\n    n = len(s)\n    dp = [[--1] * (n + 1) for _ in range(n + 1)]\n    return dfs(s, 0, n - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp = [[-1] * (n + 1) for _ in range(n + 1)]",
      "mutated_line": "dp = [[-1] * (n + 1) for _ in range(n + 2)]",
      "code": "def min_palindrome_partitions(s: str) -> int:\n\n    def is_palindrome(s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n        return True\n\n    def dfs(s, i, j, dp):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        if i >= j:\n            return 0\n        if is_palindrome(s, i, j):\n            return 0\n        mx = len(s)\n        for k in range(i, j):\n            if is_palindrome(s, i, k):\n                t = dfs(s, k + 1, j, dp) + 1\n                mx = min(mx, t)\n        dp[i][j] = mx\n        return dp[i][j]\n    n = len(s)\n    dp = [[-1] * (n + 1) for _ in range(n + 2)]\n    return dfs(s, 0, n - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp = [[-1] * (n + 1) for _ in range(n + 1)]",
      "mutated_line": "dp = [[-1] * (n + 1) for _ in range(n + 0)]",
      "code": "def min_palindrome_partitions(s: str) -> int:\n\n    def is_palindrome(s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n        return True\n\n    def dfs(s, i, j, dp):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        if i >= j:\n            return 0\n        if is_palindrome(s, i, j):\n            return 0\n        mx = len(s)\n        for k in range(i, j):\n            if is_palindrome(s, i, k):\n                t = dfs(s, k + 1, j, dp) + 1\n                mx = min(mx, t)\n        dp[i][j] = mx\n        return dp[i][j]\n    n = len(s)\n    dp = [[-1] * (n + 1) for _ in range(n + 0)]\n    return dfs(s, 0, n - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp = [[-1] * (n + 1) for _ in range(n + 1)]",
      "mutated_line": "dp = [[-1] * (n + 1) for _ in range(n + 0)]",
      "code": "def min_palindrome_partitions(s: str) -> int:\n\n    def is_palindrome(s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n        return True\n\n    def dfs(s, i, j, dp):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        if i >= j:\n            return 0\n        if is_palindrome(s, i, j):\n            return 0\n        mx = len(s)\n        for k in range(i, j):\n            if is_palindrome(s, i, k):\n                t = dfs(s, k + 1, j, dp) + 1\n                mx = min(mx, t)\n        dp[i][j] = mx\n        return dp[i][j]\n    n = len(s)\n    dp = [[-1] * (n + 1) for _ in range(n + 0)]\n    return dfs(s, 0, n - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp = [[-1] * (n + 1) for _ in range(n + 1)]",
      "mutated_line": "dp = [[-1] * (n + 1) for _ in range(n + -1)]",
      "code": "def min_palindrome_partitions(s: str) -> int:\n\n    def is_palindrome(s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n        return True\n\n    def dfs(s, i, j, dp):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        if i >= j:\n            return 0\n        if is_palindrome(s, i, j):\n            return 0\n        mx = len(s)\n        for k in range(i, j):\n            if is_palindrome(s, i, k):\n                t = dfs(s, k + 1, j, dp) + 1\n                mx = min(mx, t)\n        dp[i][j] = mx\n        return dp[i][j]\n    n = len(s)\n    dp = [[-1] * (n + 1) for _ in range(n + -1)]\n    return dfs(s, 0, n - 1, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "t = dfs(s, k + 1, j, dp) + 1",
      "mutated_line": "t = dfs(s, k - 1, j, dp) + 1",
      "code": "def min_palindrome_partitions(s: str) -> int:\n\n    def is_palindrome(s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n        return True\n\n    def dfs(s, i, j, dp):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        if i >= j:\n            return 0\n        if is_palindrome(s, i, j):\n            return 0\n        mx = len(s)\n        for k in range(i, j):\n            if is_palindrome(s, i, k):\n                t = dfs(s, k - 1, j, dp) + 1\n                mx = min(mx, t)\n        dp[i][j] = mx\n        return dp[i][j]\n    n = len(s)\n    dp = [[-1] * (n + 1) for _ in range(n + 1)]\n    return dfs(s, 0, n - 1, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "t = dfs(s, k + 1, j, dp) + 1",
      "mutated_line": "t = dfs(s, k * 1, j, dp) + 1",
      "code": "def min_palindrome_partitions(s: str) -> int:\n\n    def is_palindrome(s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n        return True\n\n    def dfs(s, i, j, dp):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        if i >= j:\n            return 0\n        if is_palindrome(s, i, j):\n            return 0\n        mx = len(s)\n        for k in range(i, j):\n            if is_palindrome(s, i, k):\n                t = dfs(s, k * 1, j, dp) + 1\n                mx = min(mx, t)\n        dp[i][j] = mx\n        return dp[i][j]\n    n = len(s)\n    dp = [[-1] * (n + 1) for _ in range(n + 1)]\n    return dfs(s, 0, n - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "t = dfs(s, k + 1, j, dp) + 1",
      "mutated_line": "t = dfs(s, k + 2, j, dp) + 1",
      "code": "def min_palindrome_partitions(s: str) -> int:\n\n    def is_palindrome(s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n        return True\n\n    def dfs(s, i, j, dp):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        if i >= j:\n            return 0\n        if is_palindrome(s, i, j):\n            return 0\n        mx = len(s)\n        for k in range(i, j):\n            if is_palindrome(s, i, k):\n                t = dfs(s, k + 2, j, dp) + 1\n                mx = min(mx, t)\n        dp[i][j] = mx\n        return dp[i][j]\n    n = len(s)\n    dp = [[-1] * (n + 1) for _ in range(n + 1)]\n    return dfs(s, 0, n - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "t = dfs(s, k + 1, j, dp) + 1",
      "mutated_line": "t = dfs(s, k + 0, j, dp) + 1",
      "code": "def min_palindrome_partitions(s: str) -> int:\n\n    def is_palindrome(s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n        return True\n\n    def dfs(s, i, j, dp):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        if i >= j:\n            return 0\n        if is_palindrome(s, i, j):\n            return 0\n        mx = len(s)\n        for k in range(i, j):\n            if is_palindrome(s, i, k):\n                t = dfs(s, k + 0, j, dp) + 1\n                mx = min(mx, t)\n        dp[i][j] = mx\n        return dp[i][j]\n    n = len(s)\n    dp = [[-1] * (n + 1) for _ in range(n + 1)]\n    return dfs(s, 0, n - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "t = dfs(s, k + 1, j, dp) + 1",
      "mutated_line": "t = dfs(s, k + 0, j, dp) + 1",
      "code": "def min_palindrome_partitions(s: str) -> int:\n\n    def is_palindrome(s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n        return True\n\n    def dfs(s, i, j, dp):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        if i >= j:\n            return 0\n        if is_palindrome(s, i, j):\n            return 0\n        mx = len(s)\n        for k in range(i, j):\n            if is_palindrome(s, i, k):\n                t = dfs(s, k + 0, j, dp) + 1\n                mx = min(mx, t)\n        dp[i][j] = mx\n        return dp[i][j]\n    n = len(s)\n    dp = [[-1] * (n + 1) for _ in range(n + 1)]\n    return dfs(s, 0, n - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "t = dfs(s, k + 1, j, dp) + 1",
      "mutated_line": "t = dfs(s, k + -1, j, dp) + 1",
      "code": "def min_palindrome_partitions(s: str) -> int:\n\n    def is_palindrome(s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n        return True\n\n    def dfs(s, i, j, dp):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        if i >= j:\n            return 0\n        if is_palindrome(s, i, j):\n            return 0\n        mx = len(s)\n        for k in range(i, j):\n            if is_palindrome(s, i, k):\n                t = dfs(s, k + -1, j, dp) + 1\n                mx = min(mx, t)\n        dp[i][j] = mx\n        return dp[i][j]\n    n = len(s)\n    dp = [[-1] * (n + 1) for _ in range(n + 1)]\n    return dfs(s, 0, n - 1, dp)"
    }
  ]
}