{
  "task_id": "taco_19207",
  "entry_point": "eulerian_path",
  "mutant_count": 61,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "root = 0",
      "mutated_line": "root = 1",
      "code": "import sys\nfrom collections import deque\n\ndef eulerian_path(root, adj):\n    path = []\n    stack = [root]\n    while stack:\n        u = stack[-1]\n        if len(adj[u]) == 0:\n            path.append(u)\n            stack.pop()\n        else:\n            v = adj[u][-1]\n            adj[u].pop()\n            adj[v] = [w for w in adj[v] if w != u]\n            stack.append(v)\n    return path\n\ndef find_rook_path(N, M, marked_squares):\n    marked = dict()\n    adj = [[] for _ in range(2 * (N + 1))]\n    root = 1\n    for (i, (row, col)) in enumerate(marked_squares, 1):\n        marked[row, col] = i\n        col = col + N\n        adj[row].append(col)\n        adj[col].append(row)\n        root = max(root, row)\n    for (node, neighbors) in enumerate(adj):\n        if len(neighbors) % 2:\n            root = node\n    path = eulerian_path(root, adj)\n    soln = []\n    for (row, col) in zip(path[:-1], path[1:]):\n        if row > N:\n            row = row - N\n            (row, col) = (col, row)\n        else:\n            col = col - N\n        soln.append(marked[row, col])\n    return soln"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "root = 0",
      "mutated_line": "root = -1",
      "code": "import sys\nfrom collections import deque\n\ndef eulerian_path(root, adj):\n    path = []\n    stack = [root]\n    while stack:\n        u = stack[-1]\n        if len(adj[u]) == 0:\n            path.append(u)\n            stack.pop()\n        else:\n            v = adj[u][-1]\n            adj[u].pop()\n            adj[v] = [w for w in adj[v] if w != u]\n            stack.append(v)\n    return path\n\ndef find_rook_path(N, M, marked_squares):\n    marked = dict()\n    adj = [[] for _ in range(2 * (N + 1))]\n    root = -1\n    for (i, (row, col)) in enumerate(marked_squares, 1):\n        marked[row, col] = i\n        col = col + N\n        adj[row].append(col)\n        adj[col].append(row)\n        root = max(root, row)\n    for (node, neighbors) in enumerate(adj):\n        if len(neighbors) % 2:\n            root = node\n    path = eulerian_path(root, adj)\n    soln = []\n    for (row, col) in zip(path[:-1], path[1:]):\n        if row > N:\n            row = row - N\n            (row, col) = (col, row)\n        else:\n            col = col - N\n        soln.append(marked[row, col])\n    return soln"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "root = 0",
      "mutated_line": "root = 1",
      "code": "import sys\nfrom collections import deque\n\ndef eulerian_path(root, adj):\n    path = []\n    stack = [root]\n    while stack:\n        u = stack[-1]\n        if len(adj[u]) == 0:\n            path.append(u)\n            stack.pop()\n        else:\n            v = adj[u][-1]\n            adj[u].pop()\n            adj[v] = [w for w in adj[v] if w != u]\n            stack.append(v)\n    return path\n\ndef find_rook_path(N, M, marked_squares):\n    marked = dict()\n    adj = [[] for _ in range(2 * (N + 1))]\n    root = 1\n    for (i, (row, col)) in enumerate(marked_squares, 1):\n        marked[row, col] = i\n        col = col + N\n        adj[row].append(col)\n        adj[col].append(row)\n        root = max(root, row)\n    for (node, neighbors) in enumerate(adj):\n        if len(neighbors) % 2:\n            root = node\n    path = eulerian_path(root, adj)\n    soln = []\n    for (row, col) in zip(path[:-1], path[1:]):\n        if row > N:\n            row = row - N\n            (row, col) = (col, row)\n        else:\n            col = col - N\n        soln.append(marked[row, col])\n    return soln"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if len(adj[u]) == 0:",
      "mutated_line": "if len(adj[u]) != 0:",
      "code": "import sys\nfrom collections import deque\n\ndef eulerian_path(root, adj):\n    path = []\n    stack = [root]\n    while stack:\n        u = stack[-1]\n        if len(adj[u]) != 0:\n            path.append(u)\n            stack.pop()\n        else:\n            v = adj[u][-1]\n            adj[u].pop()\n            adj[v] = [w for w in adj[v] if w != u]\n            stack.append(v)\n    return path\n\ndef find_rook_path(N, M, marked_squares):\n    marked = dict()\n    adj = [[] for _ in range(2 * (N + 1))]\n    root = 0\n    for (i, (row, col)) in enumerate(marked_squares, 1):\n        marked[row, col] = i\n        col = col + N\n        adj[row].append(col)\n        adj[col].append(row)\n        root = max(root, row)\n    for (node, neighbors) in enumerate(adj):\n        if len(neighbors) % 2:\n            root = node\n    path = eulerian_path(root, adj)\n    soln = []\n    for (row, col) in zip(path[:-1], path[1:]):\n        if row > N:\n            row = row - N\n            (row, col) = (col, row)\n        else:\n            col = col - N\n        soln.append(marked[row, col])\n    return soln"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i, (row, col) in enumerate(marked_squares, 1):",
      "mutated_line": "for (i, (row, col)) in enumerate(marked_squares, 2):",
      "code": "import sys\nfrom collections import deque\n\ndef eulerian_path(root, adj):\n    path = []\n    stack = [root]\n    while stack:\n        u = stack[-1]\n        if len(adj[u]) == 0:\n            path.append(u)\n            stack.pop()\n        else:\n            v = adj[u][-1]\n            adj[u].pop()\n            adj[v] = [w for w in adj[v] if w != u]\n            stack.append(v)\n    return path\n\ndef find_rook_path(N, M, marked_squares):\n    marked = dict()\n    adj = [[] for _ in range(2 * (N + 1))]\n    root = 0\n    for (i, (row, col)) in enumerate(marked_squares, 2):\n        marked[row, col] = i\n        col = col + N\n        adj[row].append(col)\n        adj[col].append(row)\n        root = max(root, row)\n    for (node, neighbors) in enumerate(adj):\n        if len(neighbors) % 2:\n            root = node\n    path = eulerian_path(root, adj)\n    soln = []\n    for (row, col) in zip(path[:-1], path[1:]):\n        if row > N:\n            row = row - N\n            (row, col) = (col, row)\n        else:\n            col = col - N\n        soln.append(marked[row, col])\n    return soln"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i, (row, col) in enumerate(marked_squares, 1):",
      "mutated_line": "for (i, (row, col)) in enumerate(marked_squares, 0):",
      "code": "import sys\nfrom collections import deque\n\ndef eulerian_path(root, adj):\n    path = []\n    stack = [root]\n    while stack:\n        u = stack[-1]\n        if len(adj[u]) == 0:\n            path.append(u)\n            stack.pop()\n        else:\n            v = adj[u][-1]\n            adj[u].pop()\n            adj[v] = [w for w in adj[v] if w != u]\n            stack.append(v)\n    return path\n\ndef find_rook_path(N, M, marked_squares):\n    marked = dict()\n    adj = [[] for _ in range(2 * (N + 1))]\n    root = 0\n    for (i, (row, col)) in enumerate(marked_squares, 0):\n        marked[row, col] = i\n        col = col + N\n        adj[row].append(col)\n        adj[col].append(row)\n        root = max(root, row)\n    for (node, neighbors) in enumerate(adj):\n        if len(neighbors) % 2:\n            root = node\n    path = eulerian_path(root, adj)\n    soln = []\n    for (row, col) in zip(path[:-1], path[1:]):\n        if row > N:\n            row = row - N\n            (row, col) = (col, row)\n        else:\n            col = col - N\n        soln.append(marked[row, col])\n    return soln"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i, (row, col) in enumerate(marked_squares, 1):",
      "mutated_line": "for (i, (row, col)) in enumerate(marked_squares, 0):",
      "code": "import sys\nfrom collections import deque\n\ndef eulerian_path(root, adj):\n    path = []\n    stack = [root]\n    while stack:\n        u = stack[-1]\n        if len(adj[u]) == 0:\n            path.append(u)\n            stack.pop()\n        else:\n            v = adj[u][-1]\n            adj[u].pop()\n            adj[v] = [w for w in adj[v] if w != u]\n            stack.append(v)\n    return path\n\ndef find_rook_path(N, M, marked_squares):\n    marked = dict()\n    adj = [[] for _ in range(2 * (N + 1))]\n    root = 0\n    for (i, (row, col)) in enumerate(marked_squares, 0):\n        marked[row, col] = i\n        col = col + N\n        adj[row].append(col)\n        adj[col].append(row)\n        root = max(root, row)\n    for (node, neighbors) in enumerate(adj):\n        if len(neighbors) % 2:\n            root = node\n    path = eulerian_path(root, adj)\n    soln = []\n    for (row, col) in zip(path[:-1], path[1:]):\n        if row > N:\n            row = row - N\n            (row, col) = (col, row)\n        else:\n            col = col - N\n        soln.append(marked[row, col])\n    return soln"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i, (row, col) in enumerate(marked_squares, 1):",
      "mutated_line": "for (i, (row, col)) in enumerate(marked_squares, -1):",
      "code": "import sys\nfrom collections import deque\n\ndef eulerian_path(root, adj):\n    path = []\n    stack = [root]\n    while stack:\n        u = stack[-1]\n        if len(adj[u]) == 0:\n            path.append(u)\n            stack.pop()\n        else:\n            v = adj[u][-1]\n            adj[u].pop()\n            adj[v] = [w for w in adj[v] if w != u]\n            stack.append(v)\n    return path\n\ndef find_rook_path(N, M, marked_squares):\n    marked = dict()\n    adj = [[] for _ in range(2 * (N + 1))]\n    root = 0\n    for (i, (row, col)) in enumerate(marked_squares, -1):\n        marked[row, col] = i\n        col = col + N\n        adj[row].append(col)\n        adj[col].append(row)\n        root = max(root, row)\n    for (node, neighbors) in enumerate(adj):\n        if len(neighbors) % 2:\n            root = node\n    path = eulerian_path(root, adj)\n    soln = []\n    for (row, col) in zip(path[:-1], path[1:]):\n        if row > N:\n            row = row - N\n            (row, col) = (col, row)\n        else:\n            col = col - N\n        soln.append(marked[row, col])\n    return soln"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "col = col + N",
      "mutated_line": "col = col - N",
      "code": "import sys\nfrom collections import deque\n\ndef eulerian_path(root, adj):\n    path = []\n    stack = [root]\n    while stack:\n        u = stack[-1]\n        if len(adj[u]) == 0:\n            path.append(u)\n            stack.pop()\n        else:\n            v = adj[u][-1]\n            adj[u].pop()\n            adj[v] = [w for w in adj[v] if w != u]\n            stack.append(v)\n    return path\n\ndef find_rook_path(N, M, marked_squares):\n    marked = dict()\n    adj = [[] for _ in range(2 * (N + 1))]\n    root = 0\n    for (i, (row, col)) in enumerate(marked_squares, 1):\n        marked[row, col] = i\n        col = col - N\n        adj[row].append(col)\n        adj[col].append(row)\n        root = max(root, row)\n    for (node, neighbors) in enumerate(adj):\n        if len(neighbors) % 2:\n            root = node\n    path = eulerian_path(root, adj)\n    soln = []\n    for (row, col) in zip(path[:-1], path[1:]):\n        if row > N:\n            row = row - N\n            (row, col) = (col, row)\n        else:\n            col = col - N\n        soln.append(marked[row, col])\n    return soln"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "col = col + N",
      "mutated_line": "col = col * N",
      "code": "import sys\nfrom collections import deque\n\ndef eulerian_path(root, adj):\n    path = []\n    stack = [root]\n    while stack:\n        u = stack[-1]\n        if len(adj[u]) == 0:\n            path.append(u)\n            stack.pop()\n        else:\n            v = adj[u][-1]\n            adj[u].pop()\n            adj[v] = [w for w in adj[v] if w != u]\n            stack.append(v)\n    return path\n\ndef find_rook_path(N, M, marked_squares):\n    marked = dict()\n    adj = [[] for _ in range(2 * (N + 1))]\n    root = 0\n    for (i, (row, col)) in enumerate(marked_squares, 1):\n        marked[row, col] = i\n        col = col * N\n        adj[row].append(col)\n        adj[col].append(row)\n        root = max(root, row)\n    for (node, neighbors) in enumerate(adj):\n        if len(neighbors) % 2:\n            root = node\n    path = eulerian_path(root, adj)\n    soln = []\n    for (row, col) in zip(path[:-1], path[1:]):\n        if row > N:\n            row = row - N\n            (row, col) = (col, row)\n        else:\n            col = col - N\n        soln.append(marked[row, col])\n    return soln"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "if len(neighbors) % 2:",
      "mutated_line": "if len(neighbors) * 2:",
      "code": "import sys\nfrom collections import deque\n\ndef eulerian_path(root, adj):\n    path = []\n    stack = [root]\n    while stack:\n        u = stack[-1]\n        if len(adj[u]) == 0:\n            path.append(u)\n            stack.pop()\n        else:\n            v = adj[u][-1]\n            adj[u].pop()\n            adj[v] = [w for w in adj[v] if w != u]\n            stack.append(v)\n    return path\n\ndef find_rook_path(N, M, marked_squares):\n    marked = dict()\n    adj = [[] for _ in range(2 * (N + 1))]\n    root = 0\n    for (i, (row, col)) in enumerate(marked_squares, 1):\n        marked[row, col] = i\n        col = col + N\n        adj[row].append(col)\n        adj[col].append(row)\n        root = max(root, row)\n    for (node, neighbors) in enumerate(adj):\n        if len(neighbors) * 2:\n            root = node\n    path = eulerian_path(root, adj)\n    soln = []\n    for (row, col) in zip(path[:-1], path[1:]):\n        if row > N:\n            row = row - N\n            (row, col) = (col, row)\n        else:\n            col = col - N\n        soln.append(marked[row, col])\n    return soln"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "if len(neighbors) % 2:",
      "mutated_line": "if len(neighbors) + 2:",
      "code": "import sys\nfrom collections import deque\n\ndef eulerian_path(root, adj):\n    path = []\n    stack = [root]\n    while stack:\n        u = stack[-1]\n        if len(adj[u]) == 0:\n            path.append(u)\n            stack.pop()\n        else:\n            v = adj[u][-1]\n            adj[u].pop()\n            adj[v] = [w for w in adj[v] if w != u]\n            stack.append(v)\n    return path\n\ndef find_rook_path(N, M, marked_squares):\n    marked = dict()\n    adj = [[] for _ in range(2 * (N + 1))]\n    root = 0\n    for (i, (row, col)) in enumerate(marked_squares, 1):\n        marked[row, col] = i\n        col = col + N\n        adj[row].append(col)\n        adj[col].append(row)\n        root = max(root, row)\n    for (node, neighbors) in enumerate(adj):\n        if len(neighbors) + 2:\n            root = node\n    path = eulerian_path(root, adj)\n    soln = []\n    for (row, col) in zip(path[:-1], path[1:]):\n        if row > N:\n            row = row - N\n            (row, col) = (col, row)\n        else:\n            col = col - N\n        soln.append(marked[row, col])\n    return soln"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if row > N:",
      "mutated_line": "if row >= N:",
      "code": "import sys\nfrom collections import deque\n\ndef eulerian_path(root, adj):\n    path = []\n    stack = [root]\n    while stack:\n        u = stack[-1]\n        if len(adj[u]) == 0:\n            path.append(u)\n            stack.pop()\n        else:\n            v = adj[u][-1]\n            adj[u].pop()\n            adj[v] = [w for w in adj[v] if w != u]\n            stack.append(v)\n    return path\n\ndef find_rook_path(N, M, marked_squares):\n    marked = dict()\n    adj = [[] for _ in range(2 * (N + 1))]\n    root = 0\n    for (i, (row, col)) in enumerate(marked_squares, 1):\n        marked[row, col] = i\n        col = col + N\n        adj[row].append(col)\n        adj[col].append(row)\n        root = max(root, row)\n    for (node, neighbors) in enumerate(adj):\n        if len(neighbors) % 2:\n            root = node\n    path = eulerian_path(root, adj)\n    soln = []\n    for (row, col) in zip(path[:-1], path[1:]):\n        if row >= N:\n            row = row - N\n            (row, col) = (col, row)\n        else:\n            col = col - N\n        soln.append(marked[row, col])\n    return soln"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if row > N:",
      "mutated_line": "if row <= N:",
      "code": "import sys\nfrom collections import deque\n\ndef eulerian_path(root, adj):\n    path = []\n    stack = [root]\n    while stack:\n        u = stack[-1]\n        if len(adj[u]) == 0:\n            path.append(u)\n            stack.pop()\n        else:\n            v = adj[u][-1]\n            adj[u].pop()\n            adj[v] = [w for w in adj[v] if w != u]\n            stack.append(v)\n    return path\n\ndef find_rook_path(N, M, marked_squares):\n    marked = dict()\n    adj = [[] for _ in range(2 * (N + 1))]\n    root = 0\n    for (i, (row, col)) in enumerate(marked_squares, 1):\n        marked[row, col] = i\n        col = col + N\n        adj[row].append(col)\n        adj[col].append(row)\n        root = max(root, row)\n    for (node, neighbors) in enumerate(adj):\n        if len(neighbors) % 2:\n            root = node\n    path = eulerian_path(root, adj)\n    soln = []\n    for (row, col) in zip(path[:-1], path[1:]):\n        if row <= N:\n            row = row - N\n            (row, col) = (col, row)\n        else:\n            col = col - N\n        soln.append(marked[row, col])\n    return soln"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if row > N:",
      "mutated_line": "if row != N:",
      "code": "import sys\nfrom collections import deque\n\ndef eulerian_path(root, adj):\n    path = []\n    stack = [root]\n    while stack:\n        u = stack[-1]\n        if len(adj[u]) == 0:\n            path.append(u)\n            stack.pop()\n        else:\n            v = adj[u][-1]\n            adj[u].pop()\n            adj[v] = [w for w in adj[v] if w != u]\n            stack.append(v)\n    return path\n\ndef find_rook_path(N, M, marked_squares):\n    marked = dict()\n    adj = [[] for _ in range(2 * (N + 1))]\n    root = 0\n    for (i, (row, col)) in enumerate(marked_squares, 1):\n        marked[row, col] = i\n        col = col + N\n        adj[row].append(col)\n        adj[col].append(row)\n        root = max(root, row)\n    for (node, neighbors) in enumerate(adj):\n        if len(neighbors) % 2:\n            root = node\n    path = eulerian_path(root, adj)\n    soln = []\n    for (row, col) in zip(path[:-1], path[1:]):\n        if row != N:\n            row = row - N\n            (row, col) = (col, row)\n        else:\n            col = col - N\n        soln.append(marked[row, col])\n    return soln"
    },
    {
      "operator": "UOI",
      "lineno": 8,
      "original_line": "u = stack[-1]",
      "mutated_line": "u = stack[+1]",
      "code": "import sys\nfrom collections import deque\n\ndef eulerian_path(root, adj):\n    path = []\n    stack = [root]\n    while stack:\n        u = stack[+1]\n        if len(adj[u]) == 0:\n            path.append(u)\n            stack.pop()\n        else:\n            v = adj[u][-1]\n            adj[u].pop()\n            adj[v] = [w for w in adj[v] if w != u]\n            stack.append(v)\n    return path\n\ndef find_rook_path(N, M, marked_squares):\n    marked = dict()\n    adj = [[] for _ in range(2 * (N + 1))]\n    root = 0\n    for (i, (row, col)) in enumerate(marked_squares, 1):\n        marked[row, col] = i\n        col = col + N\n        adj[row].append(col)\n        adj[col].append(row)\n        root = max(root, row)\n    for (node, neighbors) in enumerate(adj):\n        if len(neighbors) % 2:\n            root = node\n    path = eulerian_path(root, adj)\n    soln = []\n    for (row, col) in zip(path[:-1], path[1:]):\n        if row > N:\n            row = row - N\n            (row, col) = (col, row)\n        else:\n            col = col - N\n        soln.append(marked[row, col])\n    return soln"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if len(adj[u]) == 0:",
      "mutated_line": "if len(adj[u]) == 1:",
      "code": "import sys\nfrom collections import deque\n\ndef eulerian_path(root, adj):\n    path = []\n    stack = [root]\n    while stack:\n        u = stack[-1]\n        if len(adj[u]) == 1:\n            path.append(u)\n            stack.pop()\n        else:\n            v = adj[u][-1]\n            adj[u].pop()\n            adj[v] = [w for w in adj[v] if w != u]\n            stack.append(v)\n    return path\n\ndef find_rook_path(N, M, marked_squares):\n    marked = dict()\n    adj = [[] for _ in range(2 * (N + 1))]\n    root = 0\n    for (i, (row, col)) in enumerate(marked_squares, 1):\n        marked[row, col] = i\n        col = col + N\n        adj[row].append(col)\n        adj[col].append(row)\n        root = max(root, row)\n    for (node, neighbors) in enumerate(adj):\n        if len(neighbors) % 2:\n            root = node\n    path = eulerian_path(root, adj)\n    soln = []\n    for (row, col) in zip(path[:-1], path[1:]):\n        if row > N:\n            row = row - N\n            (row, col) = (col, row)\n        else:\n            col = col - N\n        soln.append(marked[row, col])\n    return soln"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if len(adj[u]) == 0:",
      "mutated_line": "if len(adj[u]) == -1:",
      "code": "import sys\nfrom collections import deque\n\ndef eulerian_path(root, adj):\n    path = []\n    stack = [root]\n    while stack:\n        u = stack[-1]\n        if len(adj[u]) == -1:\n            path.append(u)\n            stack.pop()\n        else:\n            v = adj[u][-1]\n            adj[u].pop()\n            adj[v] = [w for w in adj[v] if w != u]\n            stack.append(v)\n    return path\n\ndef find_rook_path(N, M, marked_squares):\n    marked = dict()\n    adj = [[] for _ in range(2 * (N + 1))]\n    root = 0\n    for (i, (row, col)) in enumerate(marked_squares, 1):\n        marked[row, col] = i\n        col = col + N\n        adj[row].append(col)\n        adj[col].append(row)\n        root = max(root, row)\n    for (node, neighbors) in enumerate(adj):\n        if len(neighbors) % 2:\n            root = node\n    path = eulerian_path(root, adj)\n    soln = []\n    for (row, col) in zip(path[:-1], path[1:]):\n        if row > N:\n            row = row - N\n            (row, col) = (col, row)\n        else:\n            col = col - N\n        soln.append(marked[row, col])\n    return soln"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if len(adj[u]) == 0:",
      "mutated_line": "if len(adj[u]) == 1:",
      "code": "import sys\nfrom collections import deque\n\ndef eulerian_path(root, adj):\n    path = []\n    stack = [root]\n    while stack:\n        u = stack[-1]\n        if len(adj[u]) == 1:\n            path.append(u)\n            stack.pop()\n        else:\n            v = adj[u][-1]\n            adj[u].pop()\n            adj[v] = [w for w in adj[v] if w != u]\n            stack.append(v)\n    return path\n\ndef find_rook_path(N, M, marked_squares):\n    marked = dict()\n    adj = [[] for _ in range(2 * (N + 1))]\n    root = 0\n    for (i, (row, col)) in enumerate(marked_squares, 1):\n        marked[row, col] = i\n        col = col + N\n        adj[row].append(col)\n        adj[col].append(row)\n        root = max(root, row)\n    for (node, neighbors) in enumerate(adj):\n        if len(neighbors) % 2:\n            root = node\n    path = eulerian_path(root, adj)\n    soln = []\n    for (row, col) in zip(path[:-1], path[1:]):\n        if row > N:\n            row = row - N\n            (row, col) = (col, row)\n        else:\n            col = col - N\n        soln.append(marked[row, col])\n    return soln"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if len(neighbors) % 2:",
      "mutated_line": "if len(neighbors) % 3:",
      "code": "import sys\nfrom collections import deque\n\ndef eulerian_path(root, adj):\n    path = []\n    stack = [root]\n    while stack:\n        u = stack[-1]\n        if len(adj[u]) == 0:\n            path.append(u)\n            stack.pop()\n        else:\n            v = adj[u][-1]\n            adj[u].pop()\n            adj[v] = [w for w in adj[v] if w != u]\n            stack.append(v)\n    return path\n\ndef find_rook_path(N, M, marked_squares):\n    marked = dict()\n    adj = [[] for _ in range(2 * (N + 1))]\n    root = 0\n    for (i, (row, col)) in enumerate(marked_squares, 1):\n        marked[row, col] = i\n        col = col + N\n        adj[row].append(col)\n        adj[col].append(row)\n        root = max(root, row)\n    for (node, neighbors) in enumerate(adj):\n        if len(neighbors) % 3:\n            root = node\n    path = eulerian_path(root, adj)\n    soln = []\n    for (row, col) in zip(path[:-1], path[1:]):\n        if row > N:\n            row = row - N\n            (row, col) = (col, row)\n        else:\n            col = col - N\n        soln.append(marked[row, col])\n    return soln"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if len(neighbors) % 2:",
      "mutated_line": "if len(neighbors) % 1:",
      "code": "import sys\nfrom collections import deque\n\ndef eulerian_path(root, adj):\n    path = []\n    stack = [root]\n    while stack:\n        u = stack[-1]\n        if len(adj[u]) == 0:\n            path.append(u)\n            stack.pop()\n        else:\n            v = adj[u][-1]\n            adj[u].pop()\n            adj[v] = [w for w in adj[v] if w != u]\n            stack.append(v)\n    return path\n\ndef find_rook_path(N, M, marked_squares):\n    marked = dict()\n    adj = [[] for _ in range(2 * (N + 1))]\n    root = 0\n    for (i, (row, col)) in enumerate(marked_squares, 1):\n        marked[row, col] = i\n        col = col + N\n        adj[row].append(col)\n        adj[col].append(row)\n        root = max(root, row)\n    for (node, neighbors) in enumerate(adj):\n        if len(neighbors) % 1:\n            root = node\n    path = eulerian_path(root, adj)\n    soln = []\n    for (row, col) in zip(path[:-1], path[1:]):\n        if row > N:\n            row = row - N\n            (row, col) = (col, row)\n        else:\n            col = col - N\n        soln.append(marked[row, col])\n    return soln"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if len(neighbors) % 2:",
      "mutated_line": "if len(neighbors) % 0:",
      "code": "import sys\nfrom collections import deque\n\ndef eulerian_path(root, adj):\n    path = []\n    stack = [root]\n    while stack:\n        u = stack[-1]\n        if len(adj[u]) == 0:\n            path.append(u)\n            stack.pop()\n        else:\n            v = adj[u][-1]\n            adj[u].pop()\n            adj[v] = [w for w in adj[v] if w != u]\n            stack.append(v)\n    return path\n\ndef find_rook_path(N, M, marked_squares):\n    marked = dict()\n    adj = [[] for _ in range(2 * (N + 1))]\n    root = 0\n    for (i, (row, col)) in enumerate(marked_squares, 1):\n        marked[row, col] = i\n        col = col + N\n        adj[row].append(col)\n        adj[col].append(row)\n        root = max(root, row)\n    for (node, neighbors) in enumerate(adj):\n        if len(neighbors) % 0:\n            root = node\n    path = eulerian_path(root, adj)\n    soln = []\n    for (row, col) in zip(path[:-1], path[1:]):\n        if row > N:\n            row = row - N\n            (row, col) = (col, row)\n        else:\n            col = col - N\n        soln.append(marked[row, col])\n    return soln"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if len(neighbors) % 2:",
      "mutated_line": "if len(neighbors) % 1:",
      "code": "import sys\nfrom collections import deque\n\ndef eulerian_path(root, adj):\n    path = []\n    stack = [root]\n    while stack:\n        u = stack[-1]\n        if len(adj[u]) == 0:\n            path.append(u)\n            stack.pop()\n        else:\n            v = adj[u][-1]\n            adj[u].pop()\n            adj[v] = [w for w in adj[v] if w != u]\n            stack.append(v)\n    return path\n\ndef find_rook_path(N, M, marked_squares):\n    marked = dict()\n    adj = [[] for _ in range(2 * (N + 1))]\n    root = 0\n    for (i, (row, col)) in enumerate(marked_squares, 1):\n        marked[row, col] = i\n        col = col + N\n        adj[row].append(col)\n        adj[col].append(row)\n        root = max(root, row)\n    for (node, neighbors) in enumerate(adj):\n        if len(neighbors) % 1:\n            root = node\n    path = eulerian_path(root, adj)\n    soln = []\n    for (row, col) in zip(path[:-1], path[1:]):\n        if row > N:\n            row = row - N\n            (row, col) = (col, row)\n        else:\n            col = col - N\n        soln.append(marked[row, col])\n    return soln"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if len(neighbors) % 2:",
      "mutated_line": "if len(neighbors) % -2:",
      "code": "import sys\nfrom collections import deque\n\ndef eulerian_path(root, adj):\n    path = []\n    stack = [root]\n    while stack:\n        u = stack[-1]\n        if len(adj[u]) == 0:\n            path.append(u)\n            stack.pop()\n        else:\n            v = adj[u][-1]\n            adj[u].pop()\n            adj[v] = [w for w in adj[v] if w != u]\n            stack.append(v)\n    return path\n\ndef find_rook_path(N, M, marked_squares):\n    marked = dict()\n    adj = [[] for _ in range(2 * (N + 1))]\n    root = 0\n    for (i, (row, col)) in enumerate(marked_squares, 1):\n        marked[row, col] = i\n        col = col + N\n        adj[row].append(col)\n        adj[col].append(row)\n        root = max(root, row)\n    for (node, neighbors) in enumerate(adj):\n        if len(neighbors) % -2:\n            root = node\n    path = eulerian_path(root, adj)\n    soln = []\n    for (row, col) in zip(path[:-1], path[1:]):\n        if row > N:\n            row = row - N\n            (row, col) = (col, row)\n        else:\n            col = col - N\n        soln.append(marked[row, col])\n    return soln"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "row = row - N",
      "mutated_line": "row = row + N",
      "code": "import sys\nfrom collections import deque\n\ndef eulerian_path(root, adj):\n    path = []\n    stack = [root]\n    while stack:\n        u = stack[-1]\n        if len(adj[u]) == 0:\n            path.append(u)\n            stack.pop()\n        else:\n            v = adj[u][-1]\n            adj[u].pop()\n            adj[v] = [w for w in adj[v] if w != u]\n            stack.append(v)\n    return path\n\ndef find_rook_path(N, M, marked_squares):\n    marked = dict()\n    adj = [[] for _ in range(2 * (N + 1))]\n    root = 0\n    for (i, (row, col)) in enumerate(marked_squares, 1):\n        marked[row, col] = i\n        col = col + N\n        adj[row].append(col)\n        adj[col].append(row)\n        root = max(root, row)\n    for (node, neighbors) in enumerate(adj):\n        if len(neighbors) % 2:\n            root = node\n    path = eulerian_path(root, adj)\n    soln = []\n    for (row, col) in zip(path[:-1], path[1:]):\n        if row > N:\n            row = row + N\n            (row, col) = (col, row)\n        else:\n            col = col - N\n        soln.append(marked[row, col])\n    return soln"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "row = row - N",
      "mutated_line": "row = row * N",
      "code": "import sys\nfrom collections import deque\n\ndef eulerian_path(root, adj):\n    path = []\n    stack = [root]\n    while stack:\n        u = stack[-1]\n        if len(adj[u]) == 0:\n            path.append(u)\n            stack.pop()\n        else:\n            v = adj[u][-1]\n            adj[u].pop()\n            adj[v] = [w for w in adj[v] if w != u]\n            stack.append(v)\n    return path\n\ndef find_rook_path(N, M, marked_squares):\n    marked = dict()\n    adj = [[] for _ in range(2 * (N + 1))]\n    root = 0\n    for (i, (row, col)) in enumerate(marked_squares, 1):\n        marked[row, col] = i\n        col = col + N\n        adj[row].append(col)\n        adj[col].append(row)\n        root = max(root, row)\n    for (node, neighbors) in enumerate(adj):\n        if len(neighbors) % 2:\n            root = node\n    path = eulerian_path(root, adj)\n    soln = []\n    for (row, col) in zip(path[:-1], path[1:]):\n        if row > N:\n            row = row * N\n            (row, col) = (col, row)\n        else:\n            col = col - N\n        soln.append(marked[row, col])\n    return soln"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "col = col - N",
      "mutated_line": "col = col + N",
      "code": "import sys\nfrom collections import deque\n\ndef eulerian_path(root, adj):\n    path = []\n    stack = [root]\n    while stack:\n        u = stack[-1]\n        if len(adj[u]) == 0:\n            path.append(u)\n            stack.pop()\n        else:\n            v = adj[u][-1]\n            adj[u].pop()\n            adj[v] = [w for w in adj[v] if w != u]\n            stack.append(v)\n    return path\n\ndef find_rook_path(N, M, marked_squares):\n    marked = dict()\n    adj = [[] for _ in range(2 * (N + 1))]\n    root = 0\n    for (i, (row, col)) in enumerate(marked_squares, 1):\n        marked[row, col] = i\n        col = col + N\n        adj[row].append(col)\n        adj[col].append(row)\n        root = max(root, row)\n    for (node, neighbors) in enumerate(adj):\n        if len(neighbors) % 2:\n            root = node\n    path = eulerian_path(root, adj)\n    soln = []\n    for (row, col) in zip(path[:-1], path[1:]):\n        if row > N:\n            row = row - N\n            (row, col) = (col, row)\n        else:\n            col = col + N\n        soln.append(marked[row, col])\n    return soln"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "col = col - N",
      "mutated_line": "col = col * N",
      "code": "import sys\nfrom collections import deque\n\ndef eulerian_path(root, adj):\n    path = []\n    stack = [root]\n    while stack:\n        u = stack[-1]\n        if len(adj[u]) == 0:\n            path.append(u)\n            stack.pop()\n        else:\n            v = adj[u][-1]\n            adj[u].pop()\n            adj[v] = [w for w in adj[v] if w != u]\n            stack.append(v)\n    return path\n\ndef find_rook_path(N, M, marked_squares):\n    marked = dict()\n    adj = [[] for _ in range(2 * (N + 1))]\n    root = 0\n    for (i, (row, col)) in enumerate(marked_squares, 1):\n        marked[row, col] = i\n        col = col + N\n        adj[row].append(col)\n        adj[col].append(row)\n        root = max(root, row)\n    for (node, neighbors) in enumerate(adj):\n        if len(neighbors) % 2:\n            root = node\n    path = eulerian_path(root, adj)\n    soln = []\n    for (row, col) in zip(path[:-1], path[1:]):\n        if row > N:\n            row = row - N\n            (row, col) = (col, row)\n        else:\n            col = col * N\n        soln.append(marked[row, col])\n    return soln"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "u = stack[-1]",
      "mutated_line": "u = stack[-2]",
      "code": "import sys\nfrom collections import deque\n\ndef eulerian_path(root, adj):\n    path = []\n    stack = [root]\n    while stack:\n        u = stack[-2]\n        if len(adj[u]) == 0:\n            path.append(u)\n            stack.pop()\n        else:\n            v = adj[u][-1]\n            adj[u].pop()\n            adj[v] = [w for w in adj[v] if w != u]\n            stack.append(v)\n    return path\n\ndef find_rook_path(N, M, marked_squares):\n    marked = dict()\n    adj = [[] for _ in range(2 * (N + 1))]\n    root = 0\n    for (i, (row, col)) in enumerate(marked_squares, 1):\n        marked[row, col] = i\n        col = col + N\n        adj[row].append(col)\n        adj[col].append(row)\n        root = max(root, row)\n    for (node, neighbors) in enumerate(adj):\n        if len(neighbors) % 2:\n            root = node\n    path = eulerian_path(root, adj)\n    soln = []\n    for (row, col) in zip(path[:-1], path[1:]):\n        if row > N:\n            row = row - N\n            (row, col) = (col, row)\n        else:\n            col = col - N\n        soln.append(marked[row, col])\n    return soln"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "u = stack[-1]",
      "mutated_line": "u = stack[-0]",
      "code": "import sys\nfrom collections import deque\n\ndef eulerian_path(root, adj):\n    path = []\n    stack = [root]\n    while stack:\n        u = stack[-0]\n        if len(adj[u]) == 0:\n            path.append(u)\n            stack.pop()\n        else:\n            v = adj[u][-1]\n            adj[u].pop()\n            adj[v] = [w for w in adj[v] if w != u]\n            stack.append(v)\n    return path\n\ndef find_rook_path(N, M, marked_squares):\n    marked = dict()\n    adj = [[] for _ in range(2 * (N + 1))]\n    root = 0\n    for (i, (row, col)) in enumerate(marked_squares, 1):\n        marked[row, col] = i\n        col = col + N\n        adj[row].append(col)\n        adj[col].append(row)\n        root = max(root, row)\n    for (node, neighbors) in enumerate(adj):\n        if len(neighbors) % 2:\n            root = node\n    path = eulerian_path(root, adj)\n    soln = []\n    for (row, col) in zip(path[:-1], path[1:]):\n        if row > N:\n            row = row - N\n            (row, col) = (col, row)\n        else:\n            col = col - N\n        soln.append(marked[row, col])\n    return soln"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "u = stack[-1]",
      "mutated_line": "u = stack[-0]",
      "code": "import sys\nfrom collections import deque\n\ndef eulerian_path(root, adj):\n    path = []\n    stack = [root]\n    while stack:\n        u = stack[-0]\n        if len(adj[u]) == 0:\n            path.append(u)\n            stack.pop()\n        else:\n            v = adj[u][-1]\n            adj[u].pop()\n            adj[v] = [w for w in adj[v] if w != u]\n            stack.append(v)\n    return path\n\ndef find_rook_path(N, M, marked_squares):\n    marked = dict()\n    adj = [[] for _ in range(2 * (N + 1))]\n    root = 0\n    for (i, (row, col)) in enumerate(marked_squares, 1):\n        marked[row, col] = i\n        col = col + N\n        adj[row].append(col)\n        adj[col].append(row)\n        root = max(root, row)\n    for (node, neighbors) in enumerate(adj):\n        if len(neighbors) % 2:\n            root = node\n    path = eulerian_path(root, adj)\n    soln = []\n    for (row, col) in zip(path[:-1], path[1:]):\n        if row > N:\n            row = row - N\n            (row, col) = (col, row)\n        else:\n            col = col - N\n        soln.append(marked[row, col])\n    return soln"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "u = stack[-1]",
      "mutated_line": "u = stack[--1]",
      "code": "import sys\nfrom collections import deque\n\ndef eulerian_path(root, adj):\n    path = []\n    stack = [root]\n    while stack:\n        u = stack[--1]\n        if len(adj[u]) == 0:\n            path.append(u)\n            stack.pop()\n        else:\n            v = adj[u][-1]\n            adj[u].pop()\n            adj[v] = [w for w in adj[v] if w != u]\n            stack.append(v)\n    return path\n\ndef find_rook_path(N, M, marked_squares):\n    marked = dict()\n    adj = [[] for _ in range(2 * (N + 1))]\n    root = 0\n    for (i, (row, col)) in enumerate(marked_squares, 1):\n        marked[row, col] = i\n        col = col + N\n        adj[row].append(col)\n        adj[col].append(row)\n        root = max(root, row)\n    for (node, neighbors) in enumerate(adj):\n        if len(neighbors) % 2:\n            root = node\n    path = eulerian_path(root, adj)\n    soln = []\n    for (row, col) in zip(path[:-1], path[1:]):\n        if row > N:\n            row = row - N\n            (row, col) = (col, row)\n        else:\n            col = col - N\n        soln.append(marked[row, col])\n    return soln"
    },
    {
      "operator": "UOI",
      "lineno": 13,
      "original_line": "v = adj[u][-1]",
      "mutated_line": "v = adj[u][+1]",
      "code": "import sys\nfrom collections import deque\n\ndef eulerian_path(root, adj):\n    path = []\n    stack = [root]\n    while stack:\n        u = stack[-1]\n        if len(adj[u]) == 0:\n            path.append(u)\n            stack.pop()\n        else:\n            v = adj[u][+1]\n            adj[u].pop()\n            adj[v] = [w for w in adj[v] if w != u]\n            stack.append(v)\n    return path\n\ndef find_rook_path(N, M, marked_squares):\n    marked = dict()\n    adj = [[] for _ in range(2 * (N + 1))]\n    root = 0\n    for (i, (row, col)) in enumerate(marked_squares, 1):\n        marked[row, col] = i\n        col = col + N\n        adj[row].append(col)\n        adj[col].append(row)\n        root = max(root, row)\n    for (node, neighbors) in enumerate(adj):\n        if len(neighbors) % 2:\n            root = node\n    path = eulerian_path(root, adj)\n    soln = []\n    for (row, col) in zip(path[:-1], path[1:]):\n        if row > N:\n            row = row - N\n            (row, col) = (col, row)\n        else:\n            col = col - N\n        soln.append(marked[row, col])\n    return soln"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "adj = [[] for _ in range(2 * (N + 1))]",
      "mutated_line": "adj = [[] for _ in range(2 / (N + 1))]",
      "code": "import sys\nfrom collections import deque\n\ndef eulerian_path(root, adj):\n    path = []\n    stack = [root]\n    while stack:\n        u = stack[-1]\n        if len(adj[u]) == 0:\n            path.append(u)\n            stack.pop()\n        else:\n            v = adj[u][-1]\n            adj[u].pop()\n            adj[v] = [w for w in adj[v] if w != u]\n            stack.append(v)\n    return path\n\ndef find_rook_path(N, M, marked_squares):\n    marked = dict()\n    adj = [[] for _ in range(2 / (N + 1))]\n    root = 0\n    for (i, (row, col)) in enumerate(marked_squares, 1):\n        marked[row, col] = i\n        col = col + N\n        adj[row].append(col)\n        adj[col].append(row)\n        root = max(root, row)\n    for (node, neighbors) in enumerate(adj):\n        if len(neighbors) % 2:\n            root = node\n    path = eulerian_path(root, adj)\n    soln = []\n    for (row, col) in zip(path[:-1], path[1:]):\n        if row > N:\n            row = row - N\n            (row, col) = (col, row)\n        else:\n            col = col - N\n        soln.append(marked[row, col])\n    return soln"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "adj = [[] for _ in range(2 * (N + 1))]",
      "mutated_line": "adj = [[] for _ in range(2 + (N + 1))]",
      "code": "import sys\nfrom collections import deque\n\ndef eulerian_path(root, adj):\n    path = []\n    stack = [root]\n    while stack:\n        u = stack[-1]\n        if len(adj[u]) == 0:\n            path.append(u)\n            stack.pop()\n        else:\n            v = adj[u][-1]\n            adj[u].pop()\n            adj[v] = [w for w in adj[v] if w != u]\n            stack.append(v)\n    return path\n\ndef find_rook_path(N, M, marked_squares):\n    marked = dict()\n    adj = [[] for _ in range(2 + (N + 1))]\n    root = 0\n    for (i, (row, col)) in enumerate(marked_squares, 1):\n        marked[row, col] = i\n        col = col + N\n        adj[row].append(col)\n        adj[col].append(row)\n        root = max(root, row)\n    for (node, neighbors) in enumerate(adj):\n        if len(neighbors) % 2:\n            root = node\n    path = eulerian_path(root, adj)\n    soln = []\n    for (row, col) in zip(path[:-1], path[1:]):\n        if row > N:\n            row = row - N\n            (row, col) = (col, row)\n        else:\n            col = col - N\n        soln.append(marked[row, col])\n    return soln"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "adj = [[] for _ in range(2 * (N + 1))]",
      "mutated_line": "adj = [[] for _ in range(2 ** (N + 1))]",
      "code": "import sys\nfrom collections import deque\n\ndef eulerian_path(root, adj):\n    path = []\n    stack = [root]\n    while stack:\n        u = stack[-1]\n        if len(adj[u]) == 0:\n            path.append(u)\n            stack.pop()\n        else:\n            v = adj[u][-1]\n            adj[u].pop()\n            adj[v] = [w for w in adj[v] if w != u]\n            stack.append(v)\n    return path\n\ndef find_rook_path(N, M, marked_squares):\n    marked = dict()\n    adj = [[] for _ in range(2 ** (N + 1))]\n    root = 0\n    for (i, (row, col)) in enumerate(marked_squares, 1):\n        marked[row, col] = i\n        col = col + N\n        adj[row].append(col)\n        adj[col].append(row)\n        root = max(root, row)\n    for (node, neighbors) in enumerate(adj):\n        if len(neighbors) % 2:\n            root = node\n    path = eulerian_path(root, adj)\n    soln = []\n    for (row, col) in zip(path[:-1], path[1:]):\n        if row > N:\n            row = row - N\n            (row, col) = (col, row)\n        else:\n            col = col - N\n        soln.append(marked[row, col])\n    return soln"
    },
    {
      "operator": "UOI",
      "lineno": 38,
      "original_line": "for row, col in zip(path[:-1], path[1:]):",
      "mutated_line": "for (row, col) in zip(path[:+1], path[1:]):",
      "code": "import sys\nfrom collections import deque\n\ndef eulerian_path(root, adj):\n    path = []\n    stack = [root]\n    while stack:\n        u = stack[-1]\n        if len(adj[u]) == 0:\n            path.append(u)\n            stack.pop()\n        else:\n            v = adj[u][-1]\n            adj[u].pop()\n            adj[v] = [w for w in adj[v] if w != u]\n            stack.append(v)\n    return path\n\ndef find_rook_path(N, M, marked_squares):\n    marked = dict()\n    adj = [[] for _ in range(2 * (N + 1))]\n    root = 0\n    for (i, (row, col)) in enumerate(marked_squares, 1):\n        marked[row, col] = i\n        col = col + N\n        adj[row].append(col)\n        adj[col].append(row)\n        root = max(root, row)\n    for (node, neighbors) in enumerate(adj):\n        if len(neighbors) % 2:\n            root = node\n    path = eulerian_path(root, adj)\n    soln = []\n    for (row, col) in zip(path[:+1], path[1:]):\n        if row > N:\n            row = row - N\n            (row, col) = (col, row)\n        else:\n            col = col - N\n        soln.append(marked[row, col])\n    return soln"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for row, col in zip(path[:-1], path[1:]):",
      "mutated_line": "for (row, col) in zip(path[:-1], path[2:]):",
      "code": "import sys\nfrom collections import deque\n\ndef eulerian_path(root, adj):\n    path = []\n    stack = [root]\n    while stack:\n        u = stack[-1]\n        if len(adj[u]) == 0:\n            path.append(u)\n            stack.pop()\n        else:\n            v = adj[u][-1]\n            adj[u].pop()\n            adj[v] = [w for w in adj[v] if w != u]\n            stack.append(v)\n    return path\n\ndef find_rook_path(N, M, marked_squares):\n    marked = dict()\n    adj = [[] for _ in range(2 * (N + 1))]\n    root = 0\n    for (i, (row, col)) in enumerate(marked_squares, 1):\n        marked[row, col] = i\n        col = col + N\n        adj[row].append(col)\n        adj[col].append(row)\n        root = max(root, row)\n    for (node, neighbors) in enumerate(adj):\n        if len(neighbors) % 2:\n            root = node\n    path = eulerian_path(root, adj)\n    soln = []\n    for (row, col) in zip(path[:-1], path[2:]):\n        if row > N:\n            row = row - N\n            (row, col) = (col, row)\n        else:\n            col = col - N\n        soln.append(marked[row, col])\n    return soln"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for row, col in zip(path[:-1], path[1:]):",
      "mutated_line": "for (row, col) in zip(path[:-1], path[0:]):",
      "code": "import sys\nfrom collections import deque\n\ndef eulerian_path(root, adj):\n    path = []\n    stack = [root]\n    while stack:\n        u = stack[-1]\n        if len(adj[u]) == 0:\n            path.append(u)\n            stack.pop()\n        else:\n            v = adj[u][-1]\n            adj[u].pop()\n            adj[v] = [w for w in adj[v] if w != u]\n            stack.append(v)\n    return path\n\ndef find_rook_path(N, M, marked_squares):\n    marked = dict()\n    adj = [[] for _ in range(2 * (N + 1))]\n    root = 0\n    for (i, (row, col)) in enumerate(marked_squares, 1):\n        marked[row, col] = i\n        col = col + N\n        adj[row].append(col)\n        adj[col].append(row)\n        root = max(root, row)\n    for (node, neighbors) in enumerate(adj):\n        if len(neighbors) % 2:\n            root = node\n    path = eulerian_path(root, adj)\n    soln = []\n    for (row, col) in zip(path[:-1], path[0:]):\n        if row > N:\n            row = row - N\n            (row, col) = (col, row)\n        else:\n            col = col - N\n        soln.append(marked[row, col])\n    return soln"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for row, col in zip(path[:-1], path[1:]):",
      "mutated_line": "for (row, col) in zip(path[:-1], path[0:]):",
      "code": "import sys\nfrom collections import deque\n\ndef eulerian_path(root, adj):\n    path = []\n    stack = [root]\n    while stack:\n        u = stack[-1]\n        if len(adj[u]) == 0:\n            path.append(u)\n            stack.pop()\n        else:\n            v = adj[u][-1]\n            adj[u].pop()\n            adj[v] = [w for w in adj[v] if w != u]\n            stack.append(v)\n    return path\n\ndef find_rook_path(N, M, marked_squares):\n    marked = dict()\n    adj = [[] for _ in range(2 * (N + 1))]\n    root = 0\n    for (i, (row, col)) in enumerate(marked_squares, 1):\n        marked[row, col] = i\n        col = col + N\n        adj[row].append(col)\n        adj[col].append(row)\n        root = max(root, row)\n    for (node, neighbors) in enumerate(adj):\n        if len(neighbors) % 2:\n            root = node\n    path = eulerian_path(root, adj)\n    soln = []\n    for (row, col) in zip(path[:-1], path[0:]):\n        if row > N:\n            row = row - N\n            (row, col) = (col, row)\n        else:\n            col = col - N\n        soln.append(marked[row, col])\n    return soln"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for row, col in zip(path[:-1], path[1:]):",
      "mutated_line": "for (row, col) in zip(path[:-1], path[-1:]):",
      "code": "import sys\nfrom collections import deque\n\ndef eulerian_path(root, adj):\n    path = []\n    stack = [root]\n    while stack:\n        u = stack[-1]\n        if len(adj[u]) == 0:\n            path.append(u)\n            stack.pop()\n        else:\n            v = adj[u][-1]\n            adj[u].pop()\n            adj[v] = [w for w in adj[v] if w != u]\n            stack.append(v)\n    return path\n\ndef find_rook_path(N, M, marked_squares):\n    marked = dict()\n    adj = [[] for _ in range(2 * (N + 1))]\n    root = 0\n    for (i, (row, col)) in enumerate(marked_squares, 1):\n        marked[row, col] = i\n        col = col + N\n        adj[row].append(col)\n        adj[col].append(row)\n        root = max(root, row)\n    for (node, neighbors) in enumerate(adj):\n        if len(neighbors) % 2:\n            root = node\n    path = eulerian_path(root, adj)\n    soln = []\n    for (row, col) in zip(path[:-1], path[-1:]):\n        if row > N:\n            row = row - N\n            (row, col) = (col, row)\n        else:\n            col = col - N\n        soln.append(marked[row, col])\n    return soln"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "v = adj[u][-1]",
      "mutated_line": "v = adj[u][-2]",
      "code": "import sys\nfrom collections import deque\n\ndef eulerian_path(root, adj):\n    path = []\n    stack = [root]\n    while stack:\n        u = stack[-1]\n        if len(adj[u]) == 0:\n            path.append(u)\n            stack.pop()\n        else:\n            v = adj[u][-2]\n            adj[u].pop()\n            adj[v] = [w for w in adj[v] if w != u]\n            stack.append(v)\n    return path\n\ndef find_rook_path(N, M, marked_squares):\n    marked = dict()\n    adj = [[] for _ in range(2 * (N + 1))]\n    root = 0\n    for (i, (row, col)) in enumerate(marked_squares, 1):\n        marked[row, col] = i\n        col = col + N\n        adj[row].append(col)\n        adj[col].append(row)\n        root = max(root, row)\n    for (node, neighbors) in enumerate(adj):\n        if len(neighbors) % 2:\n            root = node\n    path = eulerian_path(root, adj)\n    soln = []\n    for (row, col) in zip(path[:-1], path[1:]):\n        if row > N:\n            row = row - N\n            (row, col) = (col, row)\n        else:\n            col = col - N\n        soln.append(marked[row, col])\n    return soln"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "v = adj[u][-1]",
      "mutated_line": "v = adj[u][-0]",
      "code": "import sys\nfrom collections import deque\n\ndef eulerian_path(root, adj):\n    path = []\n    stack = [root]\n    while stack:\n        u = stack[-1]\n        if len(adj[u]) == 0:\n            path.append(u)\n            stack.pop()\n        else:\n            v = adj[u][-0]\n            adj[u].pop()\n            adj[v] = [w for w in adj[v] if w != u]\n            stack.append(v)\n    return path\n\ndef find_rook_path(N, M, marked_squares):\n    marked = dict()\n    adj = [[] for _ in range(2 * (N + 1))]\n    root = 0\n    for (i, (row, col)) in enumerate(marked_squares, 1):\n        marked[row, col] = i\n        col = col + N\n        adj[row].append(col)\n        adj[col].append(row)\n        root = max(root, row)\n    for (node, neighbors) in enumerate(adj):\n        if len(neighbors) % 2:\n            root = node\n    path = eulerian_path(root, adj)\n    soln = []\n    for (row, col) in zip(path[:-1], path[1:]):\n        if row > N:\n            row = row - N\n            (row, col) = (col, row)\n        else:\n            col = col - N\n        soln.append(marked[row, col])\n    return soln"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "v = adj[u][-1]",
      "mutated_line": "v = adj[u][-0]",
      "code": "import sys\nfrom collections import deque\n\ndef eulerian_path(root, adj):\n    path = []\n    stack = [root]\n    while stack:\n        u = stack[-1]\n        if len(adj[u]) == 0:\n            path.append(u)\n            stack.pop()\n        else:\n            v = adj[u][-0]\n            adj[u].pop()\n            adj[v] = [w for w in adj[v] if w != u]\n            stack.append(v)\n    return path\n\ndef find_rook_path(N, M, marked_squares):\n    marked = dict()\n    adj = [[] for _ in range(2 * (N + 1))]\n    root = 0\n    for (i, (row, col)) in enumerate(marked_squares, 1):\n        marked[row, col] = i\n        col = col + N\n        adj[row].append(col)\n        adj[col].append(row)\n        root = max(root, row)\n    for (node, neighbors) in enumerate(adj):\n        if len(neighbors) % 2:\n            root = node\n    path = eulerian_path(root, adj)\n    soln = []\n    for (row, col) in zip(path[:-1], path[1:]):\n        if row > N:\n            row = row - N\n            (row, col) = (col, row)\n        else:\n            col = col - N\n        soln.append(marked[row, col])\n    return soln"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "v = adj[u][-1]",
      "mutated_line": "v = adj[u][--1]",
      "code": "import sys\nfrom collections import deque\n\ndef eulerian_path(root, adj):\n    path = []\n    stack = [root]\n    while stack:\n        u = stack[-1]\n        if len(adj[u]) == 0:\n            path.append(u)\n            stack.pop()\n        else:\n            v = adj[u][--1]\n            adj[u].pop()\n            adj[v] = [w for w in adj[v] if w != u]\n            stack.append(v)\n    return path\n\ndef find_rook_path(N, M, marked_squares):\n    marked = dict()\n    adj = [[] for _ in range(2 * (N + 1))]\n    root = 0\n    for (i, (row, col)) in enumerate(marked_squares, 1):\n        marked[row, col] = i\n        col = col + N\n        adj[row].append(col)\n        adj[col].append(row)\n        root = max(root, row)\n    for (node, neighbors) in enumerate(adj):\n        if len(neighbors) % 2:\n            root = node\n    path = eulerian_path(root, adj)\n    soln = []\n    for (row, col) in zip(path[:-1], path[1:]):\n        if row > N:\n            row = row - N\n            (row, col) = (col, row)\n        else:\n            col = col - N\n        soln.append(marked[row, col])\n    return soln"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "adj[v] = [w for w in adj[v] if w != u]",
      "mutated_line": "adj[v] = [w for w in adj[v] if w == u]",
      "code": "import sys\nfrom collections import deque\n\ndef eulerian_path(root, adj):\n    path = []\n    stack = [root]\n    while stack:\n        u = stack[-1]\n        if len(adj[u]) == 0:\n            path.append(u)\n            stack.pop()\n        else:\n            v = adj[u][-1]\n            adj[u].pop()\n            adj[v] = [w for w in adj[v] if w == u]\n            stack.append(v)\n    return path\n\ndef find_rook_path(N, M, marked_squares):\n    marked = dict()\n    adj = [[] for _ in range(2 * (N + 1))]\n    root = 0\n    for (i, (row, col)) in enumerate(marked_squares, 1):\n        marked[row, col] = i\n        col = col + N\n        adj[row].append(col)\n        adj[col].append(row)\n        root = max(root, row)\n    for (node, neighbors) in enumerate(adj):\n        if len(neighbors) % 2:\n            root = node\n    path = eulerian_path(root, adj)\n    soln = []\n    for (row, col) in zip(path[:-1], path[1:]):\n        if row > N:\n            row = row - N\n            (row, col) = (col, row)\n        else:\n            col = col - N\n        soln.append(marked[row, col])\n    return soln"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "adj = [[] for _ in range(2 * (N + 1))]",
      "mutated_line": "adj = [[] for _ in range(3 * (N + 1))]",
      "code": "import sys\nfrom collections import deque\n\ndef eulerian_path(root, adj):\n    path = []\n    stack = [root]\n    while stack:\n        u = stack[-1]\n        if len(adj[u]) == 0:\n            path.append(u)\n            stack.pop()\n        else:\n            v = adj[u][-1]\n            adj[u].pop()\n            adj[v] = [w for w in adj[v] if w != u]\n            stack.append(v)\n    return path\n\ndef find_rook_path(N, M, marked_squares):\n    marked = dict()\n    adj = [[] for _ in range(3 * (N + 1))]\n    root = 0\n    for (i, (row, col)) in enumerate(marked_squares, 1):\n        marked[row, col] = i\n        col = col + N\n        adj[row].append(col)\n        adj[col].append(row)\n        root = max(root, row)\n    for (node, neighbors) in enumerate(adj):\n        if len(neighbors) % 2:\n            root = node\n    path = eulerian_path(root, adj)\n    soln = []\n    for (row, col) in zip(path[:-1], path[1:]):\n        if row > N:\n            row = row - N\n            (row, col) = (col, row)\n        else:\n            col = col - N\n        soln.append(marked[row, col])\n    return soln"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "adj = [[] for _ in range(2 * (N + 1))]",
      "mutated_line": "adj = [[] for _ in range(1 * (N + 1))]",
      "code": "import sys\nfrom collections import deque\n\ndef eulerian_path(root, adj):\n    path = []\n    stack = [root]\n    while stack:\n        u = stack[-1]\n        if len(adj[u]) == 0:\n            path.append(u)\n            stack.pop()\n        else:\n            v = adj[u][-1]\n            adj[u].pop()\n            adj[v] = [w for w in adj[v] if w != u]\n            stack.append(v)\n    return path\n\ndef find_rook_path(N, M, marked_squares):\n    marked = dict()\n    adj = [[] for _ in range(1 * (N + 1))]\n    root = 0\n    for (i, (row, col)) in enumerate(marked_squares, 1):\n        marked[row, col] = i\n        col = col + N\n        adj[row].append(col)\n        adj[col].append(row)\n        root = max(root, row)\n    for (node, neighbors) in enumerate(adj):\n        if len(neighbors) % 2:\n            root = node\n    path = eulerian_path(root, adj)\n    soln = []\n    for (row, col) in zip(path[:-1], path[1:]):\n        if row > N:\n            row = row - N\n            (row, col) = (col, row)\n        else:\n            col = col - N\n        soln.append(marked[row, col])\n    return soln"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "adj = [[] for _ in range(2 * (N + 1))]",
      "mutated_line": "adj = [[] for _ in range(0 * (N + 1))]",
      "code": "import sys\nfrom collections import deque\n\ndef eulerian_path(root, adj):\n    path = []\n    stack = [root]\n    while stack:\n        u = stack[-1]\n        if len(adj[u]) == 0:\n            path.append(u)\n            stack.pop()\n        else:\n            v = adj[u][-1]\n            adj[u].pop()\n            adj[v] = [w for w in adj[v] if w != u]\n            stack.append(v)\n    return path\n\ndef find_rook_path(N, M, marked_squares):\n    marked = dict()\n    adj = [[] for _ in range(0 * (N + 1))]\n    root = 0\n    for (i, (row, col)) in enumerate(marked_squares, 1):\n        marked[row, col] = i\n        col = col + N\n        adj[row].append(col)\n        adj[col].append(row)\n        root = max(root, row)\n    for (node, neighbors) in enumerate(adj):\n        if len(neighbors) % 2:\n            root = node\n    path = eulerian_path(root, adj)\n    soln = []\n    for (row, col) in zip(path[:-1], path[1:]):\n        if row > N:\n            row = row - N\n            (row, col) = (col, row)\n        else:\n            col = col - N\n        soln.append(marked[row, col])\n    return soln"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "adj = [[] for _ in range(2 * (N + 1))]",
      "mutated_line": "adj = [[] for _ in range(1 * (N + 1))]",
      "code": "import sys\nfrom collections import deque\n\ndef eulerian_path(root, adj):\n    path = []\n    stack = [root]\n    while stack:\n        u = stack[-1]\n        if len(adj[u]) == 0:\n            path.append(u)\n            stack.pop()\n        else:\n            v = adj[u][-1]\n            adj[u].pop()\n            adj[v] = [w for w in adj[v] if w != u]\n            stack.append(v)\n    return path\n\ndef find_rook_path(N, M, marked_squares):\n    marked = dict()\n    adj = [[] for _ in range(1 * (N + 1))]\n    root = 0\n    for (i, (row, col)) in enumerate(marked_squares, 1):\n        marked[row, col] = i\n        col = col + N\n        adj[row].append(col)\n        adj[col].append(row)\n        root = max(root, row)\n    for (node, neighbors) in enumerate(adj):\n        if len(neighbors) % 2:\n            root = node\n    path = eulerian_path(root, adj)\n    soln = []\n    for (row, col) in zip(path[:-1], path[1:]):\n        if row > N:\n            row = row - N\n            (row, col) = (col, row)\n        else:\n            col = col - N\n        soln.append(marked[row, col])\n    return soln"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "adj = [[] for _ in range(2 * (N + 1))]",
      "mutated_line": "adj = [[] for _ in range(-2 * (N + 1))]",
      "code": "import sys\nfrom collections import deque\n\ndef eulerian_path(root, adj):\n    path = []\n    stack = [root]\n    while stack:\n        u = stack[-1]\n        if len(adj[u]) == 0:\n            path.append(u)\n            stack.pop()\n        else:\n            v = adj[u][-1]\n            adj[u].pop()\n            adj[v] = [w for w in adj[v] if w != u]\n            stack.append(v)\n    return path\n\ndef find_rook_path(N, M, marked_squares):\n    marked = dict()\n    adj = [[] for _ in range(-2 * (N + 1))]\n    root = 0\n    for (i, (row, col)) in enumerate(marked_squares, 1):\n        marked[row, col] = i\n        col = col + N\n        adj[row].append(col)\n        adj[col].append(row)\n        root = max(root, row)\n    for (node, neighbors) in enumerate(adj):\n        if len(neighbors) % 2:\n            root = node\n    path = eulerian_path(root, adj)\n    soln = []\n    for (row, col) in zip(path[:-1], path[1:]):\n        if row > N:\n            row = row - N\n            (row, col) = (col, row)\n        else:\n            col = col - N\n        soln.append(marked[row, col])\n    return soln"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "adj = [[] for _ in range(2 * (N + 1))]",
      "mutated_line": "adj = [[] for _ in range(2 * (N - 1))]",
      "code": "import sys\nfrom collections import deque\n\ndef eulerian_path(root, adj):\n    path = []\n    stack = [root]\n    while stack:\n        u = stack[-1]\n        if len(adj[u]) == 0:\n            path.append(u)\n            stack.pop()\n        else:\n            v = adj[u][-1]\n            adj[u].pop()\n            adj[v] = [w for w in adj[v] if w != u]\n            stack.append(v)\n    return path\n\ndef find_rook_path(N, M, marked_squares):\n    marked = dict()\n    adj = [[] for _ in range(2 * (N - 1))]\n    root = 0\n    for (i, (row, col)) in enumerate(marked_squares, 1):\n        marked[row, col] = i\n        col = col + N\n        adj[row].append(col)\n        adj[col].append(row)\n        root = max(root, row)\n    for (node, neighbors) in enumerate(adj):\n        if len(neighbors) % 2:\n            root = node\n    path = eulerian_path(root, adj)\n    soln = []\n    for (row, col) in zip(path[:-1], path[1:]):\n        if row > N:\n            row = row - N\n            (row, col) = (col, row)\n        else:\n            col = col - N\n        soln.append(marked[row, col])\n    return soln"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "adj = [[] for _ in range(2 * (N + 1))]",
      "mutated_line": "adj = [[] for _ in range(2 * (N * 1))]",
      "code": "import sys\nfrom collections import deque\n\ndef eulerian_path(root, adj):\n    path = []\n    stack = [root]\n    while stack:\n        u = stack[-1]\n        if len(adj[u]) == 0:\n            path.append(u)\n            stack.pop()\n        else:\n            v = adj[u][-1]\n            adj[u].pop()\n            adj[v] = [w for w in adj[v] if w != u]\n            stack.append(v)\n    return path\n\ndef find_rook_path(N, M, marked_squares):\n    marked = dict()\n    adj = [[] for _ in range(2 * (N * 1))]\n    root = 0\n    for (i, (row, col)) in enumerate(marked_squares, 1):\n        marked[row, col] = i\n        col = col + N\n        adj[row].append(col)\n        adj[col].append(row)\n        root = max(root, row)\n    for (node, neighbors) in enumerate(adj):\n        if len(neighbors) % 2:\n            root = node\n    path = eulerian_path(root, adj)\n    soln = []\n    for (row, col) in zip(path[:-1], path[1:]):\n        if row > N:\n            row = row - N\n            (row, col) = (col, row)\n        else:\n            col = col - N\n        soln.append(marked[row, col])\n    return soln"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for row, col in zip(path[:-1], path[1:]):",
      "mutated_line": "for (row, col) in zip(path[:-2], path[1:]):",
      "code": "import sys\nfrom collections import deque\n\ndef eulerian_path(root, adj):\n    path = []\n    stack = [root]\n    while stack:\n        u = stack[-1]\n        if len(adj[u]) == 0:\n            path.append(u)\n            stack.pop()\n        else:\n            v = adj[u][-1]\n            adj[u].pop()\n            adj[v] = [w for w in adj[v] if w != u]\n            stack.append(v)\n    return path\n\ndef find_rook_path(N, M, marked_squares):\n    marked = dict()\n    adj = [[] for _ in range(2 * (N + 1))]\n    root = 0\n    for (i, (row, col)) in enumerate(marked_squares, 1):\n        marked[row, col] = i\n        col = col + N\n        adj[row].append(col)\n        adj[col].append(row)\n        root = max(root, row)\n    for (node, neighbors) in enumerate(adj):\n        if len(neighbors) % 2:\n            root = node\n    path = eulerian_path(root, adj)\n    soln = []\n    for (row, col) in zip(path[:-2], path[1:]):\n        if row > N:\n            row = row - N\n            (row, col) = (col, row)\n        else:\n            col = col - N\n        soln.append(marked[row, col])\n    return soln"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for row, col in zip(path[:-1], path[1:]):",
      "mutated_line": "for (row, col) in zip(path[:-0], path[1:]):",
      "code": "import sys\nfrom collections import deque\n\ndef eulerian_path(root, adj):\n    path = []\n    stack = [root]\n    while stack:\n        u = stack[-1]\n        if len(adj[u]) == 0:\n            path.append(u)\n            stack.pop()\n        else:\n            v = adj[u][-1]\n            adj[u].pop()\n            adj[v] = [w for w in adj[v] if w != u]\n            stack.append(v)\n    return path\n\ndef find_rook_path(N, M, marked_squares):\n    marked = dict()\n    adj = [[] for _ in range(2 * (N + 1))]\n    root = 0\n    for (i, (row, col)) in enumerate(marked_squares, 1):\n        marked[row, col] = i\n        col = col + N\n        adj[row].append(col)\n        adj[col].append(row)\n        root = max(root, row)\n    for (node, neighbors) in enumerate(adj):\n        if len(neighbors) % 2:\n            root = node\n    path = eulerian_path(root, adj)\n    soln = []\n    for (row, col) in zip(path[:-0], path[1:]):\n        if row > N:\n            row = row - N\n            (row, col) = (col, row)\n        else:\n            col = col - N\n        soln.append(marked[row, col])\n    return soln"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for row, col in zip(path[:-1], path[1:]):",
      "mutated_line": "for (row, col) in zip(path[:-0], path[1:]):",
      "code": "import sys\nfrom collections import deque\n\ndef eulerian_path(root, adj):\n    path = []\n    stack = [root]\n    while stack:\n        u = stack[-1]\n        if len(adj[u]) == 0:\n            path.append(u)\n            stack.pop()\n        else:\n            v = adj[u][-1]\n            adj[u].pop()\n            adj[v] = [w for w in adj[v] if w != u]\n            stack.append(v)\n    return path\n\ndef find_rook_path(N, M, marked_squares):\n    marked = dict()\n    adj = [[] for _ in range(2 * (N + 1))]\n    root = 0\n    for (i, (row, col)) in enumerate(marked_squares, 1):\n        marked[row, col] = i\n        col = col + N\n        adj[row].append(col)\n        adj[col].append(row)\n        root = max(root, row)\n    for (node, neighbors) in enumerate(adj):\n        if len(neighbors) % 2:\n            root = node\n    path = eulerian_path(root, adj)\n    soln = []\n    for (row, col) in zip(path[:-0], path[1:]):\n        if row > N:\n            row = row - N\n            (row, col) = (col, row)\n        else:\n            col = col - N\n        soln.append(marked[row, col])\n    return soln"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for row, col in zip(path[:-1], path[1:]):",
      "mutated_line": "for (row, col) in zip(path[:--1], path[1:]):",
      "code": "import sys\nfrom collections import deque\n\ndef eulerian_path(root, adj):\n    path = []\n    stack = [root]\n    while stack:\n        u = stack[-1]\n        if len(adj[u]) == 0:\n            path.append(u)\n            stack.pop()\n        else:\n            v = adj[u][-1]\n            adj[u].pop()\n            adj[v] = [w for w in adj[v] if w != u]\n            stack.append(v)\n    return path\n\ndef find_rook_path(N, M, marked_squares):\n    marked = dict()\n    adj = [[] for _ in range(2 * (N + 1))]\n    root = 0\n    for (i, (row, col)) in enumerate(marked_squares, 1):\n        marked[row, col] = i\n        col = col + N\n        adj[row].append(col)\n        adj[col].append(row)\n        root = max(root, row)\n    for (node, neighbors) in enumerate(adj):\n        if len(neighbors) % 2:\n            root = node\n    path = eulerian_path(root, adj)\n    soln = []\n    for (row, col) in zip(path[:--1], path[1:]):\n        if row > N:\n            row = row - N\n            (row, col) = (col, row)\n        else:\n            col = col - N\n        soln.append(marked[row, col])\n    return soln"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "adj = [[] for _ in range(2 * (N + 1))]",
      "mutated_line": "adj = [[] for _ in range(2 * (N + 2))]",
      "code": "import sys\nfrom collections import deque\n\ndef eulerian_path(root, adj):\n    path = []\n    stack = [root]\n    while stack:\n        u = stack[-1]\n        if len(adj[u]) == 0:\n            path.append(u)\n            stack.pop()\n        else:\n            v = adj[u][-1]\n            adj[u].pop()\n            adj[v] = [w for w in adj[v] if w != u]\n            stack.append(v)\n    return path\n\ndef find_rook_path(N, M, marked_squares):\n    marked = dict()\n    adj = [[] for _ in range(2 * (N + 2))]\n    root = 0\n    for (i, (row, col)) in enumerate(marked_squares, 1):\n        marked[row, col] = i\n        col = col + N\n        adj[row].append(col)\n        adj[col].append(row)\n        root = max(root, row)\n    for (node, neighbors) in enumerate(adj):\n        if len(neighbors) % 2:\n            root = node\n    path = eulerian_path(root, adj)\n    soln = []\n    for (row, col) in zip(path[:-1], path[1:]):\n        if row > N:\n            row = row - N\n            (row, col) = (col, row)\n        else:\n            col = col - N\n        soln.append(marked[row, col])\n    return soln"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "adj = [[] for _ in range(2 * (N + 1))]",
      "mutated_line": "adj = [[] for _ in range(2 * (N + 0))]",
      "code": "import sys\nfrom collections import deque\n\ndef eulerian_path(root, adj):\n    path = []\n    stack = [root]\n    while stack:\n        u = stack[-1]\n        if len(adj[u]) == 0:\n            path.append(u)\n            stack.pop()\n        else:\n            v = adj[u][-1]\n            adj[u].pop()\n            adj[v] = [w for w in adj[v] if w != u]\n            stack.append(v)\n    return path\n\ndef find_rook_path(N, M, marked_squares):\n    marked = dict()\n    adj = [[] for _ in range(2 * (N + 0))]\n    root = 0\n    for (i, (row, col)) in enumerate(marked_squares, 1):\n        marked[row, col] = i\n        col = col + N\n        adj[row].append(col)\n        adj[col].append(row)\n        root = max(root, row)\n    for (node, neighbors) in enumerate(adj):\n        if len(neighbors) % 2:\n            root = node\n    path = eulerian_path(root, adj)\n    soln = []\n    for (row, col) in zip(path[:-1], path[1:]):\n        if row > N:\n            row = row - N\n            (row, col) = (col, row)\n        else:\n            col = col - N\n        soln.append(marked[row, col])\n    return soln"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "adj = [[] for _ in range(2 * (N + 1))]",
      "mutated_line": "adj = [[] for _ in range(2 * (N + 0))]",
      "code": "import sys\nfrom collections import deque\n\ndef eulerian_path(root, adj):\n    path = []\n    stack = [root]\n    while stack:\n        u = stack[-1]\n        if len(adj[u]) == 0:\n            path.append(u)\n            stack.pop()\n        else:\n            v = adj[u][-1]\n            adj[u].pop()\n            adj[v] = [w for w in adj[v] if w != u]\n            stack.append(v)\n    return path\n\ndef find_rook_path(N, M, marked_squares):\n    marked = dict()\n    adj = [[] for _ in range(2 * (N + 0))]\n    root = 0\n    for (i, (row, col)) in enumerate(marked_squares, 1):\n        marked[row, col] = i\n        col = col + N\n        adj[row].append(col)\n        adj[col].append(row)\n        root = max(root, row)\n    for (node, neighbors) in enumerate(adj):\n        if len(neighbors) % 2:\n            root = node\n    path = eulerian_path(root, adj)\n    soln = []\n    for (row, col) in zip(path[:-1], path[1:]):\n        if row > N:\n            row = row - N\n            (row, col) = (col, row)\n        else:\n            col = col - N\n        soln.append(marked[row, col])\n    return soln"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "adj = [[] for _ in range(2 * (N + 1))]",
      "mutated_line": "adj = [[] for _ in range(2 * (N + -1))]",
      "code": "import sys\nfrom collections import deque\n\ndef eulerian_path(root, adj):\n    path = []\n    stack = [root]\n    while stack:\n        u = stack[-1]\n        if len(adj[u]) == 0:\n            path.append(u)\n            stack.pop()\n        else:\n            v = adj[u][-1]\n            adj[u].pop()\n            adj[v] = [w for w in adj[v] if w != u]\n            stack.append(v)\n    return path\n\ndef find_rook_path(N, M, marked_squares):\n    marked = dict()\n    adj = [[] for _ in range(2 * (N + -1))]\n    root = 0\n    for (i, (row, col)) in enumerate(marked_squares, 1):\n        marked[row, col] = i\n        col = col + N\n        adj[row].append(col)\n        adj[col].append(row)\n        root = max(root, row)\n    for (node, neighbors) in enumerate(adj):\n        if len(neighbors) % 2:\n            root = node\n    path = eulerian_path(root, adj)\n    soln = []\n    for (row, col) in zip(path[:-1], path[1:]):\n        if row > N:\n            row = row - N\n            (row, col) = (col, row)\n        else:\n            col = col - N\n        soln.append(marked[row, col])\n    return soln"
    }
  ]
}