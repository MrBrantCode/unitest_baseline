{
  "task_id": "taco_7069",
  "entry_point": "can_balance_weights",
  "mutant_count": 35,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "result = 'NO'",
      "mutated_line": "result = ''",
      "code": "def can_balance_weights(weight_availability: str, m: int) -> tuple:\n    available_weights = [i for (i, x) in enumerate(weight_availability, 1) if x == '1']\n    queue = [(-1, 0, 0, [])]\n    result = ''\n    while queue:\n        (x, d, s, t) = queue.pop()\n        if s == m:\n            result = 'YES'\n            return (result, t)\n        for y in available_weights:\n            if y != x and y > d:\n                queue.append((y, y - d, s + 1, t + [y]))\n    return (result, [])"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if s == m:",
      "mutated_line": "if s != m:",
      "code": "def can_balance_weights(weight_availability: str, m: int) -> tuple:\n    available_weights = [i for (i, x) in enumerate(weight_availability, 1) if x == '1']\n    queue = [(-1, 0, 0, [])]\n    result = 'NO'\n    while queue:\n        (x, d, s, t) = queue.pop()\n        if s != m:\n            result = 'YES'\n            return (result, t)\n        for y in available_weights:\n            if y != x and y > d:\n                queue.append((y, y - d, s + 1, t + [y]))\n    return (result, [])"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "available_weights = [i for i, x in enumerate(weight_availability, 1) if x == '1']",
      "mutated_line": "available_weights = [i for (i, x) in enumerate(weight_availability, 1) if x != '1']",
      "code": "def can_balance_weights(weight_availability: str, m: int) -> tuple:\n    available_weights = [i for (i, x) in enumerate(weight_availability, 1) if x != '1']\n    queue = [(-1, 0, 0, [])]\n    result = 'NO'\n    while queue:\n        (x, d, s, t) = queue.pop()\n        if s == m:\n            result = 'YES'\n            return (result, t)\n        for y in available_weights:\n            if y != x and y > d:\n                queue.append((y, y - d, s + 1, t + [y]))\n    return (result, [])"
    },
    {
      "operator": "UOI",
      "lineno": 6,
      "original_line": "queue = [(-1, 0, 0, [])]",
      "mutated_line": "queue = [(+1, 0, 0, [])]",
      "code": "def can_balance_weights(weight_availability: str, m: int) -> tuple:\n    available_weights = [i for (i, x) in enumerate(weight_availability, 1) if x == '1']\n    queue = [(+1, 0, 0, [])]\n    result = 'NO'\n    while queue:\n        (x, d, s, t) = queue.pop()\n        if s == m:\n            result = 'YES'\n            return (result, t)\n        for y in available_weights:\n            if y != x and y > d:\n                queue.append((y, y - d, s + 1, t + [y]))\n    return (result, [])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "queue = [(-1, 0, 0, [])]",
      "mutated_line": "queue = [(-1, 1, 0, [])]",
      "code": "def can_balance_weights(weight_availability: str, m: int) -> tuple:\n    available_weights = [i for (i, x) in enumerate(weight_availability, 1) if x == '1']\n    queue = [(-1, 1, 0, [])]\n    result = 'NO'\n    while queue:\n        (x, d, s, t) = queue.pop()\n        if s == m:\n            result = 'YES'\n            return (result, t)\n        for y in available_weights:\n            if y != x and y > d:\n                queue.append((y, y - d, s + 1, t + [y]))\n    return (result, [])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "queue = [(-1, 0, 0, [])]",
      "mutated_line": "queue = [(-1, -1, 0, [])]",
      "code": "def can_balance_weights(weight_availability: str, m: int) -> tuple:\n    available_weights = [i for (i, x) in enumerate(weight_availability, 1) if x == '1']\n    queue = [(-1, -1, 0, [])]\n    result = 'NO'\n    while queue:\n        (x, d, s, t) = queue.pop()\n        if s == m:\n            result = 'YES'\n            return (result, t)\n        for y in available_weights:\n            if y != x and y > d:\n                queue.append((y, y - d, s + 1, t + [y]))\n    return (result, [])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "queue = [(-1, 0, 0, [])]",
      "mutated_line": "queue = [(-1, 1, 0, [])]",
      "code": "def can_balance_weights(weight_availability: str, m: int) -> tuple:\n    available_weights = [i for (i, x) in enumerate(weight_availability, 1) if x == '1']\n    queue = [(-1, 1, 0, [])]\n    result = 'NO'\n    while queue:\n        (x, d, s, t) = queue.pop()\n        if s == m:\n            result = 'YES'\n            return (result, t)\n        for y in available_weights:\n            if y != x and y > d:\n                queue.append((y, y - d, s + 1, t + [y]))\n    return (result, [])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "queue = [(-1, 0, 0, [])]",
      "mutated_line": "queue = [(-1, 0, 1, [])]",
      "code": "def can_balance_weights(weight_availability: str, m: int) -> tuple:\n    available_weights = [i for (i, x) in enumerate(weight_availability, 1) if x == '1']\n    queue = [(-1, 0, 1, [])]\n    result = 'NO'\n    while queue:\n        (x, d, s, t) = queue.pop()\n        if s == m:\n            result = 'YES'\n            return (result, t)\n        for y in available_weights:\n            if y != x and y > d:\n                queue.append((y, y - d, s + 1, t + [y]))\n    return (result, [])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "queue = [(-1, 0, 0, [])]",
      "mutated_line": "queue = [(-1, 0, -1, [])]",
      "code": "def can_balance_weights(weight_availability: str, m: int) -> tuple:\n    available_weights = [i for (i, x) in enumerate(weight_availability, 1) if x == '1']\n    queue = [(-1, 0, -1, [])]\n    result = 'NO'\n    while queue:\n        (x, d, s, t) = queue.pop()\n        if s == m:\n            result = 'YES'\n            return (result, t)\n        for y in available_weights:\n            if y != x and y > d:\n                queue.append((y, y - d, s + 1, t + [y]))\n    return (result, [])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "queue = [(-1, 0, 0, [])]",
      "mutated_line": "queue = [(-1, 0, 1, [])]",
      "code": "def can_balance_weights(weight_availability: str, m: int) -> tuple:\n    available_weights = [i for (i, x) in enumerate(weight_availability, 1) if x == '1']\n    queue = [(-1, 0, 1, [])]\n    result = 'NO'\n    while queue:\n        (x, d, s, t) = queue.pop()\n        if s == m:\n            result = 'YES'\n            return (result, t)\n        for y in available_weights:\n            if y != x and y > d:\n                queue.append((y, y - d, s + 1, t + [y]))\n    return (result, [])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "result = 'YES'",
      "mutated_line": "result = ''",
      "code": "def can_balance_weights(weight_availability: str, m: int) -> tuple:\n    available_weights = [i for (i, x) in enumerate(weight_availability, 1) if x == '1']\n    queue = [(-1, 0, 0, [])]\n    result = 'NO'\n    while queue:\n        (x, d, s, t) = queue.pop()\n        if s == m:\n            result = ''\n            return (result, t)\n        for y in available_weights:\n            if y != x and y > d:\n                queue.append((y, y - d, s + 1, t + [y]))\n    return (result, [])"
    },
    {
      "operator": "LCR",
      "lineno": 16,
      "original_line": "if y != x and y > d:",
      "mutated_line": "if y != x or y > d:",
      "code": "def can_balance_weights(weight_availability: str, m: int) -> tuple:\n    available_weights = [i for (i, x) in enumerate(weight_availability, 1) if x == '1']\n    queue = [(-1, 0, 0, [])]\n    result = 'NO'\n    while queue:\n        (x, d, s, t) = queue.pop()\n        if s == m:\n            result = 'YES'\n            return (result, t)\n        for y in available_weights:\n            if y != x or y > d:\n                queue.append((y, y - d, s + 1, t + [y]))\n    return (result, [])"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "available_weights = [i for i, x in enumerate(weight_availability, 1) if x == '1']",
      "mutated_line": "available_weights = [i for (i, x) in enumerate(weight_availability, 2) if x == '1']",
      "code": "def can_balance_weights(weight_availability: str, m: int) -> tuple:\n    available_weights = [i for (i, x) in enumerate(weight_availability, 2) if x == '1']\n    queue = [(-1, 0, 0, [])]\n    result = 'NO'\n    while queue:\n        (x, d, s, t) = queue.pop()\n        if s == m:\n            result = 'YES'\n            return (result, t)\n        for y in available_weights:\n            if y != x and y > d:\n                queue.append((y, y - d, s + 1, t + [y]))\n    return (result, [])"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "available_weights = [i for i, x in enumerate(weight_availability, 1) if x == '1']",
      "mutated_line": "available_weights = [i for (i, x) in enumerate(weight_availability, 0) if x == '1']",
      "code": "def can_balance_weights(weight_availability: str, m: int) -> tuple:\n    available_weights = [i for (i, x) in enumerate(weight_availability, 0) if x == '1']\n    queue = [(-1, 0, 0, [])]\n    result = 'NO'\n    while queue:\n        (x, d, s, t) = queue.pop()\n        if s == m:\n            result = 'YES'\n            return (result, t)\n        for y in available_weights:\n            if y != x and y > d:\n                queue.append((y, y - d, s + 1, t + [y]))\n    return (result, [])"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "available_weights = [i for i, x in enumerate(weight_availability, 1) if x == '1']",
      "mutated_line": "available_weights = [i for (i, x) in enumerate(weight_availability, 0) if x == '1']",
      "code": "def can_balance_weights(weight_availability: str, m: int) -> tuple:\n    available_weights = [i for (i, x) in enumerate(weight_availability, 0) if x == '1']\n    queue = [(-1, 0, 0, [])]\n    result = 'NO'\n    while queue:\n        (x, d, s, t) = queue.pop()\n        if s == m:\n            result = 'YES'\n            return (result, t)\n        for y in available_weights:\n            if y != x and y > d:\n                queue.append((y, y - d, s + 1, t + [y]))\n    return (result, [])"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "available_weights = [i for i, x in enumerate(weight_availability, 1) if x == '1']",
      "mutated_line": "available_weights = [i for (i, x) in enumerate(weight_availability, -1) if x == '1']",
      "code": "def can_balance_weights(weight_availability: str, m: int) -> tuple:\n    available_weights = [i for (i, x) in enumerate(weight_availability, -1) if x == '1']\n    queue = [(-1, 0, 0, [])]\n    result = 'NO'\n    while queue:\n        (x, d, s, t) = queue.pop()\n        if s == m:\n            result = 'YES'\n            return (result, t)\n        for y in available_weights:\n            if y != x and y > d:\n                queue.append((y, y - d, s + 1, t + [y]))\n    return (result, [])"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "available_weights = [i for i, x in enumerate(weight_availability, 1) if x == '1']",
      "mutated_line": "available_weights = [i for (i, x) in enumerate(weight_availability, 1) if x == '']",
      "code": "def can_balance_weights(weight_availability: str, m: int) -> tuple:\n    available_weights = [i for (i, x) in enumerate(weight_availability, 1) if x == '']\n    queue = [(-1, 0, 0, [])]\n    result = 'NO'\n    while queue:\n        (x, d, s, t) = queue.pop()\n        if s == m:\n            result = 'YES'\n            return (result, t)\n        for y in available_weights:\n            if y != x and y > d:\n                queue.append((y, y - d, s + 1, t + [y]))\n    return (result, [])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "queue = [(-1, 0, 0, [])]",
      "mutated_line": "queue = [(-2, 0, 0, [])]",
      "code": "def can_balance_weights(weight_availability: str, m: int) -> tuple:\n    available_weights = [i for (i, x) in enumerate(weight_availability, 1) if x == '1']\n    queue = [(-2, 0, 0, [])]\n    result = 'NO'\n    while queue:\n        (x, d, s, t) = queue.pop()\n        if s == m:\n            result = 'YES'\n            return (result, t)\n        for y in available_weights:\n            if y != x and y > d:\n                queue.append((y, y - d, s + 1, t + [y]))\n    return (result, [])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "queue = [(-1, 0, 0, [])]",
      "mutated_line": "queue = [(-0, 0, 0, [])]",
      "code": "def can_balance_weights(weight_availability: str, m: int) -> tuple:\n    available_weights = [i for (i, x) in enumerate(weight_availability, 1) if x == '1']\n    queue = [(-0, 0, 0, [])]\n    result = 'NO'\n    while queue:\n        (x, d, s, t) = queue.pop()\n        if s == m:\n            result = 'YES'\n            return (result, t)\n        for y in available_weights:\n            if y != x and y > d:\n                queue.append((y, y - d, s + 1, t + [y]))\n    return (result, [])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "queue = [(-1, 0, 0, [])]",
      "mutated_line": "queue = [(-0, 0, 0, [])]",
      "code": "def can_balance_weights(weight_availability: str, m: int) -> tuple:\n    available_weights = [i for (i, x) in enumerate(weight_availability, 1) if x == '1']\n    queue = [(-0, 0, 0, [])]\n    result = 'NO'\n    while queue:\n        (x, d, s, t) = queue.pop()\n        if s == m:\n            result = 'YES'\n            return (result, t)\n        for y in available_weights:\n            if y != x and y > d:\n                queue.append((y, y - d, s + 1, t + [y]))\n    return (result, [])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "queue = [(-1, 0, 0, [])]",
      "mutated_line": "queue = [(--1, 0, 0, [])]",
      "code": "def can_balance_weights(weight_availability: str, m: int) -> tuple:\n    available_weights = [i for (i, x) in enumerate(weight_availability, 1) if x == '1']\n    queue = [(--1, 0, 0, [])]\n    result = 'NO'\n    while queue:\n        (x, d, s, t) = queue.pop()\n        if s == m:\n            result = 'YES'\n            return (result, t)\n        for y in available_weights:\n            if y != x and y > d:\n                queue.append((y, y - d, s + 1, t + [y]))\n    return (result, [])"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if y != x and y > d:",
      "mutated_line": "if y == x and y > d:",
      "code": "def can_balance_weights(weight_availability: str, m: int) -> tuple:\n    available_weights = [i for (i, x) in enumerate(weight_availability, 1) if x == '1']\n    queue = [(-1, 0, 0, [])]\n    result = 'NO'\n    while queue:\n        (x, d, s, t) = queue.pop()\n        if s == m:\n            result = 'YES'\n            return (result, t)\n        for y in available_weights:\n            if y == x and y > d:\n                queue.append((y, y - d, s + 1, t + [y]))\n    return (result, [])"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if y != x and y > d:",
      "mutated_line": "if y != x and y >= d:",
      "code": "def can_balance_weights(weight_availability: str, m: int) -> tuple:\n    available_weights = [i for (i, x) in enumerate(weight_availability, 1) if x == '1']\n    queue = [(-1, 0, 0, [])]\n    result = 'NO'\n    while queue:\n        (x, d, s, t) = queue.pop()\n        if s == m:\n            result = 'YES'\n            return (result, t)\n        for y in available_weights:\n            if y != x and y >= d:\n                queue.append((y, y - d, s + 1, t + [y]))\n    return (result, [])"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if y != x and y > d:",
      "mutated_line": "if y != x and y <= d:",
      "code": "def can_balance_weights(weight_availability: str, m: int) -> tuple:\n    available_weights = [i for (i, x) in enumerate(weight_availability, 1) if x == '1']\n    queue = [(-1, 0, 0, [])]\n    result = 'NO'\n    while queue:\n        (x, d, s, t) = queue.pop()\n        if s == m:\n            result = 'YES'\n            return (result, t)\n        for y in available_weights:\n            if y != x and y <= d:\n                queue.append((y, y - d, s + 1, t + [y]))\n    return (result, [])"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if y != x and y > d:",
      "mutated_line": "if y != x and y != d:",
      "code": "def can_balance_weights(weight_availability: str, m: int) -> tuple:\n    available_weights = [i for (i, x) in enumerate(weight_availability, 1) if x == '1']\n    queue = [(-1, 0, 0, [])]\n    result = 'NO'\n    while queue:\n        (x, d, s, t) = queue.pop()\n        if s == m:\n            result = 'YES'\n            return (result, t)\n        for y in available_weights:\n            if y != x and y != d:\n                queue.append((y, y - d, s + 1, t + [y]))\n    return (result, [])"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "queue.append((y, y - d, s + 1, t + [y]))",
      "mutated_line": "queue.append((y, y + d, s + 1, t + [y]))",
      "code": "def can_balance_weights(weight_availability: str, m: int) -> tuple:\n    available_weights = [i for (i, x) in enumerate(weight_availability, 1) if x == '1']\n    queue = [(-1, 0, 0, [])]\n    result = 'NO'\n    while queue:\n        (x, d, s, t) = queue.pop()\n        if s == m:\n            result = 'YES'\n            return (result, t)\n        for y in available_weights:\n            if y != x and y > d:\n                queue.append((y, y + d, s + 1, t + [y]))\n    return (result, [])"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "queue.append((y, y - d, s + 1, t + [y]))",
      "mutated_line": "queue.append((y, y * d, s + 1, t + [y]))",
      "code": "def can_balance_weights(weight_availability: str, m: int) -> tuple:\n    available_weights = [i for (i, x) in enumerate(weight_availability, 1) if x == '1']\n    queue = [(-1, 0, 0, [])]\n    result = 'NO'\n    while queue:\n        (x, d, s, t) = queue.pop()\n        if s == m:\n            result = 'YES'\n            return (result, t)\n        for y in available_weights:\n            if y != x and y > d:\n                queue.append((y, y * d, s + 1, t + [y]))\n    return (result, [])"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "queue.append((y, y - d, s + 1, t + [y]))",
      "mutated_line": "queue.append((y, y - d, s - 1, t + [y]))",
      "code": "def can_balance_weights(weight_availability: str, m: int) -> tuple:\n    available_weights = [i for (i, x) in enumerate(weight_availability, 1) if x == '1']\n    queue = [(-1, 0, 0, [])]\n    result = 'NO'\n    while queue:\n        (x, d, s, t) = queue.pop()\n        if s == m:\n            result = 'YES'\n            return (result, t)\n        for y in available_weights:\n            if y != x and y > d:\n                queue.append((y, y - d, s - 1, t + [y]))\n    return (result, [])"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "queue.append((y, y - d, s + 1, t + [y]))",
      "mutated_line": "queue.append((y, y - d, s * 1, t + [y]))",
      "code": "def can_balance_weights(weight_availability: str, m: int) -> tuple:\n    available_weights = [i for (i, x) in enumerate(weight_availability, 1) if x == '1']\n    queue = [(-1, 0, 0, [])]\n    result = 'NO'\n    while queue:\n        (x, d, s, t) = queue.pop()\n        if s == m:\n            result = 'YES'\n            return (result, t)\n        for y in available_weights:\n            if y != x and y > d:\n                queue.append((y, y - d, s * 1, t + [y]))\n    return (result, [])"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "queue.append((y, y - d, s + 1, t + [y]))",
      "mutated_line": "queue.append((y, y - d, s + 1, t - [y]))",
      "code": "def can_balance_weights(weight_availability: str, m: int) -> tuple:\n    available_weights = [i for (i, x) in enumerate(weight_availability, 1) if x == '1']\n    queue = [(-1, 0, 0, [])]\n    result = 'NO'\n    while queue:\n        (x, d, s, t) = queue.pop()\n        if s == m:\n            result = 'YES'\n            return (result, t)\n        for y in available_weights:\n            if y != x and y > d:\n                queue.append((y, y - d, s + 1, t - [y]))\n    return (result, [])"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "queue.append((y, y - d, s + 1, t + [y]))",
      "mutated_line": "queue.append((y, y - d, s + 1, t * [y]))",
      "code": "def can_balance_weights(weight_availability: str, m: int) -> tuple:\n    available_weights = [i for (i, x) in enumerate(weight_availability, 1) if x == '1']\n    queue = [(-1, 0, 0, [])]\n    result = 'NO'\n    while queue:\n        (x, d, s, t) = queue.pop()\n        if s == m:\n            result = 'YES'\n            return (result, t)\n        for y in available_weights:\n            if y != x and y > d:\n                queue.append((y, y - d, s + 1, t * [y]))\n    return (result, [])"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "queue.append((y, y - d, s + 1, t + [y]))",
      "mutated_line": "queue.append((y, y - d, s + 2, t + [y]))",
      "code": "def can_balance_weights(weight_availability: str, m: int) -> tuple:\n    available_weights = [i for (i, x) in enumerate(weight_availability, 1) if x == '1']\n    queue = [(-1, 0, 0, [])]\n    result = 'NO'\n    while queue:\n        (x, d, s, t) = queue.pop()\n        if s == m:\n            result = 'YES'\n            return (result, t)\n        for y in available_weights:\n            if y != x and y > d:\n                queue.append((y, y - d, s + 2, t + [y]))\n    return (result, [])"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "queue.append((y, y - d, s + 1, t + [y]))",
      "mutated_line": "queue.append((y, y - d, s + 0, t + [y]))",
      "code": "def can_balance_weights(weight_availability: str, m: int) -> tuple:\n    available_weights = [i for (i, x) in enumerate(weight_availability, 1) if x == '1']\n    queue = [(-1, 0, 0, [])]\n    result = 'NO'\n    while queue:\n        (x, d, s, t) = queue.pop()\n        if s == m:\n            result = 'YES'\n            return (result, t)\n        for y in available_weights:\n            if y != x and y > d:\n                queue.append((y, y - d, s + 0, t + [y]))\n    return (result, [])"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "queue.append((y, y - d, s + 1, t + [y]))",
      "mutated_line": "queue.append((y, y - d, s + 0, t + [y]))",
      "code": "def can_balance_weights(weight_availability: str, m: int) -> tuple:\n    available_weights = [i for (i, x) in enumerate(weight_availability, 1) if x == '1']\n    queue = [(-1, 0, 0, [])]\n    result = 'NO'\n    while queue:\n        (x, d, s, t) = queue.pop()\n        if s == m:\n            result = 'YES'\n            return (result, t)\n        for y in available_weights:\n            if y != x and y > d:\n                queue.append((y, y - d, s + 0, t + [y]))\n    return (result, [])"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "queue.append((y, y - d, s + 1, t + [y]))",
      "mutated_line": "queue.append((y, y - d, s + -1, t + [y]))",
      "code": "def can_balance_weights(weight_availability: str, m: int) -> tuple:\n    available_weights = [i for (i, x) in enumerate(weight_availability, 1) if x == '1']\n    queue = [(-1, 0, 0, [])]\n    result = 'NO'\n    while queue:\n        (x, d, s, t) = queue.pop()\n        if s == m:\n            result = 'YES'\n            return (result, t)\n        for y in available_weights:\n            if y != x and y > d:\n                queue.append((y, y - d, s + -1, t + [y]))\n    return (result, [])"
    }
  ]
}