{
  "task_id": "taco_9815",
  "entry_point": "count_palindromic_paths",
  "mutant_count": 179,
  "mutants": [
    {
      "operator": "LCR",
      "lineno": 5,
      "original_line": "if i1 >= n or j1 >= m or i2 < 0 or j2 < 0 or i1 > i2 or j1 > j2 or ma[i1][j1] != ma[i2][j2]:",
      "mutated_line": "if i1 >= n and j1 >= m and (i2 < 0) and (j2 < 0) and (i1 > i2) and (j1 > j2) and (ma[i1][j1] != ma[i2][j2]):",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n and j1 >= m and (i2 < 0) and (j2 < 0) and (i1 > i2) and (j1 > j2) and (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "LCR",
      "lineno": 7,
      "original_line": "if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):",
      "mutated_line": "if (i1 == i2 and j1 == j2) and (i1 == i2 and j1 + 1 == j2) and (j1 == j2 and i1 + 1 == i2):",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if (i1 == i2 and j1 == j2) and (i1 == i2 and j1 + 1 == j2) and (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "x = i1 * n + j1",
      "mutated_line": "x = i1 * n - j1",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n - j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "x = i1 * n + j1",
      "mutated_line": "x = i1 * n * j1",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n * j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "y = i2 * n + j2",
      "mutated_line": "y = i2 * n - j2",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n - j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "y = i2 * n + j2",
      "mutated_line": "y = i2 * n * j2",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n * j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "LCR",
      "lineno": 11,
      "original_line": "if x in dp and y in dp[x]:",
      "mutated_line": "if x in dp or y in dp[x]:",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp or y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 1\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = -1\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 1\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M",
      "mutated_line": "ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) * M",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) * M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M",
      "mutated_line": "ans = ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp) + M",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp) + M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M",
      "mutated_line": "ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) * M",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) * M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M",
      "mutated_line": "ans = ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp) + M",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp) + M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M",
      "mutated_line": "ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) * M",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) * M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M",
      "mutated_line": "ans = ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp) + M",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp) + M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M",
      "mutated_line": "ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) * M",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) * M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M",
      "mutated_line": "ans = ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp) + M",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp) + M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if x not in dp:",
      "mutated_line": "if x in dp:",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if matrix[i][-1] == ' ':",
      "mutated_line": "if matrix[i][-1] != ' ':",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] != ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "M = int(1000000000.0 + 7)",
      "mutated_line": "M = int(1000000000.0 - 7)",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 - 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "M = int(1000000000.0 + 7)",
      "mutated_line": "M = int(1000000000.0 * 7)",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 * 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return solve(matrix, 0, 0, n - 1, m - 1, dp)",
      "mutated_line": "return solve(matrix, 1, 0, n - 1, m - 1, dp)",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 1, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return solve(matrix, 0, 0, n - 1, m - 1, dp)",
      "mutated_line": "return solve(matrix, -1, 0, n - 1, m - 1, dp)",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, -1, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return solve(matrix, 0, 0, n - 1, m - 1, dp)",
      "mutated_line": "return solve(matrix, 1, 0, n - 1, m - 1, dp)",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 1, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return solve(matrix, 0, 0, n - 1, m - 1, dp)",
      "mutated_line": "return solve(matrix, 0, 1, n - 1, m - 1, dp)",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 1, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return solve(matrix, 0, 0, n - 1, m - 1, dp)",
      "mutated_line": "return solve(matrix, 0, -1, n - 1, m - 1, dp)",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, -1, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return solve(matrix, 0, 0, n - 1, m - 1, dp)",
      "mutated_line": "return solve(matrix, 0, 1, n - 1, m - 1, dp)",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 1, n - 1, m - 1, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "return solve(matrix, 0, 0, n - 1, m - 1, dp)",
      "mutated_line": "return solve(matrix, 0, 0, n + 1, m - 1, dp)",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n + 1, m - 1, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "return solve(matrix, 0, 0, n - 1, m - 1, dp)",
      "mutated_line": "return solve(matrix, 0, 0, n * 1, m - 1, dp)",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n * 1, m - 1, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "return solve(matrix, 0, 0, n - 1, m - 1, dp)",
      "mutated_line": "return solve(matrix, 0, 0, n - 1, m + 1, dp)",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m + 1, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "return solve(matrix, 0, 0, n - 1, m - 1, dp)",
      "mutated_line": "return solve(matrix, 0, 0, n - 1, m * 1, dp)",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m * 1, dp)"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if i1 >= n or j1 >= m or i2 < 0 or j2 < 0 or i1 > i2 or j1 > j2 or ma[i1][j1] != ma[i2][j2]:",
      "mutated_line": "if i1 > n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 > n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if i1 >= n or j1 >= m or i2 < 0 or j2 < 0 or i1 > i2 or j1 > j2 or ma[i1][j1] != ma[i2][j2]:",
      "mutated_line": "if i1 < n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 < n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if i1 >= n or j1 >= m or i2 < 0 or j2 < 0 or i1 > i2 or j1 > j2 or ma[i1][j1] != ma[i2][j2]:",
      "mutated_line": "if i1 == n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 == n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if i1 >= n or j1 >= m or i2 < 0 or j2 < 0 or i1 > i2 or j1 > j2 or ma[i1][j1] != ma[i2][j2]:",
      "mutated_line": "if i1 >= n or j1 > m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 > m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if i1 >= n or j1 >= m or i2 < 0 or j2 < 0 or i1 > i2 or j1 > j2 or ma[i1][j1] != ma[i2][j2]:",
      "mutated_line": "if i1 >= n or j1 < m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 < m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if i1 >= n or j1 >= m or i2 < 0 or j2 < 0 or i1 > i2 or j1 > j2 or ma[i1][j1] != ma[i2][j2]:",
      "mutated_line": "if i1 >= n or j1 == m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 == m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if i1 >= n or j1 >= m or i2 < 0 or j2 < 0 or i1 > i2 or j1 > j2 or ma[i1][j1] != ma[i2][j2]:",
      "mutated_line": "if i1 >= n or j1 >= m or i2 <= 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 <= 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if i1 >= n or j1 >= m or i2 < 0 or j2 < 0 or i1 > i2 or j1 > j2 or ma[i1][j1] != ma[i2][j2]:",
      "mutated_line": "if i1 >= n or j1 >= m or i2 >= 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 >= 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if i1 >= n or j1 >= m or i2 < 0 or j2 < 0 or i1 > i2 or j1 > j2 or ma[i1][j1] != ma[i2][j2]:",
      "mutated_line": "if i1 >= n or j1 >= m or i2 != 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 != 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if i1 >= n or j1 >= m or i2 < 0 or j2 < 0 or i1 > i2 or j1 > j2 or ma[i1][j1] != ma[i2][j2]:",
      "mutated_line": "if i1 >= n or j1 >= m or i2 < 0 or (j2 <= 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 <= 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if i1 >= n or j1 >= m or i2 < 0 or j2 < 0 or i1 > i2 or j1 > j2 or ma[i1][j1] != ma[i2][j2]:",
      "mutated_line": "if i1 >= n or j1 >= m or i2 < 0 or (j2 >= 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 >= 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if i1 >= n or j1 >= m or i2 < 0 or j2 < 0 or i1 > i2 or j1 > j2 or ma[i1][j1] != ma[i2][j2]:",
      "mutated_line": "if i1 >= n or j1 >= m or i2 < 0 or (j2 != 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 != 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if i1 >= n or j1 >= m or i2 < 0 or j2 < 0 or i1 > i2 or j1 > j2 or ma[i1][j1] != ma[i2][j2]:",
      "mutated_line": "if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 >= i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 >= i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if i1 >= n or j1 >= m or i2 < 0 or j2 < 0 or i1 > i2 or j1 > j2 or ma[i1][j1] != ma[i2][j2]:",
      "mutated_line": "if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 <= i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 <= i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if i1 >= n or j1 >= m or i2 < 0 or j2 < 0 or i1 > i2 or j1 > j2 or ma[i1][j1] != ma[i2][j2]:",
      "mutated_line": "if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 != i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 != i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if i1 >= n or j1 >= m or i2 < 0 or j2 < 0 or i1 > i2 or j1 > j2 or ma[i1][j1] != ma[i2][j2]:",
      "mutated_line": "if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 >= j2) or (ma[i1][j1] != ma[i2][j2]):",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 >= j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if i1 >= n or j1 >= m or i2 < 0 or j2 < 0 or i1 > i2 or j1 > j2 or ma[i1][j1] != ma[i2][j2]:",
      "mutated_line": "if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 <= j2) or (ma[i1][j1] != ma[i2][j2]):",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 <= j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if i1 >= n or j1 >= m or i2 < 0 or j2 < 0 or i1 > i2 or j1 > j2 or ma[i1][j1] != ma[i2][j2]:",
      "mutated_line": "if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 != j2) or (ma[i1][j1] != ma[i2][j2]):",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 != j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if i1 >= n or j1 >= m or i2 < 0 or j2 < 0 or i1 > i2 or j1 > j2 or ma[i1][j1] != ma[i2][j2]:",
      "mutated_line": "if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] == ma[i2][j2]):",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] == ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 1\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return -1\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 1\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "LCR",
      "lineno": 7,
      "original_line": "if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):",
      "mutated_line": "if (i1 == i2 or j1 == j2) or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if (i1 == i2 or j1 == j2) or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "LCR",
      "lineno": 7,
      "original_line": "if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):",
      "mutated_line": "if i1 == i2 and j1 == j2 or (i1 == i2 or j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 or j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "LCR",
      "lineno": 7,
      "original_line": "if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):",
      "mutated_line": "if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 or i1 + 1 == i2):",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 or i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 1",
      "mutated_line": "return 2",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 2\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 0\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 0\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 1",
      "mutated_line": "return -1",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return -1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "x = i1 * n + j1",
      "mutated_line": "x = i1 / n + j1",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 / n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "x = i1 * n + j1",
      "mutated_line": "x = i1 + n + j1",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 + n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "x = i1 * n + j1",
      "mutated_line": "x = i1 ** n + j1",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 ** n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "y = i2 * n + j2",
      "mutated_line": "y = i2 / n + j2",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 / n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "y = i2 * n + j2",
      "mutated_line": "y = i2 + n + j2",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 + n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "y = i2 * n + j2",
      "mutated_line": "y = i2 ** n + j2",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 ** n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if x in dp and y in dp[x]:",
      "mutated_line": "if x not in dp and y in dp[x]:",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x not in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if x in dp and y in dp[x]:",
      "mutated_line": "if x in dp and y not in dp[x]:",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y not in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M",
      "mutated_line": "ans = (ans - solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans - solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M",
      "mutated_line": "ans = ans * solve(ma, i1 + 1, j1, i2 - 1, j2, dp) % M",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = ans * solve(ma, i1 + 1, j1, i2 - 1, j2, dp) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M",
      "mutated_line": "ans = (ans - solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans - solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M",
      "mutated_line": "ans = ans * solve(ma, i1 + 1, j1, i2, j2 - 1, dp) % M",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = ans * solve(ma, i1 + 1, j1, i2, j2 - 1, dp) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M",
      "mutated_line": "ans = (ans - solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans - solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M",
      "mutated_line": "ans = ans * solve(ma, i1, j1 + 1, i2 - 1, j2, dp) % M",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = ans * solve(ma, i1, j1 + 1, i2 - 1, j2, dp) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M",
      "mutated_line": "ans = (ans - solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans - solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M",
      "mutated_line": "ans = ans * solve(ma, i1, j1 + 1, i2, j2 - 1, dp) % M",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = ans * solve(ma, i1, j1 + 1, i2, j2 - 1, dp) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if matrix[i][-1] == ' ':",
      "mutated_line": "if matrix[i][-1] == '':",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == '':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "m = len(matrix[0])",
      "mutated_line": "m = len(matrix[1])",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[1])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "m = len(matrix[0])",
      "mutated_line": "m = len(matrix[-1])",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[-1])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "m = len(matrix[0])",
      "mutated_line": "m = len(matrix[1])",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[1])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "M = int(1000000000.0 + 7)",
      "mutated_line": "M = int(1000000001.0 + 7)",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000001.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "M = int(1000000000.0 + 7)",
      "mutated_line": "M = int(999999999.0 + 7)",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(999999999.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "M = int(1000000000.0 + 7)",
      "mutated_line": "M = int(0 + 7)",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "M = int(1000000000.0 + 7)",
      "mutated_line": "M = int(1 + 7)",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "M = int(1000000000.0 + 7)",
      "mutated_line": "M = int(-1000000000.0 + 7)",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(-1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "M = int(1000000000.0 + 7)",
      "mutated_line": "M = int(1000000000.0 + 8)",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 8)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "M = int(1000000000.0 + 7)",
      "mutated_line": "M = int(1000000000.0 + 6)",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 6)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "M = int(1000000000.0 + 7)",
      "mutated_line": "M = int(1000000000.0 + 0)",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 0)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "M = int(1000000000.0 + 7)",
      "mutated_line": "M = int(1000000000.0 + 1)",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 1)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "M = int(1000000000.0 + 7)",
      "mutated_line": "M = int(1000000000.0 + -7)",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + -7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return solve(matrix, 0, 0, n - 1, m - 1, dp)",
      "mutated_line": "return solve(matrix, 0, 0, n - 2, m - 1, dp)",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 2, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return solve(matrix, 0, 0, n - 1, m - 1, dp)",
      "mutated_line": "return solve(matrix, 0, 0, n - 0, m - 1, dp)",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 0, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return solve(matrix, 0, 0, n - 1, m - 1, dp)",
      "mutated_line": "return solve(matrix, 0, 0, n - 0, m - 1, dp)",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 0, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return solve(matrix, 0, 0, n - 1, m - 1, dp)",
      "mutated_line": "return solve(matrix, 0, 0, n - -1, m - 1, dp)",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - -1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return solve(matrix, 0, 0, n - 1, m - 1, dp)",
      "mutated_line": "return solve(matrix, 0, 0, n - 1, m - 2, dp)",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 2, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return solve(matrix, 0, 0, n - 1, m - 1, dp)",
      "mutated_line": "return solve(matrix, 0, 0, n - 1, m - 0, dp)",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 0, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return solve(matrix, 0, 0, n - 1, m - 1, dp)",
      "mutated_line": "return solve(matrix, 0, 0, n - 1, m - 0, dp)",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 0, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return solve(matrix, 0, 0, n - 1, m - 1, dp)",
      "mutated_line": "return solve(matrix, 0, 0, n - 1, m - -1, dp)",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - -1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "m = len(ma[0])",
      "mutated_line": "m = len(ma[1])",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[1])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "m = len(ma[0])",
      "mutated_line": "m = len(ma[-1])",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[-1])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "m = len(ma[0])",
      "mutated_line": "m = len(ma[1])",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[1])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if i1 >= n or j1 >= m or i2 < 0 or j2 < 0 or i1 > i2 or j1 > j2 or ma[i1][j1] != ma[i2][j2]:",
      "mutated_line": "if i1 >= n or j1 >= m or i2 < 1 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 1 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if i1 >= n or j1 >= m or i2 < 0 or j2 < 0 or i1 > i2 or j1 > j2 or ma[i1][j1] != ma[i2][j2]:",
      "mutated_line": "if i1 >= n or j1 >= m or i2 < -1 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < -1 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if i1 >= n or j1 >= m or i2 < 0 or j2 < 0 or i1 > i2 or j1 > j2 or ma[i1][j1] != ma[i2][j2]:",
      "mutated_line": "if i1 >= n or j1 >= m or i2 < 1 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 1 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if i1 >= n or j1 >= m or i2 < 0 or j2 < 0 or i1 > i2 or j1 > j2 or ma[i1][j1] != ma[i2][j2]:",
      "mutated_line": "if i1 >= n or j1 >= m or i2 < 0 or (j2 < 1) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 1) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if i1 >= n or j1 >= m or i2 < 0 or j2 < 0 or i1 > i2 or j1 > j2 or ma[i1][j1] != ma[i2][j2]:",
      "mutated_line": "if i1 >= n or j1 >= m or i2 < 0 or (j2 < -1) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < -1) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if i1 >= n or j1 >= m or i2 < 0 or j2 < 0 or i1 > i2 or j1 > j2 or ma[i1][j1] != ma[i2][j2]:",
      "mutated_line": "if i1 >= n or j1 >= m or i2 < 0 or (j2 < 1) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 1) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):",
      "mutated_line": "if i1 != i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 != i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):",
      "mutated_line": "if i1 == i2 and j1 != j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 != j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):",
      "mutated_line": "if i1 == i2 and j1 == j2 or (i1 != i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 != i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):",
      "mutated_line": "if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 != j2) or (j1 == j2 and i1 + 1 == i2):",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 != j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):",
      "mutated_line": "if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 != j2 and i1 + 1 == i2):",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 != j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):",
      "mutated_line": "if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 != i2):",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 != i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "UOI",
      "lineno": 26,
      "original_line": "if matrix[i][-1] == ' ':",
      "mutated_line": "if matrix[i][+1] == ' ':",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][+1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):",
      "mutated_line": "if i1 == i2 and j1 == j2 or (i1 == i2 and j1 - 1 == j2) or (j1 == j2 and i1 + 1 == i2):",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 - 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):",
      "mutated_line": "if i1 == i2 and j1 == j2 or (i1 == i2 and j1 * 1 == j2) or (j1 == j2 and i1 + 1 == i2):",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 * 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):",
      "mutated_line": "if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 - 1 == i2):",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 - 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):",
      "mutated_line": "if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 * 1 == i2):",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 * 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M",
      "mutated_line": "ans = (ans + solve(ma, i1 - 1, j1, i2 - 1, j2, dp)) % M",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 - 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M",
      "mutated_line": "ans = (ans + solve(ma, i1 * 1, j1, i2 - 1, j2, dp)) % M",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 * 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M",
      "mutated_line": "ans = (ans + solve(ma, i1 + 1, j1, i2 + 1, j2, dp)) % M",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 + 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M",
      "mutated_line": "ans = (ans + solve(ma, i1 + 1, j1, i2 * 1, j2, dp)) % M",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 * 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M",
      "mutated_line": "ans = (ans + solve(ma, i1 - 1, j1, i2, j2 - 1, dp)) % M",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 - 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M",
      "mutated_line": "ans = (ans + solve(ma, i1 * 1, j1, i2, j2 - 1, dp)) % M",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 * 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M",
      "mutated_line": "ans = (ans + solve(ma, i1 + 1, j1, i2, j2 + 1, dp)) % M",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 + 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M",
      "mutated_line": "ans = (ans + solve(ma, i1 + 1, j1, i2, j2 * 1, dp)) % M",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 * 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M",
      "mutated_line": "ans = (ans + solve(ma, i1, j1 - 1, i2 - 1, j2, dp)) % M",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 - 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M",
      "mutated_line": "ans = (ans + solve(ma, i1, j1 * 1, i2 - 1, j2, dp)) % M",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 * 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M",
      "mutated_line": "ans = (ans + solve(ma, i1, j1 + 1, i2 + 1, j2, dp)) % M",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 + 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M",
      "mutated_line": "ans = (ans + solve(ma, i1, j1 + 1, i2 * 1, j2, dp)) % M",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 * 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M",
      "mutated_line": "ans = (ans + solve(ma, i1, j1 - 1, i2, j2 - 1, dp)) % M",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 - 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M",
      "mutated_line": "ans = (ans + solve(ma, i1, j1 * 1, i2, j2 - 1, dp)) % M",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 * 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M",
      "mutated_line": "ans = (ans + solve(ma, i1, j1 + 1, i2, j2 + 1, dp)) % M",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 + 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M",
      "mutated_line": "ans = (ans + solve(ma, i1, j1 + 1, i2, j2 * 1, dp)) % M",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 * 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if matrix[i][-1] == ' ':",
      "mutated_line": "if matrix[i][-2] == ' ':",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-2] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if matrix[i][-1] == ' ':",
      "mutated_line": "if matrix[i][-0] == ' ':",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-0] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if matrix[i][-1] == ' ':",
      "mutated_line": "if matrix[i][-0] == ' ':",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-0] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if matrix[i][-1] == ' ':",
      "mutated_line": "if matrix[i][--1] == ' ':",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][--1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):",
      "mutated_line": "if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 2 == j2) or (j1 == j2 and i1 + 1 == i2):",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 2 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):",
      "mutated_line": "if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 0 == j2) or (j1 == j2 and i1 + 1 == i2):",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 0 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):",
      "mutated_line": "if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 0 == j2) or (j1 == j2 and i1 + 1 == i2):",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 0 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):",
      "mutated_line": "if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + -1 == j2) or (j1 == j2 and i1 + 1 == i2):",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + -1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):",
      "mutated_line": "if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 2 == i2):",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 2 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):",
      "mutated_line": "if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 0 == i2):",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 0 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):",
      "mutated_line": "if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 0 == i2):",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 0 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):",
      "mutated_line": "if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + -1 == i2):",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + -1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M",
      "mutated_line": "ans = (ans + solve(ma, i1 + 2, j1, i2 - 1, j2, dp)) % M",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 2, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M",
      "mutated_line": "ans = (ans + solve(ma, i1 + 0, j1, i2 - 1, j2, dp)) % M",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 0, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M",
      "mutated_line": "ans = (ans + solve(ma, i1 + 0, j1, i2 - 1, j2, dp)) % M",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 0, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M",
      "mutated_line": "ans = (ans + solve(ma, i1 + -1, j1, i2 - 1, j2, dp)) % M",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + -1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M",
      "mutated_line": "ans = (ans + solve(ma, i1 + 1, j1, i2 - 2, j2, dp)) % M",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 2, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M",
      "mutated_line": "ans = (ans + solve(ma, i1 + 1, j1, i2 - 0, j2, dp)) % M",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 0, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M",
      "mutated_line": "ans = (ans + solve(ma, i1 + 1, j1, i2 - 0, j2, dp)) % M",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 0, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M",
      "mutated_line": "ans = (ans + solve(ma, i1 + 1, j1, i2 - -1, j2, dp)) % M",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - -1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M",
      "mutated_line": "ans = (ans + solve(ma, i1 + 2, j1, i2, j2 - 1, dp)) % M",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 2, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M",
      "mutated_line": "ans = (ans + solve(ma, i1 + 0, j1, i2, j2 - 1, dp)) % M",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 0, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M",
      "mutated_line": "ans = (ans + solve(ma, i1 + 0, j1, i2, j2 - 1, dp)) % M",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 0, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M",
      "mutated_line": "ans = (ans + solve(ma, i1 + -1, j1, i2, j2 - 1, dp)) % M",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + -1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M",
      "mutated_line": "ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 2, dp)) % M",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M",
      "mutated_line": "ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 0, dp)) % M",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 0, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M",
      "mutated_line": "ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 0, dp)) % M",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 0, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M",
      "mutated_line": "ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - -1, dp)) % M",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - -1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M",
      "mutated_line": "ans = (ans + solve(ma, i1, j1 + 2, i2 - 1, j2, dp)) % M",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 2, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M",
      "mutated_line": "ans = (ans + solve(ma, i1, j1 + 0, i2 - 1, j2, dp)) % M",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 0, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M",
      "mutated_line": "ans = (ans + solve(ma, i1, j1 + 0, i2 - 1, j2, dp)) % M",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 0, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M",
      "mutated_line": "ans = (ans + solve(ma, i1, j1 + -1, i2 - 1, j2, dp)) % M",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + -1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M",
      "mutated_line": "ans = (ans + solve(ma, i1, j1 + 1, i2 - 2, j2, dp)) % M",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 2, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M",
      "mutated_line": "ans = (ans + solve(ma, i1, j1 + 1, i2 - 0, j2, dp)) % M",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 0, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M",
      "mutated_line": "ans = (ans + solve(ma, i1, j1 + 1, i2 - 0, j2, dp)) % M",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 0, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M",
      "mutated_line": "ans = (ans + solve(ma, i1, j1 + 1, i2 - -1, j2, dp)) % M",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - -1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M",
      "mutated_line": "ans = (ans + solve(ma, i1, j1 + 2, i2, j2 - 1, dp)) % M",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 2, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M",
      "mutated_line": "ans = (ans + solve(ma, i1, j1 + 0, i2, j2 - 1, dp)) % M",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 0, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M",
      "mutated_line": "ans = (ans + solve(ma, i1, j1 + 0, i2, j2 - 1, dp)) % M",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 0, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M",
      "mutated_line": "ans = (ans + solve(ma, i1, j1 + -1, i2, j2 - 1, dp)) % M",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + -1, i2, j2 - 1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M",
      "mutated_line": "ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 2, dp)) % M",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 2, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M",
      "mutated_line": "ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 0, dp)) % M",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 0, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M",
      "mutated_line": "ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 0, dp)) % M",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 0, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - 1, dp)) % M",
      "mutated_line": "ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - -1, dp)) % M",
      "code": "def count_palindromic_paths(matrix):\n\n    def solve(ma, i1, j1, i2, j2, dp):\n        n = len(ma)\n        m = len(ma[0])\n        if i1 >= n or j1 >= m or i2 < 0 or (j2 < 0) or (i1 > i2) or (j1 > j2) or (ma[i1][j1] != ma[i2][j2]):\n            return 0\n        if i1 == i2 and j1 == j2 or (i1 == i2 and j1 + 1 == j2) or (j1 == j2 and i1 + 1 == i2):\n            return 1\n        x = i1 * n + j1\n        y = i2 * n + j2\n        if x in dp and y in dp[x]:\n            return dp[x][y]\n        ans = 0\n        ans = (ans + solve(ma, i1 + 1, j1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1 + 1, j1, i2, j2 - 1, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2 - 1, j2, dp)) % M\n        ans = (ans + solve(ma, i1, j1 + 1, i2, j2 - -1, dp)) % M\n        if x not in dp:\n            dp[x] = {}\n        dp[x][y] = ans\n        return ans\n    dp = {}\n    n = len(matrix)\n    for i in range(n):\n        if matrix[i][-1] == ' ':\n            matrix[i].pop()\n    m = len(matrix[0])\n    M = int(1000000000.0 + 7)\n    return solve(matrix, 0, 0, n - 1, m - 1, dp)"
    }
  ]
}