{
  "task_id": "taco_15000",
  "entry_point": "count_missile_silos",
  "mutant_count": 90,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "distances = [float('inf')] * (n + 1)",
      "mutated_line": "distances = [float('inf')] / (n + 1)",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] / (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "distances = [float('inf')] * (n + 1)",
      "mutated_line": "distances = [float('inf')] + (n + 1)",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] + (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "distances = [float('inf')] * (n + 1)",
      "mutated_line": "distances = [float('inf')] ** (n + 1)",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] ** (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "distances[s] = 0",
      "mutated_line": "distances[s] = 1",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 1\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "distances[s] = 0",
      "mutated_line": "distances[s] = -1",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = -1\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "distances[s] = 0",
      "mutated_line": "distances[s] = 1",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 1\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "silo_count = 0",
      "mutated_line": "silo_count = 1",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 1\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "silo_count = 0",
      "mutated_line": "silo_count = -1",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = -1\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "silo_count = 0",
      "mutated_line": "silo_count = 1",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 1\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "distances = [float('inf')] * (n + 1)",
      "mutated_line": "distances = [float('inf')] * (n - 1)",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n - 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "distances = [float('inf')] * (n + 1)",
      "mutated_line": "distances = [float('inf')] * (n * 1)",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n * 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if current_distance > distances[current_node]:",
      "mutated_line": "if current_distance >= distances[current_node]:",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance >= distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if current_distance > distances[current_node]:",
      "mutated_line": "if current_distance <= distances[current_node]:",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance <= distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if current_distance > distances[current_node]:",
      "mutated_line": "if current_distance != distances[current_node]:",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance != distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for u in range(1, n + 1):",
      "mutated_line": "for u in range(2, n + 1):",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(2, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for u in range(1, n + 1):",
      "mutated_line": "for u in range(0, n + 1):",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(0, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for u in range(1, n + 1):",
      "mutated_line": "for u in range(0, n + 1):",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(0, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for u in range(1, n + 1):",
      "mutated_line": "for u in range(-1, n + 1):",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(-1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "for u in range(1, n + 1):",
      "mutated_line": "for u in range(1, n - 1):",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n - 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "for u in range(1, n + 1):",
      "mutated_line": "for u in range(1, n * 1):",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n * 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if d < l:",
      "mutated_line": "if d <= l:",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d <= l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if d < l:",
      "mutated_line": "if d >= l:",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d >= l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if d < l:",
      "mutated_line": "if d != l:",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d != l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "distances = [float('inf')] * (n + 1)",
      "mutated_line": "distances = [float('inf')] * (n + 2)",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 2)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "distances = [float('inf')] * (n + 1)",
      "mutated_line": "distances = [float('inf')] * (n + 0)",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 0)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "distances = [float('inf')] * (n + 1)",
      "mutated_line": "distances = [float('inf')] * (n + 0)",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 0)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "distances = [float('inf')] * (n + 1)",
      "mutated_line": "distances = [float('inf')] * (n + -1)",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + -1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "priority_queue = [(0, s)]",
      "mutated_line": "priority_queue = [(1, s)]",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(1, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "priority_queue = [(0, s)]",
      "mutated_line": "priority_queue = [(-1, s)]",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(-1, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "priority_queue = [(0, s)]",
      "mutated_line": "priority_queue = [(1, s)]",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(1, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "distance = current_distance + weight",
      "mutated_line": "distance = current_distance - weight",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance - weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "distance = current_distance + weight",
      "mutated_line": "distance = current_distance * weight",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance * weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if distance < distances[neighbor]:",
      "mutated_line": "if distance <= distances[neighbor]:",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance <= distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if distance < distances[neighbor]:",
      "mutated_line": "if distance >= distances[neighbor]:",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance >= distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if distance < distances[neighbor]:",
      "mutated_line": "if distance != distances[neighbor]:",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance != distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for u in range(1, n + 1):",
      "mutated_line": "for u in range(1, n + 2):",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 2):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for u in range(1, n + 1):",
      "mutated_line": "for u in range(1, n + 0):",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 0):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for u in range(1, n + 1):",
      "mutated_line": "for u in range(1, n + 0):",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 0):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for u in range(1, n + 1):",
      "mutated_line": "for u in range(1, n + -1):",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + -1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "elif d == l:",
      "mutated_line": "elif d != l:",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):\n                    silo_count += 1\n        elif d != l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "ASR",
      "lineno": 37,
      "original_line": "silo_count += 1",
      "mutated_line": "silo_count -= 1",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count -= 1\n    return silo_count"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "distances = [float('inf')] * (n + 1)",
      "mutated_line": "distances = [float('')] * (n + 1)",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "LCR",
      "lineno": 34,
      "original_line": "if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):",
      "mutated_line": "if d + w > l or (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l or (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "ASR",
      "lineno": 35,
      "original_line": "silo_count += 1",
      "mutated_line": "silo_count -= 1",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):\n                    silo_count -= 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "silo_count += 1",
      "mutated_line": "silo_count += 2",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 2\n    return silo_count"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "silo_count += 1",
      "mutated_line": "silo_count += 0",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 0\n    return silo_count"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "silo_count += 1",
      "mutated_line": "silo_count += 0",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 0\n    return silo_count"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "silo_count += 1",
      "mutated_line": "silo_count += -1",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += -1\n    return silo_count"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):",
      "mutated_line": "if d + w >= l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w >= l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):",
      "mutated_line": "if d + w <= l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w <= l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):",
      "mutated_line": "if d + w != l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w != l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "LCR",
      "lineno": 34,
      "original_line": "if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):",
      "mutated_line": "if d + w > l and (distances[v] + d + w > 2 * l and (u < v and distances[v] + d + w == 2 * l)):",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > 2 * l and (u < v and distances[v] + d + w == 2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "silo_count += 1",
      "mutated_line": "silo_count += 2",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):\n                    silo_count += 2\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "silo_count += 1",
      "mutated_line": "silo_count += 0",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):\n                    silo_count += 0\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "silo_count += 1",
      "mutated_line": "silo_count += 0",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):\n                    silo_count += 0\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "silo_count += 1",
      "mutated_line": "silo_count += -1",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):\n                    silo_count += -1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):",
      "mutated_line": "if d - w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d - w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):",
      "mutated_line": "if d * w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d * w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):",
      "mutated_line": "if d + w > l and (distances[v] + d + w >= 2 * l or (u < v and distances[v] + d + w == 2 * l)):",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w >= 2 * l or (u < v and distances[v] + d + w == 2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):",
      "mutated_line": "if d + w > l and (distances[v] + d + w <= 2 * l or (u < v and distances[v] + d + w == 2 * l)):",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w <= 2 * l or (u < v and distances[v] + d + w == 2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):",
      "mutated_line": "if d + w > l and (distances[v] + d + w != 2 * l or (u < v and distances[v] + d + w == 2 * l)):",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w != 2 * l or (u < v and distances[v] + d + w == 2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "LCR",
      "lineno": 34,
      "original_line": "if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):",
      "mutated_line": "if d + w > l and (distances[v] + d + w > 2 * l or (u < v or distances[v] + d + w == 2 * l)):",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > 2 * l or (u < v or distances[v] + d + w == 2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):",
      "mutated_line": "if d + w > l and (distances[v] + d - w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d - w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):",
      "mutated_line": "if d + w > l and ((distances[v] + d) * w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and ((distances[v] + d) * w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):",
      "mutated_line": "if d + w > l and (distances[v] + d + w > 2 / l or (u < v and distances[v] + d + w == 2 * l)):",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > 2 / l or (u < v and distances[v] + d + w == 2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):",
      "mutated_line": "if d + w > l and (distances[v] + d + w > 2 + l or (u < v and distances[v] + d + w == 2 * l)):",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > 2 + l or (u < v and distances[v] + d + w == 2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):",
      "mutated_line": "if d + w > l and (distances[v] + d + w > 2 ** l or (u < v and distances[v] + d + w == 2 * l)):",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > 2 ** l or (u < v and distances[v] + d + w == 2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):",
      "mutated_line": "if d + w > l and (distances[v] + d + w > 2 * l or (u <= v and distances[v] + d + w == 2 * l)):",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > 2 * l or (u <= v and distances[v] + d + w == 2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):",
      "mutated_line": "if d + w > l and (distances[v] + d + w > 2 * l or (u >= v and distances[v] + d + w == 2 * l)):",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > 2 * l or (u >= v and distances[v] + d + w == 2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):",
      "mutated_line": "if d + w > l and (distances[v] + d + w > 2 * l or (u != v and distances[v] + d + w == 2 * l)):",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > 2 * l or (u != v and distances[v] + d + w == 2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):",
      "mutated_line": "if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w != 2 * l)):",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w != 2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):",
      "mutated_line": "if d + w > l and (distances[v] - d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] - d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):",
      "mutated_line": "if d + w > l and (distances[v] * d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] * d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):",
      "mutated_line": "if d + w > l and (distances[v] + d + w > 3 * l or (u < v and distances[v] + d + w == 2 * l)):",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > 3 * l or (u < v and distances[v] + d + w == 2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):",
      "mutated_line": "if d + w > l and (distances[v] + d + w > 1 * l or (u < v and distances[v] + d + w == 2 * l)):",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > 1 * l or (u < v and distances[v] + d + w == 2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):",
      "mutated_line": "if d + w > l and (distances[v] + d + w > 0 * l or (u < v and distances[v] + d + w == 2 * l)):",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > 0 * l or (u < v and distances[v] + d + w == 2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):",
      "mutated_line": "if d + w > l and (distances[v] + d + w > 1 * l or (u < v and distances[v] + d + w == 2 * l)):",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > 1 * l or (u < v and distances[v] + d + w == 2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):",
      "mutated_line": "if d + w > l and (distances[v] + d + w > -2 * l or (u < v and distances[v] + d + w == 2 * l)):",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > -2 * l or (u < v and distances[v] + d + w == 2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):",
      "mutated_line": "if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d - w == 2 * l)):",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d - w == 2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):",
      "mutated_line": "if d + w > l and (distances[v] + d + w > 2 * l or (u < v and (distances[v] + d) * w == 2 * l)):",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > 2 * l or (u < v and (distances[v] + d) * w == 2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):",
      "mutated_line": "if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 / l)):",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 / l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):",
      "mutated_line": "if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 + l)):",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 + l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):",
      "mutated_line": "if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 ** l)):",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 ** l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):",
      "mutated_line": "if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] - d + w == 2 * l)):",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] - d + w == 2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):",
      "mutated_line": "if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] * d + w == 2 * l)):",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] * d + w == 2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):",
      "mutated_line": "if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 3 * l)):",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 3 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):",
      "mutated_line": "if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 1 * l)):",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 1 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):",
      "mutated_line": "if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 0 * l)):",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 0 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):",
      "mutated_line": "if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 1 * l)):",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 1 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == 2 * l)):",
      "mutated_line": "if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == -2 * l)):",
      "code": "def count_missile_silos(n, m, s, roads, l):\n    from collections import defaultdict\n    import heapq\n    graph = defaultdict(list)\n    for (u, v, w) in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    distances = [float('inf')] * (n + 1)\n    distances[s] = 0\n    priority_queue = [(0, s)]\n    while priority_queue:\n        (current_distance, current_node) = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for (neighbor, weight) in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    silo_count = 0\n    for u in range(1, n + 1):\n        d = distances[u]\n        if d < l:\n            for (v, w) in graph[u]:\n                if d + w > l and (distances[v] + d + w > 2 * l or (u < v and distances[v] + d + w == -2 * l)):\n                    silo_count += 1\n        elif d == l:\n            silo_count += 1\n    return silo_count"
    }
  ]
}