{
  "task_id": "taco_10797",
  "entry_point": "calculate_largest_fence_perimeter",
  "mutant_count": 215,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "max_so_far = 0",
      "mutated_line": "max_so_far = 1",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 1\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "max_so_far = 0",
      "mutated_line": "max_so_far = -1",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = -1\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "max_so_far = 0",
      "mutated_line": "max_so_far = 1",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 1\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "next_free_below = [[-1] * n for _ in range(m)]",
      "mutated_line": "next_free_below = [[-1] / n for _ in range(m)]",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] / n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "next_free_below = [[-1] * n for _ in range(m)]",
      "mutated_line": "next_free_below = [[-1] + n for _ in range(m)]",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] + n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "next_free_below = [[-1] * n for _ in range(m)]",
      "mutated_line": "next_free_below = [[-1] ** n for _ in range(m)]",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] ** n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "last_free = m - 1",
      "mutated_line": "last_free = m + 1",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m + 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "last_free = m - 1",
      "mutated_line": "last_free = m * 1",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m * 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "next_free_below[m - 1][i] = -1",
      "mutated_line": "next_free_below[m - 1][i] = +1",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = +1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "next_free_right = [[-1] * n for _ in range(m)]",
      "mutated_line": "next_free_right = [[-1] / n for _ in range(m)]",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] / n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "next_free_right = [[-1] * n for _ in range(m)]",
      "mutated_line": "next_free_right = [[-1] + n for _ in range(m)]",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] + n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "next_free_right = [[-1] * n for _ in range(m)]",
      "mutated_line": "next_free_right = [[-1] ** n for _ in range(m)]",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] ** n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "last_free = n - 1",
      "mutated_line": "last_free = n + 1",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n + 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "last_free = n - 1",
      "mutated_line": "last_free = n * 1",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n * 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "UOI",
      "lineno": 28,
      "original_line": "next_free_right[i][n - 1] = -1",
      "mutated_line": "next_free_right[i][n - 1] = +1",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = +1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "for i1 in range(m - 1):",
      "mutated_line": "for i1 in range(m + 1):",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m + 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "for i1 in range(m - 1):",
      "mutated_line": "for i1 in range(m * 1):",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m * 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return max_so_far if max_so_far else 'impossible'",
      "mutated_line": "return max_so_far if max_so_far else ''",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else ''"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "n = len(grid[0])",
      "mutated_line": "n = len(grid[1])",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[1])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "n = len(grid[0])",
      "mutated_line": "n = len(grid[-1])",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[-1])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "n = len(grid[0])",
      "mutated_line": "n = len(grid[1])",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[1])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "last_free = m - 1",
      "mutated_line": "last_free = m - 2",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 2\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "last_free = m - 1",
      "mutated_line": "last_free = m - 0",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 0\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "last_free = m - 1",
      "mutated_line": "last_free = m - 0",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 0\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "last_free = m - 1",
      "mutated_line": "last_free = m - -1",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - -1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "for j in range(m - 1, -1, -1):",
      "mutated_line": "for j in range(m + 1, -1, -1):",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m + 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "for j in range(m - 1, -1, -1):",
      "mutated_line": "for j in range(m * 1, -1, -1):",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m * 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "UOI",
      "lineno": 12,
      "original_line": "for j in range(m - 1, -1, -1):",
      "mutated_line": "for j in range(m - 1, +1, -1):",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, +1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "UOI",
      "lineno": 12,
      "original_line": "for j in range(m - 1, -1, -1):",
      "mutated_line": "for j in range(m - 1, -1, +1):",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, +1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if land[j][i] == 1:",
      "mutated_line": "if land[j][i] != 1:",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] != 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "next_free_below[m - 1][i] = -1",
      "mutated_line": "next_free_below[m - 1][i] = -2",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -2\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "next_free_below[m - 1][i] = -1",
      "mutated_line": "next_free_below[m - 1][i] = -0",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -0\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "next_free_below[m - 1][i] = -1",
      "mutated_line": "next_free_below[m - 1][i] = -0",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -0\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "next_free_below[m - 1][i] = -1",
      "mutated_line": "next_free_below[m - 1][i] = --1",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = --1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "last_free = n - 1",
      "mutated_line": "last_free = n - 2",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 2\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "last_free = n - 1",
      "mutated_line": "last_free = n - 0",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 0\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "last_free = n - 1",
      "mutated_line": "last_free = n - 0",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 0\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "last_free = n - 1",
      "mutated_line": "last_free = n - -1",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - -1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for j in range(n - 1, -1, -1):",
      "mutated_line": "for j in range(n + 1, -1, -1):",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n + 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for j in range(n - 1, -1, -1):",
      "mutated_line": "for j in range(n * 1, -1, -1):",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n * 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "UOI",
      "lineno": 23,
      "original_line": "for j in range(n - 1, -1, -1):",
      "mutated_line": "for j in range(n - 1, +1, -1):",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, +1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "UOI",
      "lineno": 23,
      "original_line": "for j in range(n - 1, -1, -1):",
      "mutated_line": "for j in range(n - 1, -1, +1):",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, +1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if land[i][j] == 1:",
      "mutated_line": "if land[i][j] != 1:",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] != 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "next_free_right[i][n - 1] = -1",
      "mutated_line": "next_free_right[i][n + 1] = -1",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n + 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "next_free_right[i][n - 1] = -1",
      "mutated_line": "next_free_right[i][n * 1] = -1",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n * 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "next_free_right[i][n - 1] = -1",
      "mutated_line": "next_free_right[i][n - 1] = -2",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -2\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "next_free_right[i][n - 1] = -1",
      "mutated_line": "next_free_right[i][n - 1] = -0",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -0\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "next_free_right[i][n - 1] = -1",
      "mutated_line": "next_free_right[i][n - 1] = -0",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -0\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "next_free_right[i][n - 1] = -1",
      "mutated_line": "next_free_right[i][n - 1] = --1",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = --1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i1 in range(m - 1):",
      "mutated_line": "for i1 in range(m - 2):",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 2):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i1 in range(m - 1):",
      "mutated_line": "for i1 in range(m - 0):",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 0):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i1 in range(m - 1):",
      "mutated_line": "for i1 in range(m - 0):",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 0):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i1 in range(m - 1):",
      "mutated_line": "for i1 in range(m - -1):",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - -1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "for j1 in range(n - 1):",
      "mutated_line": "for j1 in range(n + 1):",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n + 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "for j1 in range(n - 1):",
      "mutated_line": "for j1 in range(n * 1):",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n * 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if land[i1][j1] == 1:",
      "mutated_line": "if land[i1][j1] != 1:",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] != 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "land = [[0 if c == '.' else 1 for c in row] for row in grid]",
      "mutated_line": "land = [[0 if c != '.' else 1 for c in row] for row in grid]",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c != '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "land = [[0 if c == '.' else 1 for c in row] for row in grid]",
      "mutated_line": "land = [[1 if c == '.' else 1 for c in row] for row in grid]",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[1 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "land = [[0 if c == '.' else 1 for c in row] for row in grid]",
      "mutated_line": "land = [[-1 if c == '.' else 1 for c in row] for row in grid]",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[-1 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "land = [[0 if c == '.' else 1 for c in row] for row in grid]",
      "mutated_line": "land = [[1 if c == '.' else 1 for c in row] for row in grid]",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[1 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "land = [[0 if c == '.' else 1 for c in row] for row in grid]",
      "mutated_line": "land = [[0 if c == '.' else 2 for c in row] for row in grid]",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 2 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "land = [[0 if c == '.' else 1 for c in row] for row in grid]",
      "mutated_line": "land = [[0 if c == '.' else 0 for c in row] for row in grid]",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 0 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "land = [[0 if c == '.' else 1 for c in row] for row in grid]",
      "mutated_line": "land = [[0 if c == '.' else 0 for c in row] for row in grid]",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 0 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "land = [[0 if c == '.' else 1 for c in row] for row in grid]",
      "mutated_line": "land = [[0 if c == '.' else -1 for c in row] for row in grid]",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else -1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "UOI",
      "lineno": 9,
      "original_line": "next_free_below = [[-1] * n for _ in range(m)]",
      "mutated_line": "next_free_below = [[+1] * n for _ in range(m)]",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[+1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for j in range(m - 1, -1, -1):",
      "mutated_line": "for j in range(m - 2, -1, -1):",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 2, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for j in range(m - 1, -1, -1):",
      "mutated_line": "for j in range(m - 0, -1, -1):",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 0, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for j in range(m - 1, -1, -1):",
      "mutated_line": "for j in range(m - 0, -1, -1):",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 0, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for j in range(m - 1, -1, -1):",
      "mutated_line": "for j in range(m - -1, -1, -1):",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - -1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for j in range(m - 1, -1, -1):",
      "mutated_line": "for j in range(m - 1, -2, -1):",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -2, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for j in range(m - 1, -1, -1):",
      "mutated_line": "for j in range(m - 1, -0, -1):",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -0, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for j in range(m - 1, -1, -1):",
      "mutated_line": "for j in range(m - 1, -0, -1):",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -0, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for j in range(m - 1, -1, -1):",
      "mutated_line": "for j in range(m - 1, --1, -1):",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, --1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for j in range(m - 1, -1, -1):",
      "mutated_line": "for j in range(m - 1, -1, -2):",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -2):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for j in range(m - 1, -1, -1):",
      "mutated_line": "for j in range(m - 1, -1, -0):",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -0):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for j in range(m - 1, -1, -1):",
      "mutated_line": "for j in range(m - 1, -1, -0):",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -0):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for j in range(m - 1, -1, -1):",
      "mutated_line": "for j in range(m - 1, -1, --1):",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, --1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if land[j][i] == 1:",
      "mutated_line": "if land[j][i] == 2:",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 2:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if land[j][i] == 1:",
      "mutated_line": "if land[j][i] == 0:",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 0:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if land[j][i] == 1:",
      "mutated_line": "if land[j][i] == 0:",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 0:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if land[j][i] == 1:",
      "mutated_line": "if land[j][i] == -1:",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == -1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "last_free = j - 1",
      "mutated_line": "last_free = j + 1",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j + 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "last_free = j - 1",
      "mutated_line": "last_free = j * 1",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j * 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "next_free_below[m - 1][i] = -1",
      "mutated_line": "next_free_below[m + 1][i] = -1",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m + 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "next_free_below[m - 1][i] = -1",
      "mutated_line": "next_free_below[m * 1][i] = -1",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m * 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "UOI",
      "lineno": 20,
      "original_line": "next_free_right = [[-1] * n for _ in range(m)]",
      "mutated_line": "next_free_right = [[+1] * n for _ in range(m)]",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[+1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for j in range(n - 1, -1, -1):",
      "mutated_line": "for j in range(n - 2, -1, -1):",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 2, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for j in range(n - 1, -1, -1):",
      "mutated_line": "for j in range(n - 0, -1, -1):",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 0, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for j in range(n - 1, -1, -1):",
      "mutated_line": "for j in range(n - 0, -1, -1):",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 0, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for j in range(n - 1, -1, -1):",
      "mutated_line": "for j in range(n - -1, -1, -1):",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - -1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for j in range(n - 1, -1, -1):",
      "mutated_line": "for j in range(n - 1, -2, -1):",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -2, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for j in range(n - 1, -1, -1):",
      "mutated_line": "for j in range(n - 1, -0, -1):",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -0, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for j in range(n - 1, -1, -1):",
      "mutated_line": "for j in range(n - 1, -0, -1):",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -0, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for j in range(n - 1, -1, -1):",
      "mutated_line": "for j in range(n - 1, --1, -1):",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, --1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for j in range(n - 1, -1, -1):",
      "mutated_line": "for j in range(n - 1, -1, -2):",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -2):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for j in range(n - 1, -1, -1):",
      "mutated_line": "for j in range(n - 1, -1, -0):",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -0):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for j in range(n - 1, -1, -1):",
      "mutated_line": "for j in range(n - 1, -1, -0):",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -0):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for j in range(n - 1, -1, -1):",
      "mutated_line": "for j in range(n - 1, -1, --1):",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, --1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if land[i][j] == 1:",
      "mutated_line": "if land[i][j] == 2:",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 2:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if land[i][j] == 1:",
      "mutated_line": "if land[i][j] == 0:",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 0:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if land[i][j] == 1:",
      "mutated_line": "if land[i][j] == 0:",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 0:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if land[i][j] == 1:",
      "mutated_line": "if land[i][j] == -1:",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == -1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "last_free = j - 1",
      "mutated_line": "last_free = j + 1",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j + 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "last_free = j - 1",
      "mutated_line": "last_free = j * 1",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j * 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "next_free_right[i][n - 1] = -1",
      "mutated_line": "next_free_right[i][n - 2] = -1",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 2] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "next_free_right[i][n - 1] = -1",
      "mutated_line": "next_free_right[i][n - 0] = -1",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 0] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "next_free_right[i][n - 1] = -1",
      "mutated_line": "next_free_right[i][n - 0] = -1",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 0] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "next_free_right[i][n - 1] = -1",
      "mutated_line": "next_free_right[i][n - -1] = -1",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - -1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for j1 in range(n - 1):",
      "mutated_line": "for j1 in range(n - 2):",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 2):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for j1 in range(n - 1):",
      "mutated_line": "for j1 in range(n - 0):",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 0):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for j1 in range(n - 1):",
      "mutated_line": "for j1 in range(n - 0):",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 0):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for j1 in range(n - 1):",
      "mutated_line": "for j1 in range(n - -1):",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - -1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if land[i1][j1] == 1:",
      "mutated_line": "if land[i1][j1] == 2:",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 2:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if land[i1][j1] == 1:",
      "mutated_line": "if land[i1][j1] == 0:",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 0:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if land[i1][j1] == 1:",
      "mutated_line": "if land[i1][j1] == 0:",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 0:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if land[i1][j1] == 1:",
      "mutated_line": "if land[i1][j1] == -1:",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == -1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "UOI",
      "lineno": 35,
      "original_line": "for i2 in range(next_free_below[i1][j1], i1, -1):",
      "mutated_line": "for i2 in range(next_free_below[i1][j1], i1, +1):",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, +1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:",
      "mutated_line": "if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) <= max_so_far:",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) <= max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:",
      "mutated_line": "if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) >= max_so_far:",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) >= max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:",
      "mutated_line": "if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) != max_so_far:",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) != max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "land = [[0 if c == '.' else 1 for c in row] for row in grid]",
      "mutated_line": "land = [[0 if c == '' else 1 for c in row] for row in grid]",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "next_free_below = [[-1] * n for _ in range(m)]",
      "mutated_line": "next_free_below = [[-2] * n for _ in range(m)]",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-2] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "next_free_below = [[-1] * n for _ in range(m)]",
      "mutated_line": "next_free_below = [[-0] * n for _ in range(m)]",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-0] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "next_free_below = [[-1] * n for _ in range(m)]",
      "mutated_line": "next_free_below = [[-0] * n for _ in range(m)]",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-0] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "next_free_below = [[-1] * n for _ in range(m)]",
      "mutated_line": "next_free_below = [[--1] * n for _ in range(m)]",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[--1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "last_free = j - 1",
      "mutated_line": "last_free = j - 2",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 2\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "last_free = j - 1",
      "mutated_line": "last_free = j - 0",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 0\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "last_free = j - 1",
      "mutated_line": "last_free = j - 0",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 0\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "last_free = j - 1",
      "mutated_line": "last_free = j - -1",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - -1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "next_free_below[m - 1][i] = -1",
      "mutated_line": "next_free_below[m - 2][i] = -1",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 2][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "next_free_below[m - 1][i] = -1",
      "mutated_line": "next_free_below[m - 0][i] = -1",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 0][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "next_free_below[m - 1][i] = -1",
      "mutated_line": "next_free_below[m - 0][i] = -1",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 0][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "next_free_below[m - 1][i] = -1",
      "mutated_line": "next_free_below[m - -1][i] = -1",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - -1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "next_free_right = [[-1] * n for _ in range(m)]",
      "mutated_line": "next_free_right = [[-2] * n for _ in range(m)]",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-2] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "next_free_right = [[-1] * n for _ in range(m)]",
      "mutated_line": "next_free_right = [[-0] * n for _ in range(m)]",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-0] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "next_free_right = [[-1] * n for _ in range(m)]",
      "mutated_line": "next_free_right = [[-0] * n for _ in range(m)]",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-0] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "next_free_right = [[-1] * n for _ in range(m)]",
      "mutated_line": "next_free_right = [[--1] * n for _ in range(m)]",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[--1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "last_free = j - 1",
      "mutated_line": "last_free = j - 2",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 2\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "last_free = j - 1",
      "mutated_line": "last_free = j - 0",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 0\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "last_free = j - 1",
      "mutated_line": "last_free = j - 0",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 0\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "last_free = j - 1",
      "mutated_line": "last_free = j - -1",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - -1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for i2 in range(next_free_below[i1][j1], i1, -1):",
      "mutated_line": "for i2 in range(next_free_below[i1][j1], i1, -2):",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -2):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for i2 in range(next_free_below[i1][j1], i1, -1):",
      "mutated_line": "for i2 in range(next_free_below[i1][j1], i1, -0):",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -0):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for i2 in range(next_free_below[i1][j1], i1, -1):",
      "mutated_line": "for i2 in range(next_free_below[i1][j1], i1, -0):",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -0):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for i2 in range(next_free_below[i1][j1], i1, -1):",
      "mutated_line": "for i2 in range(next_free_below[i1][j1], i1, --1):",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, --1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:",
      "mutated_line": "if 2 * (i2 - i1) - 2 * (next_free_right[i1][j1] - j1) < max_so_far:",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) - 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:",
      "mutated_line": "if 2 * (i2 - i1) * (2 * (next_free_right[i1][j1] - j1)) < max_so_far:",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) * (2 * (next_free_right[i1][j1] - j1)) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "UOI",
      "lineno": 38,
      "original_line": "for j2 in range(next_free_right[i1][j1], j1, -1):",
      "mutated_line": "for j2 in range(next_free_right[i1][j1], j1, +1):",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, +1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "LCR",
      "lineno": 39,
      "original_line": "if (land[i1][j1] == 0 and land[i2][j2] == 0 and",
      "mutated_line": "if land[i1][j1] == 0 or land[i2][j2] == 0 or next_free_below[i1][j1] >= i2 or (next_free_right[i1][j1] >= j2) or (next_free_below[i1][j2] >= i2) or (next_free_right[i2][j1] >= j2):",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 or land[i2][j2] == 0 or next_free_below[i1][j1] >= i2 or (next_free_right[i1][j1] >= j2) or (next_free_below[i1][j2] >= i2) or (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:",
      "mutated_line": "if 2 / (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 / (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:",
      "mutated_line": "if 2 + (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 + (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:",
      "mutated_line": "if 2 ** (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 ** (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:",
      "mutated_line": "if 2 * (i2 - i1) + 2 / (next_free_right[i1][j1] - j1) < max_so_far:",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 / (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:",
      "mutated_line": "if 2 * (i2 - i1) + (2 + (next_free_right[i1][j1] - j1)) < max_so_far:",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + (2 + (next_free_right[i1][j1] - j1)) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:",
      "mutated_line": "if 2 * (i2 - i1) + 2 ** (next_free_right[i1][j1] - j1) < max_so_far:",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 ** (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for j2 in range(next_free_right[i1][j1], j1, -1):",
      "mutated_line": "for j2 in range(next_free_right[i1][j1], j1, -2):",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -2):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for j2 in range(next_free_right[i1][j1], j1, -1):",
      "mutated_line": "for j2 in range(next_free_right[i1][j1], j1, -0):",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -0):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for j2 in range(next_free_right[i1][j1], j1, -1):",
      "mutated_line": "for j2 in range(next_free_right[i1][j1], j1, -0):",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -0):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for j2 in range(next_free_right[i1][j1], j1, -1):",
      "mutated_line": "for j2 in range(next_free_right[i1][j1], j1, --1):",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, --1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if (land[i1][j1] == 0 and land[i2][j2] == 0 and",
      "mutated_line": "if land[i1][j1] != 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] != 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if (land[i1][j1] == 0 and land[i2][j2] == 0 and",
      "mutated_line": "if land[i1][j1] == 0 and land[i2][j2] != 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] != 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "next_free_below[i1][j1] >= i2 and",
      "mutated_line": "if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] > i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] > i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "next_free_below[i1][j1] >= i2 and",
      "mutated_line": "if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] < i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] < i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "next_free_below[i1][j1] >= i2 and",
      "mutated_line": "if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] == i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] == i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "next_free_right[i1][j1] >= j2 and",
      "mutated_line": "if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] > j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] > j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "next_free_right[i1][j1] >= j2 and",
      "mutated_line": "if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] < j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] < j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "next_free_right[i1][j1] >= j2 and",
      "mutated_line": "if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] == j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] == j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "next_free_below[i1][j2] >= i2 and",
      "mutated_line": "if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] > i2) and (next_free_right[i2][j1] >= j2):",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] > i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "next_free_below[i1][j2] >= i2 and",
      "mutated_line": "if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] < i2) and (next_free_right[i2][j1] >= j2):",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] < i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "next_free_below[i1][j2] >= i2 and",
      "mutated_line": "if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] == i2) and (next_free_right[i2][j1] >= j2):",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] == i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "next_free_right[i2][j1] >= j2):",
      "mutated_line": "if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] > j2):",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] > j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "next_free_right[i2][j1] >= j2):",
      "mutated_line": "if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] < j2):",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] < j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "next_free_right[i2][j1] >= j2):",
      "mutated_line": "if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] == j2):",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] == j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:",
      "mutated_line": "if 3 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 3 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:",
      "mutated_line": "if 1 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 1 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:",
      "mutated_line": "if 0 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 0 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:",
      "mutated_line": "if 1 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 1 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:",
      "mutated_line": "if -2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if -2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:",
      "mutated_line": "if 2 * (i2 + i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 + i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:",
      "mutated_line": "if 2 * (i2 * i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 * i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:",
      "mutated_line": "if 2 * (i2 - i1) + 3 * (next_free_right[i1][j1] - j1) < max_so_far:",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 3 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:",
      "mutated_line": "if 2 * (i2 - i1) + 1 * (next_free_right[i1][j1] - j1) < max_so_far:",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 1 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:",
      "mutated_line": "if 2 * (i2 - i1) + 0 * (next_free_right[i1][j1] - j1) < max_so_far:",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 0 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:",
      "mutated_line": "if 2 * (i2 - i1) + 1 * (next_free_right[i1][j1] - j1) < max_so_far:",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 1 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:",
      "mutated_line": "if 2 * (i2 - i1) + -2 * (next_free_right[i1][j1] - j1) < max_so_far:",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + -2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:",
      "mutated_line": "if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] + j1) < max_so_far:",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] + j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:",
      "mutated_line": "if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] * j1) < max_so_far:",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] * j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if (land[i1][j1] == 0 and land[i2][j2] == 0 and",
      "mutated_line": "if land[i1][j1] == 1 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 1 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if (land[i1][j1] == 0 and land[i2][j2] == 0 and",
      "mutated_line": "if land[i1][j1] == -1 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == -1 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if (land[i1][j1] == 0 and land[i2][j2] == 0 and",
      "mutated_line": "if land[i1][j1] == 1 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 1 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if (land[i1][j1] == 0 and land[i2][j2] == 0 and",
      "mutated_line": "if land[i1][j1] == 0 and land[i2][j2] == 1 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 1 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if (land[i1][j1] == 0 and land[i2][j2] == 0 and",
      "mutated_line": "if land[i1][j1] == 0 and land[i2][j2] == -1 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == -1 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if (land[i1][j1] == 0 and land[i2][j2] == 0 and",
      "mutated_line": "if land[i1][j1] == 0 and land[i2][j2] == 1 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 1 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))",
      "mutated_line": "max_so_far = max(max_so_far, 2 * (i2 - i1) - 2 * (j2 - j1))",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) - 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))",
      "mutated_line": "max_so_far = max(max_so_far, 2 * (i2 - i1) * (2 * (j2 - j1)))",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) * (2 * (j2 - j1)))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))",
      "mutated_line": "max_so_far = max(max_so_far, 2 / (i2 - i1) + 2 * (j2 - j1))",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 / (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))",
      "mutated_line": "max_so_far = max(max_so_far, 2 + (i2 - i1) + 2 * (j2 - j1))",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 + (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))",
      "mutated_line": "max_so_far = max(max_so_far, 2 ** (i2 - i1) + 2 * (j2 - j1))",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 ** (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))",
      "mutated_line": "max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 / (j2 - j1))",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 / (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))",
      "mutated_line": "max_so_far = max(max_so_far, 2 * (i2 - i1) + (2 + (j2 - j1)))",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + (2 + (j2 - j1)))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))",
      "mutated_line": "max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 ** (j2 - j1))",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 ** (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))",
      "mutated_line": "max_so_far = max(max_so_far, 3 * (i2 - i1) + 2 * (j2 - j1))",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 3 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))",
      "mutated_line": "max_so_far = max(max_so_far, 1 * (i2 - i1) + 2 * (j2 - j1))",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 1 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))",
      "mutated_line": "max_so_far = max(max_so_far, 0 * (i2 - i1) + 2 * (j2 - j1))",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 0 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))",
      "mutated_line": "max_so_far = max(max_so_far, 1 * (i2 - i1) + 2 * (j2 - j1))",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 1 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))",
      "mutated_line": "max_so_far = max(max_so_far, -2 * (i2 - i1) + 2 * (j2 - j1))",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, -2 * (i2 - i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))",
      "mutated_line": "max_so_far = max(max_so_far, 2 * (i2 + i1) + 2 * (j2 - j1))",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 + i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))",
      "mutated_line": "max_so_far = max(max_so_far, 2 * (i2 * i1) + 2 * (j2 - j1))",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 * i1) + 2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))",
      "mutated_line": "max_so_far = max(max_so_far, 2 * (i2 - i1) + 3 * (j2 - j1))",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 3 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))",
      "mutated_line": "max_so_far = max(max_so_far, 2 * (i2 - i1) + 1 * (j2 - j1))",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 1 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))",
      "mutated_line": "max_so_far = max(max_so_far, 2 * (i2 - i1) + 0 * (j2 - j1))",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 0 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))",
      "mutated_line": "max_so_far = max(max_so_far, 2 * (i2 - i1) + 1 * (j2 - j1))",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 1 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))",
      "mutated_line": "max_so_far = max(max_so_far, 2 * (i2 - i1) + -2 * (j2 - j1))",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + -2 * (j2 - j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))",
      "mutated_line": "max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 + j1))",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 + j1))\n    return max_so_far if max_so_far else 'impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 - j1))",
      "mutated_line": "max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 * j1))",
      "code": "def calculate_largest_fence_perimeter(grid):\n    m = len(grid)\n    n = len(grid[0])\n    land = [[0 if c == '.' else 1 for c in row] for row in grid]\n    next_free_below = [[-1] * n for _ in range(m)]\n    for i in range(n):\n        last_free = m - 1\n        for j in range(m - 1, -1, -1):\n            if land[j][i] == 1:\n                last_free = j - 1\n            else:\n                next_free_below[j][i] = last_free\n        next_free_below[m - 1][i] = -1\n    next_free_right = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        last_free = n - 1\n        for j in range(n - 1, -1, -1):\n            if land[i][j] == 1:\n                last_free = j - 1\n            else:\n                next_free_right[i][j] = last_free\n        next_free_right[i][n - 1] = -1\n    max_so_far = 0\n    for i1 in range(m - 1):\n        for j1 in range(n - 1):\n            if land[i1][j1] == 1:\n                continue\n            for i2 in range(next_free_below[i1][j1], i1, -1):\n                if 2 * (i2 - i1) + 2 * (next_free_right[i1][j1] - j1) < max_so_far:\n                    continue\n                for j2 in range(next_free_right[i1][j1], j1, -1):\n                    if land[i1][j1] == 0 and land[i2][j2] == 0 and (next_free_below[i1][j1] >= i2) and (next_free_right[i1][j1] >= j2) and (next_free_below[i1][j2] >= i2) and (next_free_right[i2][j1] >= j2):\n                        max_so_far = max(max_so_far, 2 * (i2 - i1) + 2 * (j2 * j1))\n    return max_so_far if max_so_far else 'impossible'"
    }
  ]
}