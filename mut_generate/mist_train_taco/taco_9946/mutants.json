{
  "task_id": "taco_9946",
  "entry_point": "find_min_edges_for_odd_cycle",
  "mutant_count": 160,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if m == 0:",
      "mutated_line": "if m != 0:",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m != 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 1\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = -1\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 1\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "ASR",
      "lineno": 25,
      "original_line": "ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2",
      "mutated_line": "ans -= (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans -= (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if m == 0:",
      "mutated_line": "if m == 1:",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 1:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if m == 0:",
      "mutated_line": "if m == -1:",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == -1:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if m == 0:",
      "mutated_line": "if m == 1:",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 1:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "elif max((len(E[v]) for v in E)) == 1:",
      "mutated_line": "elif max((len(E[v]) for v in E)) != 1:",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) != 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "E[u - 1].append(v - 1)",
      "mutated_line": "E[u - 1].append(v + 1)",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v + 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "E[u - 1].append(v - 1)",
      "mutated_line": "E[u - 1].append(v * 1)",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v * 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "E[v - 1].append(u - 1)",
      "mutated_line": "E[v - 1].append(u + 1)",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u + 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "E[v - 1].append(u - 1)",
      "mutated_line": "E[v - 1].append(u * 1)",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u * 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "visited = [False for _ in range(n)]",
      "mutated_line": "visited = [True for _ in range(n)]",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [True for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "colour = [0 for _ in range(n)]",
      "mutated_line": "colour = [1 for _ in range(n)]",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [1 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "colour = [0 for _ in range(n)]",
      "mutated_line": "colour = [-1 for _ in range(n)]",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [-1 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "colour = [0 for _ in range(n)]",
      "mutated_line": "colour = [1 for _ in range(n)]",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [1 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2",
      "mutated_line": "ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) / 2",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) / 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2",
      "mutated_line": "ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) * 2",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) * 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return (1, ans)",
      "mutated_line": "return (2, ans)",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (2, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return (1, ans)",
      "mutated_line": "return (0, ans)",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (0, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return (1, ans)",
      "mutated_line": "return (0, ans)",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (0, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return (1, ans)",
      "mutated_line": "return (-1, ans)",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (-1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return (3, n * (n - 1) * (n - 2) // 6)",
      "mutated_line": "return (4, n * (n - 1) * (n - 2) // 6)",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (4, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return (3, n * (n - 1) * (n - 2) // 6)",
      "mutated_line": "return (2, n * (n - 1) * (n - 2) // 6)",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (2, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return (3, n * (n - 1) * (n - 2) // 6)",
      "mutated_line": "return (0, n * (n - 1) * (n - 2) // 6)",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (0, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return (3, n * (n - 1) * (n - 2) // 6)",
      "mutated_line": "return (1, n * (n - 1) * (n - 2) // 6)",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (1, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return (3, n * (n - 1) * (n - 2) // 6)",
      "mutated_line": "return (-3, n * (n - 1) * (n - 2) // 6)",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (-3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return (3, n * (n - 1) * (n - 2) // 6)",
      "mutated_line": "return (3, n * (n - 1) * (n - 2) / 6)",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) / 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return (3, n * (n - 1) * (n - 2) // 6)",
      "mutated_line": "return (3, n * (n - 1) * (n - 2) * 6)",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) * 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "elif max((len(E[v]) for v in E)) == 1:",
      "mutated_line": "elif max((len(E[v]) for v in E)) == 2:",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 2:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "elif max((len(E[v]) for v in E)) == 1:",
      "mutated_line": "elif max((len(E[v]) for v in E)) == 0:",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 0:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "elif max((len(E[v]) for v in E)) == 1:",
      "mutated_line": "elif max((len(E[v]) for v in E)) == 0:",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 0:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "elif max((len(E[v]) for v in E)) == 1:",
      "mutated_line": "elif max((len(E[v]) for v in E)) == -1:",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == -1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "E[u - 1].append(v - 1)",
      "mutated_line": "E[u - 1].append(v - 2)",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 2)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "E[u - 1].append(v - 1)",
      "mutated_line": "E[u - 1].append(v - 0)",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 0)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "E[u - 1].append(v - 1)",
      "mutated_line": "E[u - 1].append(v - 0)",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 0)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "E[u - 1].append(v - 1)",
      "mutated_line": "E[u - 1].append(v - -1)",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - -1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "E[v - 1].append(u - 1)",
      "mutated_line": "E[v - 1].append(u - 2)",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 2)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "E[v - 1].append(u - 1)",
      "mutated_line": "E[v - 1].append(u - 0)",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 0)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "E[v - 1].append(u - 1)",
      "mutated_line": "E[v - 1].append(u - 0)",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 0)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "E[v - 1].append(u - 1)",
      "mutated_line": "E[v - 1].append(u - -1)",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - -1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "part = [0, 0]",
      "mutated_line": "part = [1, 0]",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [1, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "part = [0, 0]",
      "mutated_line": "part = [-1, 0]",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [-1, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "part = [0, 0]",
      "mutated_line": "part = [1, 0]",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [1, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "part = [0, 0]",
      "mutated_line": "part = [0, 1]",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 1]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "part = [0, 0]",
      "mutated_line": "part = [0, -1]",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, -1]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "part = [0, 0]",
      "mutated_line": "part = [0, 1]",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 1]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "ASR",
      "lineno": 19,
      "original_line": "part[c] += 1",
      "mutated_line": "part[c] -= 1",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] -= 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2",
      "mutated_line": "ans += (part[0] * (part[0] - 1) - part[1] * (part[1] - 1)) // 2",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) - part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2",
      "mutated_line": "ans += part[0] * (part[0] - 1) * (part[1] * (part[1] - 1)) // 2",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += part[0] * (part[0] - 1) * (part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2",
      "mutated_line": "ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 3",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 3\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2",
      "mutated_line": "ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 1",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 1\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2",
      "mutated_line": "ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 0",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 0\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2",
      "mutated_line": "ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 1",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 1\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2",
      "mutated_line": "ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // -2",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // -2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return (3, n * (n - 1) * (n - 2) // 6)",
      "mutated_line": "return (3, n * (n - 1) / (n - 2) // 6)",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) / (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return (3, n * (n - 1) * (n - 2) // 6)",
      "mutated_line": "return (3, (n * (n - 1) + (n - 2)) // 6)",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, (n * (n - 1) + (n - 2)) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return (3, n * (n - 1) * (n - 2) // 6)",
      "mutated_line": "return (3, (n * (n - 1)) ** (n - 2) // 6)",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, (n * (n - 1)) ** (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return (3, n * (n - 1) * (n - 2) // 6)",
      "mutated_line": "return (3, n * (n - 1) * (n - 2) // 7)",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 7)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return (3, n * (n - 1) * (n - 2) // 6)",
      "mutated_line": "return (3, n * (n - 1) * (n - 2) // 5)",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 5)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return (3, n * (n - 1) * (n - 2) // 6)",
      "mutated_line": "return (3, n * (n - 1) * (n - 2) // 0)",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 0)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return (3, n * (n - 1) * (n - 2) // 6)",
      "mutated_line": "return (3, n * (n - 1) * (n - 2) // 1)",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 1)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return (3, n * (n - 1) * (n - 2) // 6)",
      "mutated_line": "return (3, n * (n - 1) * (n - 2) // -6)",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // -6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (2, m * (n - 2))",
      "mutated_line": "return (3, m * (n - 2))",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (3, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (2, m * (n - 2))",
      "mutated_line": "return (1, m * (n - 2))",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (1, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (2, m * (n - 2))",
      "mutated_line": "return (0, m * (n - 2))",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (0, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (2, m * (n - 2))",
      "mutated_line": "return (1, m * (n - 2))",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (1, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (2, m * (n - 2))",
      "mutated_line": "return (-2, m * (n - 2))",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (-2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "return (2, m * (n - 2))",
      "mutated_line": "return (2, m / (n - 2))",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m / (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "return (2, m * (n - 2))",
      "mutated_line": "return (2, m + (n - 2))",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m + (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "return (2, m * (n - 2))",
      "mutated_line": "return (2, m ** (n - 2))",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m ** (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "E[u - 1].append(v - 1)",
      "mutated_line": "E[u + 1].append(v - 1)",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u + 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "E[u - 1].append(v - 1)",
      "mutated_line": "E[u * 1].append(v - 1)",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u * 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "E[v - 1].append(u - 1)",
      "mutated_line": "E[v + 1].append(u - 1)",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v + 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "E[v - 1].append(u - 1)",
      "mutated_line": "E[v * 1].append(u - 1)",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v * 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "stack = [(v, 0)]",
      "mutated_line": "stack = [(v, 1)]",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 1)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "stack = [(v, 0)]",
      "mutated_line": "stack = [(v, -1)]",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, -1)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "stack = [(v, 0)]",
      "mutated_line": "stack = [(v, 1)]",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 1)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "part[c] += 1",
      "mutated_line": "part[c] += 2",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 2\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "part[c] += 1",
      "mutated_line": "part[c] += 0",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 0\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "part[c] += 1",
      "mutated_line": "part[c] += 0",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 0\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "part[c] += 1",
      "mutated_line": "part[c] += -1",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += -1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "visited[node] = True",
      "mutated_line": "visited[node] = False",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = False\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "elif c != colour[node]:",
      "mutated_line": "elif c == colour[node]:",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c == colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2",
      "mutated_line": "ans += (part[0] / (part[0] - 1) + part[1] * (part[1] - 1)) // 2",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] / (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2",
      "mutated_line": "ans += (part[0] + (part[0] - 1) + part[1] * (part[1] - 1)) // 2",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] + (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2",
      "mutated_line": "ans += (part[0] ** (part[0] - 1) + part[1] * (part[1] - 1)) // 2",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] ** (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2",
      "mutated_line": "ans += (part[0] * (part[0] - 1) + part[1] / (part[1] - 1)) // 2",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] / (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2",
      "mutated_line": "ans += (part[0] * (part[0] - 1) + (part[1] + (part[1] - 1))) // 2",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + (part[1] + (part[1] - 1))) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2",
      "mutated_line": "ans += (part[0] * (part[0] - 1) + part[1] ** (part[1] - 1)) // 2",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] ** (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return (3, n * (n - 1) * (n - 2) // 6)",
      "mutated_line": "return (3, n / (n - 1) * (n - 2) // 6)",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n / (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return (3, n * (n - 1) * (n - 2) // 6)",
      "mutated_line": "return (3, (n + (n - 1)) * (n - 2) // 6)",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, (n + (n - 1)) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return (3, n * (n - 1) * (n - 2) // 6)",
      "mutated_line": "return (3, n ** (n - 1) * (n - 2) // 6)",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n ** (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return (3, n * (n - 1) * (n - 2) // 6)",
      "mutated_line": "return (3, n * (n - 1) * (n + 2) // 6)",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n + 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return (3, n * (n - 1) * (n - 2) // 6)",
      "mutated_line": "return (3, n * (n - 1) * (n * 2) // 6)",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n * 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "return (2, m * (n - 2))",
      "mutated_line": "return (2, m * (n + 2))",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n + 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "return (2, m * (n - 2))",
      "mutated_line": "return (2, m * (n * 2))",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n * 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "E[u - 1].append(v - 1)",
      "mutated_line": "E[u - 2].append(v - 1)",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 2].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "E[u - 1].append(v - 1)",
      "mutated_line": "E[u - 0].append(v - 1)",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 0].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "E[u - 1].append(v - 1)",
      "mutated_line": "E[u - 0].append(v - 1)",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 0].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "E[u - 1].append(v - 1)",
      "mutated_line": "E[u - -1].append(v - 1)",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - -1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "E[v - 1].append(u - 1)",
      "mutated_line": "E[v - 2].append(u - 1)",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 2].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "E[v - 1].append(u - 1)",
      "mutated_line": "E[v - 0].append(u - 1)",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 0].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "E[v - 1].append(u - 1)",
      "mutated_line": "E[v - 0].append(u - 1)",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 0].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "E[v - 1].append(u - 1)",
      "mutated_line": "E[v - -1].append(u - 1)",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - -1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2",
      "mutated_line": "ans += (part[0] * (part[0] + 1) + part[1] * (part[1] - 1)) // 2",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] + 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2",
      "mutated_line": "ans += (part[0] * (part[0] * 1) + part[1] * (part[1] - 1)) // 2",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] * 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2",
      "mutated_line": "ans += (part[0] * (part[0] - 1) + part[1] * (part[1] + 1)) // 2",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] + 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2",
      "mutated_line": "ans += (part[0] * (part[0] - 1) + part[1] * (part[1] * 1)) // 2",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] * 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return (3, n * (n - 1) * (n - 2) // 6)",
      "mutated_line": "return (3, n * (n + 1) * (n - 2) // 6)",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n + 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return (3, n * (n - 1) * (n - 2) // 6)",
      "mutated_line": "return (3, n * (n * 1) * (n - 2) // 6)",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n * 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return (3, n * (n - 1) * (n - 2) // 6)",
      "mutated_line": "return (3, n * (n - 1) * (n - 3) // 6)",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 3) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return (3, n * (n - 1) * (n - 2) // 6)",
      "mutated_line": "return (3, n * (n - 1) * (n - 1) // 6)",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 1) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return (3, n * (n - 1) * (n - 2) // 6)",
      "mutated_line": "return (3, n * (n - 1) * (n - 0) // 6)",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 0) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return (3, n * (n - 1) * (n - 2) // 6)",
      "mutated_line": "return (3, n * (n - 1) * (n - 1) // 6)",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 1) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return (3, n * (n - 1) * (n - 2) // 6)",
      "mutated_line": "return (3, n * (n - 1) * (n - -2) // 6)",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - -2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (2, m * (n - 2))",
      "mutated_line": "return (2, m * (n - 3))",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 3))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (2, m * (n - 2))",
      "mutated_line": "return (2, m * (n - 1))",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 1))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (2, m * (n - 2))",
      "mutated_line": "return (2, m * (n - 0))",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 0))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (2, m * (n - 2))",
      "mutated_line": "return (2, m * (n - 1))",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 1))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (2, m * (n - 2))",
      "mutated_line": "return (2, m * (n - -2))",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - -2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return (0, 1)",
      "mutated_line": "return (1, 1)",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (1, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return (0, 1)",
      "mutated_line": "return (-1, 1)",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (-1, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return (0, 1)",
      "mutated_line": "return (1, 1)",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (1, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return (0, 1)",
      "mutated_line": "return (0, 2)",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 2)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return (0, 1)",
      "mutated_line": "return (0, 0)",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 0)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return (0, 1)",
      "mutated_line": "return (0, 0)",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 0)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return (0, 1)",
      "mutated_line": "return (0, -1)",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, -1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2",
      "mutated_line": "ans += (part[1] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[1] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2",
      "mutated_line": "ans += (part[-1] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[-1] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2",
      "mutated_line": "ans += (part[1] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[1] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2",
      "mutated_line": "ans += (part[0] * (part[0] - 2) + part[1] * (part[1] - 1)) // 2",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 2) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2",
      "mutated_line": "ans += (part[0] * (part[0] - 0) + part[1] * (part[1] - 1)) // 2",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 0) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2",
      "mutated_line": "ans += (part[0] * (part[0] - 0) + part[1] * (part[1] - 1)) // 2",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 0) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2",
      "mutated_line": "ans += (part[0] * (part[0] - -1) + part[1] * (part[1] - 1)) // 2",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - -1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2",
      "mutated_line": "ans += (part[0] * (part[0] - 1) + part[2] * (part[1] - 1)) // 2",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[2] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2",
      "mutated_line": "ans += (part[0] * (part[0] - 1) + part[0] * (part[1] - 1)) // 2",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[0] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2",
      "mutated_line": "ans += (part[0] * (part[0] - 1) + part[0] * (part[1] - 1)) // 2",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[0] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2",
      "mutated_line": "ans += (part[0] * (part[0] - 1) + part[-1] * (part[1] - 1)) // 2",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[-1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2",
      "mutated_line": "ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 2)) // 2",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 2)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2",
      "mutated_line": "ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 0)) // 2",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 0)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2",
      "mutated_line": "ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 0)) // 2",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 0)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2",
      "mutated_line": "ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - -1)) // 2",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - -1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return (3, n * (n - 1) * (n - 2) // 6)",
      "mutated_line": "return (3, n * (n - 2) * (n - 2) // 6)",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 2) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return (3, n * (n - 1) * (n - 2) // 6)",
      "mutated_line": "return (3, n * (n - 0) * (n - 2) // 6)",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 0) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return (3, n * (n - 1) * (n - 2) // 6)",
      "mutated_line": "return (3, n * (n - 0) * (n - 2) // 6)",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 0) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return (3, n * (n - 1) * (n - 2) // 6)",
      "mutated_line": "return (3, n * (n - -1) * (n - 2) // 6)",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - -1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "stack.extend(((u, c ^ 1) for u in E[node]))",
      "mutated_line": "stack.extend(((u, c | 1) for u in E[node]))",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c | 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2",
      "mutated_line": "ans += (part[0] * (part[1] - 1) + part[1] * (part[1] - 1)) // 2",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[1] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2",
      "mutated_line": "ans += (part[0] * (part[-1] - 1) + part[1] * (part[1] - 1)) // 2",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[-1] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2",
      "mutated_line": "ans += (part[0] * (part[1] - 1) + part[1] * (part[1] - 1)) // 2",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[1] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2",
      "mutated_line": "ans += (part[0] * (part[0] - 1) + part[1] * (part[2] - 1)) // 2",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[2] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2",
      "mutated_line": "ans += (part[0] * (part[0] - 1) + part[1] * (part[0] - 1)) // 2",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[0] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2",
      "mutated_line": "ans += (part[0] * (part[0] - 1) + part[1] * (part[0] - 1)) // 2",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[0] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2",
      "mutated_line": "ans += (part[0] * (part[0] - 1) + part[1] * (part[-1] - 1)) // 2",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[-1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "stack.extend(((u, c ^ 1) for u in E[node]))",
      "mutated_line": "stack.extend(((u, c ^ 2) for u in E[node]))",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 2) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "stack.extend(((u, c ^ 1) for u in E[node]))",
      "mutated_line": "stack.extend(((u, c ^ 0) for u in E[node]))",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 0) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "stack.extend(((u, c ^ 1) for u in E[node]))",
      "mutated_line": "stack.extend(((u, c ^ 0) for u in E[node]))",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ 0) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "stack.extend(((u, c ^ 1) for u in E[node]))",
      "mutated_line": "stack.extend(((u, c ^ -1) for u in E[node]))",
      "code": "def find_min_edges_for_odd_cycle(n, m, edges):\n    E = {i: [] for i in range(n)}\n    for (u, v) in edges:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs():\n        visited = [False for _ in range(n)]\n        colour = [0 for _ in range(n)]\n        ans = 0\n        for v in range(n):\n            if visited[v]:\n                continue\n            stack = [(v, 0)]\n            part = [0, 0]\n            while stack:\n                (node, c) = stack.pop()\n                if not visited[node]:\n                    part[c] += 1\n                    visited[node] = True\n                    colour[node] = c\n                    stack.extend(((u, c ^ -1) for u in E[node]))\n                elif c != colour[node]:\n                    return (0, 1)\n            ans += (part[0] * (part[0] - 1) + part[1] * (part[1] - 1)) // 2\n        return (1, ans)\n    if m == 0:\n        return (3, n * (n - 1) * (n - 2) // 6)\n    elif max((len(E[v]) for v in E)) == 1:\n        return (2, m * (n - 2))\n    else:\n        return dfs()"
    }
  ]
}