{
  "task_id": "taco_53",
  "entry_point": "shortest_reach",
  "mutant_count": 59,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 9,
      "original_line": "x -= 1  # Convert to 0-based index",
      "mutated_line": "x += 1",
      "code": "import heapq\n\ndef shortest_reach(n, edges, start_node):\n    graph = [{} for _ in range(n)]\n    for (x, y, r) in edges:\n        x += 1\n        y -= 1\n        if y not in graph[x]:\n            graph[x][y] = r\n        else:\n            graph[x][y] = min(graph[x][y], r)\n        if x not in graph[y]:\n            graph[y][x] = r\n        else:\n            graph[y][x] = min(graph[y][x], r)\n    dist = [-1] * n\n    visited = [False] * n\n    pq = [(0, start_node - 1)]\n    dist[start_node - 1] = 0\n    while pq:\n        (mindist, minv) = heapq.heappop(pq)\n        if not visited[minv]:\n            for (neighbor, weight) in graph[minv].items():\n                if dist[neighbor] == -1:\n                    dist[neighbor] = mindist + weight\n                else:\n                    dist[neighbor] = min(dist[neighbor], mindist + weight)\n                heapq.heappush(pq, (dist[neighbor], neighbor))\n            visited[minv] = True\n    del dist[start_node - 1]\n    return dist"
    },
    {
      "operator": "ASR",
      "lineno": 10,
      "original_line": "y -= 1  # Convert to 0-based index",
      "mutated_line": "y += 1",
      "code": "import heapq\n\ndef shortest_reach(n, edges, start_node):\n    graph = [{} for _ in range(n)]\n    for (x, y, r) in edges:\n        x -= 1\n        y += 1\n        if y not in graph[x]:\n            graph[x][y] = r\n        else:\n            graph[x][y] = min(graph[x][y], r)\n        if x not in graph[y]:\n            graph[y][x] = r\n        else:\n            graph[y][x] = min(graph[y][x], r)\n    dist = [-1] * n\n    visited = [False] * n\n    pq = [(0, start_node - 1)]\n    dist[start_node - 1] = 0\n    while pq:\n        (mindist, minv) = heapq.heappop(pq)\n        if not visited[minv]:\n            for (neighbor, weight) in graph[minv].items():\n                if dist[neighbor] == -1:\n                    dist[neighbor] = mindist + weight\n                else:\n                    dist[neighbor] = min(dist[neighbor], mindist + weight)\n                heapq.heappush(pq, (dist[neighbor], neighbor))\n            visited[minv] = True\n    del dist[start_node - 1]\n    return dist"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "dist = [-1] * n",
      "mutated_line": "dist = [-1] / n",
      "code": "import heapq\n\ndef shortest_reach(n, edges, start_node):\n    graph = [{} for _ in range(n)]\n    for (x, y, r) in edges:\n        x -= 1\n        y -= 1\n        if y not in graph[x]:\n            graph[x][y] = r\n        else:\n            graph[x][y] = min(graph[x][y], r)\n        if x not in graph[y]:\n            graph[y][x] = r\n        else:\n            graph[y][x] = min(graph[y][x], r)\n    dist = [-1] / n\n    visited = [False] * n\n    pq = [(0, start_node - 1)]\n    dist[start_node - 1] = 0\n    while pq:\n        (mindist, minv) = heapq.heappop(pq)\n        if not visited[minv]:\n            for (neighbor, weight) in graph[minv].items():\n                if dist[neighbor] == -1:\n                    dist[neighbor] = mindist + weight\n                else:\n                    dist[neighbor] = min(dist[neighbor], mindist + weight)\n                heapq.heappush(pq, (dist[neighbor], neighbor))\n            visited[minv] = True\n    del dist[start_node - 1]\n    return dist"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "dist = [-1] * n",
      "mutated_line": "dist = [-1] + n",
      "code": "import heapq\n\ndef shortest_reach(n, edges, start_node):\n    graph = [{} for _ in range(n)]\n    for (x, y, r) in edges:\n        x -= 1\n        y -= 1\n        if y not in graph[x]:\n            graph[x][y] = r\n        else:\n            graph[x][y] = min(graph[x][y], r)\n        if x not in graph[y]:\n            graph[y][x] = r\n        else:\n            graph[y][x] = min(graph[y][x], r)\n    dist = [-1] + n\n    visited = [False] * n\n    pq = [(0, start_node - 1)]\n    dist[start_node - 1] = 0\n    while pq:\n        (mindist, minv) = heapq.heappop(pq)\n        if not visited[minv]:\n            for (neighbor, weight) in graph[minv].items():\n                if dist[neighbor] == -1:\n                    dist[neighbor] = mindist + weight\n                else:\n                    dist[neighbor] = min(dist[neighbor], mindist + weight)\n                heapq.heappush(pq, (dist[neighbor], neighbor))\n            visited[minv] = True\n    del dist[start_node - 1]\n    return dist"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "dist = [-1] * n",
      "mutated_line": "dist = [-1] ** n",
      "code": "import heapq\n\ndef shortest_reach(n, edges, start_node):\n    graph = [{} for _ in range(n)]\n    for (x, y, r) in edges:\n        x -= 1\n        y -= 1\n        if y not in graph[x]:\n            graph[x][y] = r\n        else:\n            graph[x][y] = min(graph[x][y], r)\n        if x not in graph[y]:\n            graph[y][x] = r\n        else:\n            graph[y][x] = min(graph[y][x], r)\n    dist = [-1] ** n\n    visited = [False] * n\n    pq = [(0, start_node - 1)]\n    dist[start_node - 1] = 0\n    while pq:\n        (mindist, minv) = heapq.heappop(pq)\n        if not visited[minv]:\n            for (neighbor, weight) in graph[minv].items():\n                if dist[neighbor] == -1:\n                    dist[neighbor] = mindist + weight\n                else:\n                    dist[neighbor] = min(dist[neighbor], mindist + weight)\n                heapq.heappush(pq, (dist[neighbor], neighbor))\n            visited[minv] = True\n    del dist[start_node - 1]\n    return dist"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "visited = [False] * n",
      "mutated_line": "visited = [False] / n",
      "code": "import heapq\n\ndef shortest_reach(n, edges, start_node):\n    graph = [{} for _ in range(n)]\n    for (x, y, r) in edges:\n        x -= 1\n        y -= 1\n        if y not in graph[x]:\n            graph[x][y] = r\n        else:\n            graph[x][y] = min(graph[x][y], r)\n        if x not in graph[y]:\n            graph[y][x] = r\n        else:\n            graph[y][x] = min(graph[y][x], r)\n    dist = [-1] * n\n    visited = [False] / n\n    pq = [(0, start_node - 1)]\n    dist[start_node - 1] = 0\n    while pq:\n        (mindist, minv) = heapq.heappop(pq)\n        if not visited[minv]:\n            for (neighbor, weight) in graph[minv].items():\n                if dist[neighbor] == -1:\n                    dist[neighbor] = mindist + weight\n                else:\n                    dist[neighbor] = min(dist[neighbor], mindist + weight)\n                heapq.heappush(pq, (dist[neighbor], neighbor))\n            visited[minv] = True\n    del dist[start_node - 1]\n    return dist"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "visited = [False] * n",
      "mutated_line": "visited = [False] + n",
      "code": "import heapq\n\ndef shortest_reach(n, edges, start_node):\n    graph = [{} for _ in range(n)]\n    for (x, y, r) in edges:\n        x -= 1\n        y -= 1\n        if y not in graph[x]:\n            graph[x][y] = r\n        else:\n            graph[x][y] = min(graph[x][y], r)\n        if x not in graph[y]:\n            graph[y][x] = r\n        else:\n            graph[y][x] = min(graph[y][x], r)\n    dist = [-1] * n\n    visited = [False] + n\n    pq = [(0, start_node - 1)]\n    dist[start_node - 1] = 0\n    while pq:\n        (mindist, minv) = heapq.heappop(pq)\n        if not visited[minv]:\n            for (neighbor, weight) in graph[minv].items():\n                if dist[neighbor] == -1:\n                    dist[neighbor] = mindist + weight\n                else:\n                    dist[neighbor] = min(dist[neighbor], mindist + weight)\n                heapq.heappush(pq, (dist[neighbor], neighbor))\n            visited[minv] = True\n    del dist[start_node - 1]\n    return dist"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "visited = [False] * n",
      "mutated_line": "visited = [False] ** n",
      "code": "import heapq\n\ndef shortest_reach(n, edges, start_node):\n    graph = [{} for _ in range(n)]\n    for (x, y, r) in edges:\n        x -= 1\n        y -= 1\n        if y not in graph[x]:\n            graph[x][y] = r\n        else:\n            graph[x][y] = min(graph[x][y], r)\n        if x not in graph[y]:\n            graph[y][x] = r\n        else:\n            graph[y][x] = min(graph[y][x], r)\n    dist = [-1] * n\n    visited = [False] ** n\n    pq = [(0, start_node - 1)]\n    dist[start_node - 1] = 0\n    while pq:\n        (mindist, minv) = heapq.heappop(pq)\n        if not visited[minv]:\n            for (neighbor, weight) in graph[minv].items():\n                if dist[neighbor] == -1:\n                    dist[neighbor] = mindist + weight\n                else:\n                    dist[neighbor] = min(dist[neighbor], mindist + weight)\n                heapq.heappush(pq, (dist[neighbor], neighbor))\n            visited[minv] = True\n    del dist[start_node - 1]\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dist[start_node - 1] = 0",
      "mutated_line": "dist[start_node - 1] = 1",
      "code": "import heapq\n\ndef shortest_reach(n, edges, start_node):\n    graph = [{} for _ in range(n)]\n    for (x, y, r) in edges:\n        x -= 1\n        y -= 1\n        if y not in graph[x]:\n            graph[x][y] = r\n        else:\n            graph[x][y] = min(graph[x][y], r)\n        if x not in graph[y]:\n            graph[y][x] = r\n        else:\n            graph[y][x] = min(graph[y][x], r)\n    dist = [-1] * n\n    visited = [False] * n\n    pq = [(0, start_node - 1)]\n    dist[start_node - 1] = 1\n    while pq:\n        (mindist, minv) = heapq.heappop(pq)\n        if not visited[minv]:\n            for (neighbor, weight) in graph[minv].items():\n                if dist[neighbor] == -1:\n                    dist[neighbor] = mindist + weight\n                else:\n                    dist[neighbor] = min(dist[neighbor], mindist + weight)\n                heapq.heappush(pq, (dist[neighbor], neighbor))\n            visited[minv] = True\n    del dist[start_node - 1]\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dist[start_node - 1] = 0",
      "mutated_line": "dist[start_node - 1] = -1",
      "code": "import heapq\n\ndef shortest_reach(n, edges, start_node):\n    graph = [{} for _ in range(n)]\n    for (x, y, r) in edges:\n        x -= 1\n        y -= 1\n        if y not in graph[x]:\n            graph[x][y] = r\n        else:\n            graph[x][y] = min(graph[x][y], r)\n        if x not in graph[y]:\n            graph[y][x] = r\n        else:\n            graph[y][x] = min(graph[y][x], r)\n    dist = [-1] * n\n    visited = [False] * n\n    pq = [(0, start_node - 1)]\n    dist[start_node - 1] = -1\n    while pq:\n        (mindist, minv) = heapq.heappop(pq)\n        if not visited[minv]:\n            for (neighbor, weight) in graph[minv].items():\n                if dist[neighbor] == -1:\n                    dist[neighbor] = mindist + weight\n                else:\n                    dist[neighbor] = min(dist[neighbor], mindist + weight)\n                heapq.heappush(pq, (dist[neighbor], neighbor))\n            visited[minv] = True\n    del dist[start_node - 1]\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dist[start_node - 1] = 0",
      "mutated_line": "dist[start_node - 1] = 1",
      "code": "import heapq\n\ndef shortest_reach(n, edges, start_node):\n    graph = [{} for _ in range(n)]\n    for (x, y, r) in edges:\n        x -= 1\n        y -= 1\n        if y not in graph[x]:\n            graph[x][y] = r\n        else:\n            graph[x][y] = min(graph[x][y], r)\n        if x not in graph[y]:\n            graph[y][x] = r\n        else:\n            graph[y][x] = min(graph[y][x], r)\n    dist = [-1] * n\n    visited = [False] * n\n    pq = [(0, start_node - 1)]\n    dist[start_node - 1] = 1\n    while pq:\n        (mindist, minv) = heapq.heappop(pq)\n        if not visited[minv]:\n            for (neighbor, weight) in graph[minv].items():\n                if dist[neighbor] == -1:\n                    dist[neighbor] = mindist + weight\n                else:\n                    dist[neighbor] = min(dist[neighbor], mindist + weight)\n                heapq.heappush(pq, (dist[neighbor], neighbor))\n            visited[minv] = True\n    del dist[start_node - 1]\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "x -= 1  # Convert to 0-based index",
      "mutated_line": "x -= 2",
      "code": "import heapq\n\ndef shortest_reach(n, edges, start_node):\n    graph = [{} for _ in range(n)]\n    for (x, y, r) in edges:\n        x -= 2\n        y -= 1\n        if y not in graph[x]:\n            graph[x][y] = r\n        else:\n            graph[x][y] = min(graph[x][y], r)\n        if x not in graph[y]:\n            graph[y][x] = r\n        else:\n            graph[y][x] = min(graph[y][x], r)\n    dist = [-1] * n\n    visited = [False] * n\n    pq = [(0, start_node - 1)]\n    dist[start_node - 1] = 0\n    while pq:\n        (mindist, minv) = heapq.heappop(pq)\n        if not visited[minv]:\n            for (neighbor, weight) in graph[minv].items():\n                if dist[neighbor] == -1:\n                    dist[neighbor] = mindist + weight\n                else:\n                    dist[neighbor] = min(dist[neighbor], mindist + weight)\n                heapq.heappush(pq, (dist[neighbor], neighbor))\n            visited[minv] = True\n    del dist[start_node - 1]\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "x -= 1  # Convert to 0-based index",
      "mutated_line": "x -= 0",
      "code": "import heapq\n\ndef shortest_reach(n, edges, start_node):\n    graph = [{} for _ in range(n)]\n    for (x, y, r) in edges:\n        x -= 0\n        y -= 1\n        if y not in graph[x]:\n            graph[x][y] = r\n        else:\n            graph[x][y] = min(graph[x][y], r)\n        if x not in graph[y]:\n            graph[y][x] = r\n        else:\n            graph[y][x] = min(graph[y][x], r)\n    dist = [-1] * n\n    visited = [False] * n\n    pq = [(0, start_node - 1)]\n    dist[start_node - 1] = 0\n    while pq:\n        (mindist, minv) = heapq.heappop(pq)\n        if not visited[minv]:\n            for (neighbor, weight) in graph[minv].items():\n                if dist[neighbor] == -1:\n                    dist[neighbor] = mindist + weight\n                else:\n                    dist[neighbor] = min(dist[neighbor], mindist + weight)\n                heapq.heappush(pq, (dist[neighbor], neighbor))\n            visited[minv] = True\n    del dist[start_node - 1]\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "x -= 1  # Convert to 0-based index",
      "mutated_line": "x -= 0",
      "code": "import heapq\n\ndef shortest_reach(n, edges, start_node):\n    graph = [{} for _ in range(n)]\n    for (x, y, r) in edges:\n        x -= 0\n        y -= 1\n        if y not in graph[x]:\n            graph[x][y] = r\n        else:\n            graph[x][y] = min(graph[x][y], r)\n        if x not in graph[y]:\n            graph[y][x] = r\n        else:\n            graph[y][x] = min(graph[y][x], r)\n    dist = [-1] * n\n    visited = [False] * n\n    pq = [(0, start_node - 1)]\n    dist[start_node - 1] = 0\n    while pq:\n        (mindist, minv) = heapq.heappop(pq)\n        if not visited[minv]:\n            for (neighbor, weight) in graph[minv].items():\n                if dist[neighbor] == -1:\n                    dist[neighbor] = mindist + weight\n                else:\n                    dist[neighbor] = min(dist[neighbor], mindist + weight)\n                heapq.heappush(pq, (dist[neighbor], neighbor))\n            visited[minv] = True\n    del dist[start_node - 1]\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "x -= 1  # Convert to 0-based index",
      "mutated_line": "x -= -1",
      "code": "import heapq\n\ndef shortest_reach(n, edges, start_node):\n    graph = [{} for _ in range(n)]\n    for (x, y, r) in edges:\n        x -= -1\n        y -= 1\n        if y not in graph[x]:\n            graph[x][y] = r\n        else:\n            graph[x][y] = min(graph[x][y], r)\n        if x not in graph[y]:\n            graph[y][x] = r\n        else:\n            graph[y][x] = min(graph[y][x], r)\n    dist = [-1] * n\n    visited = [False] * n\n    pq = [(0, start_node - 1)]\n    dist[start_node - 1] = 0\n    while pq:\n        (mindist, minv) = heapq.heappop(pq)\n        if not visited[minv]:\n            for (neighbor, weight) in graph[minv].items():\n                if dist[neighbor] == -1:\n                    dist[neighbor] = mindist + weight\n                else:\n                    dist[neighbor] = min(dist[neighbor], mindist + weight)\n                heapq.heappush(pq, (dist[neighbor], neighbor))\n            visited[minv] = True\n    del dist[start_node - 1]\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "y -= 1  # Convert to 0-based index",
      "mutated_line": "y -= 2",
      "code": "import heapq\n\ndef shortest_reach(n, edges, start_node):\n    graph = [{} for _ in range(n)]\n    for (x, y, r) in edges:\n        x -= 1\n        y -= 2\n        if y not in graph[x]:\n            graph[x][y] = r\n        else:\n            graph[x][y] = min(graph[x][y], r)\n        if x not in graph[y]:\n            graph[y][x] = r\n        else:\n            graph[y][x] = min(graph[y][x], r)\n    dist = [-1] * n\n    visited = [False] * n\n    pq = [(0, start_node - 1)]\n    dist[start_node - 1] = 0\n    while pq:\n        (mindist, minv) = heapq.heappop(pq)\n        if not visited[minv]:\n            for (neighbor, weight) in graph[minv].items():\n                if dist[neighbor] == -1:\n                    dist[neighbor] = mindist + weight\n                else:\n                    dist[neighbor] = min(dist[neighbor], mindist + weight)\n                heapq.heappush(pq, (dist[neighbor], neighbor))\n            visited[minv] = True\n    del dist[start_node - 1]\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "y -= 1  # Convert to 0-based index",
      "mutated_line": "y -= 0",
      "code": "import heapq\n\ndef shortest_reach(n, edges, start_node):\n    graph = [{} for _ in range(n)]\n    for (x, y, r) in edges:\n        x -= 1\n        y -= 0\n        if y not in graph[x]:\n            graph[x][y] = r\n        else:\n            graph[x][y] = min(graph[x][y], r)\n        if x not in graph[y]:\n            graph[y][x] = r\n        else:\n            graph[y][x] = min(graph[y][x], r)\n    dist = [-1] * n\n    visited = [False] * n\n    pq = [(0, start_node - 1)]\n    dist[start_node - 1] = 0\n    while pq:\n        (mindist, minv) = heapq.heappop(pq)\n        if not visited[minv]:\n            for (neighbor, weight) in graph[minv].items():\n                if dist[neighbor] == -1:\n                    dist[neighbor] = mindist + weight\n                else:\n                    dist[neighbor] = min(dist[neighbor], mindist + weight)\n                heapq.heappush(pq, (dist[neighbor], neighbor))\n            visited[minv] = True\n    del dist[start_node - 1]\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "y -= 1  # Convert to 0-based index",
      "mutated_line": "y -= 0",
      "code": "import heapq\n\ndef shortest_reach(n, edges, start_node):\n    graph = [{} for _ in range(n)]\n    for (x, y, r) in edges:\n        x -= 1\n        y -= 0\n        if y not in graph[x]:\n            graph[x][y] = r\n        else:\n            graph[x][y] = min(graph[x][y], r)\n        if x not in graph[y]:\n            graph[y][x] = r\n        else:\n            graph[y][x] = min(graph[y][x], r)\n    dist = [-1] * n\n    visited = [False] * n\n    pq = [(0, start_node - 1)]\n    dist[start_node - 1] = 0\n    while pq:\n        (mindist, minv) = heapq.heappop(pq)\n        if not visited[minv]:\n            for (neighbor, weight) in graph[minv].items():\n                if dist[neighbor] == -1:\n                    dist[neighbor] = mindist + weight\n                else:\n                    dist[neighbor] = min(dist[neighbor], mindist + weight)\n                heapq.heappush(pq, (dist[neighbor], neighbor))\n            visited[minv] = True\n    del dist[start_node - 1]\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "y -= 1  # Convert to 0-based index",
      "mutated_line": "y -= -1",
      "code": "import heapq\n\ndef shortest_reach(n, edges, start_node):\n    graph = [{} for _ in range(n)]\n    for (x, y, r) in edges:\n        x -= 1\n        y -= -1\n        if y not in graph[x]:\n            graph[x][y] = r\n        else:\n            graph[x][y] = min(graph[x][y], r)\n        if x not in graph[y]:\n            graph[y][x] = r\n        else:\n            graph[y][x] = min(graph[y][x], r)\n    dist = [-1] * n\n    visited = [False] * n\n    pq = [(0, start_node - 1)]\n    dist[start_node - 1] = 0\n    while pq:\n        (mindist, minv) = heapq.heappop(pq)\n        if not visited[minv]:\n            for (neighbor, weight) in graph[minv].items():\n                if dist[neighbor] == -1:\n                    dist[neighbor] = mindist + weight\n                else:\n                    dist[neighbor] = min(dist[neighbor], mindist + weight)\n                heapq.heappush(pq, (dist[neighbor], neighbor))\n            visited[minv] = True\n    del dist[start_node - 1]\n    return dist"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if y not in graph[x]:",
      "mutated_line": "if y in graph[x]:",
      "code": "import heapq\n\ndef shortest_reach(n, edges, start_node):\n    graph = [{} for _ in range(n)]\n    for (x, y, r) in edges:\n        x -= 1\n        y -= 1\n        if y in graph[x]:\n            graph[x][y] = r\n        else:\n            graph[x][y] = min(graph[x][y], r)\n        if x not in graph[y]:\n            graph[y][x] = r\n        else:\n            graph[y][x] = min(graph[y][x], r)\n    dist = [-1] * n\n    visited = [False] * n\n    pq = [(0, start_node - 1)]\n    dist[start_node - 1] = 0\n    while pq:\n        (mindist, minv) = heapq.heappop(pq)\n        if not visited[minv]:\n            for (neighbor, weight) in graph[minv].items():\n                if dist[neighbor] == -1:\n                    dist[neighbor] = mindist + weight\n                else:\n                    dist[neighbor] = min(dist[neighbor], mindist + weight)\n                heapq.heappush(pq, (dist[neighbor], neighbor))\n            visited[minv] = True\n    del dist[start_node - 1]\n    return dist"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if x not in graph[y]:",
      "mutated_line": "if x in graph[y]:",
      "code": "import heapq\n\ndef shortest_reach(n, edges, start_node):\n    graph = [{} for _ in range(n)]\n    for (x, y, r) in edges:\n        x -= 1\n        y -= 1\n        if y not in graph[x]:\n            graph[x][y] = r\n        else:\n            graph[x][y] = min(graph[x][y], r)\n        if x in graph[y]:\n            graph[y][x] = r\n        else:\n            graph[y][x] = min(graph[y][x], r)\n    dist = [-1] * n\n    visited = [False] * n\n    pq = [(0, start_node - 1)]\n    dist[start_node - 1] = 0\n    while pq:\n        (mindist, minv) = heapq.heappop(pq)\n        if not visited[minv]:\n            for (neighbor, weight) in graph[minv].items():\n                if dist[neighbor] == -1:\n                    dist[neighbor] = mindist + weight\n                else:\n                    dist[neighbor] = min(dist[neighbor], mindist + weight)\n                heapq.heappush(pq, (dist[neighbor], neighbor))\n            visited[minv] = True\n    del dist[start_node - 1]\n    return dist"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dist[start_node - 1] = 0",
      "mutated_line": "dist[start_node + 1] = 0",
      "code": "import heapq\n\ndef shortest_reach(n, edges, start_node):\n    graph = [{} for _ in range(n)]\n    for (x, y, r) in edges:\n        x -= 1\n        y -= 1\n        if y not in graph[x]:\n            graph[x][y] = r\n        else:\n            graph[x][y] = min(graph[x][y], r)\n        if x not in graph[y]:\n            graph[y][x] = r\n        else:\n            graph[y][x] = min(graph[y][x], r)\n    dist = [-1] * n\n    visited = [False] * n\n    pq = [(0, start_node - 1)]\n    dist[start_node + 1] = 0\n    while pq:\n        (mindist, minv) = heapq.heappop(pq)\n        if not visited[minv]:\n            for (neighbor, weight) in graph[minv].items():\n                if dist[neighbor] == -1:\n                    dist[neighbor] = mindist + weight\n                else:\n                    dist[neighbor] = min(dist[neighbor], mindist + weight)\n                heapq.heappush(pq, (dist[neighbor], neighbor))\n            visited[minv] = True\n    del dist[start_node - 1]\n    return dist"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dist[start_node - 1] = 0",
      "mutated_line": "dist[start_node * 1] = 0",
      "code": "import heapq\n\ndef shortest_reach(n, edges, start_node):\n    graph = [{} for _ in range(n)]\n    for (x, y, r) in edges:\n        x -= 1\n        y -= 1\n        if y not in graph[x]:\n            graph[x][y] = r\n        else:\n            graph[x][y] = min(graph[x][y], r)\n        if x not in graph[y]:\n            graph[y][x] = r\n        else:\n            graph[y][x] = min(graph[y][x], r)\n    dist = [-1] * n\n    visited = [False] * n\n    pq = [(0, start_node - 1)]\n    dist[start_node * 1] = 0\n    while pq:\n        (mindist, minv) = heapq.heappop(pq)\n        if not visited[minv]:\n            for (neighbor, weight) in graph[minv].items():\n                if dist[neighbor] == -1:\n                    dist[neighbor] = mindist + weight\n                else:\n                    dist[neighbor] = min(dist[neighbor], mindist + weight)\n                heapq.heappush(pq, (dist[neighbor], neighbor))\n            visited[minv] = True\n    del dist[start_node - 1]\n    return dist"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "del dist[start_node - 1]",
      "mutated_line": "del dist[start_node + 1]",
      "code": "import heapq\n\ndef shortest_reach(n, edges, start_node):\n    graph = [{} for _ in range(n)]\n    for (x, y, r) in edges:\n        x -= 1\n        y -= 1\n        if y not in graph[x]:\n            graph[x][y] = r\n        else:\n            graph[x][y] = min(graph[x][y], r)\n        if x not in graph[y]:\n            graph[y][x] = r\n        else:\n            graph[y][x] = min(graph[y][x], r)\n    dist = [-1] * n\n    visited = [False] * n\n    pq = [(0, start_node - 1)]\n    dist[start_node - 1] = 0\n    while pq:\n        (mindist, minv) = heapq.heappop(pq)\n        if not visited[minv]:\n            for (neighbor, weight) in graph[minv].items():\n                if dist[neighbor] == -1:\n                    dist[neighbor] = mindist + weight\n                else:\n                    dist[neighbor] = min(dist[neighbor], mindist + weight)\n                heapq.heappush(pq, (dist[neighbor], neighbor))\n            visited[minv] = True\n    del dist[start_node + 1]\n    return dist"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "del dist[start_node - 1]",
      "mutated_line": "del dist[start_node * 1]",
      "code": "import heapq\n\ndef shortest_reach(n, edges, start_node):\n    graph = [{} for _ in range(n)]\n    for (x, y, r) in edges:\n        x -= 1\n        y -= 1\n        if y not in graph[x]:\n            graph[x][y] = r\n        else:\n            graph[x][y] = min(graph[x][y], r)\n        if x not in graph[y]:\n            graph[y][x] = r\n        else:\n            graph[y][x] = min(graph[y][x], r)\n    dist = [-1] * n\n    visited = [False] * n\n    pq = [(0, start_node - 1)]\n    dist[start_node - 1] = 0\n    while pq:\n        (mindist, minv) = heapq.heappop(pq)\n        if not visited[minv]:\n            for (neighbor, weight) in graph[minv].items():\n                if dist[neighbor] == -1:\n                    dist[neighbor] = mindist + weight\n                else:\n                    dist[neighbor] = min(dist[neighbor], mindist + weight)\n                heapq.heappush(pq, (dist[neighbor], neighbor))\n            visited[minv] = True\n    del dist[start_node * 1]\n    return dist"
    },
    {
      "operator": "UOI",
      "lineno": 21,
      "original_line": "dist = [-1] * n",
      "mutated_line": "dist = [+1] * n",
      "code": "import heapq\n\ndef shortest_reach(n, edges, start_node):\n    graph = [{} for _ in range(n)]\n    for (x, y, r) in edges:\n        x -= 1\n        y -= 1\n        if y not in graph[x]:\n            graph[x][y] = r\n        else:\n            graph[x][y] = min(graph[x][y], r)\n        if x not in graph[y]:\n            graph[y][x] = r\n        else:\n            graph[y][x] = min(graph[y][x], r)\n    dist = [+1] * n\n    visited = [False] * n\n    pq = [(0, start_node - 1)]\n    dist[start_node - 1] = 0\n    while pq:\n        (mindist, minv) = heapq.heappop(pq)\n        if not visited[minv]:\n            for (neighbor, weight) in graph[minv].items():\n                if dist[neighbor] == -1:\n                    dist[neighbor] = mindist + weight\n                else:\n                    dist[neighbor] = min(dist[neighbor], mindist + weight)\n                heapq.heappush(pq, (dist[neighbor], neighbor))\n            visited[minv] = True\n    del dist[start_node - 1]\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "visited = [False] * n",
      "mutated_line": "visited = [True] * n",
      "code": "import heapq\n\ndef shortest_reach(n, edges, start_node):\n    graph = [{} for _ in range(n)]\n    for (x, y, r) in edges:\n        x -= 1\n        y -= 1\n        if y not in graph[x]:\n            graph[x][y] = r\n        else:\n            graph[x][y] = min(graph[x][y], r)\n        if x not in graph[y]:\n            graph[y][x] = r\n        else:\n            graph[y][x] = min(graph[y][x], r)\n    dist = [-1] * n\n    visited = [True] * n\n    pq = [(0, start_node - 1)]\n    dist[start_node - 1] = 0\n    while pq:\n        (mindist, minv) = heapq.heappop(pq)\n        if not visited[minv]:\n            for (neighbor, weight) in graph[minv].items():\n                if dist[neighbor] == -1:\n                    dist[neighbor] = mindist + weight\n                else:\n                    dist[neighbor] = min(dist[neighbor], mindist + weight)\n                heapq.heappush(pq, (dist[neighbor], neighbor))\n            visited[minv] = True\n    del dist[start_node - 1]\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "pq = [(0, start_node - 1)]  # Convert start_node to 0-based index",
      "mutated_line": "pq = [(1, start_node - 1)]",
      "code": "import heapq\n\ndef shortest_reach(n, edges, start_node):\n    graph = [{} for _ in range(n)]\n    for (x, y, r) in edges:\n        x -= 1\n        y -= 1\n        if y not in graph[x]:\n            graph[x][y] = r\n        else:\n            graph[x][y] = min(graph[x][y], r)\n        if x not in graph[y]:\n            graph[y][x] = r\n        else:\n            graph[y][x] = min(graph[y][x], r)\n    dist = [-1] * n\n    visited = [False] * n\n    pq = [(1, start_node - 1)]\n    dist[start_node - 1] = 0\n    while pq:\n        (mindist, minv) = heapq.heappop(pq)\n        if not visited[minv]:\n            for (neighbor, weight) in graph[minv].items():\n                if dist[neighbor] == -1:\n                    dist[neighbor] = mindist + weight\n                else:\n                    dist[neighbor] = min(dist[neighbor], mindist + weight)\n                heapq.heappush(pq, (dist[neighbor], neighbor))\n            visited[minv] = True\n    del dist[start_node - 1]\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "pq = [(0, start_node - 1)]  # Convert start_node to 0-based index",
      "mutated_line": "pq = [(-1, start_node - 1)]",
      "code": "import heapq\n\ndef shortest_reach(n, edges, start_node):\n    graph = [{} for _ in range(n)]\n    for (x, y, r) in edges:\n        x -= 1\n        y -= 1\n        if y not in graph[x]:\n            graph[x][y] = r\n        else:\n            graph[x][y] = min(graph[x][y], r)\n        if x not in graph[y]:\n            graph[y][x] = r\n        else:\n            graph[y][x] = min(graph[y][x], r)\n    dist = [-1] * n\n    visited = [False] * n\n    pq = [(-1, start_node - 1)]\n    dist[start_node - 1] = 0\n    while pq:\n        (mindist, minv) = heapq.heappop(pq)\n        if not visited[minv]:\n            for (neighbor, weight) in graph[minv].items():\n                if dist[neighbor] == -1:\n                    dist[neighbor] = mindist + weight\n                else:\n                    dist[neighbor] = min(dist[neighbor], mindist + weight)\n                heapq.heappush(pq, (dist[neighbor], neighbor))\n            visited[minv] = True\n    del dist[start_node - 1]\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "pq = [(0, start_node - 1)]  # Convert start_node to 0-based index",
      "mutated_line": "pq = [(1, start_node - 1)]",
      "code": "import heapq\n\ndef shortest_reach(n, edges, start_node):\n    graph = [{} for _ in range(n)]\n    for (x, y, r) in edges:\n        x -= 1\n        y -= 1\n        if y not in graph[x]:\n            graph[x][y] = r\n        else:\n            graph[x][y] = min(graph[x][y], r)\n        if x not in graph[y]:\n            graph[y][x] = r\n        else:\n            graph[y][x] = min(graph[y][x], r)\n    dist = [-1] * n\n    visited = [False] * n\n    pq = [(1, start_node - 1)]\n    dist[start_node - 1] = 0\n    while pq:\n        (mindist, minv) = heapq.heappop(pq)\n        if not visited[minv]:\n            for (neighbor, weight) in graph[minv].items():\n                if dist[neighbor] == -1:\n                    dist[neighbor] = mindist + weight\n                else:\n                    dist[neighbor] = min(dist[neighbor], mindist + weight)\n                heapq.heappush(pq, (dist[neighbor], neighbor))\n            visited[minv] = True\n    del dist[start_node - 1]\n    return dist"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "pq = [(0, start_node - 1)]  # Convert start_node to 0-based index",
      "mutated_line": "pq = [(0, start_node + 1)]",
      "code": "import heapq\n\ndef shortest_reach(n, edges, start_node):\n    graph = [{} for _ in range(n)]\n    for (x, y, r) in edges:\n        x -= 1\n        y -= 1\n        if y not in graph[x]:\n            graph[x][y] = r\n        else:\n            graph[x][y] = min(graph[x][y], r)\n        if x not in graph[y]:\n            graph[y][x] = r\n        else:\n            graph[y][x] = min(graph[y][x], r)\n    dist = [-1] * n\n    visited = [False] * n\n    pq = [(0, start_node + 1)]\n    dist[start_node - 1] = 0\n    while pq:\n        (mindist, minv) = heapq.heappop(pq)\n        if not visited[minv]:\n            for (neighbor, weight) in graph[minv].items():\n                if dist[neighbor] == -1:\n                    dist[neighbor] = mindist + weight\n                else:\n                    dist[neighbor] = min(dist[neighbor], mindist + weight)\n                heapq.heappush(pq, (dist[neighbor], neighbor))\n            visited[minv] = True\n    del dist[start_node - 1]\n    return dist"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "pq = [(0, start_node - 1)]  # Convert start_node to 0-based index",
      "mutated_line": "pq = [(0, start_node * 1)]",
      "code": "import heapq\n\ndef shortest_reach(n, edges, start_node):\n    graph = [{} for _ in range(n)]\n    for (x, y, r) in edges:\n        x -= 1\n        y -= 1\n        if y not in graph[x]:\n            graph[x][y] = r\n        else:\n            graph[x][y] = min(graph[x][y], r)\n        if x not in graph[y]:\n            graph[y][x] = r\n        else:\n            graph[y][x] = min(graph[y][x], r)\n    dist = [-1] * n\n    visited = [False] * n\n    pq = [(0, start_node * 1)]\n    dist[start_node - 1] = 0\n    while pq:\n        (mindist, minv) = heapq.heappop(pq)\n        if not visited[minv]:\n            for (neighbor, weight) in graph[minv].items():\n                if dist[neighbor] == -1:\n                    dist[neighbor] = mindist + weight\n                else:\n                    dist[neighbor] = min(dist[neighbor], mindist + weight)\n                heapq.heappush(pq, (dist[neighbor], neighbor))\n            visited[minv] = True\n    del dist[start_node - 1]\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dist[start_node - 1] = 0",
      "mutated_line": "dist[start_node - 2] = 0",
      "code": "import heapq\n\ndef shortest_reach(n, edges, start_node):\n    graph = [{} for _ in range(n)]\n    for (x, y, r) in edges:\n        x -= 1\n        y -= 1\n        if y not in graph[x]:\n            graph[x][y] = r\n        else:\n            graph[x][y] = min(graph[x][y], r)\n        if x not in graph[y]:\n            graph[y][x] = r\n        else:\n            graph[y][x] = min(graph[y][x], r)\n    dist = [-1] * n\n    visited = [False] * n\n    pq = [(0, start_node - 1)]\n    dist[start_node - 2] = 0\n    while pq:\n        (mindist, minv) = heapq.heappop(pq)\n        if not visited[minv]:\n            for (neighbor, weight) in graph[minv].items():\n                if dist[neighbor] == -1:\n                    dist[neighbor] = mindist + weight\n                else:\n                    dist[neighbor] = min(dist[neighbor], mindist + weight)\n                heapq.heappush(pq, (dist[neighbor], neighbor))\n            visited[minv] = True\n    del dist[start_node - 1]\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dist[start_node - 1] = 0",
      "mutated_line": "dist[start_node - 0] = 0",
      "code": "import heapq\n\ndef shortest_reach(n, edges, start_node):\n    graph = [{} for _ in range(n)]\n    for (x, y, r) in edges:\n        x -= 1\n        y -= 1\n        if y not in graph[x]:\n            graph[x][y] = r\n        else:\n            graph[x][y] = min(graph[x][y], r)\n        if x not in graph[y]:\n            graph[y][x] = r\n        else:\n            graph[y][x] = min(graph[y][x], r)\n    dist = [-1] * n\n    visited = [False] * n\n    pq = [(0, start_node - 1)]\n    dist[start_node - 0] = 0\n    while pq:\n        (mindist, minv) = heapq.heappop(pq)\n        if not visited[minv]:\n            for (neighbor, weight) in graph[minv].items():\n                if dist[neighbor] == -1:\n                    dist[neighbor] = mindist + weight\n                else:\n                    dist[neighbor] = min(dist[neighbor], mindist + weight)\n                heapq.heappush(pq, (dist[neighbor], neighbor))\n            visited[minv] = True\n    del dist[start_node - 1]\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dist[start_node - 1] = 0",
      "mutated_line": "dist[start_node - 0] = 0",
      "code": "import heapq\n\ndef shortest_reach(n, edges, start_node):\n    graph = [{} for _ in range(n)]\n    for (x, y, r) in edges:\n        x -= 1\n        y -= 1\n        if y not in graph[x]:\n            graph[x][y] = r\n        else:\n            graph[x][y] = min(graph[x][y], r)\n        if x not in graph[y]:\n            graph[y][x] = r\n        else:\n            graph[y][x] = min(graph[y][x], r)\n    dist = [-1] * n\n    visited = [False] * n\n    pq = [(0, start_node - 1)]\n    dist[start_node - 0] = 0\n    while pq:\n        (mindist, minv) = heapq.heappop(pq)\n        if not visited[minv]:\n            for (neighbor, weight) in graph[minv].items():\n                if dist[neighbor] == -1:\n                    dist[neighbor] = mindist + weight\n                else:\n                    dist[neighbor] = min(dist[neighbor], mindist + weight)\n                heapq.heappush(pq, (dist[neighbor], neighbor))\n            visited[minv] = True\n    del dist[start_node - 1]\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dist[start_node - 1] = 0",
      "mutated_line": "dist[start_node - -1] = 0",
      "code": "import heapq\n\ndef shortest_reach(n, edges, start_node):\n    graph = [{} for _ in range(n)]\n    for (x, y, r) in edges:\n        x -= 1\n        y -= 1\n        if y not in graph[x]:\n            graph[x][y] = r\n        else:\n            graph[x][y] = min(graph[x][y], r)\n        if x not in graph[y]:\n            graph[y][x] = r\n        else:\n            graph[y][x] = min(graph[y][x], r)\n    dist = [-1] * n\n    visited = [False] * n\n    pq = [(0, start_node - 1)]\n    dist[start_node - -1] = 0\n    while pq:\n        (mindist, minv) = heapq.heappop(pq)\n        if not visited[minv]:\n            for (neighbor, weight) in graph[minv].items():\n                if dist[neighbor] == -1:\n                    dist[neighbor] = mindist + weight\n                else:\n                    dist[neighbor] = min(dist[neighbor], mindist + weight)\n                heapq.heappush(pq, (dist[neighbor], neighbor))\n            visited[minv] = True\n    del dist[start_node - 1]\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "visited[minv] = True",
      "mutated_line": "visited[minv] = False",
      "code": "import heapq\n\ndef shortest_reach(n, edges, start_node):\n    graph = [{} for _ in range(n)]\n    for (x, y, r) in edges:\n        x -= 1\n        y -= 1\n        if y not in graph[x]:\n            graph[x][y] = r\n        else:\n            graph[x][y] = min(graph[x][y], r)\n        if x not in graph[y]:\n            graph[y][x] = r\n        else:\n            graph[y][x] = min(graph[y][x], r)\n    dist = [-1] * n\n    visited = [False] * n\n    pq = [(0, start_node - 1)]\n    dist[start_node - 1] = 0\n    while pq:\n        (mindist, minv) = heapq.heappop(pq)\n        if not visited[minv]:\n            for (neighbor, weight) in graph[minv].items():\n                if dist[neighbor] == -1:\n                    dist[neighbor] = mindist + weight\n                else:\n                    dist[neighbor] = min(dist[neighbor], mindist + weight)\n                heapq.heappush(pq, (dist[neighbor], neighbor))\n            visited[minv] = False\n    del dist[start_node - 1]\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "del dist[start_node - 1]",
      "mutated_line": "del dist[start_node - 2]",
      "code": "import heapq\n\ndef shortest_reach(n, edges, start_node):\n    graph = [{} for _ in range(n)]\n    for (x, y, r) in edges:\n        x -= 1\n        y -= 1\n        if y not in graph[x]:\n            graph[x][y] = r\n        else:\n            graph[x][y] = min(graph[x][y], r)\n        if x not in graph[y]:\n            graph[y][x] = r\n        else:\n            graph[y][x] = min(graph[y][x], r)\n    dist = [-1] * n\n    visited = [False] * n\n    pq = [(0, start_node - 1)]\n    dist[start_node - 1] = 0\n    while pq:\n        (mindist, minv) = heapq.heappop(pq)\n        if not visited[minv]:\n            for (neighbor, weight) in graph[minv].items():\n                if dist[neighbor] == -1:\n                    dist[neighbor] = mindist + weight\n                else:\n                    dist[neighbor] = min(dist[neighbor], mindist + weight)\n                heapq.heappush(pq, (dist[neighbor], neighbor))\n            visited[minv] = True\n    del dist[start_node - 2]\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "del dist[start_node - 1]",
      "mutated_line": "del dist[start_node - 0]",
      "code": "import heapq\n\ndef shortest_reach(n, edges, start_node):\n    graph = [{} for _ in range(n)]\n    for (x, y, r) in edges:\n        x -= 1\n        y -= 1\n        if y not in graph[x]:\n            graph[x][y] = r\n        else:\n            graph[x][y] = min(graph[x][y], r)\n        if x not in graph[y]:\n            graph[y][x] = r\n        else:\n            graph[y][x] = min(graph[y][x], r)\n    dist = [-1] * n\n    visited = [False] * n\n    pq = [(0, start_node - 1)]\n    dist[start_node - 1] = 0\n    while pq:\n        (mindist, minv) = heapq.heappop(pq)\n        if not visited[minv]:\n            for (neighbor, weight) in graph[minv].items():\n                if dist[neighbor] == -1:\n                    dist[neighbor] = mindist + weight\n                else:\n                    dist[neighbor] = min(dist[neighbor], mindist + weight)\n                heapq.heappush(pq, (dist[neighbor], neighbor))\n            visited[minv] = True\n    del dist[start_node - 0]\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "del dist[start_node - 1]",
      "mutated_line": "del dist[start_node - 0]",
      "code": "import heapq\n\ndef shortest_reach(n, edges, start_node):\n    graph = [{} for _ in range(n)]\n    for (x, y, r) in edges:\n        x -= 1\n        y -= 1\n        if y not in graph[x]:\n            graph[x][y] = r\n        else:\n            graph[x][y] = min(graph[x][y], r)\n        if x not in graph[y]:\n            graph[y][x] = r\n        else:\n            graph[y][x] = min(graph[y][x], r)\n    dist = [-1] * n\n    visited = [False] * n\n    pq = [(0, start_node - 1)]\n    dist[start_node - 1] = 0\n    while pq:\n        (mindist, minv) = heapq.heappop(pq)\n        if not visited[minv]:\n            for (neighbor, weight) in graph[minv].items():\n                if dist[neighbor] == -1:\n                    dist[neighbor] = mindist + weight\n                else:\n                    dist[neighbor] = min(dist[neighbor], mindist + weight)\n                heapq.heappush(pq, (dist[neighbor], neighbor))\n            visited[minv] = True\n    del dist[start_node - 0]\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "del dist[start_node - 1]",
      "mutated_line": "del dist[start_node - -1]",
      "code": "import heapq\n\ndef shortest_reach(n, edges, start_node):\n    graph = [{} for _ in range(n)]\n    for (x, y, r) in edges:\n        x -= 1\n        y -= 1\n        if y not in graph[x]:\n            graph[x][y] = r\n        else:\n            graph[x][y] = min(graph[x][y], r)\n        if x not in graph[y]:\n            graph[y][x] = r\n        else:\n            graph[y][x] = min(graph[y][x], r)\n    dist = [-1] * n\n    visited = [False] * n\n    pq = [(0, start_node - 1)]\n    dist[start_node - 1] = 0\n    while pq:\n        (mindist, minv) = heapq.heappop(pq)\n        if not visited[minv]:\n            for (neighbor, weight) in graph[minv].items():\n                if dist[neighbor] == -1:\n                    dist[neighbor] = mindist + weight\n                else:\n                    dist[neighbor] = min(dist[neighbor], mindist + weight)\n                heapq.heappush(pq, (dist[neighbor], neighbor))\n            visited[minv] = True\n    del dist[start_node - -1]\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dist = [-1] * n",
      "mutated_line": "dist = [-2] * n",
      "code": "import heapq\n\ndef shortest_reach(n, edges, start_node):\n    graph = [{} for _ in range(n)]\n    for (x, y, r) in edges:\n        x -= 1\n        y -= 1\n        if y not in graph[x]:\n            graph[x][y] = r\n        else:\n            graph[x][y] = min(graph[x][y], r)\n        if x not in graph[y]:\n            graph[y][x] = r\n        else:\n            graph[y][x] = min(graph[y][x], r)\n    dist = [-2] * n\n    visited = [False] * n\n    pq = [(0, start_node - 1)]\n    dist[start_node - 1] = 0\n    while pq:\n        (mindist, minv) = heapq.heappop(pq)\n        if not visited[minv]:\n            for (neighbor, weight) in graph[minv].items():\n                if dist[neighbor] == -1:\n                    dist[neighbor] = mindist + weight\n                else:\n                    dist[neighbor] = min(dist[neighbor], mindist + weight)\n                heapq.heappush(pq, (dist[neighbor], neighbor))\n            visited[minv] = True\n    del dist[start_node - 1]\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dist = [-1] * n",
      "mutated_line": "dist = [-0] * n",
      "code": "import heapq\n\ndef shortest_reach(n, edges, start_node):\n    graph = [{} for _ in range(n)]\n    for (x, y, r) in edges:\n        x -= 1\n        y -= 1\n        if y not in graph[x]:\n            graph[x][y] = r\n        else:\n            graph[x][y] = min(graph[x][y], r)\n        if x not in graph[y]:\n            graph[y][x] = r\n        else:\n            graph[y][x] = min(graph[y][x], r)\n    dist = [-0] * n\n    visited = [False] * n\n    pq = [(0, start_node - 1)]\n    dist[start_node - 1] = 0\n    while pq:\n        (mindist, minv) = heapq.heappop(pq)\n        if not visited[minv]:\n            for (neighbor, weight) in graph[minv].items():\n                if dist[neighbor] == -1:\n                    dist[neighbor] = mindist + weight\n                else:\n                    dist[neighbor] = min(dist[neighbor], mindist + weight)\n                heapq.heappush(pq, (dist[neighbor], neighbor))\n            visited[minv] = True\n    del dist[start_node - 1]\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dist = [-1] * n",
      "mutated_line": "dist = [-0] * n",
      "code": "import heapq\n\ndef shortest_reach(n, edges, start_node):\n    graph = [{} for _ in range(n)]\n    for (x, y, r) in edges:\n        x -= 1\n        y -= 1\n        if y not in graph[x]:\n            graph[x][y] = r\n        else:\n            graph[x][y] = min(graph[x][y], r)\n        if x not in graph[y]:\n            graph[y][x] = r\n        else:\n            graph[y][x] = min(graph[y][x], r)\n    dist = [-0] * n\n    visited = [False] * n\n    pq = [(0, start_node - 1)]\n    dist[start_node - 1] = 0\n    while pq:\n        (mindist, minv) = heapq.heappop(pq)\n        if not visited[minv]:\n            for (neighbor, weight) in graph[minv].items():\n                if dist[neighbor] == -1:\n                    dist[neighbor] = mindist + weight\n                else:\n                    dist[neighbor] = min(dist[neighbor], mindist + weight)\n                heapq.heappush(pq, (dist[neighbor], neighbor))\n            visited[minv] = True\n    del dist[start_node - 1]\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dist = [-1] * n",
      "mutated_line": "dist = [--1] * n",
      "code": "import heapq\n\ndef shortest_reach(n, edges, start_node):\n    graph = [{} for _ in range(n)]\n    for (x, y, r) in edges:\n        x -= 1\n        y -= 1\n        if y not in graph[x]:\n            graph[x][y] = r\n        else:\n            graph[x][y] = min(graph[x][y], r)\n        if x not in graph[y]:\n            graph[y][x] = r\n        else:\n            graph[y][x] = min(graph[y][x], r)\n    dist = [--1] * n\n    visited = [False] * n\n    pq = [(0, start_node - 1)]\n    dist[start_node - 1] = 0\n    while pq:\n        (mindist, minv) = heapq.heappop(pq)\n        if not visited[minv]:\n            for (neighbor, weight) in graph[minv].items():\n                if dist[neighbor] == -1:\n                    dist[neighbor] = mindist + weight\n                else:\n                    dist[neighbor] = min(dist[neighbor], mindist + weight)\n                heapq.heappush(pq, (dist[neighbor], neighbor))\n            visited[minv] = True\n    del dist[start_node - 1]\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "pq = [(0, start_node - 1)]  # Convert start_node to 0-based index",
      "mutated_line": "pq = [(0, start_node - 2)]",
      "code": "import heapq\n\ndef shortest_reach(n, edges, start_node):\n    graph = [{} for _ in range(n)]\n    for (x, y, r) in edges:\n        x -= 1\n        y -= 1\n        if y not in graph[x]:\n            graph[x][y] = r\n        else:\n            graph[x][y] = min(graph[x][y], r)\n        if x not in graph[y]:\n            graph[y][x] = r\n        else:\n            graph[y][x] = min(graph[y][x], r)\n    dist = [-1] * n\n    visited = [False] * n\n    pq = [(0, start_node - 2)]\n    dist[start_node - 1] = 0\n    while pq:\n        (mindist, minv) = heapq.heappop(pq)\n        if not visited[minv]:\n            for (neighbor, weight) in graph[minv].items():\n                if dist[neighbor] == -1:\n                    dist[neighbor] = mindist + weight\n                else:\n                    dist[neighbor] = min(dist[neighbor], mindist + weight)\n                heapq.heappush(pq, (dist[neighbor], neighbor))\n            visited[minv] = True\n    del dist[start_node - 1]\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "pq = [(0, start_node - 1)]  # Convert start_node to 0-based index",
      "mutated_line": "pq = [(0, start_node - 0)]",
      "code": "import heapq\n\ndef shortest_reach(n, edges, start_node):\n    graph = [{} for _ in range(n)]\n    for (x, y, r) in edges:\n        x -= 1\n        y -= 1\n        if y not in graph[x]:\n            graph[x][y] = r\n        else:\n            graph[x][y] = min(graph[x][y], r)\n        if x not in graph[y]:\n            graph[y][x] = r\n        else:\n            graph[y][x] = min(graph[y][x], r)\n    dist = [-1] * n\n    visited = [False] * n\n    pq = [(0, start_node - 0)]\n    dist[start_node - 1] = 0\n    while pq:\n        (mindist, minv) = heapq.heappop(pq)\n        if not visited[minv]:\n            for (neighbor, weight) in graph[minv].items():\n                if dist[neighbor] == -1:\n                    dist[neighbor] = mindist + weight\n                else:\n                    dist[neighbor] = min(dist[neighbor], mindist + weight)\n                heapq.heappush(pq, (dist[neighbor], neighbor))\n            visited[minv] = True\n    del dist[start_node - 1]\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "pq = [(0, start_node - 1)]  # Convert start_node to 0-based index",
      "mutated_line": "pq = [(0, start_node - 0)]",
      "code": "import heapq\n\ndef shortest_reach(n, edges, start_node):\n    graph = [{} for _ in range(n)]\n    for (x, y, r) in edges:\n        x -= 1\n        y -= 1\n        if y not in graph[x]:\n            graph[x][y] = r\n        else:\n            graph[x][y] = min(graph[x][y], r)\n        if x not in graph[y]:\n            graph[y][x] = r\n        else:\n            graph[y][x] = min(graph[y][x], r)\n    dist = [-1] * n\n    visited = [False] * n\n    pq = [(0, start_node - 0)]\n    dist[start_node - 1] = 0\n    while pq:\n        (mindist, minv) = heapq.heappop(pq)\n        if not visited[minv]:\n            for (neighbor, weight) in graph[minv].items():\n                if dist[neighbor] == -1:\n                    dist[neighbor] = mindist + weight\n                else:\n                    dist[neighbor] = min(dist[neighbor], mindist + weight)\n                heapq.heappush(pq, (dist[neighbor], neighbor))\n            visited[minv] = True\n    del dist[start_node - 1]\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "pq = [(0, start_node - 1)]  # Convert start_node to 0-based index",
      "mutated_line": "pq = [(0, start_node - -1)]",
      "code": "import heapq\n\ndef shortest_reach(n, edges, start_node):\n    graph = [{} for _ in range(n)]\n    for (x, y, r) in edges:\n        x -= 1\n        y -= 1\n        if y not in graph[x]:\n            graph[x][y] = r\n        else:\n            graph[x][y] = min(graph[x][y], r)\n        if x not in graph[y]:\n            graph[y][x] = r\n        else:\n            graph[y][x] = min(graph[y][x], r)\n    dist = [-1] * n\n    visited = [False] * n\n    pq = [(0, start_node - -1)]\n    dist[start_node - 1] = 0\n    while pq:\n        (mindist, minv) = heapq.heappop(pq)\n        if not visited[minv]:\n            for (neighbor, weight) in graph[minv].items():\n                if dist[neighbor] == -1:\n                    dist[neighbor] = mindist + weight\n                else:\n                    dist[neighbor] = min(dist[neighbor], mindist + weight)\n                heapq.heappush(pq, (dist[neighbor], neighbor))\n            visited[minv] = True\n    del dist[start_node - 1]\n    return dist"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if dist[neighbor] == -1:",
      "mutated_line": "if dist[neighbor] != -1:",
      "code": "import heapq\n\ndef shortest_reach(n, edges, start_node):\n    graph = [{} for _ in range(n)]\n    for (x, y, r) in edges:\n        x -= 1\n        y -= 1\n        if y not in graph[x]:\n            graph[x][y] = r\n        else:\n            graph[x][y] = min(graph[x][y], r)\n        if x not in graph[y]:\n            graph[y][x] = r\n        else:\n            graph[y][x] = min(graph[y][x], r)\n    dist = [-1] * n\n    visited = [False] * n\n    pq = [(0, start_node - 1)]\n    dist[start_node - 1] = 0\n    while pq:\n        (mindist, minv) = heapq.heappop(pq)\n        if not visited[minv]:\n            for (neighbor, weight) in graph[minv].items():\n                if dist[neighbor] != -1:\n                    dist[neighbor] = mindist + weight\n                else:\n                    dist[neighbor] = min(dist[neighbor], mindist + weight)\n                heapq.heappush(pq, (dist[neighbor], neighbor))\n            visited[minv] = True\n    del dist[start_node - 1]\n    return dist"
    },
    {
      "operator": "UOI",
      "lineno": 32,
      "original_line": "if dist[neighbor] == -1:",
      "mutated_line": "if dist[neighbor] == +1:",
      "code": "import heapq\n\ndef shortest_reach(n, edges, start_node):\n    graph = [{} for _ in range(n)]\n    for (x, y, r) in edges:\n        x -= 1\n        y -= 1\n        if y not in graph[x]:\n            graph[x][y] = r\n        else:\n            graph[x][y] = min(graph[x][y], r)\n        if x not in graph[y]:\n            graph[y][x] = r\n        else:\n            graph[y][x] = min(graph[y][x], r)\n    dist = [-1] * n\n    visited = [False] * n\n    pq = [(0, start_node - 1)]\n    dist[start_node - 1] = 0\n    while pq:\n        (mindist, minv) = heapq.heappop(pq)\n        if not visited[minv]:\n            for (neighbor, weight) in graph[minv].items():\n                if dist[neighbor] == +1:\n                    dist[neighbor] = mindist + weight\n                else:\n                    dist[neighbor] = min(dist[neighbor], mindist + weight)\n                heapq.heappush(pq, (dist[neighbor], neighbor))\n            visited[minv] = True\n    del dist[start_node - 1]\n    return dist"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "dist[neighbor] = mindist + weight",
      "mutated_line": "dist[neighbor] = mindist - weight",
      "code": "import heapq\n\ndef shortest_reach(n, edges, start_node):\n    graph = [{} for _ in range(n)]\n    for (x, y, r) in edges:\n        x -= 1\n        y -= 1\n        if y not in graph[x]:\n            graph[x][y] = r\n        else:\n            graph[x][y] = min(graph[x][y], r)\n        if x not in graph[y]:\n            graph[y][x] = r\n        else:\n            graph[y][x] = min(graph[y][x], r)\n    dist = [-1] * n\n    visited = [False] * n\n    pq = [(0, start_node - 1)]\n    dist[start_node - 1] = 0\n    while pq:\n        (mindist, minv) = heapq.heappop(pq)\n        if not visited[minv]:\n            for (neighbor, weight) in graph[minv].items():\n                if dist[neighbor] == -1:\n                    dist[neighbor] = mindist - weight\n                else:\n                    dist[neighbor] = min(dist[neighbor], mindist + weight)\n                heapq.heappush(pq, (dist[neighbor], neighbor))\n            visited[minv] = True\n    del dist[start_node - 1]\n    return dist"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "dist[neighbor] = mindist + weight",
      "mutated_line": "dist[neighbor] = mindist * weight",
      "code": "import heapq\n\ndef shortest_reach(n, edges, start_node):\n    graph = [{} for _ in range(n)]\n    for (x, y, r) in edges:\n        x -= 1\n        y -= 1\n        if y not in graph[x]:\n            graph[x][y] = r\n        else:\n            graph[x][y] = min(graph[x][y], r)\n        if x not in graph[y]:\n            graph[y][x] = r\n        else:\n            graph[y][x] = min(graph[y][x], r)\n    dist = [-1] * n\n    visited = [False] * n\n    pq = [(0, start_node - 1)]\n    dist[start_node - 1] = 0\n    while pq:\n        (mindist, minv) = heapq.heappop(pq)\n        if not visited[minv]:\n            for (neighbor, weight) in graph[minv].items():\n                if dist[neighbor] == -1:\n                    dist[neighbor] = mindist * weight\n                else:\n                    dist[neighbor] = min(dist[neighbor], mindist + weight)\n                heapq.heappush(pq, (dist[neighbor], neighbor))\n            visited[minv] = True\n    del dist[start_node - 1]\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if dist[neighbor] == -1:",
      "mutated_line": "if dist[neighbor] == -2:",
      "code": "import heapq\n\ndef shortest_reach(n, edges, start_node):\n    graph = [{} for _ in range(n)]\n    for (x, y, r) in edges:\n        x -= 1\n        y -= 1\n        if y not in graph[x]:\n            graph[x][y] = r\n        else:\n            graph[x][y] = min(graph[x][y], r)\n        if x not in graph[y]:\n            graph[y][x] = r\n        else:\n            graph[y][x] = min(graph[y][x], r)\n    dist = [-1] * n\n    visited = [False] * n\n    pq = [(0, start_node - 1)]\n    dist[start_node - 1] = 0\n    while pq:\n        (mindist, minv) = heapq.heappop(pq)\n        if not visited[minv]:\n            for (neighbor, weight) in graph[minv].items():\n                if dist[neighbor] == -2:\n                    dist[neighbor] = mindist + weight\n                else:\n                    dist[neighbor] = min(dist[neighbor], mindist + weight)\n                heapq.heappush(pq, (dist[neighbor], neighbor))\n            visited[minv] = True\n    del dist[start_node - 1]\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if dist[neighbor] == -1:",
      "mutated_line": "if dist[neighbor] == -0:",
      "code": "import heapq\n\ndef shortest_reach(n, edges, start_node):\n    graph = [{} for _ in range(n)]\n    for (x, y, r) in edges:\n        x -= 1\n        y -= 1\n        if y not in graph[x]:\n            graph[x][y] = r\n        else:\n            graph[x][y] = min(graph[x][y], r)\n        if x not in graph[y]:\n            graph[y][x] = r\n        else:\n            graph[y][x] = min(graph[y][x], r)\n    dist = [-1] * n\n    visited = [False] * n\n    pq = [(0, start_node - 1)]\n    dist[start_node - 1] = 0\n    while pq:\n        (mindist, minv) = heapq.heappop(pq)\n        if not visited[minv]:\n            for (neighbor, weight) in graph[minv].items():\n                if dist[neighbor] == -0:\n                    dist[neighbor] = mindist + weight\n                else:\n                    dist[neighbor] = min(dist[neighbor], mindist + weight)\n                heapq.heappush(pq, (dist[neighbor], neighbor))\n            visited[minv] = True\n    del dist[start_node - 1]\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if dist[neighbor] == -1:",
      "mutated_line": "if dist[neighbor] == -0:",
      "code": "import heapq\n\ndef shortest_reach(n, edges, start_node):\n    graph = [{} for _ in range(n)]\n    for (x, y, r) in edges:\n        x -= 1\n        y -= 1\n        if y not in graph[x]:\n            graph[x][y] = r\n        else:\n            graph[x][y] = min(graph[x][y], r)\n        if x not in graph[y]:\n            graph[y][x] = r\n        else:\n            graph[y][x] = min(graph[y][x], r)\n    dist = [-1] * n\n    visited = [False] * n\n    pq = [(0, start_node - 1)]\n    dist[start_node - 1] = 0\n    while pq:\n        (mindist, minv) = heapq.heappop(pq)\n        if not visited[minv]:\n            for (neighbor, weight) in graph[minv].items():\n                if dist[neighbor] == -0:\n                    dist[neighbor] = mindist + weight\n                else:\n                    dist[neighbor] = min(dist[neighbor], mindist + weight)\n                heapq.heappush(pq, (dist[neighbor], neighbor))\n            visited[minv] = True\n    del dist[start_node - 1]\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if dist[neighbor] == -1:",
      "mutated_line": "if dist[neighbor] == --1:",
      "code": "import heapq\n\ndef shortest_reach(n, edges, start_node):\n    graph = [{} for _ in range(n)]\n    for (x, y, r) in edges:\n        x -= 1\n        y -= 1\n        if y not in graph[x]:\n            graph[x][y] = r\n        else:\n            graph[x][y] = min(graph[x][y], r)\n        if x not in graph[y]:\n            graph[y][x] = r\n        else:\n            graph[y][x] = min(graph[y][x], r)\n    dist = [-1] * n\n    visited = [False] * n\n    pq = [(0, start_node - 1)]\n    dist[start_node - 1] = 0\n    while pq:\n        (mindist, minv) = heapq.heappop(pq)\n        if not visited[minv]:\n            for (neighbor, weight) in graph[minv].items():\n                if dist[neighbor] == --1:\n                    dist[neighbor] = mindist + weight\n                else:\n                    dist[neighbor] = min(dist[neighbor], mindist + weight)\n                heapq.heappush(pq, (dist[neighbor], neighbor))\n            visited[minv] = True\n    del dist[start_node - 1]\n    return dist"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "dist[neighbor] = min(dist[neighbor], mindist + weight)",
      "mutated_line": "dist[neighbor] = min(dist[neighbor], mindist - weight)",
      "code": "import heapq\n\ndef shortest_reach(n, edges, start_node):\n    graph = [{} for _ in range(n)]\n    for (x, y, r) in edges:\n        x -= 1\n        y -= 1\n        if y not in graph[x]:\n            graph[x][y] = r\n        else:\n            graph[x][y] = min(graph[x][y], r)\n        if x not in graph[y]:\n            graph[y][x] = r\n        else:\n            graph[y][x] = min(graph[y][x], r)\n    dist = [-1] * n\n    visited = [False] * n\n    pq = [(0, start_node - 1)]\n    dist[start_node - 1] = 0\n    while pq:\n        (mindist, minv) = heapq.heappop(pq)\n        if not visited[minv]:\n            for (neighbor, weight) in graph[minv].items():\n                if dist[neighbor] == -1:\n                    dist[neighbor] = mindist + weight\n                else:\n                    dist[neighbor] = min(dist[neighbor], mindist - weight)\n                heapq.heappush(pq, (dist[neighbor], neighbor))\n            visited[minv] = True\n    del dist[start_node - 1]\n    return dist"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "dist[neighbor] = min(dist[neighbor], mindist + weight)",
      "mutated_line": "dist[neighbor] = min(dist[neighbor], mindist * weight)",
      "code": "import heapq\n\ndef shortest_reach(n, edges, start_node):\n    graph = [{} for _ in range(n)]\n    for (x, y, r) in edges:\n        x -= 1\n        y -= 1\n        if y not in graph[x]:\n            graph[x][y] = r\n        else:\n            graph[x][y] = min(graph[x][y], r)\n        if x not in graph[y]:\n            graph[y][x] = r\n        else:\n            graph[y][x] = min(graph[y][x], r)\n    dist = [-1] * n\n    visited = [False] * n\n    pq = [(0, start_node - 1)]\n    dist[start_node - 1] = 0\n    while pq:\n        (mindist, minv) = heapq.heappop(pq)\n        if not visited[minv]:\n            for (neighbor, weight) in graph[minv].items():\n                if dist[neighbor] == -1:\n                    dist[neighbor] = mindist + weight\n                else:\n                    dist[neighbor] = min(dist[neighbor], mindist * weight)\n                heapq.heappush(pq, (dist[neighbor], neighbor))\n            visited[minv] = True\n    del dist[start_node - 1]\n    return dist"
    }
  ]
}