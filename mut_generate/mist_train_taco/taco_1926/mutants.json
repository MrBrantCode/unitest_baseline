{
  "task_id": "taco_1926",
  "entry_point": "process_operations",
  "mutant_count": 86,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if Q[0] == 'a':",
      "mutated_line": "if Q[0] != 'a':",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]\n                if ans == 0:\n                    return 0\n                elif ans & 1:\n                    return ans / 2\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] != 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 15,
      "original_line": "if position >= len(self.items) or self.items[position] != num:",
      "mutated_line": "if position >= len(self.items) and self.items[position] != num:",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) and self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]\n                if ans == 0:\n                    return 0\n                elif ans & 1:\n                    return ans / 2\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if l == 0:",
      "mutated_line": "if l != 0:",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l != 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]\n                if ans == 0:\n                    return 0\n                elif ans & 1:\n                    return ans / 2\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "Q = operation.split(' ')",
      "mutated_line": "Q = operation.split('')",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]\n                if ans == 0:\n                    return 0\n                elif ans & 1:\n                    return ans / 2\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split('')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if Q[0] == 'a':",
      "mutated_line": "if Q[0] == '':",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]\n                if ans == 0:\n                    return 0\n                elif ans & 1:\n                    return ans / 2\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == '':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "elif Q[0] == 'r':",
      "mutated_line": "elif Q[0] != 'r':",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]\n                if ans == 0:\n                    return 0\n                elif ans & 1:\n                    return ans / 2\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] != 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if position >= len(self.items) or self.items[position] != num:",
      "mutated_line": "if position > len(self.items) or self.items[position] != num:",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position > len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]\n                if ans == 0:\n                    return 0\n                elif ans & 1:\n                    return ans / 2\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if position >= len(self.items) or self.items[position] != num:",
      "mutated_line": "if position < len(self.items) or self.items[position] != num:",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position < len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]\n                if ans == 0:\n                    return 0\n                elif ans & 1:\n                    return ans / 2\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if position >= len(self.items) or self.items[position] != num:",
      "mutated_line": "if position == len(self.items) or self.items[position] != num:",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position == len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]\n                if ans == 0:\n                    return 0\n                elif ans & 1:\n                    return ans / 2\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if position >= len(self.items) or self.items[position] != num:",
      "mutated_line": "if position >= len(self.items) or self.items[position] == num:",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] == num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]\n                if ans == 0:\n                    return 0\n                elif ans & 1:\n                    return ans / 2\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return 'Wrong!'",
      "mutated_line": "return ''",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return ''\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]\n                if ans == 0:\n                    return 0\n                elif ans & 1:\n                    return ans / 2\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if l == 0:",
      "mutated_line": "if l == 1:",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 1:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]\n                if ans == 0:\n                    return 0\n                elif ans & 1:\n                    return ans / 2\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if l == 0:",
      "mutated_line": "if l == -1:",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == -1:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]\n                if ans == 0:\n                    return 0\n                elif ans & 1:\n                    return ans / 2\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if l == 0:",
      "mutated_line": "if l == 1:",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 1:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]\n                if ans == 0:\n                    return 0\n                elif ans & 1:\n                    return ans / 2\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return 'Wrong!'",
      "mutated_line": "return ''",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return ''\n            elif l & 1:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]\n                if ans == 0:\n                    return 0\n                elif ans & 1:\n                    return ans / 2\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "elif l & 1:",
      "mutated_line": "elif l | 1:",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l | 1:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]\n                if ans == 0:\n                    return 0\n                elif ans & 1:\n                    return ans / 2\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "num = int(Q[1])",
      "mutated_line": "num = int(Q[2])",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]\n                if ans == 0:\n                    return 0\n                elif ans & 1:\n                    return ans / 2\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[2])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "num = int(Q[1])",
      "mutated_line": "num = int(Q[0])",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]\n                if ans == 0:\n                    return 0\n                elif ans & 1:\n                    return ans / 2\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[0])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "num = int(Q[1])",
      "mutated_line": "num = int(Q[0])",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]\n                if ans == 0:\n                    return 0\n                elif ans & 1:\n                    return ans / 2\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[0])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "num = int(Q[1])",
      "mutated_line": "num = int(Q[-1])",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]\n                if ans == 0:\n                    return 0\n                elif ans & 1:\n                    return ans / 2\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[-1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if Q[0] == 'a':",
      "mutated_line": "if Q[1] == 'a':",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]\n                if ans == 0:\n                    return 0\n                elif ans & 1:\n                    return ans / 2\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[1] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if Q[0] == 'a':",
      "mutated_line": "if Q[-1] == 'a':",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]\n                if ans == 0:\n                    return 0\n                elif ans & 1:\n                    return ans / 2\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[-1] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if Q[0] == 'a':",
      "mutated_line": "if Q[1] == 'a':",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]\n                if ans == 0:\n                    return 0\n                elif ans & 1:\n                    return ans / 2\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[1] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "elif Q[0] == 'r':",
      "mutated_line": "elif Q[0] == '':",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]\n                if ans == 0:\n                    return 0\n                elif ans & 1:\n                    return ans / 2\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == '':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "elif l & 1:",
      "mutated_line": "elif l & 2:",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 2:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]\n                if ans == 0:\n                    return 0\n                elif ans & 1:\n                    return ans / 2\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "elif l & 1:",
      "mutated_line": "elif l & 0:",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 0:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]\n                if ans == 0:\n                    return 0\n                elif ans & 1:\n                    return ans / 2\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "elif l & 1:",
      "mutated_line": "elif l & 0:",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 0:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]\n                if ans == 0:\n                    return 0\n                elif ans & 1:\n                    return ans / 2\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "elif l & 1:",
      "mutated_line": "elif l & -1:",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & -1:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]\n                if ans == 0:\n                    return 0\n                elif ans & 1:\n                    return ans / 2\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]",
      "mutated_line": "ans = self.items[int(l / 2)] - self.items[int(l / 2) - 1]",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / 2)] - self.items[int(l / 2) - 1]\n                if ans == 0:\n                    return 0\n                elif ans & 1:\n                    return ans / 2\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]",
      "mutated_line": "ans = self.items[int(l / 2)] * self.items[int(l / 2) - 1]",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / 2)] * self.items[int(l / 2) - 1]\n                if ans == 0:\n                    return 0\n                elif ans & 1:\n                    return ans / 2\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if ans == 0:",
      "mutated_line": "if ans != 0:",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]\n                if ans != 0:\n                    return 0\n                elif ans & 1:\n                    return ans / 2\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "elif Q[0] == 'r':",
      "mutated_line": "elif Q[1] == 'r':",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]\n                if ans == 0:\n                    return 0\n                elif ans & 1:\n                    return ans / 2\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[1] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "elif Q[0] == 'r':",
      "mutated_line": "elif Q[-1] == 'r':",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]\n                if ans == 0:\n                    return 0\n                elif ans & 1:\n                    return ans / 2\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[-1] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "elif Q[0] == 'r':",
      "mutated_line": "elif Q[1] == 'r':",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]\n                if ans == 0:\n                    return 0\n                elif ans & 1:\n                    return ans / 2\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[1] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if ans == 0:",
      "mutated_line": "if ans == 1:",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]\n                if ans == 1:\n                    return 0\n                elif ans & 1:\n                    return ans / 2\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if ans == 0:",
      "mutated_line": "if ans == -1:",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]\n                if ans == -1:\n                    return 0\n                elif ans & 1:\n                    return ans / 2\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if ans == 0:",
      "mutated_line": "if ans == 1:",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]\n                if ans == 1:\n                    return 0\n                elif ans & 1:\n                    return ans / 2\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]\n                if ans == 0:\n                    return 1\n                elif ans & 1:\n                    return ans / 2\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]\n                if ans == 0:\n                    return -1\n                elif ans & 1:\n                    return ans / 2\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]\n                if ans == 0:\n                    return 1\n                elif ans & 1:\n                    return ans / 2\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "elif ans & 1:",
      "mutated_line": "elif ans | 1:",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]\n                if ans == 0:\n                    return 0\n                elif ans | 1:\n                    return ans / 2\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return self.items[int(l / 2)]",
      "mutated_line": "return self.items[int(l * 2)]",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l * 2)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]\n                if ans == 0:\n                    return 0\n                elif ans & 1:\n                    return ans / 2\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return self.items[int(l / 2)]",
      "mutated_line": "return self.items[int(l // 2)]",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l // 2)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]\n                if ans == 0:\n                    return 0\n                elif ans & 1:\n                    return ans / 2\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]",
      "mutated_line": "ans = self.items[int(l / 2)] + self.items[int(l / 2) + 1]",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l / 2) + 1]\n                if ans == 0:\n                    return 0\n                elif ans & 1:\n                    return ans / 2\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]",
      "mutated_line": "ans = self.items[int(l / 2)] + self.items[int(l / 2) * 1]",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l / 2) * 1]\n                if ans == 0:\n                    return 0\n                elif ans & 1:\n                    return ans / 2\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "elif ans & 1:",
      "mutated_line": "elif ans & 2:",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]\n                if ans == 0:\n                    return 0\n                elif ans & 2:\n                    return ans / 2\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "elif ans & 1:",
      "mutated_line": "elif ans & 0:",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]\n                if ans == 0:\n                    return 0\n                elif ans & 0:\n                    return ans / 2\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "elif ans & 1:",
      "mutated_line": "elif ans & 0:",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]\n                if ans == 0:\n                    return 0\n                elif ans & 0:\n                    return ans / 2\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "elif ans & 1:",
      "mutated_line": "elif ans & -1:",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]\n                if ans == 0:\n                    return 0\n                elif ans & -1:\n                    return ans / 2\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "return ans / 2",
      "mutated_line": "return ans * 2",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]\n                if ans == 0:\n                    return 0\n                elif ans & 1:\n                    return ans * 2\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "return ans / 2",
      "mutated_line": "return ans // 2",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]\n                if ans == 0:\n                    return 0\n                elif ans & 1:\n                    return ans // 2\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return self.items[int(l / 2)]",
      "mutated_line": "return self.items[int(l / 3)]",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 3)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]\n                if ans == 0:\n                    return 0\n                elif ans & 1:\n                    return ans / 2\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return self.items[int(l / 2)]",
      "mutated_line": "return self.items[int(l / 1)]",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 1)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]\n                if ans == 0:\n                    return 0\n                elif ans & 1:\n                    return ans / 2\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return self.items[int(l / 2)]",
      "mutated_line": "return self.items[int(l / 0)]",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 0)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]\n                if ans == 0:\n                    return 0\n                elif ans & 1:\n                    return ans / 2\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return self.items[int(l / 2)]",
      "mutated_line": "return self.items[int(l / 1)]",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 1)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]\n                if ans == 0:\n                    return 0\n                elif ans & 1:\n                    return ans / 2\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return self.items[int(l / 2)]",
      "mutated_line": "return self.items[int(l / -2)]",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / -2)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]\n                if ans == 0:\n                    return 0\n                elif ans & 1:\n                    return ans / 2\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]",
      "mutated_line": "ans = self.items[int(l * 2)] + self.items[int(l / 2) - 1]",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l * 2)] + self.items[int(l / 2) - 1]\n                if ans == 0:\n                    return 0\n                elif ans & 1:\n                    return ans / 2\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]",
      "mutated_line": "ans = self.items[int(l // 2)] + self.items[int(l / 2) - 1]",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l // 2)] + self.items[int(l / 2) - 1]\n                if ans == 0:\n                    return 0\n                elif ans & 1:\n                    return ans / 2\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]",
      "mutated_line": "ans = self.items[int(l / 2)] + self.items[int(l / 2) - 2]",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l / 2) - 2]\n                if ans == 0:\n                    return 0\n                elif ans & 1:\n                    return ans / 2\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]",
      "mutated_line": "ans = self.items[int(l / 2)] + self.items[int(l / 2) - 0]",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l / 2) - 0]\n                if ans == 0:\n                    return 0\n                elif ans & 1:\n                    return ans / 2\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]",
      "mutated_line": "ans = self.items[int(l / 2)] + self.items[int(l / 2) - 0]",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l / 2) - 0]\n                if ans == 0:\n                    return 0\n                elif ans & 1:\n                    return ans / 2\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]",
      "mutated_line": "ans = self.items[int(l / 2)] + self.items[int(l / 2) - -1]",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l / 2) - -1]\n                if ans == 0:\n                    return 0\n                elif ans & 1:\n                    return ans / 2\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return ans / 2",
      "mutated_line": "return ans / 3",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]\n                if ans == 0:\n                    return 0\n                elif ans & 1:\n                    return ans / 3\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return ans / 2",
      "mutated_line": "return ans / 1",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]\n                if ans == 0:\n                    return 0\n                elif ans & 1:\n                    return ans / 1\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return ans / 2",
      "mutated_line": "return ans / 0",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]\n                if ans == 0:\n                    return 0\n                elif ans & 1:\n                    return ans / 0\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return ans / 2",
      "mutated_line": "return ans / 1",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]\n                if ans == 0:\n                    return 0\n                elif ans & 1:\n                    return ans / 1\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return ans / 2",
      "mutated_line": "return ans / -2",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]\n                if ans == 0:\n                    return 0\n                elif ans & 1:\n                    return ans / -2\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "return int(ans / 2)",
      "mutated_line": "return int(ans * 2)",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]\n                if ans == 0:\n                    return 0\n                elif ans & 1:\n                    return ans / 2\n                else:\n                    return int(ans * 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "return int(ans / 2)",
      "mutated_line": "return int(ans // 2)",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]\n                if ans == 0:\n                    return 0\n                elif ans & 1:\n                    return ans / 2\n                else:\n                    return int(ans // 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]",
      "mutated_line": "ans = self.items[int(l / 3)] + self.items[int(l / 2) - 1]",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / 3)] + self.items[int(l / 2) - 1]\n                if ans == 0:\n                    return 0\n                elif ans & 1:\n                    return ans / 2\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]",
      "mutated_line": "ans = self.items[int(l / 1)] + self.items[int(l / 2) - 1]",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / 1)] + self.items[int(l / 2) - 1]\n                if ans == 0:\n                    return 0\n                elif ans & 1:\n                    return ans / 2\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]",
      "mutated_line": "ans = self.items[int(l / 0)] + self.items[int(l / 2) - 1]",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / 0)] + self.items[int(l / 2) - 1]\n                if ans == 0:\n                    return 0\n                elif ans & 1:\n                    return ans / 2\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]",
      "mutated_line": "ans = self.items[int(l / 1)] + self.items[int(l / 2) - 1]",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / 1)] + self.items[int(l / 2) - 1]\n                if ans == 0:\n                    return 0\n                elif ans & 1:\n                    return ans / 2\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]",
      "mutated_line": "ans = self.items[int(l / -2)] + self.items[int(l / 2) - 1]",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / -2)] + self.items[int(l / 2) - 1]\n                if ans == 0:\n                    return 0\n                elif ans & 1:\n                    return ans / 2\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]",
      "mutated_line": "ans = self.items[int(l / 2)] + self.items[int(l * 2) - 1]",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l * 2) - 1]\n                if ans == 0:\n                    return 0\n                elif ans & 1:\n                    return ans / 2\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]",
      "mutated_line": "ans = self.items[int(l / 2)] + self.items[int(l // 2) - 1]",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l // 2) - 1]\n                if ans == 0:\n                    return 0\n                elif ans & 1:\n                    return ans / 2\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return int(ans / 2)",
      "mutated_line": "return int(ans / 3)",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]\n                if ans == 0:\n                    return 0\n                elif ans & 1:\n                    return ans / 2\n                else:\n                    return int(ans / 3)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return int(ans / 2)",
      "mutated_line": "return int(ans / 1)",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]\n                if ans == 0:\n                    return 0\n                elif ans & 1:\n                    return ans / 2\n                else:\n                    return int(ans / 1)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return int(ans / 2)",
      "mutated_line": "return int(ans / 0)",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]\n                if ans == 0:\n                    return 0\n                elif ans & 1:\n                    return ans / 2\n                else:\n                    return int(ans / 0)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return int(ans / 2)",
      "mutated_line": "return int(ans / 1)",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]\n                if ans == 0:\n                    return 0\n                elif ans & 1:\n                    return ans / 2\n                else:\n                    return int(ans / 1)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return int(ans / 2)",
      "mutated_line": "return int(ans / -2)",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]\n                if ans == 0:\n                    return 0\n                elif ans & 1:\n                    return ans / 2\n                else:\n                    return int(ans / -2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]",
      "mutated_line": "ans = self.items[int(l / 2)] + self.items[int(l / 3) - 1]",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l / 3) - 1]\n                if ans == 0:\n                    return 0\n                elif ans & 1:\n                    return ans / 2\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]",
      "mutated_line": "ans = self.items[int(l / 2)] + self.items[int(l / 1) - 1]",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l / 1) - 1]\n                if ans == 0:\n                    return 0\n                elif ans & 1:\n                    return ans / 2\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]",
      "mutated_line": "ans = self.items[int(l / 2)] + self.items[int(l / 0) - 1]",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l / 0) - 1]\n                if ans == 0:\n                    return 0\n                elif ans & 1:\n                    return ans / 2\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]",
      "mutated_line": "ans = self.items[int(l / 2)] + self.items[int(l / 1) - 1]",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l / 1) - 1]\n                if ans == 0:\n                    return 0\n                elif ans & 1:\n                    return ans / 2\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ans = self.items[int(l / 2)] + self.items[int(l / 2) - 1]",
      "mutated_line": "ans = self.items[int(l / 2)] + self.items[int(l / -2) - 1]",
      "code": "from bisect import bisect_left\n\ndef process_operations(operations):\n\n    class MedianFinder:\n\n        def __init__(self):\n            self.items = []\n\n        def addItem(self, num):\n            position = bisect_left(self.items, num)\n            self.items.insert(position, num)\n            return self.median()\n\n        def remItem(self, num):\n            position = bisect_left(self.items, num)\n            if position >= len(self.items) or self.items[position] != num:\n                return 'Wrong!'\n            else:\n                del self.items[position]\n                return self.median()\n\n        def median(self):\n            l = len(self.items)\n            if l == 0:\n                return 'Wrong!'\n            elif l & 1:\n                return self.items[int(l / 2)]\n            else:\n                ans = self.items[int(l / 2)] + self.items[int(l / -2) - 1]\n                if ans == 0:\n                    return 0\n                elif ans & 1:\n                    return ans / 2\n                else:\n                    return int(ans / 2)\n    arr = MedianFinder()\n    results = []\n    for operation in operations:\n        Q = operation.split(' ')\n        num = int(Q[1])\n        if Q[0] == 'a':\n            results.append(arr.addItem(num))\n        elif Q[0] == 'r':\n            results.append(arr.remItem(num))\n    return results"
    }
  ]
}