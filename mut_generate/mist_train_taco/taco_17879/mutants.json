{
  "task_id": "taco_17879",
  "entry_point": "can_move_with_ticket",
  "mutant_count": 82,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 5,
      "original_line": "a -= 1",
      "mutated_line": "a += 1",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a += 1\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 ** 20\n        dist = [INF] * S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d -= 1\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 6,
      "original_line": "b -= 1",
      "mutated_line": "b += 1",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b += 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 ** 20\n        dist = [INF] * S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d -= 1\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "a -= 1",
      "mutated_line": "a -= 2",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 2\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 ** 20\n        dist = [INF] * S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d -= 1\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "a -= 1",
      "mutated_line": "a -= 0",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 0\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 ** 20\n        dist = [INF] * S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d -= 1\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "a -= 1",
      "mutated_line": "a -= 0",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 0\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 ** 20\n        dist = [INF] * S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d -= 1\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "a -= 1",
      "mutated_line": "a -= -1",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= -1\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 ** 20\n        dist = [INF] * S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d -= 1\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "b -= 1",
      "mutated_line": "b -= 2",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b -= 2\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 ** 20\n        dist = [INF] * S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d -= 1\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "b -= 1",
      "mutated_line": "b -= 0",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b -= 0\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 ** 20\n        dist = [INF] * S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d -= 1\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "b -= 1",
      "mutated_line": "b -= 0",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b -= 0\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 ** 20\n        dist = [INF] * S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d -= 1\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "b -= 1",
      "mutated_line": "b -= -1",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b -= -1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 ** 20\n        dist = [INF] * S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d -= 1\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 11,
      "original_line": "u -= 1",
      "mutated_line": "u += 1",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u += 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 ** 20\n        dist = [INF] * S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d -= 1\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 12,
      "original_line": "v -= 1",
      "mutated_line": "v += 1",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v += 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 ** 20\n        dist = [INF] * S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d -= 1\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 53,
      "original_line": "c -= 1",
      "mutated_line": "c += 1",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 ** 20\n        dist = [INF] * S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c += 1\n        d -= 1\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 54,
      "original_line": "d -= 1",
      "mutated_line": "d += 1",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 ** 20\n        dist = [INF] * S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d += 1\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "u -= 1",
      "mutated_line": "u -= 2",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 2\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 ** 20\n        dist = [INF] * S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d -= 1\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "u -= 1",
      "mutated_line": "u -= 0",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 0\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 ** 20\n        dist = [INF] * S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d -= 1\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "u -= 1",
      "mutated_line": "u -= 0",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 0\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 ** 20\n        dist = [INF] * S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d -= 1\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "u -= 1",
      "mutated_line": "u -= -1",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= -1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 ** 20\n        dist = [INF] * S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d -= 1\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "v -= 1",
      "mutated_line": "v -= 2",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v -= 2\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 ** 20\n        dist = [INF] * S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d -= 1\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "v -= 1",
      "mutated_line": "v -= 0",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v -= 0\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 ** 20\n        dist = [INF] * S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d -= 1\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "v -= 1",
      "mutated_line": "v -= 0",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v -= 0\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 ** 20\n        dist = [INF] * S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d -= 1\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "v -= 1",
      "mutated_line": "v -= -1",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v -= -1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 ** 20\n        dist = [INF] * S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d -= 1\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 10 * 20",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 * 20\n        dist = [INF] * S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d -= 1\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 10 + 20",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 + 20\n        dist = [INF] * S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d -= 1\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "dist = [INF] * S",
      "mutated_line": "dist = [INF] / S",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 ** 20\n        dist = [INF] / S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d -= 1\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "dist = [INF] * S",
      "mutated_line": "dist = [INF] + S",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 ** 20\n        dist = [INF] + S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d -= 1\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "dist = [INF] * S",
      "mutated_line": "dist = [INF] ** S",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 ** 20\n        dist = [INF] ** S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d -= 1\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dist[start] = 0",
      "mutated_line": "dist[start] = 1",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 ** 20\n        dist = [INF] * S\n        dist[start] = 1\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d -= 1\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dist[start] = 0",
      "mutated_line": "dist[start] = -1",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 ** 20\n        dist = [INF] * S\n        dist[start] = -1\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d -= 1\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dist[start] = 0",
      "mutated_line": "dist[start] = 1",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 ** 20\n        dist = [INF] * S\n        dist[start] = 1\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d -= 1\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if c == d:",
      "mutated_line": "if c != d:",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 ** 20\n        dist = [INF] * S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c != d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d -= 1\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if d in mem:",
      "mutated_line": "if d not in mem:",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 ** 20\n        dist = [INF] * S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d not in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d -= 1\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if dist_from_a[c] >= dist_from_a[d]:",
      "mutated_line": "if dist_from_a[c] > dist_from_a[d]:",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 ** 20\n        dist = [INF] * S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] > dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d -= 1\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if dist_from_a[c] >= dist_from_a[d]:",
      "mutated_line": "if dist_from_a[c] < dist_from_a[d]:",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 ** 20\n        dist = [INF] * S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] < dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d -= 1\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if dist_from_a[c] >= dist_from_a[d]:",
      "mutated_line": "if dist_from_a[c] == dist_from_a[d]:",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 ** 20\n        dist = [INF] * S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] == dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d -= 1\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 ** 20\n        dist = [INF] * S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return True\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d -= 1\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "c -= 1",
      "mutated_line": "c -= 2",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 ** 20\n        dist = [INF] * S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 2\n        d -= 1\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "c -= 1",
      "mutated_line": "c -= 0",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 ** 20\n        dist = [INF] * S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 0\n        d -= 1\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "c -= 1",
      "mutated_line": "c -= 0",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 ** 20\n        dist = [INF] * S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 0\n        d -= 1\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "c -= 1",
      "mutated_line": "c -= -1",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 ** 20\n        dist = [INF] * S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= -1\n        d -= 1\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "d -= 1",
      "mutated_line": "d -= 2",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 ** 20\n        dist = [INF] * S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d -= 2\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "d -= 1",
      "mutated_line": "d -= 0",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 ** 20\n        dist = [INF] * S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d -= 0\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "d -= 1",
      "mutated_line": "d -= 0",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 ** 20\n        dist = [INF] * S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d -= 0\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "d -= 1",
      "mutated_line": "d -= -1",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 ** 20\n        dist = [INF] * S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d -= -1\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 55,
      "original_line": "if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):",
      "mutated_line": "if dist_from_a[c] + dist_from_b[c] == shortest or dist_from_a[d] + dist_from_b[d] == shortest or on_shortest_path(c, d, set()):",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 ** 20\n        dist = [INF] * S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d -= 1\n        if dist_from_a[c] + dist_from_b[c] == shortest or dist_from_a[d] + dist_from_b[d] == shortest or on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 11 ** 20",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 11 ** 20\n        dist = [INF] * S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d -= 1\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 9 ** 20",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 9 ** 20\n        dist = [INF] * S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d -= 1\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 0 ** 20",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 0 ** 20\n        dist = [INF] * S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d -= 1\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 1 ** 20",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 1 ** 20\n        dist = [INF] * S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d -= 1\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = -10 ** 20",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = -10 ** 20\n        dist = [INF] * S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d -= 1\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 10 ** 21",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 ** 21\n        dist = [INF] * S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d -= 1\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 10 ** 19",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 ** 19\n        dist = [INF] * S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d -= 1\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 10 ** 0",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 ** 0\n        dist = [INF] * S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d -= 1\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 10 ** 1",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 ** 1\n        dist = [INF] * S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d -= 1\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 10 ** -20",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 ** -20\n        dist = [INF] * S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d -= 1\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 ** 20\n        dist = [INF] * S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return False\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d -= 1\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 ** 20\n        dist = [INF] * S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return True\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d -= 1\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 ** 20\n        dist = [INF] * S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return True\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d -= 1\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 55,
      "original_line": "if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):",
      "mutated_line": "if dist_from_a[c] + dist_from_b[c] != shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 ** 20\n        dist = [INF] * S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d -= 1\n        if dist_from_a[c] + dist_from_b[c] != shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 55,
      "original_line": "if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):",
      "mutated_line": "if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] != shortest and on_shortest_path(c, d, set()):",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 ** 20\n        dist = [INF] * S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d -= 1\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] != shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "heappush(que, (0, start))",
      "mutated_line": "heappush(que, (1, start))",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 ** 20\n        dist = [INF] * S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (1, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d -= 1\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "heappush(que, (0, start))",
      "mutated_line": "heappush(que, (-1, start))",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 ** 20\n        dist = [INF] * S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (-1, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d -= 1\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "heappush(que, (0, start))",
      "mutated_line": "heappush(que, (1, start))",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 ** 20\n        dist = [INF] * S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (1, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d -= 1\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if dist[to] > score + w:",
      "mutated_line": "if dist[to] >= score + w:",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 ** 20\n        dist = [INF] * S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] >= score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d -= 1\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if dist[to] > score + w:",
      "mutated_line": "if dist[to] <= score + w:",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 ** 20\n        dist = [INF] * S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] <= score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d -= 1\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if dist[to] > score + w:",
      "mutated_line": "if dist[to] != score + w:",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 ** 20\n        dist = [INF] * S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] != score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d -= 1\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 ** 20\n        dist = [INF] * S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return False\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d -= 1\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):",
      "mutated_line": "if dist_from_a[c] - dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 ** 20\n        dist = [INF] * S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d -= 1\n        if dist_from_a[c] - dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):",
      "mutated_line": "if dist_from_a[c] * dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 ** 20\n        dist = [INF] * S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d -= 1\n        if dist_from_a[c] * dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):",
      "mutated_line": "if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] - dist_from_b[d] == shortest and on_shortest_path(c, d, set()):",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 ** 20\n        dist = [INF] * S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d -= 1\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] - dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):",
      "mutated_line": "if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] * dist_from_b[d] == shortest and on_shortest_path(c, d, set()):",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 ** 20\n        dist = [INF] * S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d -= 1\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] * dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "results.append('Yes')",
      "mutated_line": "results.append('')",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 ** 20\n        dist = [INF] * S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d -= 1\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 58,
      "original_line": "results.append('No')",
      "mutated_line": "results.append('')",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 ** 20\n        dist = [INF] * S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d -= 1\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if dist[to] > score + w:",
      "mutated_line": "if dist[to] > score - w:",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 ** 20\n        dist = [INF] * S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score - w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d -= 1\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if dist[to] > score + w:",
      "mutated_line": "if dist[to] > score * w:",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 ** 20\n        dist = [INF] * S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score * w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d -= 1\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "dist[to] = score + w",
      "mutated_line": "dist[to] = score - w",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 ** 20\n        dist = [INF] * S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score - w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d -= 1\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "dist[to] = score + w",
      "mutated_line": "dist[to] = score * w",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 ** 20\n        dist = [INF] * S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score * w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d -= 1\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "elif dist[to] == score + w:",
      "mutated_line": "elif dist[to] != score + w:",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 ** 20\n        dist = [INF] * S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] != score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d -= 1\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "elif dist[to] == score + w:",
      "mutated_line": "elif dist[to] == score - w:",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 ** 20\n        dist = [INF] * S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score - w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d -= 1\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "elif dist[to] == score + w:",
      "mutated_line": "elif dist[to] == score * w:",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 ** 20\n        dist = [INF] * S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score + w, to))\n                elif dist[to] == score * w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d -= 1\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "heappush(que, (score + w, to))",
      "mutated_line": "heappush(que, (score - w, to))",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 ** 20\n        dist = [INF] * S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score - w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d -= 1\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "heappush(que, (score + w, to))",
      "mutated_line": "heappush(que, (score * w, to))",
      "code": "from heapq import heappush, heappop\n\ndef can_move_with_ticket(S, R, edges, a, b, queries):\n    a -= 1\n    b -= 1\n    adj_list = [[] for _ in range(S)]\n    for (u, v, w) in edges:\n        u -= 1\n        v -= 1\n        adj_list[u].append((v, w))\n        adj_list[v].append((u, w))\n\n    def dijkstra(start):\n        INF = 10 ** 20\n        dist = [INF] * S\n        dist[start] = 0\n        parents = [[] for _ in range(S)]\n        que = []\n        heappush(que, (0, start))\n        while que:\n            (score, node) = heappop(que)\n            for (to, w) in adj_list[node]:\n                if dist[to] > score + w:\n                    dist[to] = score + w\n                    parents[to] = {node}\n                    heappush(que, (score * w, to))\n                elif dist[to] == score + w:\n                    parents[to].add(node)\n        return (dist, parents)\n\n    def on_shortest_path(c, d, mem):\n        if c == d:\n            return True\n        if d in mem:\n            return False\n        mem.add(d)\n        if dist_from_a[c] >= dist_from_a[d]:\n            return False\n        for parent in parents[d]:\n            if on_shortest_path(c, parent, mem):\n                return True\n        return False\n    (dist_from_a, parents) = dijkstra(a)\n    (dist_from_b, _) = dijkstra(b)\n    shortest = dist_from_a[b]\n    results = []\n    for (c, d) in queries:\n        c -= 1\n        d -= 1\n        if dist_from_a[c] + dist_from_b[c] == shortest and dist_from_a[d] + dist_from_b[d] == shortest and on_shortest_path(c, d, set()):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results"
    }
  ]
}