{
  "task_id": "taco_10234",
  "entry_point": "count_colorings",
  "mutant_count": 271,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 9 - 7",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 - 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 9 * 7",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 * 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if m == 1:",
      "mutated_line": "if m != 1:",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m != 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if m == 2:",
      "mutated_line": "if m != 2:",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m != 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "dp = [0] * (n + 1)",
      "mutated_line": "dp = [0] / (n + 1)",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] / (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "dp = [0] * (n + 1)",
      "mutated_line": "dp = [0] + (n + 1)",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] + (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "dp = [0] * (n + 1)",
      "mutated_line": "dp = [0] ** (n + 1)",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] ** (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dp[1] = 1",
      "mutated_line": "dp[1] = 2",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 2\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dp[1] = 1",
      "mutated_line": "dp[1] = 0",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 0\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dp[1] = 1",
      "mutated_line": "dp[1] = 0",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 0\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dp[1] = 1",
      "mutated_line": "dp[1] = -1",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = -1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 1\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = -1\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 1\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 * 9 + 7",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 * 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 + 9 + 7",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 + 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 9 + 8",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 8\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 9 + 6",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 6\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 9 + 0",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 0\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 9 + 1",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 1\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 9 + -7",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + -7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if m == 1:",
      "mutated_line": "if m == 2:",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 2:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if m == 1:",
      "mutated_line": "if m == 0:",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 0:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if m == 1:",
      "mutated_line": "if m == 0:",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 0:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if m == 1:",
      "mutated_line": "if m == -1:",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == -1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "fac = [1]",
      "mutated_line": "fac = [2]",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [2]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "fac = [1]",
      "mutated_line": "fac = [0]",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [0]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "fac = [1]",
      "mutated_line": "fac = [0]",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [0]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "fac = [1]",
      "mutated_line": "fac = [-1]",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [-1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "ifac = [1]",
      "mutated_line": "ifac = [2]",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [2]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "ifac = [1]",
      "mutated_line": "ifac = [0]",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [0]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "ifac = [1]",
      "mutated_line": "ifac = [0]",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [0]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "ifac = [1]",
      "mutated_line": "ifac = [-1]",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [-1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "tav = [0]",
      "mutated_line": "tav = [1]",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [1]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "tav = [0]",
      "mutated_line": "tav = [-1]",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [-1]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "tav = [0]",
      "mutated_line": "tav = [1]",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [1]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, max(k + 1, n + 1)):",
      "mutated_line": "for i in range(2, max(k + 1, n + 1)):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(2, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, max(k + 1, n + 1)):",
      "mutated_line": "for i in range(0, max(k + 1, n + 1)):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(0, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, max(k + 1, n + 1)):",
      "mutated_line": "for i in range(0, max(k + 1, n + 1)):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(0, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, max(k + 1, n + 1)):",
      "mutated_line": "for i in range(-1, max(k + 1, n + 1)):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(-1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(1, min(k + 1, n + 1)):",
      "mutated_line": "for i in range(2, min(k + 1, n + 1)):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(2, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(1, min(k + 1, n + 1)):",
      "mutated_line": "for i in range(0, min(k + 1, n + 1)):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(0, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(1, min(k + 1, n + 1)):",
      "mutated_line": "for i in range(0, min(k + 1, n + 1)):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(0, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(1, min(k + 1, n + 1)):",
      "mutated_line": "for i in range(-1, min(k + 1, n + 1)):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(-1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if m == 2:",
      "mutated_line": "if m == 3:",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 3:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if m == 2:",
      "mutated_line": "if m == 1:",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 1:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if m == 2:",
      "mutated_line": "if m == 0:",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 0:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if m == 2:",
      "mutated_line": "if m == 1:",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 1:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if m == 2:",
      "mutated_line": "if m == -2:",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == -2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "tav[0] = 1",
      "mutated_line": "tav[0] = 2",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 2\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "tav[0] = 1",
      "mutated_line": "tav[0] = 0",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 0\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "tav[0] = 1",
      "mutated_line": "tav[0] = 0",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 0\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "tav[0] = 1",
      "mutated_line": "tav[0] = -1",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = -1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "dp = [0] * (n + 1)",
      "mutated_line": "dp = [0] * (n - 1)",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n - 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "dp = [0] * (n + 1)",
      "mutated_line": "dp = [0] * (n * 1)",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n * 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dp[1] = 1",
      "mutated_line": "dp[2] = 1",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[2] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dp[1] = 1",
      "mutated_line": "dp[0] = 1",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dp[1] = 1",
      "mutated_line": "dp[0] = 1",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dp[1] = 1",
      "mutated_line": "dp[-1] = 1",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[-1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(3, n + 1):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(3, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(1, n + 1):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(1, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(0, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(1, n + 1):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(1, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(-2, n + 1):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(-2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(2, n - 1):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n - 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(2, n * 1):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n * 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for i in range(1, min(k + 1, n + 1)):",
      "mutated_line": "for i in range(2, min(k + 1, n + 1)):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(2, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for i in range(1, min(k + 1, n + 1)):",
      "mutated_line": "for i in range(0, min(k + 1, n + 1)):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(0, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for i in range(1, min(k + 1, n + 1)):",
      "mutated_line": "for i in range(0, min(k + 1, n + 1)):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(0, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for i in range(1, min(k + 1, n + 1)):",
      "mutated_line": "for i in range(-1, min(k + 1, n + 1)):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(-1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 11 ** 9 + 7",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 11 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 9 ** 9 + 7",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 9 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 0 ** 9 + 7",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 0 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 1 ** 9 + 7",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 1 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = -10 ** 9 + 7",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = -10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 10 + 7",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 10 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 8 + 7",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 8 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 0 + 7",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 0 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 1 + 7",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 1 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** -9 + 7",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** -9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "for i in range(1, max(k + 1, n + 1)):",
      "mutated_line": "for i in range(1, max(k - 1, n + 1)):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k - 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "for i in range(1, max(k + 1, n + 1)):",
      "mutated_line": "for i in range(1, max(k * 1, n + 1)):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k * 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "for i in range(1, max(k + 1, n + 1)):",
      "mutated_line": "for i in range(1, max(k + 1, n - 1)):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n - 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "for i in range(1, max(k + 1, n + 1)):",
      "mutated_line": "for i in range(1, max(k + 1, n * 1)):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n * 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "fac.append(fac[i - 1] * i % mod)",
      "mutated_line": "fac.append(fac[i - 1] * i * mod)",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i * mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "fac.append(fac[i - 1] * i % mod)",
      "mutated_line": "fac.append(fac[i - 1] * i + mod)",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i + mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "for i in range(1, min(k + 1, n + 1)):",
      "mutated_line": "for i in range(1, min(k - 1, n + 1)):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k - 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "for i in range(1, min(k + 1, n + 1)):",
      "mutated_line": "for i in range(1, min(k * 1, n + 1)):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k * 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "for i in range(1, min(k + 1, n + 1)):",
      "mutated_line": "for i in range(1, min(k + 1, n - 1)):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n - 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "for i in range(1, min(k + 1, n + 1)):",
      "mutated_line": "for i in range(1, min(k + 1, n * 1)):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n * 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)",
      "mutated_line": "ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) * mod)",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) * mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)",
      "mutated_line": "ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) + mod)",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) + mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "tav[0] = 1",
      "mutated_line": "tav[1] = 1",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[1] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "tav[0] = 1",
      "mutated_line": "tav[-1] = 1",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[-1] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "tav[0] = 1",
      "mutated_line": "tav[1] = 1",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[1] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dp = [0] * (n + 1)",
      "mutated_line": "dp = [1] * (n + 1)",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [1] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dp = [0] * (n + 1)",
      "mutated_line": "dp = [-1] * (n + 1)",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [-1] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dp = [0] * (n + 1)",
      "mutated_line": "dp = [1] * (n + 1)",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [1] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dp = [0] * (n + 1)",
      "mutated_line": "dp = [0] * (n + 2)",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 2)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dp = [0] * (n + 1)",
      "mutated_line": "dp = [0] * (n + 0)",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 0)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dp = [0] * (n + 1)",
      "mutated_line": "dp = [0] * (n + 0)",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 0)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dp = [0] * (n + 1)",
      "mutated_line": "dp = [0] * (n + -1)",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + -1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(2, n + 2):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 2):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(2, n + 0):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 0):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(2, n + 0):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 0):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(2, n + -1):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + -1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range(i, 1, -1):",
      "mutated_line": "for j in range(i, 2, -1):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 2, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range(i, 1, -1):",
      "mutated_line": "for j in range(i, 0, -1):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 0, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range(i, 1, -1):",
      "mutated_line": "for j in range(i, 0, -1):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 0, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range(i, 1, -1):",
      "mutated_line": "for j in range(i, -1, -1):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, -1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 25,
      "original_line": "for j in range(i, 1, -1):",
      "mutated_line": "for j in range(i, 1, +1):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, +1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dp[j] = (j * dp[j] + dp[j - 1]) % mod",
      "mutated_line": "dp[j] = (j * dp[j] + dp[j - 1]) * mod",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) * mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dp[j] = (j * dp[j] + dp[j - 1]) % mod",
      "mutated_line": "dp[j] = j * dp[j] + dp[j - 1] + mod",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = j * dp[j] + dp[j - 1] + mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "for i in range(1, min(k + 1, n + 1)):",
      "mutated_line": "for i in range(1, min(k - 1, n + 1)):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k - 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "for i in range(1, min(k + 1, n + 1)):",
      "mutated_line": "for i in range(1, min(k * 1, n + 1)):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k * 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "for i in range(1, min(k + 1, n + 1)):",
      "mutated_line": "for i in range(1, min(k + 1, n - 1)):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n - 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "for i in range(1, min(k + 1, n + 1)):",
      "mutated_line": "for i in range(1, min(k + 1, n * 1)):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n * 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for j in range(0, i + 1):",
      "mutated_line": "for j in range(1, i + 1):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(1, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for j in range(0, i + 1):",
      "mutated_line": "for j in range(-1, i + 1):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(-1, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for j in range(0, i + 1):",
      "mutated_line": "for j in range(1, i + 1):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(1, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "for j in range(0, i + 1):",
      "mutated_line": "for j in range(0, i - 1):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i - 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "for j in range(0, i + 1):",
      "mutated_line": "for j in range(0, i * 1):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i * 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if 2 * i - j > k:",
      "mutated_line": "if 2 * i - j >= k:",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j >= k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if 2 * i - j > k:",
      "mutated_line": "if 2 * i - j <= k:",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j <= k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if 2 * i - j > k:",
      "mutated_line": "if 2 * i - j != k:",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j != k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "mutated_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) * mod",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) * mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "mutated_line": "ans = ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j] + mod",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j] + mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, max(k + 1, n + 1)):",
      "mutated_line": "for i in range(1, max(k + 2, n + 1)):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 2, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, max(k + 1, n + 1)):",
      "mutated_line": "for i in range(1, max(k + 0, n + 1)):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 0, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, max(k + 1, n + 1)):",
      "mutated_line": "for i in range(1, max(k + 0, n + 1)):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 0, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, max(k + 1, n + 1)):",
      "mutated_line": "for i in range(1, max(k + -1, n + 1)):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + -1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, max(k + 1, n + 1)):",
      "mutated_line": "for i in range(1, max(k + 1, n + 2)):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 2)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, max(k + 1, n + 1)):",
      "mutated_line": "for i in range(1, max(k + 1, n + 0)):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 0)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, max(k + 1, n + 1)):",
      "mutated_line": "for i in range(1, max(k + 1, n + 0)):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 0)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, max(k + 1, n + 1)):",
      "mutated_line": "for i in range(1, max(k + 1, n + -1)):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + -1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "fac.append(fac[i - 1] * i % mod)",
      "mutated_line": "fac.append(fac[i - 1] / i % mod)",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] / i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "fac.append(fac[i - 1] * i % mod)",
      "mutated_line": "fac.append((fac[i - 1] + i) % mod)",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append((fac[i - 1] + i) % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "fac.append(fac[i - 1] * i % mod)",
      "mutated_line": "fac.append(fac[i - 1] ** i % mod)",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] ** i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(1, min(k + 1, n + 1)):",
      "mutated_line": "for i in range(1, min(k + 2, n + 1)):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 2, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(1, min(k + 1, n + 1)):",
      "mutated_line": "for i in range(1, min(k + 0, n + 1)):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 0, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(1, min(k + 1, n + 1)):",
      "mutated_line": "for i in range(1, min(k + 0, n + 1)):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 0, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(1, min(k + 1, n + 1)):",
      "mutated_line": "for i in range(1, min(k + -1, n + 1)):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + -1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(1, min(k + 1, n + 1)):",
      "mutated_line": "for i in range(1, min(k + 1, n + 2)):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 2)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(1, min(k + 1, n + 1)):",
      "mutated_line": "for i in range(1, min(k + 1, n + 0)):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 0)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(1, min(k + 1, n + 1)):",
      "mutated_line": "for i in range(1, min(k + 1, n + 0)):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 0)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(1, min(k + 1, n + 1)):",
      "mutated_line": "for i in range(1, min(k + 1, n + -1)):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + -1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)",
      "mutated_line": "ifac.append(ifac[i - 1] / pow(i, mod - 2, mod) % mod)",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] / pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)",
      "mutated_line": "ifac.append((ifac[i - 1] + pow(i, mod - 2, mod)) % mod)",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append((ifac[i - 1] + pow(i, mod - 2, mod)) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)",
      "mutated_line": "ifac.append(ifac[i - 1] ** pow(i, mod - 2, mod) % mod)",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] ** pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "tav.append(pow(i, n * (m - 2), mod))",
      "mutated_line": "tav.append(pow(i, n / (m - 2), mod))",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n / (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "tav.append(pow(i, n * (m - 2), mod))",
      "mutated_line": "tav.append(pow(i, n + (m - 2), mod))",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n + (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "tav.append(pow(i, n * (m - 2), mod))",
      "mutated_line": "tav.append(pow(i, n ** (m - 2), mod))",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n ** (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range(i, 1, -1):",
      "mutated_line": "for j in range(i, 1, -2):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -2):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range(i, 1, -1):",
      "mutated_line": "for j in range(i, 1, -0):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -0):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range(i, 1, -1):",
      "mutated_line": "for j in range(i, 1, -0):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -0):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range(i, 1, -1):",
      "mutated_line": "for j in range(i, 1, --1):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, --1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dp[j] = (j * dp[j] + dp[j - 1]) % mod",
      "mutated_line": "dp[j] = (j * dp[j] - dp[j - 1]) % mod",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] - dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dp[j] = (j * dp[j] + dp[j - 1]) % mod",
      "mutated_line": "dp[j] = j * dp[j] * dp[j - 1] % mod",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = j * dp[j] * dp[j - 1] % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for i in range(1, min(k + 1, n + 1)):",
      "mutated_line": "for i in range(1, min(k + 2, n + 1)):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 2, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for i in range(1, min(k + 1, n + 1)):",
      "mutated_line": "for i in range(1, min(k + 0, n + 1)):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 0, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for i in range(1, min(k + 1, n + 1)):",
      "mutated_line": "for i in range(1, min(k + 0, n + 1)):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 0, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for i in range(1, min(k + 1, n + 1)):",
      "mutated_line": "for i in range(1, min(k + -1, n + 1)):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + -1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for i in range(1, min(k + 1, n + 1)):",
      "mutated_line": "for i in range(1, min(k + 1, n + 2)):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 2)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for i in range(1, min(k + 1, n + 1)):",
      "mutated_line": "for i in range(1, min(k + 1, n + 0)):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 0)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for i in range(1, min(k + 1, n + 1)):",
      "mutated_line": "for i in range(1, min(k + 1, n + 0)):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 0)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for i in range(1, min(k + 1, n + 1)):",
      "mutated_line": "for i in range(1, min(k + 1, n + -1)):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + -1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for j in range(0, i + 1):",
      "mutated_line": "for j in range(0, i + 2):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 2):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for j in range(0, i + 1):",
      "mutated_line": "for j in range(0, i + 0):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 0):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for j in range(0, i + 1):",
      "mutated_line": "for j in range(0, i + 0):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 0):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for j in range(0, i + 1):",
      "mutated_line": "for j in range(0, i + -1):",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + -1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "if 2 * i - j > k:",
      "mutated_line": "if 2 * i + j > k:",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i + j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "if 2 * i - j > k:",
      "mutated_line": "if 2 * i * j > k:",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i * j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "mutated_line": "ans = (ans - dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans - dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "mutated_line": "ans = ans * (dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = ans * (dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "tav.append(pow(i, n * (m - 2), mod))",
      "mutated_line": "tav.append(pow(i, n * (m + 2), mod))",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m + 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "tav.append(pow(i, n * (m - 2), mod))",
      "mutated_line": "tav.append(pow(i, n * (m * 2), mod))",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m * 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dp[j] = (j * dp[j] + dp[j - 1]) % mod",
      "mutated_line": "dp[j] = (j / dp[j] + dp[j - 1]) % mod",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j / dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dp[j] = (j * dp[j] + dp[j - 1]) % mod",
      "mutated_line": "dp[j] = (j + dp[j] + dp[j - 1]) % mod",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j + dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dp[j] = (j * dp[j] + dp[j - 1]) % mod",
      "mutated_line": "dp[j] = (j ** dp[j] + dp[j - 1]) % mod",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j ** dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "if 2 * i - j > k:",
      "mutated_line": "if 2 / i - j > k:",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 / i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "if 2 * i - j > k:",
      "mutated_line": "if 2 + i - j > k:",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 + i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "if 2 * i - j > k:",
      "mutated_line": "if 2 ** i - j > k:",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 ** i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "mutated_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] / ifac[j]) % mod",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] / ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "mutated_line": "ans = (ans + (dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] + ifac[j])) % mod",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + (dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] + ifac[j])) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "mutated_line": "ans = (ans + (dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j]) ** ifac[j]) % mod",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + (dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j]) ** ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "fac.append(fac[i - 1] * i % mod)",
      "mutated_line": "fac.append(fac[i + 1] * i % mod)",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i + 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "fac.append(fac[i - 1] * i % mod)",
      "mutated_line": "fac.append(fac[i * 1] * i % mod)",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i * 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)",
      "mutated_line": "ifac.append(ifac[i + 1] * pow(i, mod - 2, mod) % mod)",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i + 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)",
      "mutated_line": "ifac.append(ifac[i * 1] * pow(i, mod - 2, mod) % mod)",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i * 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)",
      "mutated_line": "ifac.append(ifac[i - 1] * pow(i, mod + 2, mod) % mod)",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod + 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)",
      "mutated_line": "ifac.append(ifac[i - 1] * pow(i, mod * 2, mod) % mod)",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod * 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "tav.append(pow(i, n * (m - 2), mod))",
      "mutated_line": "tav.append(pow(i, n * (m - 3), mod))",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 3), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "tav.append(pow(i, n * (m - 2), mod))",
      "mutated_line": "tav.append(pow(i, n * (m - 1), mod))",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 1), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "tav.append(pow(i, n * (m - 2), mod))",
      "mutated_line": "tav.append(pow(i, n * (m - 0), mod))",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 0), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "tav.append(pow(i, n * (m - 2), mod))",
      "mutated_line": "tav.append(pow(i, n * (m - 1), mod))",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 1), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "tav.append(pow(i, n * (m - 2), mod))",
      "mutated_line": "tav.append(pow(i, n * (m - -2), mod))",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - -2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dp[j] = (j * dp[j] + dp[j - 1]) % mod",
      "mutated_line": "dp[j] = (j * dp[j] + dp[j + 1]) % mod",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j + 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dp[j] = (j * dp[j] + dp[j - 1]) % mod",
      "mutated_line": "dp[j] = (j * dp[j] + dp[j * 1]) % mod",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j * 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if 2 * i - j > k:",
      "mutated_line": "if 3 * i - j > k:",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 3 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if 2 * i - j > k:",
      "mutated_line": "if 1 * i - j > k:",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 1 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if 2 * i - j > k:",
      "mutated_line": "if 0 * i - j > k:",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 0 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if 2 * i - j > k:",
      "mutated_line": "if 1 * i - j > k:",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 1 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if 2 * i - j > k:",
      "mutated_line": "if -2 * i - j > k:",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if -2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "mutated_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) / ifac[i - j] * ifac[j]) % mod",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) / ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "mutated_line": "ans = (ans + (dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) + ifac[i - j]) * ifac[j]) % mod",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + (dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) + ifac[i - j]) * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "mutated_line": "ans = (ans + (dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod)) ** ifac[i - j] * ifac[j]) % mod",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + (dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod)) ** ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "fac.append(fac[i - 1] * i % mod)",
      "mutated_line": "fac.append(fac[i - 2] * i % mod)",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 2] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "fac.append(fac[i - 1] * i % mod)",
      "mutated_line": "fac.append(fac[i - 0] * i % mod)",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 0] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "fac.append(fac[i - 1] * i % mod)",
      "mutated_line": "fac.append(fac[i - 0] * i % mod)",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 0] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "fac.append(fac[i - 1] * i % mod)",
      "mutated_line": "fac.append(fac[i - -1] * i % mod)",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - -1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)",
      "mutated_line": "ifac.append(ifac[i - 2] * pow(i, mod - 2, mod) % mod)",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 2] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)",
      "mutated_line": "ifac.append(ifac[i - 0] * pow(i, mod - 2, mod) % mod)",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 0] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)",
      "mutated_line": "ifac.append(ifac[i - 0] * pow(i, mod - 2, mod) % mod)",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 0] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)",
      "mutated_line": "ifac.append(ifac[i - -1] * pow(i, mod - 2, mod) % mod)",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - -1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)",
      "mutated_line": "ifac.append(ifac[i - 1] * pow(i, mod - 3, mod) % mod)",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 3, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)",
      "mutated_line": "ifac.append(ifac[i - 1] * pow(i, mod - 1, mod) % mod)",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 1, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)",
      "mutated_line": "ifac.append(ifac[i - 1] * pow(i, mod - 0, mod) % mod)",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 0, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)",
      "mutated_line": "ifac.append(ifac[i - 1] * pow(i, mod - 1, mod) % mod)",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 1, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)",
      "mutated_line": "ifac.append(ifac[i - 1] * pow(i, mod - -2, mod) % mod)",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - -2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp[j] = (j * dp[j] + dp[j - 1]) % mod",
      "mutated_line": "dp[j] = (j * dp[j] + dp[j - 2]) % mod",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 2]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp[j] = (j * dp[j] + dp[j - 1]) % mod",
      "mutated_line": "dp[j] = (j * dp[j] + dp[j - 0]) % mod",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 0]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp[j] = (j * dp[j] + dp[j - 1]) % mod",
      "mutated_line": "dp[j] = (j * dp[j] + dp[j - 0]) % mod",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 0]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp[j] = (j * dp[j] + dp[j - 1]) % mod",
      "mutated_line": "dp[j] = (j * dp[j] + dp[j - -1]) % mod",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - -1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "mutated_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod / pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod / pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "mutated_line": "ans = (ans + (dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod + pow(fac[k - 2 * i + j], mod - 2, mod)) * ifac[i - j] * ifac[j]) % mod",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + (dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod + pow(fac[k - 2 * i + j], mod - 2, mod)) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "mutated_line": "ans = (ans + (dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod) ** pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + (dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod) ** pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "mutated_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] * mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] * mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "mutated_line": "ans = (ans + (dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] + mod) * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + (dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] + mod) * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "mutated_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i + j] * ifac[j]) % mod",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i + j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "mutated_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i * j] * ifac[j]) % mod",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i * j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "mutated_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] / fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] / fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "mutated_line": "ans = (ans + (dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] + fac[k]) % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + (dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] + fac[k]) % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "mutated_line": "ans = (ans + (dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j]) ** fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + (dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j]) ** fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "mutated_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod + 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod + 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "mutated_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod * 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod * 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "mutated_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] / ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] / ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "mutated_line": "ans = (ans + (dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] + ifac[i - j]) * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + (dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] + ifac[i - j]) * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "mutated_line": "ans = (ans + (dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j]) ** ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + (dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j]) ** ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "mutated_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i - j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i - j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "mutated_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[(k - 2 * i) * j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[(k - 2 * i) * j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "mutated_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 3, mod) * ifac[i - j] * ifac[j]) % mod",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 3, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "mutated_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 1, mod) * ifac[i - j] * ifac[j]) % mod",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 1, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "mutated_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 0, mod) * ifac[i - j] * ifac[j]) % mod",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 0, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "mutated_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 1, mod) * ifac[i - j] * ifac[j]) % mod",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 1, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "mutated_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - -2, mod) * ifac[i - j] * ifac[j]) % mod",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - -2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "mutated_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod / tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod / tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "mutated_line": "ans = (ans + (dp[i] * dp[i] * fac[i] * fac[i] % mod + tav[j]) * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + (dp[i] * dp[i] * fac[i] * fac[i] % mod + tav[j]) * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "mutated_line": "ans = (ans + (dp[i] * dp[i] * fac[i] * fac[i] % mod) ** tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + (dp[i] * dp[i] * fac[i] * fac[i] % mod) ** tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "mutated_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k + 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k + 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "mutated_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k * (2 * i) + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k * (2 * i) + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "mutated_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] * mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] * mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "mutated_line": "ans = (ans + (dp[i] * dp[i] * fac[i] * fac[i] + mod) * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + (dp[i] * dp[i] * fac[i] * fac[i] + mod) * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "mutated_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i + j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i + j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "mutated_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i * j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i * j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "mutated_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 / i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 / i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "mutated_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - (2 + i) + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - (2 + i) + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "mutated_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 ** i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 ** i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "mutated_line": "ans = (ans + dp[i] * dp[i] * fac[i] / fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] / fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "mutated_line": "ans = (ans + (dp[i] * dp[i] * fac[i] + fac[i]) % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + (dp[i] * dp[i] * fac[i] + fac[i]) % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "mutated_line": "ans = (ans + (dp[i] * dp[i] * fac[i]) ** fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + (dp[i] * dp[i] * fac[i]) ** fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "mutated_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 3 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 3 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "mutated_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 1 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 1 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "mutated_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 0 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 0 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "mutated_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 1 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 1 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "mutated_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - -2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - -2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "mutated_line": "ans = (ans + dp[i] * dp[i] / fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] * dp[i] / fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "mutated_line": "ans = (ans + (dp[i] * dp[i] + fac[i]) * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + (dp[i] * dp[i] + fac[i]) * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "mutated_line": "ans = (ans + (dp[i] * dp[i]) ** fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + (dp[i] * dp[i]) ** fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "mutated_line": "ans = (ans + dp[i] / dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] / dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "mutated_line": "ans = (ans + (dp[i] + dp[i]) * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + (dp[i] + dp[i]) * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "ans = (ans + dp[i] * dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "mutated_line": "ans = (ans + dp[i] ** dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod",
      "code": "def count_colorings(n: int, m: int, k: int) -> int:\n    mod = 10 ** 9 + 7\n    if m == 1:\n        return pow(k, n, mod)\n    fac = [1]\n    ifac = [1]\n    tav = [0]\n    for i in range(1, max(k + 1, n + 1)):\n        fac.append(fac[i - 1] * i % mod)\n    for i in range(1, min(k + 1, n + 1)):\n        ifac.append(ifac[i - 1] * pow(i, mod - 2, mod) % mod)\n        tav.append(pow(i, n * (m - 2), mod))\n    if m == 2:\n        tav[0] = 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i, 1, -1):\n            dp[j] = (j * dp[j] + dp[j - 1]) % mod\n    ans = 0\n    for i in range(1, min(k + 1, n + 1)):\n        for j in range(0, i + 1):\n            if 2 * i - j > k:\n                continue\n            ans = (ans + dp[i] ** dp[i] * fac[i] * fac[i] % mod * tav[j] * ifac[i - j] * fac[k] % mod * pow(fac[k - 2 * i + j], mod - 2, mod) * ifac[i - j] * ifac[j]) % mod\n    return ans"
    }
  ]
}