{
  "task_id": "taco_14011",
  "entry_point": "avoid_flood",
  "mutant_count": 28,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if lake == 0:",
      "mutated_line": "if lake != 0:",
      "code": "import heapq\nfrom typing import List\n\ndef avoid_flood(rains: List[int]) -> List[int]:\n    full_lakes = {}\n    dry_days = []\n    ans = []\n    for (day, lake) in enumerate(rains):\n        if lake != 0:\n            dry_days.append(day)\n            ans.append(1)\n        else:\n            if lake in full_lakes:\n                if not dry_days:\n                    return []\n                dry_index = -1\n                for (i, dry_day) in enumerate(dry_days):\n                    if dry_day > full_lakes[lake]:\n                        dry_index = i\n                        break\n                if dry_index == -1:\n                    return []\n                ans[dry_days.pop(dry_index)] = lake\n            full_lakes[lake] = day\n            ans.append(-1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if lake == 0:",
      "mutated_line": "if lake == 1:",
      "code": "import heapq\nfrom typing import List\n\ndef avoid_flood(rains: List[int]) -> List[int]:\n    full_lakes = {}\n    dry_days = []\n    ans = []\n    for (day, lake) in enumerate(rains):\n        if lake == 1:\n            dry_days.append(day)\n            ans.append(1)\n        else:\n            if lake in full_lakes:\n                if not dry_days:\n                    return []\n                dry_index = -1\n                for (i, dry_day) in enumerate(dry_days):\n                    if dry_day > full_lakes[lake]:\n                        dry_index = i\n                        break\n                if dry_index == -1:\n                    return []\n                ans[dry_days.pop(dry_index)] = lake\n            full_lakes[lake] = day\n            ans.append(-1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if lake == 0:",
      "mutated_line": "if lake == -1:",
      "code": "import heapq\nfrom typing import List\n\ndef avoid_flood(rains: List[int]) -> List[int]:\n    full_lakes = {}\n    dry_days = []\n    ans = []\n    for (day, lake) in enumerate(rains):\n        if lake == -1:\n            dry_days.append(day)\n            ans.append(1)\n        else:\n            if lake in full_lakes:\n                if not dry_days:\n                    return []\n                dry_index = -1\n                for (i, dry_day) in enumerate(dry_days):\n                    if dry_day > full_lakes[lake]:\n                        dry_index = i\n                        break\n                if dry_index == -1:\n                    return []\n                ans[dry_days.pop(dry_index)] = lake\n            full_lakes[lake] = day\n            ans.append(-1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if lake == 0:",
      "mutated_line": "if lake == 1:",
      "code": "import heapq\nfrom typing import List\n\ndef avoid_flood(rains: List[int]) -> List[int]:\n    full_lakes = {}\n    dry_days = []\n    ans = []\n    for (day, lake) in enumerate(rains):\n        if lake == 1:\n            dry_days.append(day)\n            ans.append(1)\n        else:\n            if lake in full_lakes:\n                if not dry_days:\n                    return []\n                dry_index = -1\n                for (i, dry_day) in enumerate(dry_days):\n                    if dry_day > full_lakes[lake]:\n                        dry_index = i\n                        break\n                if dry_index == -1:\n                    return []\n                ans[dry_days.pop(dry_index)] = lake\n            full_lakes[lake] = day\n            ans.append(-1)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if lake in full_lakes:",
      "mutated_line": "if lake not in full_lakes:",
      "code": "import heapq\nfrom typing import List\n\ndef avoid_flood(rains: List[int]) -> List[int]:\n    full_lakes = {}\n    dry_days = []\n    ans = []\n    for (day, lake) in enumerate(rains):\n        if lake == 0:\n            dry_days.append(day)\n            ans.append(1)\n        else:\n            if lake not in full_lakes:\n                if not dry_days:\n                    return []\n                dry_index = -1\n                for (i, dry_day) in enumerate(dry_days):\n                    if dry_day > full_lakes[lake]:\n                        dry_index = i\n                        break\n                if dry_index == -1:\n                    return []\n                ans[dry_days.pop(dry_index)] = lake\n            full_lakes[lake] = day\n            ans.append(-1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "ans.append(1)  # Default value, can be changed later",
      "mutated_line": "ans.append(2)",
      "code": "import heapq\nfrom typing import List\n\ndef avoid_flood(rains: List[int]) -> List[int]:\n    full_lakes = {}\n    dry_days = []\n    ans = []\n    for (day, lake) in enumerate(rains):\n        if lake == 0:\n            dry_days.append(day)\n            ans.append(2)\n        else:\n            if lake in full_lakes:\n                if not dry_days:\n                    return []\n                dry_index = -1\n                for (i, dry_day) in enumerate(dry_days):\n                    if dry_day > full_lakes[lake]:\n                        dry_index = i\n                        break\n                if dry_index == -1:\n                    return []\n                ans[dry_days.pop(dry_index)] = lake\n            full_lakes[lake] = day\n            ans.append(-1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "ans.append(1)  # Default value, can be changed later",
      "mutated_line": "ans.append(0)",
      "code": "import heapq\nfrom typing import List\n\ndef avoid_flood(rains: List[int]) -> List[int]:\n    full_lakes = {}\n    dry_days = []\n    ans = []\n    for (day, lake) in enumerate(rains):\n        if lake == 0:\n            dry_days.append(day)\n            ans.append(0)\n        else:\n            if lake in full_lakes:\n                if not dry_days:\n                    return []\n                dry_index = -1\n                for (i, dry_day) in enumerate(dry_days):\n                    if dry_day > full_lakes[lake]:\n                        dry_index = i\n                        break\n                if dry_index == -1:\n                    return []\n                ans[dry_days.pop(dry_index)] = lake\n            full_lakes[lake] = day\n            ans.append(-1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "ans.append(1)  # Default value, can be changed later",
      "mutated_line": "ans.append(0)",
      "code": "import heapq\nfrom typing import List\n\ndef avoid_flood(rains: List[int]) -> List[int]:\n    full_lakes = {}\n    dry_days = []\n    ans = []\n    for (day, lake) in enumerate(rains):\n        if lake == 0:\n            dry_days.append(day)\n            ans.append(0)\n        else:\n            if lake in full_lakes:\n                if not dry_days:\n                    return []\n                dry_index = -1\n                for (i, dry_day) in enumerate(dry_days):\n                    if dry_day > full_lakes[lake]:\n                        dry_index = i\n                        break\n                if dry_index == -1:\n                    return []\n                ans[dry_days.pop(dry_index)] = lake\n            full_lakes[lake] = day\n            ans.append(-1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "ans.append(1)  # Default value, can be changed later",
      "mutated_line": "ans.append(-1)",
      "code": "import heapq\nfrom typing import List\n\ndef avoid_flood(rains: List[int]) -> List[int]:\n    full_lakes = {}\n    dry_days = []\n    ans = []\n    for (day, lake) in enumerate(rains):\n        if lake == 0:\n            dry_days.append(day)\n            ans.append(-1)\n        else:\n            if lake in full_lakes:\n                if not dry_days:\n                    return []\n                dry_index = -1\n                for (i, dry_day) in enumerate(dry_days):\n                    if dry_day > full_lakes[lake]:\n                        dry_index = i\n                        break\n                if dry_index == -1:\n                    return []\n                ans[dry_days.pop(dry_index)] = lake\n            full_lakes[lake] = day\n            ans.append(-1)\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "dry_index = -1",
      "mutated_line": "for (i, dry_day) in enumerate(dry_days):",
      "code": "import heapq\nfrom typing import List\n\ndef avoid_flood(rains: List[int]) -> List[int]:\n    full_lakes = {}\n    dry_days = []\n    ans = []\n    for (day, lake) in enumerate(rains):\n        if lake == 0:\n            dry_days.append(day)\n            ans.append(1)\n        else:\n            if lake in full_lakes:\n                if not dry_days:\n                    return []\n                dry_index = +1\n                for (i, dry_day) in enumerate(dry_days):\n                    if dry_day > full_lakes[lake]:\n                        dry_index = i\n                        break\n                if dry_index == -1:\n                    return []\n                ans[dry_days.pop(dry_index)] = lake\n            full_lakes[lake] = day\n            ans.append(-1)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if dry_index == -1:",
      "mutated_line": "if dry_index != -1:",
      "code": "import heapq\nfrom typing import List\n\ndef avoid_flood(rains: List[int]) -> List[int]:\n    full_lakes = {}\n    dry_days = []\n    ans = []\n    for (day, lake) in enumerate(rains):\n        if lake == 0:\n            dry_days.append(day)\n            ans.append(1)\n        else:\n            if lake in full_lakes:\n                if not dry_days:\n                    return []\n                dry_index = -1\n                for (i, dry_day) in enumerate(dry_days):\n                    if dry_day > full_lakes[lake]:\n                        dry_index = i\n                        break\n                if dry_index != -1:\n                    return []\n                ans[dry_days.pop(dry_index)] = lake\n            full_lakes[lake] = day\n            ans.append(-1)\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 27,
      "original_line": "ans.append(-1)",
      "mutated_line": "ans.append(+1)",
      "code": "import heapq\nfrom typing import List\n\ndef avoid_flood(rains: List[int]) -> List[int]:\n    full_lakes = {}\n    dry_days = []\n    ans = []\n    for (day, lake) in enumerate(rains):\n        if lake == 0:\n            dry_days.append(day)\n            ans.append(1)\n        else:\n            if lake in full_lakes:\n                if not dry_days:\n                    return []\n                dry_index = -1\n                for (i, dry_day) in enumerate(dry_days):\n                    if dry_day > full_lakes[lake]:\n                        dry_index = i\n                        break\n                if dry_index == -1:\n                    return []\n                ans[dry_days.pop(dry_index)] = lake\n            full_lakes[lake] = day\n            ans.append(+1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dry_index = -1",
      "mutated_line": "for (i, dry_day) in enumerate(dry_days):",
      "code": "import heapq\nfrom typing import List\n\ndef avoid_flood(rains: List[int]) -> List[int]:\n    full_lakes = {}\n    dry_days = []\n    ans = []\n    for (day, lake) in enumerate(rains):\n        if lake == 0:\n            dry_days.append(day)\n            ans.append(1)\n        else:\n            if lake in full_lakes:\n                if not dry_days:\n                    return []\n                dry_index = -2\n                for (i, dry_day) in enumerate(dry_days):\n                    if dry_day > full_lakes[lake]:\n                        dry_index = i\n                        break\n                if dry_index == -1:\n                    return []\n                ans[dry_days.pop(dry_index)] = lake\n            full_lakes[lake] = day\n            ans.append(-1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dry_index = -1",
      "mutated_line": "for (i, dry_day) in enumerate(dry_days):",
      "code": "import heapq\nfrom typing import List\n\ndef avoid_flood(rains: List[int]) -> List[int]:\n    full_lakes = {}\n    dry_days = []\n    ans = []\n    for (day, lake) in enumerate(rains):\n        if lake == 0:\n            dry_days.append(day)\n            ans.append(1)\n        else:\n            if lake in full_lakes:\n                if not dry_days:\n                    return []\n                dry_index = -0\n                for (i, dry_day) in enumerate(dry_days):\n                    if dry_day > full_lakes[lake]:\n                        dry_index = i\n                        break\n                if dry_index == -1:\n                    return []\n                ans[dry_days.pop(dry_index)] = lake\n            full_lakes[lake] = day\n            ans.append(-1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dry_index = -1",
      "mutated_line": "for (i, dry_day) in enumerate(dry_days):",
      "code": "import heapq\nfrom typing import List\n\ndef avoid_flood(rains: List[int]) -> List[int]:\n    full_lakes = {}\n    dry_days = []\n    ans = []\n    for (day, lake) in enumerate(rains):\n        if lake == 0:\n            dry_days.append(day)\n            ans.append(1)\n        else:\n            if lake in full_lakes:\n                if not dry_days:\n                    return []\n                dry_index = -0\n                for (i, dry_day) in enumerate(dry_days):\n                    if dry_day > full_lakes[lake]:\n                        dry_index = i\n                        break\n                if dry_index == -1:\n                    return []\n                ans[dry_days.pop(dry_index)] = lake\n            full_lakes[lake] = day\n            ans.append(-1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dry_index = -1",
      "mutated_line": "for (i, dry_day) in enumerate(dry_days):",
      "code": "import heapq\nfrom typing import List\n\ndef avoid_flood(rains: List[int]) -> List[int]:\n    full_lakes = {}\n    dry_days = []\n    ans = []\n    for (day, lake) in enumerate(rains):\n        if lake == 0:\n            dry_days.append(day)\n            ans.append(1)\n        else:\n            if lake in full_lakes:\n                if not dry_days:\n                    return []\n                dry_index = --1\n                for (i, dry_day) in enumerate(dry_days):\n                    if dry_day > full_lakes[lake]:\n                        dry_index = i\n                        break\n                if dry_index == -1:\n                    return []\n                ans[dry_days.pop(dry_index)] = lake\n            full_lakes[lake] = day\n            ans.append(-1)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if dry_day > full_lakes[lake]:",
      "mutated_line": "if dry_day >= full_lakes[lake]:",
      "code": "import heapq\nfrom typing import List\n\ndef avoid_flood(rains: List[int]) -> List[int]:\n    full_lakes = {}\n    dry_days = []\n    ans = []\n    for (day, lake) in enumerate(rains):\n        if lake == 0:\n            dry_days.append(day)\n            ans.append(1)\n        else:\n            if lake in full_lakes:\n                if not dry_days:\n                    return []\n                dry_index = -1\n                for (i, dry_day) in enumerate(dry_days):\n                    if dry_day >= full_lakes[lake]:\n                        dry_index = i\n                        break\n                if dry_index == -1:\n                    return []\n                ans[dry_days.pop(dry_index)] = lake\n            full_lakes[lake] = day\n            ans.append(-1)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if dry_day > full_lakes[lake]:",
      "mutated_line": "if dry_day <= full_lakes[lake]:",
      "code": "import heapq\nfrom typing import List\n\ndef avoid_flood(rains: List[int]) -> List[int]:\n    full_lakes = {}\n    dry_days = []\n    ans = []\n    for (day, lake) in enumerate(rains):\n        if lake == 0:\n            dry_days.append(day)\n            ans.append(1)\n        else:\n            if lake in full_lakes:\n                if not dry_days:\n                    return []\n                dry_index = -1\n                for (i, dry_day) in enumerate(dry_days):\n                    if dry_day <= full_lakes[lake]:\n                        dry_index = i\n                        break\n                if dry_index == -1:\n                    return []\n                ans[dry_days.pop(dry_index)] = lake\n            full_lakes[lake] = day\n            ans.append(-1)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if dry_day > full_lakes[lake]:",
      "mutated_line": "if dry_day != full_lakes[lake]:",
      "code": "import heapq\nfrom typing import List\n\ndef avoid_flood(rains: List[int]) -> List[int]:\n    full_lakes = {}\n    dry_days = []\n    ans = []\n    for (day, lake) in enumerate(rains):\n        if lake == 0:\n            dry_days.append(day)\n            ans.append(1)\n        else:\n            if lake in full_lakes:\n                if not dry_days:\n                    return []\n                dry_index = -1\n                for (i, dry_day) in enumerate(dry_days):\n                    if dry_day != full_lakes[lake]:\n                        dry_index = i\n                        break\n                if dry_index == -1:\n                    return []\n                ans[dry_days.pop(dry_index)] = lake\n            full_lakes[lake] = day\n            ans.append(-1)\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 23,
      "original_line": "if dry_index == -1:",
      "mutated_line": "if dry_index == +1:",
      "code": "import heapq\nfrom typing import List\n\ndef avoid_flood(rains: List[int]) -> List[int]:\n    full_lakes = {}\n    dry_days = []\n    ans = []\n    for (day, lake) in enumerate(rains):\n        if lake == 0:\n            dry_days.append(day)\n            ans.append(1)\n        else:\n            if lake in full_lakes:\n                if not dry_days:\n                    return []\n                dry_index = -1\n                for (i, dry_day) in enumerate(dry_days):\n                    if dry_day > full_lakes[lake]:\n                        dry_index = i\n                        break\n                if dry_index == +1:\n                    return []\n                ans[dry_days.pop(dry_index)] = lake\n            full_lakes[lake] = day\n            ans.append(-1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "ans.append(-1)",
      "mutated_line": "ans.append(-2)",
      "code": "import heapq\nfrom typing import List\n\ndef avoid_flood(rains: List[int]) -> List[int]:\n    full_lakes = {}\n    dry_days = []\n    ans = []\n    for (day, lake) in enumerate(rains):\n        if lake == 0:\n            dry_days.append(day)\n            ans.append(1)\n        else:\n            if lake in full_lakes:\n                if not dry_days:\n                    return []\n                dry_index = -1\n                for (i, dry_day) in enumerate(dry_days):\n                    if dry_day > full_lakes[lake]:\n                        dry_index = i\n                        break\n                if dry_index == -1:\n                    return []\n                ans[dry_days.pop(dry_index)] = lake\n            full_lakes[lake] = day\n            ans.append(-2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "ans.append(-1)",
      "mutated_line": "ans.append(-0)",
      "code": "import heapq\nfrom typing import List\n\ndef avoid_flood(rains: List[int]) -> List[int]:\n    full_lakes = {}\n    dry_days = []\n    ans = []\n    for (day, lake) in enumerate(rains):\n        if lake == 0:\n            dry_days.append(day)\n            ans.append(1)\n        else:\n            if lake in full_lakes:\n                if not dry_days:\n                    return []\n                dry_index = -1\n                for (i, dry_day) in enumerate(dry_days):\n                    if dry_day > full_lakes[lake]:\n                        dry_index = i\n                        break\n                if dry_index == -1:\n                    return []\n                ans[dry_days.pop(dry_index)] = lake\n            full_lakes[lake] = day\n            ans.append(-0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "ans.append(-1)",
      "mutated_line": "ans.append(-0)",
      "code": "import heapq\nfrom typing import List\n\ndef avoid_flood(rains: List[int]) -> List[int]:\n    full_lakes = {}\n    dry_days = []\n    ans = []\n    for (day, lake) in enumerate(rains):\n        if lake == 0:\n            dry_days.append(day)\n            ans.append(1)\n        else:\n            if lake in full_lakes:\n                if not dry_days:\n                    return []\n                dry_index = -1\n                for (i, dry_day) in enumerate(dry_days):\n                    if dry_day > full_lakes[lake]:\n                        dry_index = i\n                        break\n                if dry_index == -1:\n                    return []\n                ans[dry_days.pop(dry_index)] = lake\n            full_lakes[lake] = day\n            ans.append(-0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "ans.append(-1)",
      "mutated_line": "ans.append(--1)",
      "code": "import heapq\nfrom typing import List\n\ndef avoid_flood(rains: List[int]) -> List[int]:\n    full_lakes = {}\n    dry_days = []\n    ans = []\n    for (day, lake) in enumerate(rains):\n        if lake == 0:\n            dry_days.append(day)\n            ans.append(1)\n        else:\n            if lake in full_lakes:\n                if not dry_days:\n                    return []\n                dry_index = -1\n                for (i, dry_day) in enumerate(dry_days):\n                    if dry_day > full_lakes[lake]:\n                        dry_index = i\n                        break\n                if dry_index == -1:\n                    return []\n                ans[dry_days.pop(dry_index)] = lake\n            full_lakes[lake] = day\n            ans.append(--1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if dry_index == -1:",
      "mutated_line": "if dry_index == -2:",
      "code": "import heapq\nfrom typing import List\n\ndef avoid_flood(rains: List[int]) -> List[int]:\n    full_lakes = {}\n    dry_days = []\n    ans = []\n    for (day, lake) in enumerate(rains):\n        if lake == 0:\n            dry_days.append(day)\n            ans.append(1)\n        else:\n            if lake in full_lakes:\n                if not dry_days:\n                    return []\n                dry_index = -1\n                for (i, dry_day) in enumerate(dry_days):\n                    if dry_day > full_lakes[lake]:\n                        dry_index = i\n                        break\n                if dry_index == -2:\n                    return []\n                ans[dry_days.pop(dry_index)] = lake\n            full_lakes[lake] = day\n            ans.append(-1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if dry_index == -1:",
      "mutated_line": "if dry_index == -0:",
      "code": "import heapq\nfrom typing import List\n\ndef avoid_flood(rains: List[int]) -> List[int]:\n    full_lakes = {}\n    dry_days = []\n    ans = []\n    for (day, lake) in enumerate(rains):\n        if lake == 0:\n            dry_days.append(day)\n            ans.append(1)\n        else:\n            if lake in full_lakes:\n                if not dry_days:\n                    return []\n                dry_index = -1\n                for (i, dry_day) in enumerate(dry_days):\n                    if dry_day > full_lakes[lake]:\n                        dry_index = i\n                        break\n                if dry_index == -0:\n                    return []\n                ans[dry_days.pop(dry_index)] = lake\n            full_lakes[lake] = day\n            ans.append(-1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if dry_index == -1:",
      "mutated_line": "if dry_index == -0:",
      "code": "import heapq\nfrom typing import List\n\ndef avoid_flood(rains: List[int]) -> List[int]:\n    full_lakes = {}\n    dry_days = []\n    ans = []\n    for (day, lake) in enumerate(rains):\n        if lake == 0:\n            dry_days.append(day)\n            ans.append(1)\n        else:\n            if lake in full_lakes:\n                if not dry_days:\n                    return []\n                dry_index = -1\n                for (i, dry_day) in enumerate(dry_days):\n                    if dry_day > full_lakes[lake]:\n                        dry_index = i\n                        break\n                if dry_index == -0:\n                    return []\n                ans[dry_days.pop(dry_index)] = lake\n            full_lakes[lake] = day\n            ans.append(-1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if dry_index == -1:",
      "mutated_line": "if dry_index == --1:",
      "code": "import heapq\nfrom typing import List\n\ndef avoid_flood(rains: List[int]) -> List[int]:\n    full_lakes = {}\n    dry_days = []\n    ans = []\n    for (day, lake) in enumerate(rains):\n        if lake == 0:\n            dry_days.append(day)\n            ans.append(1)\n        else:\n            if lake in full_lakes:\n                if not dry_days:\n                    return []\n                dry_index = -1\n                for (i, dry_day) in enumerate(dry_days):\n                    if dry_day > full_lakes[lake]:\n                        dry_index = i\n                        break\n                if dry_index == --1:\n                    return []\n                ans[dry_days.pop(dry_index)] = lake\n            full_lakes[lake] = day\n            ans.append(-1)\n    return ans"
    }
  ]
}