{
  "task_id": "taco_12678",
  "entry_point": "edge_cost",
  "mutant_count": 180,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 10 * 20",
      "code": "import sys\nINF = 10 * 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 10 + 20",
      "code": "import sys\nINF = 10 + 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 11 ** 20",
      "code": "import sys\nINF = 11 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 9 ** 20",
      "code": "import sys\nINF = 9 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 0 ** 20",
      "code": "import sys\nINF = 0 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 1 ** 20",
      "code": "import sys\nINF = 1 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = -10 ** 20",
      "code": "import sys\nINF = -10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 10 ** 21",
      "code": "import sys\nINF = 10 ** 21\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 10 ** 19",
      "code": "import sys\nINF = 10 ** 19\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 10 ** 0",
      "code": "import sys\nINF = 10 ** 0\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 10 ** 1",
      "code": "import sys\nINF = 10 ** 1\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 10 ** -20",
      "code": "import sys\nINF = 10 ** -20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])",
      "mutated_line": "return 2 / (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 / (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])",
      "mutated_line": "return 2 + (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 + (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])",
      "mutated_line": "return 2 ** (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 ** (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if k == 0:",
      "mutated_line": "if k != 0:",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k != 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "used[v] = True",
      "mutated_line": "used[v] = False",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = False\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "used[v] = False",
      "mutated_line": "used[v] = True",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = True\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "used = [False] * n",
      "mutated_line": "used = [False] / n",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] / n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "used = [False] * n",
      "mutated_line": "used = [False] + n",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] + n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "used = [False] * n",
      "mutated_line": "used = [False] ** n",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] ** n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "ROR",
      "lineno": 53,
      "original_line": "if sub == INF:",
      "mutated_line": "if sub != INF:",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub != INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "def add_edge(self, s, t, c=1):",
      "mutated_line": "def add_edge(self, s, t, c=2):",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=2):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "def add_edge(self, s, t, c=1):",
      "mutated_line": "def add_edge(self, s, t, c=0):",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=0):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "def add_edge(self, s, t, c=1):",
      "mutated_line": "def add_edge(self, s, t, c=0):",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=0):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "def add_edge(self, s, t, c=1):",
      "mutated_line": "def add_edge(self, s, t, c=-1):",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=-1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]",
      "mutated_line": "L = [s + abs(ps[i][k] - ps[j][k]) for k in range(3)]",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s + abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]",
      "mutated_line": "L = [s * abs(ps[i][k] - ps[j][k]) for k in range(3)]",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s * abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "UOI",
      "lineno": 20,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return +1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])",
      "mutated_line": "return 3 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 3 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])",
      "mutated_line": "return 1 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 1 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])",
      "mutated_line": "return 0 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 0 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])",
      "mutated_line": "return 1 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 1 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])",
      "mutated_line": "return -2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return -2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])",
      "mutated_line": "return 2 * (L[0] * L[1] + L[1] * L[2] - L[2] * L[0])",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] - L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])",
      "mutated_line": "return 2 * ((L[0] * L[1] + L[1] * L[2]) * (L[2] * L[0]))",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * ((L[0] * L[1] + L[1] * L[2]) * (L[2] * L[0]))\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if k == 0:",
      "mutated_line": "if k == 1:",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 1:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if k == 0:",
      "mutated_line": "if k == -1:",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == -1:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if k == 0:",
      "mutated_line": "if k == 1:",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 1:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 1\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return -1\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 1\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if e[0] == pv:",
      "mutated_line": "if e[0] != pv:",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] != pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if dd < INF:",
      "mutated_line": "if dd <= INF:",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd <= INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if dd < INF:",
      "mutated_line": "if dd >= INF:",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd >= INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if dd < INF:",
      "mutated_line": "if dd != INF:",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd != INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n + 1):",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n + 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n * 1):",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n * 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "UOI",
      "lineno": 54,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return +1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "AOR",
      "lineno": 56,
      "original_line": "return 6 * k * s * s + sub",
      "mutated_line": "return 6 * k * s * s - sub",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s - sub"
    },
    {
      "operator": "AOR",
      "lineno": 56,
      "original_line": "return 6 * k * s * s + sub",
      "mutated_line": "return 6 * k * s * s * sub",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s * sub"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if any(x <= 0 for x in L):",
      "mutated_line": "if any((x < 0 for x in L)):",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x < 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if any(x <= 0 for x in L):",
      "mutated_line": "if any((x > 0 for x in L)):",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x > 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if any(x <= 0 for x in L):",
      "mutated_line": "if any((x == 0 for x in L)):",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x == 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -2\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -0\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -0\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return --1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])",
      "mutated_line": "return 2 * (L[0] * L[1] - L[1] * L[2] + L[2] * L[0])",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] - L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])",
      "mutated_line": "return 2 * (L[0] * L[1] * (L[1] * L[2]) + L[2] * L[0])",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] * (L[1] * L[2]) + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])",
      "mutated_line": "return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] / L[0])",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] / L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])",
      "mutated_line": "return 2 * (L[0] * L[1] + L[1] * L[2] + (L[2] + L[0]))",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + (L[2] + L[0]))\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])",
      "mutated_line": "return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] ** L[0])",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] ** L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "LCR",
      "lineno": 26,
      "original_line": "if e[0] != pv and used[e[0]]:",
      "mutated_line": "if e[0] != pv or used[e[0]]:",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv or used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "dd = dfs(e[0], v, k - 1, G, used)",
      "mutated_line": "dd = dfs(e[0], v, k + 1, G, used)",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k + 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "dd = dfs(e[0], v, k - 1, G, used)",
      "mutated_line": "dd = dfs(e[0], v, k * 1, G, used)",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k * 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n - 2):",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 2):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n - 0):",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 0):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n - 0):",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 0):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n - -1):",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - -1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i - 1, n):",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i - 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i * 1, n):",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i * 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "ROR",
      "lineno": 47,
      "original_line": "if c > 0:",
      "mutated_line": "if c >= 0:",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c >= 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "ROR",
      "lineno": 47,
      "original_line": "if c > 0:",
      "mutated_line": "if c <= 0:",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c <= 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "ROR",
      "lineno": 47,
      "original_line": "if c > 0:",
      "mutated_line": "if c != 0:",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c != 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "used = [False] * n",
      "mutated_line": "used = [True] * n",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [True] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -2\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -0\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -0\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return --1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "AOR",
      "lineno": 56,
      "original_line": "return 6 * k * s * s + sub",
      "mutated_line": "return 6 * k * s / s + sub",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s / s + sub"
    },
    {
      "operator": "AOR",
      "lineno": 56,
      "original_line": "return 6 * k * s * s + sub",
      "mutated_line": "return 6 * k * s + s + sub",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s + s + sub"
    },
    {
      "operator": "AOR",
      "lineno": 56,
      "original_line": "return 6 * k * s * s + sub",
      "mutated_line": "return (6 * k * s) ** s + sub",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return (6 * k * s) ** s + sub"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]",
      "mutated_line": "L = [s - abs(ps[i][k] + ps[j][k]) for k in range(3)]",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] + ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]",
      "mutated_line": "L = [s - abs(ps[i][k] * ps[j][k]) for k in range(3)]",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] * ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]",
      "mutated_line": "L = [s - abs(ps[i][k] - ps[j][k]) for k in range(4)]",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(4)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]",
      "mutated_line": "L = [s - abs(ps[i][k] - ps[j][k]) for k in range(2)]",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(2)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]",
      "mutated_line": "L = [s - abs(ps[i][k] - ps[j][k]) for k in range(0)]",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(0)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]",
      "mutated_line": "L = [s - abs(ps[i][k] - ps[j][k]) for k in range(1)]",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(1)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]",
      "mutated_line": "L = [s - abs(ps[i][k] - ps[j][k]) for k in range(-3)]",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(-3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if any(x <= 0 for x in L):",
      "mutated_line": "if any((x <= 1 for x in L)):",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 1 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if any(x <= 0 for x in L):",
      "mutated_line": "if any((x <= -1 for x in L)):",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= -1 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if any(x <= 0 for x in L):",
      "mutated_line": "if any((x <= 1 for x in L)):",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 1 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])",
      "mutated_line": "return 2 * (L[0] / L[1] + L[1] * L[2] + L[2] * L[0])",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] / L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])",
      "mutated_line": "return 2 * (L[0] + L[1] + L[1] * L[2] + L[2] * L[0])",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] + L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])",
      "mutated_line": "return 2 * (L[0] ** L[1] + L[1] * L[2] + L[2] * L[0])",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] ** L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])",
      "mutated_line": "return 2 * (L[0] * L[1] + L[1] / L[2] + L[2] * L[0])",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] / L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])",
      "mutated_line": "return 2 * (L[0] * L[1] + (L[1] + L[2]) + L[2] * L[0])",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + (L[1] + L[2]) + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])",
      "mutated_line": "return 2 * (L[0] * L[1] + L[1] ** L[2] + L[2] * L[0])",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] ** L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if e[0] != pv and used[e[0]]:",
      "mutated_line": "if e[0] == pv and used[e[0]]:",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] == pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if e[0] == pv:",
      "mutated_line": "if e[1] == pv:",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[1] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if e[0] == pv:",
      "mutated_line": "if e[-1] == pv:",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[-1] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if e[0] == pv:",
      "mutated_line": "if e[1] == pv:",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[1] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dd = dfs(e[0], v, k - 1, G, used)",
      "mutated_line": "dd = dfs(e[1], v, k - 1, G, used)",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[1], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dd = dfs(e[0], v, k - 1, G, used)",
      "mutated_line": "dd = dfs(e[-1], v, k - 1, G, used)",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[-1], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dd = dfs(e[0], v, k - 1, G, used)",
      "mutated_line": "dd = dfs(e[1], v, k - 1, G, used)",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[1], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dd = dfs(e[0], v, k - 1, G, used)",
      "mutated_line": "dd = dfs(e[0], v, k - 2, G, used)",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 2, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dd = dfs(e[0], v, k - 1, G, used)",
      "mutated_line": "dd = dfs(e[0], v, k - 0, G, used)",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 0, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dd = dfs(e[0], v, k - 1, G, used)",
      "mutated_line": "dd = dfs(e[0], v, k - 0, G, used)",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 0, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dd = dfs(e[0], v, k - 1, G, used)",
      "mutated_line": "dd = dfs(e[0], v, k - -1, G, used)",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - -1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "res = min(res, dd + e[1])",
      "mutated_line": "res = min(res, dd - e[1])",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd - e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "res = min(res, dd + e[1])",
      "mutated_line": "res = min(res, dd * e[1])",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd * e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i + 2, n):",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 2, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i + 0, n):",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 0, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i + 0, n):",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 0, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i + -1, n):",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + -1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "if c > 0:",
      "mutated_line": "if c > 1:",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 1:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "if c > 0:",
      "mutated_line": "if c > -1:",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > -1:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "if c > 0:",
      "mutated_line": "if c > 1:",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 1:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "UOI",
      "lineno": 52,
      "original_line": "sub = min(sub, dfs(i, -1, k - 1, G, used))",
      "mutated_line": "sub = min(sub, dfs(i, +1, k - 1, G, used))",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, +1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "sub = min(sub, dfs(i, -1, k - 1, G, used))",
      "mutated_line": "sub = min(sub, dfs(i, -1, k + 1, G, used))",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k + 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "sub = min(sub, dfs(i, -1, k - 1, G, used))",
      "mutated_line": "sub = min(sub, dfs(i, -1, k * 1, G, used))",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k * 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "AOR",
      "lineno": 56,
      "original_line": "return 6 * k * s * s + sub",
      "mutated_line": "return 6 * k / s * s + sub",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k / s * s + sub"
    },
    {
      "operator": "AOR",
      "lineno": 56,
      "original_line": "return 6 * k * s * s + sub",
      "mutated_line": "return (6 * k + s) * s + sub",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return (6 * k + s) * s + sub"
    },
    {
      "operator": "AOR",
      "lineno": 56,
      "original_line": "return 6 * k * s * s + sub",
      "mutated_line": "return (6 * k) ** s * s + sub",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return (6 * k) ** s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])",
      "mutated_line": "return 2 * (L[0] * L[1] + L[1] * L[2] + L[3] * L[0])",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[3] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])",
      "mutated_line": "return 2 * (L[0] * L[1] + L[1] * L[2] + L[1] * L[0])",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[1] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])",
      "mutated_line": "return 2 * (L[0] * L[1] + L[1] * L[2] + L[0] * L[0])",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[0] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])",
      "mutated_line": "return 2 * (L[0] * L[1] + L[1] * L[2] + L[1] * L[0])",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[1] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])",
      "mutated_line": "return 2 * (L[0] * L[1] + L[1] * L[2] + L[-2] * L[0])",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[-2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])",
      "mutated_line": "return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[1])",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[1])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])",
      "mutated_line": "return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[-1])",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[-1])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])",
      "mutated_line": "return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[1])",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[1])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return e[1]",
      "mutated_line": "return e[2]",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[2]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return e[1]",
      "mutated_line": "return e[0]",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[0]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return e[1]",
      "mutated_line": "return e[0]",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[0]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return e[1]",
      "mutated_line": "return e[-1]",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[-1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "UOI",
      "lineno": 48,
      "original_line": "G.add_edge(i, j, -c)",
      "mutated_line": "G.add_edge(i, j, +c)",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, +c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "sub = min(sub, dfs(i, -1, k - 1, G, used))",
      "mutated_line": "sub = min(sub, dfs(i, -2, k - 1, G, used))",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -2, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "sub = min(sub, dfs(i, -1, k - 1, G, used))",
      "mutated_line": "sub = min(sub, dfs(i, -0, k - 1, G, used))",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -0, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "sub = min(sub, dfs(i, -1, k - 1, G, used))",
      "mutated_line": "sub = min(sub, dfs(i, -0, k - 1, G, used))",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -0, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "sub = min(sub, dfs(i, -1, k - 1, G, used))",
      "mutated_line": "sub = min(sub, dfs(i, --1, k - 1, G, used))",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, --1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "sub = min(sub, dfs(i, -1, k - 1, G, used))",
      "mutated_line": "sub = min(sub, dfs(i, -1, k - 2, G, used))",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 2, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "sub = min(sub, dfs(i, -1, k - 1, G, used))",
      "mutated_line": "sub = min(sub, dfs(i, -1, k - 0, G, used))",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 0, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "sub = min(sub, dfs(i, -1, k - 1, G, used))",
      "mutated_line": "sub = min(sub, dfs(i, -1, k - 0, G, used))",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 0, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "sub = min(sub, dfs(i, -1, k - 1, G, used))",
      "mutated_line": "sub = min(sub, dfs(i, -1, k - -1, G, used))",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - -1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "AOR",
      "lineno": 56,
      "original_line": "return 6 * k * s * s + sub",
      "mutated_line": "return 6 / k * s * s + sub",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 / k * s * s + sub"
    },
    {
      "operator": "AOR",
      "lineno": 56,
      "original_line": "return 6 * k * s * s + sub",
      "mutated_line": "return (6 + k) * s * s + sub",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return (6 + k) * s * s + sub"
    },
    {
      "operator": "AOR",
      "lineno": 56,
      "original_line": "return 6 * k * s * s + sub",
      "mutated_line": "return 6 ** k * s * s + sub",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 ** k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])",
      "mutated_line": "return 2 * (L[1] * L[1] + L[1] * L[2] + L[2] * L[0])",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[1] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])",
      "mutated_line": "return 2 * (L[-1] * L[1] + L[1] * L[2] + L[2] * L[0])",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[-1] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])",
      "mutated_line": "return 2 * (L[1] * L[1] + L[1] * L[2] + L[2] * L[0])",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[1] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])",
      "mutated_line": "return 2 * (L[0] * L[2] + L[1] * L[2] + L[2] * L[0])",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[2] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])",
      "mutated_line": "return 2 * (L[0] * L[0] + L[1] * L[2] + L[2] * L[0])",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[0] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])",
      "mutated_line": "return 2 * (L[0] * L[0] + L[1] * L[2] + L[2] * L[0])",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[0] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])",
      "mutated_line": "return 2 * (L[0] * L[-1] + L[1] * L[2] + L[2] * L[0])",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[-1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])",
      "mutated_line": "return 2 * (L[0] * L[1] + L[2] * L[2] + L[2] * L[0])",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[2] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])",
      "mutated_line": "return 2 * (L[0] * L[1] + L[0] * L[2] + L[2] * L[0])",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[0] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])",
      "mutated_line": "return 2 * (L[0] * L[1] + L[0] * L[2] + L[2] * L[0])",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[0] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])",
      "mutated_line": "return 2 * (L[0] * L[1] + L[-1] * L[2] + L[2] * L[0])",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[-1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])",
      "mutated_line": "return 2 * (L[0] * L[1] + L[1] * L[3] + L[2] * L[0])",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[3] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])",
      "mutated_line": "return 2 * (L[0] * L[1] + L[1] * L[1] + L[2] * L[0])",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[1] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])",
      "mutated_line": "return 2 * (L[0] * L[1] + L[1] * L[0] + L[2] * L[0])",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[0] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])",
      "mutated_line": "return 2 * (L[0] * L[1] + L[1] * L[1] + L[2] * L[0])",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[1] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])",
      "mutated_line": "return 2 * (L[0] * L[1] + L[1] * L[-2] + L[2] * L[0])",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[-2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if e[0] != pv and used[e[0]]:",
      "mutated_line": "if e[1] != pv and used[e[0]]:",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[1] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if e[0] != pv and used[e[0]]:",
      "mutated_line": "if e[-1] != pv and used[e[0]]:",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[-1] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if e[0] != pv and used[e[0]]:",
      "mutated_line": "if e[1] != pv and used[e[0]]:",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[1] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if e[0] != pv and used[e[0]]:",
      "mutated_line": "if e[0] != pv and used[e[1]]:",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[1]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if e[0] != pv and used[e[0]]:",
      "mutated_line": "if e[0] != pv and used[e[-1]]:",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[-1]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if e[0] != pv and used[e[0]]:",
      "mutated_line": "if e[0] != pv and used[e[1]]:",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[1]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "res = min(res, dd + e[1])",
      "mutated_line": "res = min(res, dd + e[2])",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[2])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "res = min(res, dd + e[1])",
      "mutated_line": "res = min(res, dd + e[0])",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[0])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "res = min(res, dd + e[1])",
      "mutated_line": "res = min(res, dd + e[0])",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[0])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "res = min(res, dd + e[1])",
      "mutated_line": "res = min(res, dd + e[-1])",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[-1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 6 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "return 6 * k * s * s + sub",
      "mutated_line": "return 7 * k * s * s + sub",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 7 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "return 6 * k * s * s + sub",
      "mutated_line": "return 5 * k * s * s + sub",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 5 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "return 6 * k * s * s + sub",
      "mutated_line": "return 0 * k * s * s + sub",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 0 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "return 6 * k * s * s + sub",
      "mutated_line": "return 1 * k * s * s + sub",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return 1 * k * s * s + sub"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "return 6 * k * s * s + sub",
      "mutated_line": "return -6 * k * s * s + sub",
      "code": "import sys\nINF = 10 ** 20\n\nclass Graph:\n\n    def __init__(self, _n):\n        self.n = _n\n        self.g = [[] for _ in range(_n)]\n\n    def add_edge(self, s, t, c=1):\n        self.g[s].append((t, c))\n        self.g[t].append((t, c))\n\n    def __getitem__(self, v):\n        return self.g[v]\n\ndef edge_cost(i, j, ps, s):\n    L = [s - abs(ps[i][k] - ps[j][k]) for k in range(3)]\n    if any((x <= 0 for x in L)):\n        return -1\n    return 2 * (L[0] * L[1] + L[1] * L[2] + L[2] * L[0])\n\ndef dfs(v, pv, k, G, used):\n    if k == 0:\n        for e in G[v]:\n            if e[0] != pv and used[e[0]]:\n                return e[1]\n        return 0\n    if used[v]:\n        return INF\n    used[v] = True\n    res = INF\n    for e in G[v]:\n        if e[0] == pv:\n            continue\n        dd = dfs(e[0], v, k - 1, G, used)\n        if dd < INF:\n            res = min(res, dd + e[1])\n    used[v] = False\n    return res\n\ndef calculate_minimal_surface_area(n, k, s, positions):\n    G = Graph(n)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            c = edge_cost(i, j, positions, s)\n            if c > 0:\n                G.add_edge(i, j, -c)\n    used = [False] * n\n    sub = INF\n    for i in range(n):\n        sub = min(sub, dfs(i, -1, k - 1, G, used))\n    if sub == INF:\n        return -1\n    else:\n        return -6 * k * s * s + sub"
    }
  ]
}