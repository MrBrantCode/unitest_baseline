{
  "task_id": "taco_17415",
  "entry_point": "process",
  "mutant_count": 201,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "b = [0] * n",
      "mutated_line": "b = [0] / n",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] / n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "b = [0] * n",
      "mutated_line": "b = [0] + n",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] + n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "b = [0] * n",
      "mutated_line": "b = [0] ** n",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] ** n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "count = 0",
      "mutated_line": "count = 1",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 1\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "count = 0",
      "mutated_line": "count = -1",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = -1\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "count = 0",
      "mutated_line": "count = 1",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 1\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "b[0] = a[0]",
      "mutated_line": "b[1] = a[0]",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[1] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "b[0] = a[0]",
      "mutated_line": "b[-1] = a[0]",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[-1] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "b[0] = a[0]",
      "mutated_line": "b[1] = a[0]",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[1] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "b[0] = a[0]",
      "mutated_line": "b[0] = a[1]",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[1]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "b[0] = a[0]",
      "mutated_line": "b[0] = a[-1]",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[-1]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "b[0] = a[0]",
      "mutated_line": "b[0] = a[1]",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[1]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(2, n):",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(2, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(0, n):",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(0, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(0, n):",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(0, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(-1, n):",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(-1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "b[i] = a[i] - b[i - 1]",
      "mutated_line": "b[i] = a[i] + b[i - 1]",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] + b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "b[i] = a[i] - b[i - 1]",
      "mutated_line": "b[i] = a[i] * b[i - 1]",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] * b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if i % 2 == 0:",
      "mutated_line": "if i % 2 != 0:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 != 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "b = [0] * n",
      "mutated_line": "b = [1] * n",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [1] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "b = [0] * n",
      "mutated_line": "b = [-1] * n",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [-1] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "b = [0] * n",
      "mutated_line": "b = [1] * n",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [1] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "c.append([0, 1])",
      "mutated_line": "c.append([1, 1])",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([1, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "c.append([0, 1])",
      "mutated_line": "c.append([-1, 1])",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([-1, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "c.append([0, 1])",
      "mutated_line": "c.append([1, 1])",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([1, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "c.append([0, 1])",
      "mutated_line": "c.append([0, 2])",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 2])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "c.append([0, 1])",
      "mutated_line": "c.append([0, 0])",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 0])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "c.append([0, 1])",
      "mutated_line": "c.append([0, 0])",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 0])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "c.append([0, 1])",
      "mutated_line": "c.append([0, -1])",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, -1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if i % 2 == 0:",
      "mutated_line": "if i * 2 == 0:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i * 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if i % 2 == 0:",
      "mutated_line": "if i + 2 == 0:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i + 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if i % 2 == 0:",
      "mutated_line": "if i % 2 == 1:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 1:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if i % 2 == 0:",
      "mutated_line": "if i % 2 == -1:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == -1:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if i % 2 == 0:",
      "mutated_line": "if i % 2 == 1:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 1:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "LCR",
      "lineno": 17,
      "original_line": "while c and c[-1][0] > b[i]:",
      "mutated_line": "while c or c[-1][0] > b[i]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c or c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "LCR",
      "lineno": 19,
      "original_line": "if c and c[-1][0] == b[i]:",
      "mutated_line": "if c or c[-1][0] == b[i]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c or c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "ASR",
      "lineno": 20,
      "original_line": "count += c[-1][1]",
      "mutated_line": "count -= c[-1][1]",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count -= c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "ASR",
      "lineno": 21,
      "original_line": "c[-1][1] += 1",
      "mutated_line": "c[-1][1] -= 1",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] -= 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "LCR",
      "lineno": 24,
      "original_line": "while d and b[i] < -d[0][0]:",
      "mutated_line": "while d or b[i] < -d[0][0]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d or b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "LCR",
      "lineno": 26,
      "original_line": "if d and b[i] == -d[0][0]:",
      "mutated_line": "if d or b[i] == -d[0][0]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d or b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "ASR",
      "lineno": 27,
      "original_line": "count += d[0][1]",
      "mutated_line": "count -= d[0][1]",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count -= d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "LCR",
      "lineno": 29,
      "original_line": "while c and b[i] < -c[0][0]:",
      "mutated_line": "while c or b[i] < -c[0][0]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c or b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "LCR",
      "lineno": 31,
      "original_line": "if c and b[i] == -c[0][0]:",
      "mutated_line": "if c or b[i] == -c[0][0]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c or b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "ASR",
      "lineno": 32,
      "original_line": "count += c[0][1]",
      "mutated_line": "count -= c[0][1]",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count -= c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "LCR",
      "lineno": 33,
      "original_line": "while d and d[-1][0] > b[i]:",
      "mutated_line": "while d or d[-1][0] > b[i]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d or d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "LCR",
      "lineno": 35,
      "original_line": "if d and d[-1][0] == b[i]:",
      "mutated_line": "if d or d[-1][0] == b[i]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d or d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "ASR",
      "lineno": 36,
      "original_line": "count += d[-1][1]",
      "mutated_line": "count -= d[-1][1]",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count -= d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "ASR",
      "lineno": 37,
      "original_line": "d[-1][1] += 1",
      "mutated_line": "d[-1][1] -= 1",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] -= 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "b[i] = a[i] - b[i - 1]",
      "mutated_line": "b[i] = a[i] - b[i + 1]",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i + 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "b[i] = a[i] - b[i - 1]",
      "mutated_line": "b[i] = a[i] - b[i * 1]",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i * 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if i % 2 == 0:",
      "mutated_line": "if i % 3 == 0:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 3 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if i % 2 == 0:",
      "mutated_line": "if i % 1 == 0:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 1 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if i % 2 == 0:",
      "mutated_line": "if i % 0 == 0:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 0 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if i % 2 == 0:",
      "mutated_line": "if i % 1 == 0:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 1 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if i % 2 == 0:",
      "mutated_line": "if i % -2 == 0:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % -2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "while c and c[-1][0] > b[i]:",
      "mutated_line": "while c and c[-1][0] >= b[i]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] >= b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "while c and c[-1][0] > b[i]:",
      "mutated_line": "while c and c[-1][0] <= b[i]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] <= b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "while c and c[-1][0] > b[i]:",
      "mutated_line": "while c and c[-1][0] != b[i]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] != b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if c and c[-1][0] == b[i]:",
      "mutated_line": "if c and c[-1][0] != b[i]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] != b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "c[-1][1] += 1",
      "mutated_line": "c[-1][1] += 2",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 2\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "c[-1][1] += 1",
      "mutated_line": "c[-1][1] += 0",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 0\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "c[-1][1] += 1",
      "mutated_line": "c[-1][1] += 0",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 0\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "c[-1][1] += 1",
      "mutated_line": "c[-1][1] += -1",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += -1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "while d and b[i] < -d[0][0]:",
      "mutated_line": "while d and b[i] <= -d[0][0]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] <= -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "while d and b[i] < -d[0][0]:",
      "mutated_line": "while d and b[i] >= -d[0][0]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] >= -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "while d and b[i] < -d[0][0]:",
      "mutated_line": "while d and b[i] != -d[0][0]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] != -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if d and b[i] == -d[0][0]:",
      "mutated_line": "if d and b[i] != -d[0][0]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] != -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "while c and b[i] < -c[0][0]:",
      "mutated_line": "while c and b[i] <= -c[0][0]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] <= -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "while c and b[i] < -c[0][0]:",
      "mutated_line": "while c and b[i] >= -c[0][0]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] >= -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "while c and b[i] < -c[0][0]:",
      "mutated_line": "while c and b[i] != -c[0][0]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] != -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if c and b[i] == -c[0][0]:",
      "mutated_line": "if c and b[i] != -c[0][0]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] != -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "while d and d[-1][0] > b[i]:",
      "mutated_line": "while d and d[-1][0] >= b[i]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] >= b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "while d and d[-1][0] > b[i]:",
      "mutated_line": "while d and d[-1][0] <= b[i]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] <= b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "while d and d[-1][0] > b[i]:",
      "mutated_line": "while d and d[-1][0] != b[i]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] != b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if d and d[-1][0] == b[i]:",
      "mutated_line": "if d and d[-1][0] != b[i]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] != b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "d[-1][1] += 1",
      "mutated_line": "d[-1][1] += 2",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 2\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "d[-1][1] += 1",
      "mutated_line": "d[-1][1] += 0",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 0\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "d[-1][1] += 1",
      "mutated_line": "d[-1][1] += 0",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 0\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "d[-1][1] += 1",
      "mutated_line": "d[-1][1] += -1",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += -1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "b[i] = a[i] - b[i - 1]",
      "mutated_line": "b[i] = a[i] - b[i - 2]",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 2]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "b[i] = a[i] - b[i - 1]",
      "mutated_line": "b[i] = a[i] - b[i - 0]",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 0]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "b[i] = a[i] - b[i - 1]",
      "mutated_line": "b[i] = a[i] - b[i - 0]",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 0]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "b[i] = a[i] - b[i - 1]",
      "mutated_line": "b[i] = a[i] - b[i - -1]",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - -1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "count += c[-1][1]",
      "mutated_line": "count += c[-1][2]",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][2]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "count += c[-1][1]",
      "mutated_line": "count += c[-1][0]",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][0]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "count += c[-1][1]",
      "mutated_line": "count += c[-1][0]",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][0]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "count += c[-1][1]",
      "mutated_line": "count += c[-1][-1]",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][-1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "c[-1][1] += 1",
      "mutated_line": "c[-1][2] += 1",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][2] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "c[-1][1] += 1",
      "mutated_line": "c[-1][0] += 1",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][0] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "c[-1][1] += 1",
      "mutated_line": "c[-1][0] += 1",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][0] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "c[-1][1] += 1",
      "mutated_line": "c[-1][-1] += 1",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][-1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "UOI",
      "lineno": 24,
      "original_line": "while d and b[i] < -d[0][0]:",
      "mutated_line": "while d and b[i] < +d[0][0]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < +d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "UOI",
      "lineno": 26,
      "original_line": "if d and b[i] == -d[0][0]:",
      "mutated_line": "if d and b[i] == +d[0][0]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == +d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "count += d[0][1]",
      "mutated_line": "count += d[0][2]",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][2]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "count += d[0][1]",
      "mutated_line": "count += d[0][0]",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][0]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "count += d[0][1]",
      "mutated_line": "count += d[0][0]",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][0]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "count += d[0][1]",
      "mutated_line": "count += d[0][-1]",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][-1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "UOI",
      "lineno": 29,
      "original_line": "while c and b[i] < -c[0][0]:",
      "mutated_line": "while c and b[i] < +c[0][0]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < +c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "UOI",
      "lineno": 31,
      "original_line": "if c and b[i] == -c[0][0]:",
      "mutated_line": "if c and b[i] == +c[0][0]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == +c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "count += c[0][1]",
      "mutated_line": "count += c[0][2]",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][2]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "count += c[0][1]",
      "mutated_line": "count += c[0][0]",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][0]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "count += c[0][1]",
      "mutated_line": "count += c[0][0]",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][0]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "count += c[0][1]",
      "mutated_line": "count += c[0][-1]",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][-1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "count += d[-1][1]",
      "mutated_line": "count += d[-1][2]",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][2]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "count += d[-1][1]",
      "mutated_line": "count += d[-1][0]",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][0]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "count += d[-1][1]",
      "mutated_line": "count += d[-1][0]",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][0]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "count += d[-1][1]",
      "mutated_line": "count += d[-1][-1]",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][-1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "d[-1][1] += 1",
      "mutated_line": "d[-1][2] += 1",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][2] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "d[-1][1] += 1",
      "mutated_line": "d[-1][0] += 1",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][0] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "d[-1][1] += 1",
      "mutated_line": "d[-1][0] += 1",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][0] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "d[-1][1] += 1",
      "mutated_line": "d[-1][-1] += 1",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][-1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "while c and c[-1][0] > b[i]:",
      "mutated_line": "while c and c[-1][1] > b[i]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][1] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "while c and c[-1][0] > b[i]:",
      "mutated_line": "while c and c[-1][-1] > b[i]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][-1] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "while c and c[-1][0] > b[i]:",
      "mutated_line": "while c and c[-1][1] > b[i]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][1] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if c and c[-1][0] == b[i]:",
      "mutated_line": "if c and c[-1][1] == b[i]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][1] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if c and c[-1][0] == b[i]:",
      "mutated_line": "if c and c[-1][-1] == b[i]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][-1] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if c and c[-1][0] == b[i]:",
      "mutated_line": "if c and c[-1][1] == b[i]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][1] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "UOI",
      "lineno": 20,
      "original_line": "count += c[-1][1]",
      "mutated_line": "count += c[+1][1]",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[+1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "UOI",
      "lineno": 21,
      "original_line": "c[-1][1] += 1",
      "mutated_line": "c[+1][1] += 1",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[+1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "c.append([b[i], 1])",
      "mutated_line": "c.append([b[i], 2])",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 2])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "c.append([b[i], 1])",
      "mutated_line": "c.append([b[i], 0])",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 0])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "c.append([b[i], 1])",
      "mutated_line": "c.append([b[i], 0])",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 0])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "c.append([b[i], 1])",
      "mutated_line": "c.append([b[i], -1])",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], -1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "count += d[0][1]",
      "mutated_line": "count += d[1][1]",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[1][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "count += d[0][1]",
      "mutated_line": "count += d[-1][1]",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[-1][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "count += d[0][1]",
      "mutated_line": "count += d[1][1]",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[1][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "count += c[0][1]",
      "mutated_line": "count += c[1][1]",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[1][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "count += c[0][1]",
      "mutated_line": "count += c[-1][1]",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[-1][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "count += c[0][1]",
      "mutated_line": "count += c[1][1]",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[1][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "while d and d[-1][0] > b[i]:",
      "mutated_line": "while d and d[-1][1] > b[i]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][1] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "while d and d[-1][0] > b[i]:",
      "mutated_line": "while d and d[-1][-1] > b[i]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][-1] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "while d and d[-1][0] > b[i]:",
      "mutated_line": "while d and d[-1][1] > b[i]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][1] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if d and d[-1][0] == b[i]:",
      "mutated_line": "if d and d[-1][1] == b[i]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][1] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if d and d[-1][0] == b[i]:",
      "mutated_line": "if d and d[-1][-1] == b[i]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][-1] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if d and d[-1][0] == b[i]:",
      "mutated_line": "if d and d[-1][1] == b[i]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][1] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "UOI",
      "lineno": 36,
      "original_line": "count += d[-1][1]",
      "mutated_line": "count += d[+1][1]",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[+1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "UOI",
      "lineno": 37,
      "original_line": "d[-1][1] += 1",
      "mutated_line": "d[+1][1] += 1",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[+1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "d.append([b[i], 1])",
      "mutated_line": "d.append([b[i], 2])",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 2])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "d.append([b[i], 1])",
      "mutated_line": "d.append([b[i], 0])",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 0])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "d.append([b[i], 1])",
      "mutated_line": "d.append([b[i], 0])",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 0])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "d.append([b[i], 1])",
      "mutated_line": "d.append([b[i], -1])",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], -1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "while c and c[-1][0] > b[i]:",
      "mutated_line": "while c and c[+1][0] > b[i]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[+1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "UOI",
      "lineno": 19,
      "original_line": "if c and c[-1][0] == b[i]:",
      "mutated_line": "if c and c[+1][0] == b[i]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[+1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "count += c[-1][1]",
      "mutated_line": "count += c[-2][1]",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-2][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "count += c[-1][1]",
      "mutated_line": "count += c[-0][1]",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-0][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "count += c[-1][1]",
      "mutated_line": "count += c[-0][1]",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-0][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "count += c[-1][1]",
      "mutated_line": "count += c[--1][1]",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[--1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "c[-1][1] += 1",
      "mutated_line": "c[-2][1] += 1",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-2][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "c[-1][1] += 1",
      "mutated_line": "c[-0][1] += 1",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-0][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "c[-1][1] += 1",
      "mutated_line": "c[-0][1] += 1",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-0][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "c[-1][1] += 1",
      "mutated_line": "c[--1][1] += 1",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[--1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "while d and b[i] < -d[0][0]:",
      "mutated_line": "while d and b[i] < -d[0][1]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][1]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "while d and b[i] < -d[0][0]:",
      "mutated_line": "while d and b[i] < -d[0][-1]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][-1]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "while d and b[i] < -d[0][0]:",
      "mutated_line": "while d and b[i] < -d[0][1]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][1]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if d and b[i] == -d[0][0]:",
      "mutated_line": "if d and b[i] == -d[0][1]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][1]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if d and b[i] == -d[0][0]:",
      "mutated_line": "if d and b[i] == -d[0][-1]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][-1]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if d and b[i] == -d[0][0]:",
      "mutated_line": "if d and b[i] == -d[0][1]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][1]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "while c and b[i] < -c[0][0]:",
      "mutated_line": "while c and b[i] < -c[0][1]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][1]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "while c and b[i] < -c[0][0]:",
      "mutated_line": "while c and b[i] < -c[0][-1]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][-1]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "while c and b[i] < -c[0][0]:",
      "mutated_line": "while c and b[i] < -c[0][1]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][1]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if c and b[i] == -c[0][0]:",
      "mutated_line": "if c and b[i] == -c[0][1]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][1]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if c and b[i] == -c[0][0]:",
      "mutated_line": "if c and b[i] == -c[0][-1]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][-1]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if c and b[i] == -c[0][0]:",
      "mutated_line": "if c and b[i] == -c[0][1]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][1]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "UOI",
      "lineno": 33,
      "original_line": "while d and d[-1][0] > b[i]:",
      "mutated_line": "while d and d[+1][0] > b[i]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[+1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "UOI",
      "lineno": 35,
      "original_line": "if d and d[-1][0] == b[i]:",
      "mutated_line": "if d and d[+1][0] == b[i]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[+1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "count += d[-1][1]",
      "mutated_line": "count += d[-2][1]",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-2][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "count += d[-1][1]",
      "mutated_line": "count += d[-0][1]",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-0][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "count += d[-1][1]",
      "mutated_line": "count += d[-0][1]",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-0][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "count += d[-1][1]",
      "mutated_line": "count += d[--1][1]",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[--1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "d[-1][1] += 1",
      "mutated_line": "d[-2][1] += 1",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-2][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "d[-1][1] += 1",
      "mutated_line": "d[-0][1] += 1",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-0][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "d[-1][1] += 1",
      "mutated_line": "d[-0][1] += 1",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-0][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "d[-1][1] += 1",
      "mutated_line": "d[--1][1] += 1",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[--1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "while c and c[-1][0] > b[i]:",
      "mutated_line": "while c and c[-2][0] > b[i]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-2][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "while c and c[-1][0] > b[i]:",
      "mutated_line": "while c and c[-0][0] > b[i]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-0][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "while c and c[-1][0] > b[i]:",
      "mutated_line": "while c and c[-0][0] > b[i]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-0][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "while c and c[-1][0] > b[i]:",
      "mutated_line": "while c and c[--1][0] > b[i]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[--1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if c and c[-1][0] == b[i]:",
      "mutated_line": "if c and c[-2][0] == b[i]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-2][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if c and c[-1][0] == b[i]:",
      "mutated_line": "if c and c[-0][0] == b[i]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-0][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if c and c[-1][0] == b[i]:",
      "mutated_line": "if c and c[-0][0] == b[i]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-0][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if c and c[-1][0] == b[i]:",
      "mutated_line": "if c and c[--1][0] == b[i]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[--1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "while d and b[i] < -d[0][0]:",
      "mutated_line": "while d and b[i] < -d[1][0]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[1][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "while d and b[i] < -d[0][0]:",
      "mutated_line": "while d and b[i] < -d[-1][0]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[-1][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "while d and b[i] < -d[0][0]:",
      "mutated_line": "while d and b[i] < -d[1][0]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[1][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if d and b[i] == -d[0][0]:",
      "mutated_line": "if d and b[i] == -d[1][0]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[1][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if d and b[i] == -d[0][0]:",
      "mutated_line": "if d and b[i] == -d[-1][0]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[-1][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if d and b[i] == -d[0][0]:",
      "mutated_line": "if d and b[i] == -d[1][0]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[1][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "while c and b[i] < -c[0][0]:",
      "mutated_line": "while c and b[i] < -c[1][0]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[1][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "while c and b[i] < -c[0][0]:",
      "mutated_line": "while c and b[i] < -c[-1][0]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[-1][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "while c and b[i] < -c[0][0]:",
      "mutated_line": "while c and b[i] < -c[1][0]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[1][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if c and b[i] == -c[0][0]:",
      "mutated_line": "if c and b[i] == -c[1][0]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[1][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if c and b[i] == -c[0][0]:",
      "mutated_line": "if c and b[i] == -c[-1][0]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[-1][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if c and b[i] == -c[0][0]:",
      "mutated_line": "if c and b[i] == -c[1][0]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[1][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "while d and d[-1][0] > b[i]:",
      "mutated_line": "while d and d[-2][0] > b[i]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-2][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "while d and d[-1][0] > b[i]:",
      "mutated_line": "while d and d[-0][0] > b[i]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-0][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "while d and d[-1][0] > b[i]:",
      "mutated_line": "while d and d[-0][0] > b[i]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-0][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "while d and d[-1][0] > b[i]:",
      "mutated_line": "while d and d[--1][0] > b[i]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[--1][0] > b[i]:\n                d.pop()\n            if d and d[-1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if d and d[-1][0] == b[i]:",
      "mutated_line": "if d and d[-2][0] == b[i]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-2][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if d and d[-1][0] == b[i]:",
      "mutated_line": "if d and d[-0][0] == b[i]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-0][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if d and d[-1][0] == b[i]:",
      "mutated_line": "if d and d[-0][0] == b[i]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[-0][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if d and d[-1][0] == b[i]:",
      "mutated_line": "if d and d[--1][0] == b[i]:",
      "code": "from collections import deque\n\ndef process(a, n):\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] - b[i - 1]\n    return b\n\ndef check(a, b, n):\n    c = deque([])\n    c.append([0, 1])\n    d = deque([])\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            while c and c[-1][0] > b[i]:\n                c.pop()\n            if c and c[-1][0] == b[i]:\n                count += c[-1][1]\n                c[-1][1] += 1\n            else:\n                c.append([b[i], 1])\n            while d and b[i] < -d[0][0]:\n                d.popleft()\n            if d and b[i] == -d[0][0]:\n                count += d[0][1]\n        else:\n            while c and b[i] < -c[0][0]:\n                c.popleft()\n            if c and b[i] == -c[0][0]:\n                count += c[0][1]\n            while d and d[-1][0] > b[i]:\n                d.pop()\n            if d and d[--1][0] == b[i]:\n                count += d[-1][1]\n                d[-1][1] += 1\n            else:\n                d.append([b[i], 1])\n    return count\n\ndef count_winning_subsegments(a, n):\n    b = process(a, n)\n    return check(a, b, n)"
    }
  ]
}