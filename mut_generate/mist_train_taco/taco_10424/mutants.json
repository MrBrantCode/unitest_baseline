{
  "task_id": "taco_10424",
  "entry_point": "calculate_swimming_time",
  "mutant_count": 88,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "T = [0] * n",
      "mutated_line": "T = [0] / n",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] / n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "T = [0] * n",
      "mutated_line": "T = [0] + n",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] + n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "T = [0] * n",
      "mutated_line": "T = [0] ** n",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] ** n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "C = [0] * n",
      "mutated_line": "C = [0] / n",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] / n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "C = [0] * n",
      "mutated_line": "C = [0] + n",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] + n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "C = [0] * n",
      "mutated_line": "C = [0] ** n",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] ** n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 10 * 18",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 * 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 10 + 18",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 + 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 18\n    ans = 1\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 18\n    ans = -1\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 18\n    ans = 1\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 11 ** 18",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 11 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 9 ** 18",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 9 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 0 ** 18",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 0 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 1 ** 18",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 1 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = -10 ** 18",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = -10 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 10 ** 19",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 19\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 10 ** 17",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 17\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 10 ** 0",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 0\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 10 ** 1",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 1\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 10 ** -18",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** -18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 27,
      "original_line": "while que0 and que0[0][1] <= t:",
      "mutated_line": "while que0 or que0[0][1] <= t:",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 or que0[0][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 34,
      "original_line": "while que1 and que1[0][1] <= t:",
      "mutated_line": "while que1 or que1[0][1] <= t:",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 or que1[0][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 43,
      "original_line": "C[i] -= 1",
      "mutated_line": "C[i] += 1",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] += 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "T = [0] * n",
      "mutated_line": "T = [1] * n",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [1] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "T = [0] * n",
      "mutated_line": "T = [-1] * n",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [-1] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "T = [0] * n",
      "mutated_line": "T = [1] * n",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [1] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "C = [0] * n",
      "mutated_line": "C = [1] * n",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [1] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "C = [0] * n",
      "mutated_line": "C = [-1] * n",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [-1] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "C = [0] * n",
      "mutated_line": "C = [1] * n",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [1] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "while que0 and que0[0][1] <= t:",
      "mutated_line": "while que0 and que0[0][1] < t:",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] < t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "while que0 and que0[0][1] <= t:",
      "mutated_line": "while que0 and que0[0][1] > t:",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] > t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "while que0 and que0[0][1] <= t:",
      "mutated_line": "while que0 and que0[0][1] == t:",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] == t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "while que1 and que1[0][1] <= t:",
      "mutated_line": "while que1 and que1[0][1] < t:",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] < t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "while que1 and que1[0][1] <= t:",
      "mutated_line": "while que1 and que1[0][1] > t:",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] > t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "while que1 and que1[0][1] <= t:",
      "mutated_line": "while que1 and que1[0][1] == t:",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] == t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if C[i] == 1:",
      "mutated_line": "if C[i] != 1:",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] != 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 40,
      "original_line": "rest -= 1",
      "mutated_line": "rest += 1",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest += 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "C[i] -= 1",
      "mutated_line": "C[i] -= 2",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 2\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "C[i] -= 1",
      "mutated_line": "C[i] -= 0",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 0\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "C[i] -= 1",
      "mutated_line": "C[i] -= 0",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 0\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "C[i] -= 1",
      "mutated_line": "C[i] -= -1",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= -1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if C[i] == 1:",
      "mutated_line": "if C[i] == 2:",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 2:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if C[i] == 1:",
      "mutated_line": "if C[i] == 0:",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 0:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if C[i] == 1:",
      "mutated_line": "if C[i] == 0:",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 0:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if C[i] == 1:",
      "mutated_line": "if C[i] == -1:",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == -1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "rest -= 1",
      "mutated_line": "rest -= 2",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 2\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "rest -= 1",
      "mutated_line": "rest -= 0",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 0\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "rest -= 1",
      "mutated_line": "rest -= 0",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 0\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "rest -= 1",
      "mutated_line": "rest -= -1",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= -1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)",
      "mutated_line": "t = min(que0[0][2] if que0 else INF, que1[0][1] if que1 else INF)",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][2] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)",
      "mutated_line": "t = min(que0[0][0] if que0 else INF, que1[0][1] if que1 else INF)",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][0] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)",
      "mutated_line": "t = min(que0[0][0] if que0 else INF, que1[0][1] if que1 else INF)",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][0] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)",
      "mutated_line": "t = min(que0[0][-1] if que0 else INF, que1[0][1] if que1 else INF)",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][-1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)",
      "mutated_line": "t = min(que0[0][1] if que0 else INF, que1[0][2] if que1 else INF)",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][2] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)",
      "mutated_line": "t = min(que0[0][1] if que0 else INF, que1[0][0] if que1 else INF)",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][0] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)",
      "mutated_line": "t = min(que0[0][1] if que0 else INF, que1[0][0] if que1 else INF)",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][0] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)",
      "mutated_line": "t = min(que0[0][1] if que0 else INF, que1[0][-1] if que1 else INF)",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][-1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "while que0 and que0[0][1] <= t:",
      "mutated_line": "while que0 and que0[0][2] <= t:",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][2] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "while que0 and que0[0][1] <= t:",
      "mutated_line": "while que0 and que0[0][0] <= t:",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][0] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "while que0 and que0[0][1] <= t:",
      "mutated_line": "while que0 and que0[0][0] <= t:",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][0] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "while que0 and que0[0][1] <= t:",
      "mutated_line": "while que0 and que0[0][-1] <= t:",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][-1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "st0.append(que0.popleft()[0])",
      "mutated_line": "st0.append(que0.popleft()[1])",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[1])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "st0.append(que0.popleft()[0])",
      "mutated_line": "st0.append(que0.popleft()[-1])",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[-1])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "st0.append(que0.popleft()[0])",
      "mutated_line": "st0.append(que0.popleft()[1])",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[1])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "que1.append((i, t + T[i]))",
      "mutated_line": "que1.append((i, t - T[i]))",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t - T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "que1.append((i, t + T[i]))",
      "mutated_line": "que1.append((i, t * T[i]))",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t * T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "while que1 and que1[0][1] <= t:",
      "mutated_line": "while que1 and que1[0][2] <= t:",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][2] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "while que1 and que1[0][1] <= t:",
      "mutated_line": "while que1 and que1[0][0] <= t:",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][0] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "while que1 and que1[0][1] <= t:",
      "mutated_line": "while que1 and que1[0][0] <= t:",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][0] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "while que1 and que1[0][1] <= t:",
      "mutated_line": "while que1 and que1[0][-1] <= t:",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][-1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "st1.append(que1.popleft()[0])",
      "mutated_line": "st1.append(que1.popleft()[1])",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[1])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "st1.append(que1.popleft()[0])",
      "mutated_line": "st1.append(que1.popleft()[-1])",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[-1])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "st1.append(que1.popleft()[0])",
      "mutated_line": "st1.append(que1.popleft()[1])",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[1])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)",
      "mutated_line": "t = min(que0[1][1] if que0 else INF, que1[0][1] if que1 else INF)",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[1][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)",
      "mutated_line": "t = min(que0[-1][1] if que0 else INF, que1[0][1] if que1 else INF)",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[-1][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)",
      "mutated_line": "t = min(que0[1][1] if que0 else INF, que1[0][1] if que1 else INF)",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[1][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)",
      "mutated_line": "t = min(que0[0][1] if que0 else INF, que1[1][1] if que1 else INF)",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[1][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)",
      "mutated_line": "t = min(que0[0][1] if que0 else INF, que1[-1][1] if que1 else INF)",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[-1][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)",
      "mutated_line": "t = min(que0[0][1] if que0 else INF, que1[1][1] if que1 else INF)",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[1][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "while que0 and que0[0][1] <= t:",
      "mutated_line": "while que0 and que0[1][1] <= t:",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[1][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "while que0 and que0[0][1] <= t:",
      "mutated_line": "while que0 and que0[-1][1] <= t:",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[-1][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "while que0 and que0[0][1] <= t:",
      "mutated_line": "while que0 and que0[1][1] <= t:",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[1][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "while que1 and que1[0][1] <= t:",
      "mutated_line": "while que1 and que1[1][1] <= t:",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[1][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "while que1 and que1[0][1] <= t:",
      "mutated_line": "while que1 and que1[-1][1] <= t:",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[-1][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "while que1 and que1[0][1] <= t:",
      "mutated_line": "while que1 and que1[1][1] <= t:",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[1][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t + T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "que0.append((i, t + T[i]))",
      "mutated_line": "que0.append((i, t - T[i]))",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t - T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "que0.append((i, t + T[i]))",
      "mutated_line": "que0.append((i, t * T[i]))",
      "code": "from collections import deque\n\ndef calculate_swimming_time(n, swimmers):\n    T = [0] * n\n    C = [0] * n\n    que0 = deque()\n    que1 = deque()\n    swimmers.sort()\n    for i in range(n):\n        (t, c) = swimmers[i]\n        que0.append((i, t))\n        T[i] = t\n        C[i] = c\n    INF = 10 ** 18\n    ans = 0\n    rest = n\n    while rest:\n        t = min(que0[0][1] if que0 else INF, que1[0][1] if que1 else INF)\n        st0 = []\n        st1 = []\n        while que0 and que0[0][1] <= t:\n            st0.append(que0.popleft()[0])\n        st0.sort()\n        for i in st0:\n            que1.append((i, t + T[i]))\n        while que1 and que1[0][1] <= t:\n            st1.append(que1.popleft()[0])\n        st1.sort()\n        for i in st1:\n            if C[i] == 1:\n                rest -= 1\n            else:\n                que0.append((i, t * T[i]))\n            C[i] -= 1\n        ans = max(ans, t)\n    return ans"
    }
  ]
}