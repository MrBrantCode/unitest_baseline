{
  "task_id": "taco_19375",
  "entry_point": "can_maintain_permutation_with_swaps",
  "mutant_count": 151,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if n % 4 > 1:",
      "mutated_line": "return 'NO'",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 >= 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if n % 4 > 1:",
      "mutated_line": "return 'NO'",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 <= 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if n % 4 > 1:",
      "mutated_line": "return 'NO'",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 != 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "if n % 4 > 1:",
      "mutated_line": "return 'NO'",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n * 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "if n % 4 > 1:",
      "mutated_line": "return 'NO'",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n + 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if n % 4 > 1:",
      "mutated_line": "return 'NO'",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 2:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if n % 4 > 1:",
      "mutated_line": "return 'NO'",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 0:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if n % 4 > 1:",
      "mutated_line": "return 'NO'",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 0:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if n % 4 > 1:",
      "mutated_line": "return 'NO'",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > -1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return \"NO\"",
      "mutated_line": "return ''",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return ''\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "for i in range(n % 4, n, 4):",
      "mutated_line": "for i in range(n * 4, n, 4):",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n * 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "for i in range(n % 4, n, 4):",
      "mutated_line": "for i in range(n + 4, n, 4):",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n + 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(n % 4, n, 4):",
      "mutated_line": "for i in range(n % 4, n, 5):",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 5):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(n % 4, n, 4):",
      "mutated_line": "for i in range(n % 4, n, 3):",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 3):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(n % 4, n, 4):",
      "mutated_line": "for i in range(n % 4, n, 0):",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 0):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(n % 4, n, 4):",
      "mutated_line": "for i in range(n % 4, n, 1):",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 1):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(n % 4, n, 4):",
      "mutated_line": "for i in range(n % 4, n, -4):",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, -4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return \"YES\", swaps",
      "mutated_line": "return ('', swaps)",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('', swaps)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return (a + 1, b + 1)",
      "mutated_line": "return (a - 1, b + 1)",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a - 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return (a + 1, b + 1)",
      "mutated_line": "return (a * 1, b + 1)",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a * 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return (a + 1, b + 1)",
      "mutated_line": "return (a + 1, b - 1)",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b - 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return (a + 1, b + 1)",
      "mutated_line": "return (a + 1, b * 1)",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b * 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if n % 4 > 1:",
      "mutated_line": "return 'NO'",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 5 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if n % 4 > 1:",
      "mutated_line": "return 'NO'",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 3 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if n % 4 > 1:",
      "mutated_line": "return 'NO'",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 0 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if n % 4 > 1:",
      "mutated_line": "return 'NO'",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 1 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if n % 4 > 1:",
      "mutated_line": "return 'NO'",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % -4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(n % 4, n, 4):",
      "mutated_line": "for i in range(n % 5, n, 4):",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 5, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(n % 4, n, 4):",
      "mutated_line": "for i in range(n % 3, n, 4):",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 3, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(n % 4, n, 4):",
      "mutated_line": "for i in range(n % 0, n, 4):",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 0, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(n % 4, n, 4):",
      "mutated_line": "for i in range(n % 1, n, 4):",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 1, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(n % 4, n, 4):",
      "mutated_line": "for i in range(n % -4, n, 4):",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % -4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for x in range(2):",
      "mutated_line": "for x in range(3):",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(3):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for x in range(2):",
      "mutated_line": "for x in range(1):",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(1):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for x in range(2):",
      "mutated_line": "for x in range(0):",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(0):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for x in range(2):",
      "mutated_line": "for x in range(1):",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(1):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for x in range(2):",
      "mutated_line": "for x in range(-2):",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(-2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return (a + 1, b + 1)",
      "mutated_line": "return (a + 2, b + 1)",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 2, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return (a + 1, b + 1)",
      "mutated_line": "return (a + 0, b + 1)",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 0, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return (a + 1, b + 1)",
      "mutated_line": "return (a + 0, b + 1)",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 0, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return (a + 1, b + 1)",
      "mutated_line": "return (a + -1, b + 1)",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + -1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return (a + 1, b + 1)",
      "mutated_line": "return (a + 1, b + 2)",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 2)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return (a + 1, b + 1)",
      "mutated_line": "return (a + 1, b + 0)",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 0)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return (a + 1, b + 1)",
      "mutated_line": "return (a + 1, b + 0)",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 0)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return (a + 1, b + 1)",
      "mutated_line": "return (a + 1, b + -1)",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + -1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for j in range(i, 0, -1):",
      "mutated_line": "for j in range(i, 1, -1):",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 1, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for j in range(i, 0, -1):",
      "mutated_line": "for j in range(i, -1, -1):",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, -1, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for j in range(i, 0, -1):",
      "mutated_line": "for j in range(i, 1, -1):",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 1, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "UOI",
      "lineno": 14,
      "original_line": "for j in range(i, 0, -1):",
      "mutated_line": "for j in range(i, 0, +1):",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, +1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "swaps.append(p(i, i + 3))",
      "mutated_line": "swaps.append(p(i, i - 3))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i - 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "swaps.append(p(i, i + 3))",
      "mutated_line": "swaps.append(p(i, i * 3))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i * 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "swaps.append(p(i + 1, i + 2))",
      "mutated_line": "swaps.append(p(i - 1, i + 2))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i - 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "swaps.append(p(i + 1, i + 2))",
      "mutated_line": "swaps.append(p(i * 1, i + 2))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i * 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "swaps.append(p(i + 1, i + 2))",
      "mutated_line": "swaps.append(p(i + 1, i - 2))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i - 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "swaps.append(p(i + 1, i + 2))",
      "mutated_line": "swaps.append(p(i + 1, i * 2))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i * 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "swaps.append(p(i, i + 2))",
      "mutated_line": "swaps.append(p(i, i - 2))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i - 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "swaps.append(p(i, i + 2))",
      "mutated_line": "swaps.append(p(i, i * 2))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i * 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "swaps.append(p(i + 1, i + 3))",
      "mutated_line": "swaps.append(p(i - 1, i + 3))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i - 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "swaps.append(p(i + 1, i + 3))",
      "mutated_line": "swaps.append(p(i * 1, i + 3))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i * 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "swaps.append(p(i + 1, i + 3))",
      "mutated_line": "swaps.append(p(i + 1, i - 3))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i - 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "swaps.append(p(i + 1, i + 3))",
      "mutated_line": "swaps.append(p(i + 1, i * 3))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i * 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "swaps.append(p(i + 2 * x, i + 2 * x + 1))",
      "mutated_line": "swaps.append(p(i - 2 * x, i + 2 * x + 1))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i - 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "swaps.append(p(i + 2 * x, i + 2 * x + 1))",
      "mutated_line": "swaps.append(p(i * (2 * x), i + 2 * x + 1))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i * (2 * x), i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "swaps.append(p(i + 2 * x, i + 2 * x + 1))",
      "mutated_line": "swaps.append(p(i + 2 * x, i + 2 * x - 1))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x - 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "swaps.append(p(i + 2 * x, i + 2 * x + 1))",
      "mutated_line": "swaps.append(p(i + 2 * x, (i + 2 * x) * 1))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, (i + 2 * x) * 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for j in range(i, 0, -1):",
      "mutated_line": "for j in range(i, 0, -2):",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -2):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for j in range(i, 0, -1):",
      "mutated_line": "for j in range(i, 0, -0):",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -0):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for j in range(i, 0, -1):",
      "mutated_line": "for j in range(i, 0, -0):",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -0):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for j in range(i, 0, -1):",
      "mutated_line": "for j in range(i, 0, --1):",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, --1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "swaps.append(p(i, i + 3))",
      "mutated_line": "swaps.append(p(i, i + 4))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 4))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "swaps.append(p(i, i + 3))",
      "mutated_line": "swaps.append(p(i, i + 2))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "swaps.append(p(i, i + 3))",
      "mutated_line": "swaps.append(p(i, i + 0))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 0))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "swaps.append(p(i, i + 3))",
      "mutated_line": "swaps.append(p(i, i + 1))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 1))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "swaps.append(p(i, i + 3))",
      "mutated_line": "swaps.append(p(i, i + -3))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + -3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "swaps.append(p(i + 1, i + 2))",
      "mutated_line": "swaps.append(p(i + 2, i + 2))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 2, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "swaps.append(p(i + 1, i + 2))",
      "mutated_line": "swaps.append(p(i + 0, i + 2))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 0, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "swaps.append(p(i + 1, i + 2))",
      "mutated_line": "swaps.append(p(i + 0, i + 2))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 0, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "swaps.append(p(i + 1, i + 2))",
      "mutated_line": "swaps.append(p(i + -1, i + 2))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + -1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "swaps.append(p(i + 1, i + 2))",
      "mutated_line": "swaps.append(p(i + 1, i + 3))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 3))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "swaps.append(p(i + 1, i + 2))",
      "mutated_line": "swaps.append(p(i + 1, i + 1))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 1))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "swaps.append(p(i + 1, i + 2))",
      "mutated_line": "swaps.append(p(i + 1, i + 0))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 0))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "swaps.append(p(i + 1, i + 2))",
      "mutated_line": "swaps.append(p(i + 1, i + 1))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 1))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "swaps.append(p(i + 1, i + 2))",
      "mutated_line": "swaps.append(p(i + 1, i + -2))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + -2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "swaps.append(p(i, i + 2))",
      "mutated_line": "swaps.append(p(i, i + 3))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "swaps.append(p(i, i + 2))",
      "mutated_line": "swaps.append(p(i, i + 1))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 1))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "swaps.append(p(i, i + 2))",
      "mutated_line": "swaps.append(p(i, i + 0))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 0))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "swaps.append(p(i, i + 2))",
      "mutated_line": "swaps.append(p(i, i + 1))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 1))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "swaps.append(p(i, i + 2))",
      "mutated_line": "swaps.append(p(i, i + -2))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + -2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "swaps.append(p(i + 1, i + 3))",
      "mutated_line": "swaps.append(p(i + 2, i + 3))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 2, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "swaps.append(p(i + 1, i + 3))",
      "mutated_line": "swaps.append(p(i + 0, i + 3))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 0, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "swaps.append(p(i + 1, i + 3))",
      "mutated_line": "swaps.append(p(i + 0, i + 3))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 0, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "swaps.append(p(i + 1, i + 3))",
      "mutated_line": "swaps.append(p(i + -1, i + 3))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + -1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "swaps.append(p(i + 1, i + 3))",
      "mutated_line": "swaps.append(p(i + 1, i + 4))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 4))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "swaps.append(p(i + 1, i + 3))",
      "mutated_line": "swaps.append(p(i + 1, i + 2))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 2))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "swaps.append(p(i + 1, i + 3))",
      "mutated_line": "swaps.append(p(i + 1, i + 0))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 0))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "swaps.append(p(i + 1, i + 3))",
      "mutated_line": "swaps.append(p(i + 1, i + 1))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 1))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "swaps.append(p(i + 1, i + 3))",
      "mutated_line": "swaps.append(p(i + 1, i + -3))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + -3))\n    return ('YES', swaps)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "swaps.append(p(j, i + 2 * x))",
      "mutated_line": "swaps.append(p(j, i - 2 * x))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i - 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "swaps.append(p(j, i + 2 * x))",
      "mutated_line": "swaps.append(p(j, i * (2 * x)))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i * (2 * x)))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "swaps.append(p(i + 2 * x, i + 2 * x + 1))",
      "mutated_line": "swaps.append(p(i + 2 / x, i + 2 * x + 1))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 / x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "swaps.append(p(i + 2 * x, i + 2 * x + 1))",
      "mutated_line": "swaps.append(p(i + (2 + x), i + 2 * x + 1))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + (2 + x), i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "swaps.append(p(i + 2 * x, i + 2 * x + 1))",
      "mutated_line": "swaps.append(p(i + 2 ** x, i + 2 * x + 1))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 ** x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "swaps.append(p(i + 2 * x, i + 2 * x + 1))",
      "mutated_line": "swaps.append(p(i + 2 * x, i - 2 * x + 1))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i - 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "swaps.append(p(i + 2 * x, i + 2 * x + 1))",
      "mutated_line": "swaps.append(p(i + 2 * x, i * (2 * x) + 1))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i * (2 * x) + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "swaps.append(p(i + 2 * x, i + 2 * x + 1))",
      "mutated_line": "swaps.append(p(i + 2 * x, i + 2 * x + 2))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 2))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "swaps.append(p(i + 2 * x, i + 2 * x + 1))",
      "mutated_line": "swaps.append(p(i + 2 * x, i + 2 * x + 0))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 0))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "swaps.append(p(i + 2 * x, i + 2 * x + 1))",
      "mutated_line": "swaps.append(p(i + 2 * x, i + 2 * x + 0))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 0))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "swaps.append(p(i + 2 * x, i + 2 * x + 1))",
      "mutated_line": "swaps.append(p(i + 2 * x, i + 2 * x + -1))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + -1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "swaps.append(p(j - 1, i + 2 * x + 1))",
      "mutated_line": "swaps.append(p(j + 1, i + 2 * x + 1))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j + 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "swaps.append(p(j - 1, i + 2 * x + 1))",
      "mutated_line": "swaps.append(p(j * 1, i + 2 * x + 1))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j * 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "swaps.append(p(j - 1, i + 2 * x + 1))",
      "mutated_line": "swaps.append(p(j - 1, i + 2 * x - 1))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x - 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "swaps.append(p(j - 1, i + 2 * x + 1))",
      "mutated_line": "swaps.append(p(j - 1, (i + 2 * x) * 1))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, (i + 2 * x) * 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "swaps.append(p(j, i + 2 * x))",
      "mutated_line": "swaps.append(p(j, i + 2 / x))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 / x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "swaps.append(p(j, i + 2 * x))",
      "mutated_line": "swaps.append(p(j, i + (2 + x)))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + (2 + x)))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "swaps.append(p(j, i + 2 * x))",
      "mutated_line": "swaps.append(p(j, i + 2 ** x))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 ** x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "swaps.append(p(i + 2 * x, i + 2 * x + 1))",
      "mutated_line": "swaps.append(p(i + 3 * x, i + 2 * x + 1))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 3 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "swaps.append(p(i + 2 * x, i + 2 * x + 1))",
      "mutated_line": "swaps.append(p(i + 1 * x, i + 2 * x + 1))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 1 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "swaps.append(p(i + 2 * x, i + 2 * x + 1))",
      "mutated_line": "swaps.append(p(i + 0 * x, i + 2 * x + 1))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 0 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "swaps.append(p(i + 2 * x, i + 2 * x + 1))",
      "mutated_line": "swaps.append(p(i + 1 * x, i + 2 * x + 1))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 1 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "swaps.append(p(i + 2 * x, i + 2 * x + 1))",
      "mutated_line": "swaps.append(p(i + -2 * x, i + 2 * x + 1))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + -2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "swaps.append(p(i + 2 * x, i + 2 * x + 1))",
      "mutated_line": "swaps.append(p(i + 2 * x, i + 2 / x + 1))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 / x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "swaps.append(p(i + 2 * x, i + 2 * x + 1))",
      "mutated_line": "swaps.append(p(i + 2 * x, i + (2 + x) + 1))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + (2 + x) + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "swaps.append(p(i + 2 * x, i + 2 * x + 1))",
      "mutated_line": "swaps.append(p(i + 2 * x, i + 2 ** x + 1))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 ** x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "swaps.append(p(j - 1, i + 2 * x + 1))",
      "mutated_line": "swaps.append(p(j - 2, i + 2 * x + 1))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 2, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "swaps.append(p(j - 1, i + 2 * x + 1))",
      "mutated_line": "swaps.append(p(j - 0, i + 2 * x + 1))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 0, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "swaps.append(p(j - 1, i + 2 * x + 1))",
      "mutated_line": "swaps.append(p(j - 0, i + 2 * x + 1))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 0, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "swaps.append(p(j - 1, i + 2 * x + 1))",
      "mutated_line": "swaps.append(p(j - -1, i + 2 * x + 1))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - -1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "swaps.append(p(j - 1, i + 2 * x + 1))",
      "mutated_line": "swaps.append(p(j - 1, i - 2 * x + 1))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i - 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "swaps.append(p(j - 1, i + 2 * x + 1))",
      "mutated_line": "swaps.append(p(j - 1, i * (2 * x) + 1))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i * (2 * x) + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "swaps.append(p(j - 1, i + 2 * x + 1))",
      "mutated_line": "swaps.append(p(j - 1, i + 2 * x + 2))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 2))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "swaps.append(p(j - 1, i + 2 * x + 1))",
      "mutated_line": "swaps.append(p(j - 1, i + 2 * x + 0))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 0))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "swaps.append(p(j - 1, i + 2 * x + 1))",
      "mutated_line": "swaps.append(p(j - 1, i + 2 * x + 0))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 0))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "swaps.append(p(j - 1, i + 2 * x + 1))",
      "mutated_line": "swaps.append(p(j - 1, i + 2 * x + -1))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + -1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "swaps.append(p(j, i + 2 * x))",
      "mutated_line": "swaps.append(p(j, i + 3 * x))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 3 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "swaps.append(p(j, i + 2 * x))",
      "mutated_line": "swaps.append(p(j, i + 1 * x))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 1 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "swaps.append(p(j, i + 2 * x))",
      "mutated_line": "swaps.append(p(j, i + 0 * x))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 0 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "swaps.append(p(j, i + 2 * x))",
      "mutated_line": "swaps.append(p(j, i + 1 * x))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 1 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "swaps.append(p(j, i + 2 * x))",
      "mutated_line": "swaps.append(p(j, i + -2 * x))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + -2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "swaps.append(p(i + 2 * x, i + 2 * x + 1))",
      "mutated_line": "swaps.append(p(i + 2 * x, i + 3 * x + 1))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 3 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "swaps.append(p(i + 2 * x, i + 2 * x + 1))",
      "mutated_line": "swaps.append(p(i + 2 * x, i + 1 * x + 1))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 1 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "swaps.append(p(i + 2 * x, i + 2 * x + 1))",
      "mutated_line": "swaps.append(p(i + 2 * x, i + 0 * x + 1))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 0 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "swaps.append(p(i + 2 * x, i + 2 * x + 1))",
      "mutated_line": "swaps.append(p(i + 2 * x, i + 1 * x + 1))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 1 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "swaps.append(p(i + 2 * x, i + 2 * x + 1))",
      "mutated_line": "swaps.append(p(i + 2 * x, i + -2 * x + 1))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + -2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "swaps.append(p(j - 1, i + 2 * x + 1))",
      "mutated_line": "swaps.append(p(j - 1, i + 2 / x + 1))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 / x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "swaps.append(p(j - 1, i + 2 * x + 1))",
      "mutated_line": "swaps.append(p(j - 1, i + (2 + x) + 1))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + (2 + x) + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "swaps.append(p(j - 1, i + 2 * x + 1))",
      "mutated_line": "swaps.append(p(j - 1, i + 2 ** x + 1))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 2 ** x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "swaps.append(p(j - 1, i + 2 * x + 1))",
      "mutated_line": "swaps.append(p(j - 1, i + 3 * x + 1))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 3 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "swaps.append(p(j - 1, i + 2 * x + 1))",
      "mutated_line": "swaps.append(p(j - 1, i + 1 * x + 1))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 1 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "swaps.append(p(j - 1, i + 2 * x + 1))",
      "mutated_line": "swaps.append(p(j - 1, i + 0 * x + 1))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 0 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "swaps.append(p(j - 1, i + 2 * x + 1))",
      "mutated_line": "swaps.append(p(j - 1, i + 1 * x + 1))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + 1 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "swaps.append(p(j - 1, i + 2 * x + 1))",
      "mutated_line": "swaps.append(p(j - 1, i + -2 * x + 1))",
      "code": "def can_maintain_permutation_with_swaps(n):\n\n    def p(a, b):\n        return (a + 1, b + 1)\n    if n % 4 > 1:\n        return 'NO'\n    swaps = []\n    for i in range(n % 4, n, 4):\n        for x in range(2):\n            for j in range(i):\n                swaps.append(p(j, i + 2 * x))\n            swaps.append(p(i + 2 * x, i + 2 * x + 1))\n            for j in range(i, 0, -1):\n                swaps.append(p(j - 1, i + -2 * x + 1))\n        swaps.append(p(i, i + 3))\n        swaps.append(p(i + 1, i + 2))\n        swaps.append(p(i, i + 2))\n        swaps.append(p(i + 1, i + 3))\n    return ('YES', swaps)"
    }
  ]
}