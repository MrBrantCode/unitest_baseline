{
  "task_id": "taco_5485",
  "entry_point": "max_distance_to_land",
  "mutant_count": 82,
  "mutants": [
    {
      "operator": "LCR",
      "lineno": 15,
      "original_line": "if len(queue) == 0 or len(queue) == n * n:",
      "mutated_line": "if len(queue) == 0 and len(queue) == n * n:",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, 0))\n    if len(queue) == 0 and len(queue) == n * n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < n and 0 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 1))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if len(queue) == 0 or len(queue) == n * n:",
      "mutated_line": "if len(queue) != 0 or len(queue) == n * n:",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, 0))\n    if len(queue) != 0 or len(queue) == n * n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < n and 0 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 1))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if len(queue) == 0 or len(queue) == n * n:",
      "mutated_line": "if len(queue) == 0 or len(queue) != n * n:",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, 0))\n    if len(queue) == 0 or len(queue) != n * n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < n and 0 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 1))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    },
    {
      "operator": "UOI",
      "lineno": 16,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, 0))\n    if len(queue) == 0 or len(queue) == n * n:\n        return +1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < n and 0 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 1))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if (i, j) not in dist:",
      "mutated_line": "dist[i, j] = d",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, 0))\n    if len(queue) == 0 or len(queue) == n * n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < n and 0 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 1))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if grid[i][j] == 1:",
      "mutated_line": "if grid[i][j] != 1:",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] != 1:\n                queue.append((i, j, 0))\n    if len(queue) == 0 or len(queue) == n * n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < n and 0 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 1))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if len(queue) == 0 or len(queue) == n * n:",
      "mutated_line": "if len(queue) == 1 or len(queue) == n * n:",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, 0))\n    if len(queue) == 1 or len(queue) == n * n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < n and 0 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 1))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if len(queue) == 0 or len(queue) == n * n:",
      "mutated_line": "if len(queue) == -1 or len(queue) == n * n:",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, 0))\n    if len(queue) == -1 or len(queue) == n * n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < n and 0 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 1))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if len(queue) == 0 or len(queue) == n * n:",
      "mutated_line": "if len(queue) == 1 or len(queue) == n * n:",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, 0))\n    if len(queue) == 1 or len(queue) == n * n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < n and 0 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 1))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if len(queue) == 0 or len(queue) == n * n:",
      "mutated_line": "if len(queue) == 0 or len(queue) == n / n:",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, 0))\n    if len(queue) == 0 or len(queue) == n / n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < n and 0 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 1))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if len(queue) == 0 or len(queue) == n * n:",
      "mutated_line": "if len(queue) == 0 or len(queue) == n + n:",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, 0))\n    if len(queue) == 0 or len(queue) == n + n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < n and 0 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 1))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if len(queue) == 0 or len(queue) == n * n:",
      "mutated_line": "if len(queue) == 0 or len(queue) == n ** n:",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, 0))\n    if len(queue) == 0 or len(queue) == n ** n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < n and 0 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 1))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, 0))\n    if len(queue) == 0 or len(queue) == n * n:\n        return -2\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < n and 0 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 1))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, 0))\n    if len(queue) == 0 or len(queue) == n * n:\n        return -0\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < n and 0 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 1))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, 0))\n    if len(queue) == 0 or len(queue) == n * n:\n        return -0\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < n and 0 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 1))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, 0))\n    if len(queue) == 0 or len(queue) == n * n:\n        return --1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < n and 0 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 1))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    },
    {
      "operator": "UOI",
      "lineno": 32,
      "original_line": "max_dist = max(dist.values(), default=-1)",
      "mutated_line": "max_dist = max(dist.values(), default=+1)",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, 0))\n    if len(queue) == 0 or len(queue) == n * n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < n and 0 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 1))\n    max_dist = max(dist.values(), default=+1)\n    return max_dist"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if grid[i][j] == 1:",
      "mutated_line": "if grid[i][j] == 2:",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 2:\n                queue.append((i, j, 0))\n    if len(queue) == 0 or len(queue) == n * n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < n and 0 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 1))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if grid[i][j] == 1:",
      "mutated_line": "if grid[i][j] == 0:",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 0:\n                queue.append((i, j, 0))\n    if len(queue) == 0 or len(queue) == n * n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < n and 0 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 1))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if grid[i][j] == 1:",
      "mutated_line": "if grid[i][j] == 0:",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 0:\n                queue.append((i, j, 0))\n    if len(queue) == 0 or len(queue) == n * n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < n and 0 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 1))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if grid[i][j] == 1:",
      "mutated_line": "if grid[i][j] == -1:",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == -1:\n                queue.append((i, j, 0))\n    if len(queue) == 0 or len(queue) == n * n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < n and 0 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 1))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    },
    {
      "operator": "LCR",
      "lineno": 28,
      "original_line": "if 0 <= ni < n and 0 <= nj < n and (ni, nj) not in dist:",
      "mutated_line": "if 0 <= ni < n or 0 <= nj < n or (ni, nj) not in dist:",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, 0))\n    if len(queue) == 0 or len(queue) == n * n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < n or 0 <= nj < n or (ni, nj) not in dist:\n                    queue.append((ni, nj, d + 1))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "max_dist = max(dist.values(), default=-1)",
      "mutated_line": "max_dist = max(dist.values(), default=-2)",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, 0))\n    if len(queue) == 0 or len(queue) == n * n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < n and 0 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 1))\n    max_dist = max(dist.values(), default=-2)\n    return max_dist"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "max_dist = max(dist.values(), default=-1)",
      "mutated_line": "max_dist = max(dist.values(), default=-0)",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, 0))\n    if len(queue) == 0 or len(queue) == n * n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < n and 0 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 1))\n    max_dist = max(dist.values(), default=-0)\n    return max_dist"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "max_dist = max(dist.values(), default=-1)",
      "mutated_line": "max_dist = max(dist.values(), default=-0)",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, 0))\n    if len(queue) == 0 or len(queue) == n * n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < n and 0 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 1))\n    max_dist = max(dist.values(), default=-0)\n    return max_dist"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "max_dist = max(dist.values(), default=-1)",
      "mutated_line": "max_dist = max(dist.values(), default=--1)",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, 0))\n    if len(queue) == 0 or len(queue) == n * n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < n and 0 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 1))\n    max_dist = max(dist.values(), default=--1)\n    return max_dist"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for di, dj in [(1, 0), (0, 1), (-1, 0), (0, -1)]:",
      "mutated_line": "for (di, dj) in [(2, 0), (0, 1), (-1, 0), (0, -1)]:",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, 0))\n    if len(queue) == 0 or len(queue) == n * n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(2, 0), (0, 1), (-1, 0), (0, -1)]:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < n and 0 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 1))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for di, dj in [(1, 0), (0, 1), (-1, 0), (0, -1)]:",
      "mutated_line": "for (di, dj) in [(0, 0), (0, 1), (-1, 0), (0, -1)]:",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, 0))\n    if len(queue) == 0 or len(queue) == n * n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(0, 0), (0, 1), (-1, 0), (0, -1)]:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < n and 0 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 1))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for di, dj in [(1, 0), (0, 1), (-1, 0), (0, -1)]:",
      "mutated_line": "for (di, dj) in [(0, 0), (0, 1), (-1, 0), (0, -1)]:",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, 0))\n    if len(queue) == 0 or len(queue) == n * n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(0, 0), (0, 1), (-1, 0), (0, -1)]:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < n and 0 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 1))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for di, dj in [(1, 0), (0, 1), (-1, 0), (0, -1)]:",
      "mutated_line": "for (di, dj) in [(-1, 0), (0, 1), (-1, 0), (0, -1)]:",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, 0))\n    if len(queue) == 0 or len(queue) == n * n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(-1, 0), (0, 1), (-1, 0), (0, -1)]:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < n and 0 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 1))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for di, dj in [(1, 0), (0, 1), (-1, 0), (0, -1)]:",
      "mutated_line": "for (di, dj) in [(1, 1), (0, 1), (-1, 0), (0, -1)]:",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, 0))\n    if len(queue) == 0 or len(queue) == n * n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 1), (0, 1), (-1, 0), (0, -1)]:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < n and 0 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 1))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for di, dj in [(1, 0), (0, 1), (-1, 0), (0, -1)]:",
      "mutated_line": "for (di, dj) in [(1, -1), (0, 1), (-1, 0), (0, -1)]:",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, 0))\n    if len(queue) == 0 or len(queue) == n * n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, -1), (0, 1), (-1, 0), (0, -1)]:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < n and 0 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 1))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for di, dj in [(1, 0), (0, 1), (-1, 0), (0, -1)]:",
      "mutated_line": "for (di, dj) in [(1, 1), (0, 1), (-1, 0), (0, -1)]:",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, 0))\n    if len(queue) == 0 or len(queue) == n * n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 1), (0, 1), (-1, 0), (0, -1)]:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < n and 0 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 1))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for di, dj in [(1, 0), (0, 1), (-1, 0), (0, -1)]:",
      "mutated_line": "for (di, dj) in [(1, 0), (1, 1), (-1, 0), (0, -1)]:",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, 0))\n    if len(queue) == 0 or len(queue) == n * n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 0), (1, 1), (-1, 0), (0, -1)]:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < n and 0 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 1))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for di, dj in [(1, 0), (0, 1), (-1, 0), (0, -1)]:",
      "mutated_line": "for (di, dj) in [(1, 0), (-1, 1), (-1, 0), (0, -1)]:",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, 0))\n    if len(queue) == 0 or len(queue) == n * n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 0), (-1, 1), (-1, 0), (0, -1)]:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < n and 0 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 1))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for di, dj in [(1, 0), (0, 1), (-1, 0), (0, -1)]:",
      "mutated_line": "for (di, dj) in [(1, 0), (1, 1), (-1, 0), (0, -1)]:",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, 0))\n    if len(queue) == 0 or len(queue) == n * n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 0), (1, 1), (-1, 0), (0, -1)]:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < n and 0 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 1))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for di, dj in [(1, 0), (0, 1), (-1, 0), (0, -1)]:",
      "mutated_line": "for (di, dj) in [(1, 0), (0, 2), (-1, 0), (0, -1)]:",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, 0))\n    if len(queue) == 0 or len(queue) == n * n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 0), (0, 2), (-1, 0), (0, -1)]:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < n and 0 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 1))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for di, dj in [(1, 0), (0, 1), (-1, 0), (0, -1)]:",
      "mutated_line": "for (di, dj) in [(1, 0), (0, 0), (-1, 0), (0, -1)]:",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, 0))\n    if len(queue) == 0 or len(queue) == n * n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 0), (0, 0), (-1, 0), (0, -1)]:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < n and 0 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 1))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for di, dj in [(1, 0), (0, 1), (-1, 0), (0, -1)]:",
      "mutated_line": "for (di, dj) in [(1, 0), (0, 0), (-1, 0), (0, -1)]:",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, 0))\n    if len(queue) == 0 or len(queue) == n * n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 0), (0, 0), (-1, 0), (0, -1)]:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < n and 0 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 1))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for di, dj in [(1, 0), (0, 1), (-1, 0), (0, -1)]:",
      "mutated_line": "for (di, dj) in [(1, 0), (0, -1), (-1, 0), (0, -1)]:",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, 0))\n    if len(queue) == 0 or len(queue) == n * n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 0), (0, -1), (-1, 0), (0, -1)]:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < n and 0 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 1))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    },
    {
      "operator": "UOI",
      "lineno": 26,
      "original_line": "for di, dj in [(1, 0), (0, 1), (-1, 0), (0, -1)]:",
      "mutated_line": "for (di, dj) in [(1, 0), (0, 1), (+1, 0), (0, -1)]:",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, 0))\n    if len(queue) == 0 or len(queue) == n * n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 0), (0, 1), (+1, 0), (0, -1)]:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < n and 0 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 1))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for di, dj in [(1, 0), (0, 1), (-1, 0), (0, -1)]:",
      "mutated_line": "for (di, dj) in [(1, 0), (0, 1), (-1, 1), (0, -1)]:",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, 0))\n    if len(queue) == 0 or len(queue) == n * n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 0), (0, 1), (-1, 1), (0, -1)]:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < n and 0 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 1))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for di, dj in [(1, 0), (0, 1), (-1, 0), (0, -1)]:",
      "mutated_line": "for (di, dj) in [(1, 0), (0, 1), (-1, -1), (0, -1)]:",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, 0))\n    if len(queue) == 0 or len(queue) == n * n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 0), (0, 1), (-1, -1), (0, -1)]:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < n and 0 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 1))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for di, dj in [(1, 0), (0, 1), (-1, 0), (0, -1)]:",
      "mutated_line": "for (di, dj) in [(1, 0), (0, 1), (-1, 1), (0, -1)]:",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, 0))\n    if len(queue) == 0 or len(queue) == n * n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 0), (0, 1), (-1, 1), (0, -1)]:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < n and 0 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 1))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for di, dj in [(1, 0), (0, 1), (-1, 0), (0, -1)]:",
      "mutated_line": "for (di, dj) in [(1, 0), (0, 1), (-1, 0), (1, -1)]:",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, 0))\n    if len(queue) == 0 or len(queue) == n * n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 0), (0, 1), (-1, 0), (1, -1)]:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < n and 0 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 1))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for di, dj in [(1, 0), (0, 1), (-1, 0), (0, -1)]:",
      "mutated_line": "for (di, dj) in [(1, 0), (0, 1), (-1, 0), (-1, -1)]:",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, 0))\n    if len(queue) == 0 or len(queue) == n * n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 0), (0, 1), (-1, 0), (-1, -1)]:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < n and 0 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 1))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for di, dj in [(1, 0), (0, 1), (-1, 0), (0, -1)]:",
      "mutated_line": "for (di, dj) in [(1, 0), (0, 1), (-1, 0), (1, -1)]:",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, 0))\n    if len(queue) == 0 or len(queue) == n * n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 0), (0, 1), (-1, 0), (1, -1)]:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < n and 0 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 1))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    },
    {
      "operator": "UOI",
      "lineno": 26,
      "original_line": "for di, dj in [(1, 0), (0, 1), (-1, 0), (0, -1)]:",
      "mutated_line": "for (di, dj) in [(1, 0), (0, 1), (-1, 0), (0, +1)]:",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, 0))\n    if len(queue) == 0 or len(queue) == n * n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 0), (0, 1), (-1, 0), (0, +1)]:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < n and 0 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 1))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "ni, nj = i + di, j + dj",
      "mutated_line": "(ni, nj) = (i - di, j + dj)",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, 0))\n    if len(queue) == 0 or len(queue) == n * n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n                (ni, nj) = (i - di, j + dj)\n                if 0 <= ni < n and 0 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 1))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "ni, nj = i + di, j + dj",
      "mutated_line": "(ni, nj) = (i * di, j + dj)",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, 0))\n    if len(queue) == 0 or len(queue) == n * n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n                (ni, nj) = (i * di, j + dj)\n                if 0 <= ni < n and 0 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 1))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "ni, nj = i + di, j + dj",
      "mutated_line": "(ni, nj) = (i + di, j - dj)",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, 0))\n    if len(queue) == 0 or len(queue) == n * n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n                (ni, nj) = (i + di, j - dj)\n                if 0 <= ni < n and 0 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 1))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "ni, nj = i + di, j + dj",
      "mutated_line": "(ni, nj) = (i + di, j * dj)",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, 0))\n    if len(queue) == 0 or len(queue) == n * n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n                (ni, nj) = (i + di, j * dj)\n                if 0 <= ni < n and 0 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 1))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if 0 <= ni < n and 0 <= nj < n and (ni, nj) not in dist:",
      "mutated_line": "if 0 < ni < n and 0 <= nj < n and ((ni, nj) not in dist):",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, 0))\n    if len(queue) == 0 or len(queue) == n * n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n                (ni, nj) = (i + di, j + dj)\n                if 0 < ni < n and 0 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 1))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if 0 <= ni < n and 0 <= nj < n and (ni, nj) not in dist:",
      "mutated_line": "if 0 > ni < n and 0 <= nj < n and ((ni, nj) not in dist):",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, 0))\n    if len(queue) == 0 or len(queue) == n * n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n                (ni, nj) = (i + di, j + dj)\n                if 0 > ni < n and 0 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 1))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if 0 <= ni < n and 0 <= nj < n and (ni, nj) not in dist:",
      "mutated_line": "if 0 == ni < n and 0 <= nj < n and ((ni, nj) not in dist):",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, 0))\n    if len(queue) == 0 or len(queue) == n * n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n                (ni, nj) = (i + di, j + dj)\n                if 0 == ni < n and 0 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 1))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if 0 <= ni < n and 0 <= nj < n and (ni, nj) not in dist:",
      "mutated_line": "if 0 <= ni < n and 0 < nj < n and ((ni, nj) not in dist):",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, 0))\n    if len(queue) == 0 or len(queue) == n * n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < n and 0 < nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 1))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if 0 <= ni < n and 0 <= nj < n and (ni, nj) not in dist:",
      "mutated_line": "if 0 <= ni < n and 0 > nj < n and ((ni, nj) not in dist):",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, 0))\n    if len(queue) == 0 or len(queue) == n * n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < n and 0 > nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 1))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if 0 <= ni < n and 0 <= nj < n and (ni, nj) not in dist:",
      "mutated_line": "if 0 <= ni < n and 0 == nj < n and ((ni, nj) not in dist):",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, 0))\n    if len(queue) == 0 or len(queue) == n * n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < n and 0 == nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 1))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if 0 <= ni < n and 0 <= nj < n and (ni, nj) not in dist:",
      "mutated_line": "if 0 <= ni < n and 0 <= nj < n and ((ni, nj) in dist):",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, 0))\n    if len(queue) == 0 or len(queue) == n * n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < n and 0 <= nj < n and ((ni, nj) in dist):\n                    queue.append((ni, nj, d + 1))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "queue.append((i, j, 0))  # (i, j) is the position, 0 is the initial distance",
      "mutated_line": "queue.append((i, j, 1))",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, 1))\n    if len(queue) == 0 or len(queue) == n * n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < n and 0 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 1))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "queue.append((i, j, 0))  # (i, j) is the position, 0 is the initial distance",
      "mutated_line": "queue.append((i, j, -1))",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, -1))\n    if len(queue) == 0 or len(queue) == n * n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < n and 0 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 1))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "queue.append((i, j, 0))  # (i, j) is the position, 0 is the initial distance",
      "mutated_line": "queue.append((i, j, 1))",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, 1))\n    if len(queue) == 0 or len(queue) == n * n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < n and 0 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 1))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for di, dj in [(1, 0), (0, 1), (-1, 0), (0, -1)]:",
      "mutated_line": "for (di, dj) in [(1, 0), (0, 1), (-2, 0), (0, -1)]:",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, 0))\n    if len(queue) == 0 or len(queue) == n * n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 0), (0, 1), (-2, 0), (0, -1)]:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < n and 0 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 1))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for di, dj in [(1, 0), (0, 1), (-1, 0), (0, -1)]:",
      "mutated_line": "for (di, dj) in [(1, 0), (0, 1), (-0, 0), (0, -1)]:",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, 0))\n    if len(queue) == 0 or len(queue) == n * n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 0), (0, 1), (-0, 0), (0, -1)]:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < n and 0 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 1))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for di, dj in [(1, 0), (0, 1), (-1, 0), (0, -1)]:",
      "mutated_line": "for (di, dj) in [(1, 0), (0, 1), (-0, 0), (0, -1)]:",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, 0))\n    if len(queue) == 0 or len(queue) == n * n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 0), (0, 1), (-0, 0), (0, -1)]:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < n and 0 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 1))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for di, dj in [(1, 0), (0, 1), (-1, 0), (0, -1)]:",
      "mutated_line": "for (di, dj) in [(1, 0), (0, 1), (--1, 0), (0, -1)]:",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, 0))\n    if len(queue) == 0 or len(queue) == n * n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 0), (0, 1), (--1, 0), (0, -1)]:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < n and 0 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 1))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for di, dj in [(1, 0), (0, 1), (-1, 0), (0, -1)]:",
      "mutated_line": "for (di, dj) in [(1, 0), (0, 1), (-1, 0), (0, -2)]:",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, 0))\n    if len(queue) == 0 or len(queue) == n * n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 0), (0, 1), (-1, 0), (0, -2)]:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < n and 0 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 1))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for di, dj in [(1, 0), (0, 1), (-1, 0), (0, -1)]:",
      "mutated_line": "for (di, dj) in [(1, 0), (0, 1), (-1, 0), (0, -0)]:",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, 0))\n    if len(queue) == 0 or len(queue) == n * n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 0), (0, 1), (-1, 0), (0, -0)]:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < n and 0 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 1))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for di, dj in [(1, 0), (0, 1), (-1, 0), (0, -1)]:",
      "mutated_line": "for (di, dj) in [(1, 0), (0, 1), (-1, 0), (0, -0)]:",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, 0))\n    if len(queue) == 0 or len(queue) == n * n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 0), (0, 1), (-1, 0), (0, -0)]:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < n and 0 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 1))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for di, dj in [(1, 0), (0, 1), (-1, 0), (0, -1)]:",
      "mutated_line": "for (di, dj) in [(1, 0), (0, 1), (-1, 0), (0, --1)]:",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, 0))\n    if len(queue) == 0 or len(queue) == n * n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 0), (0, 1), (-1, 0), (0, --1)]:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < n and 0 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 1))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if 0 <= ni < n and 0 <= nj < n and (ni, nj) not in dist:",
      "mutated_line": "if 1 <= ni < n and 0 <= nj < n and ((ni, nj) not in dist):",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, 0))\n    if len(queue) == 0 or len(queue) == n * n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n                (ni, nj) = (i + di, j + dj)\n                if 1 <= ni < n and 0 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 1))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if 0 <= ni < n and 0 <= nj < n and (ni, nj) not in dist:",
      "mutated_line": "if -1 <= ni < n and 0 <= nj < n and ((ni, nj) not in dist):",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, 0))\n    if len(queue) == 0 or len(queue) == n * n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n                (ni, nj) = (i + di, j + dj)\n                if -1 <= ni < n and 0 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 1))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if 0 <= ni < n and 0 <= nj < n and (ni, nj) not in dist:",
      "mutated_line": "if 1 <= ni < n and 0 <= nj < n and ((ni, nj) not in dist):",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, 0))\n    if len(queue) == 0 or len(queue) == n * n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n                (ni, nj) = (i + di, j + dj)\n                if 1 <= ni < n and 0 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 1))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if 0 <= ni < n and 0 <= nj < n and (ni, nj) not in dist:",
      "mutated_line": "if 0 <= ni < n and 1 <= nj < n and ((ni, nj) not in dist):",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, 0))\n    if len(queue) == 0 or len(queue) == n * n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < n and 1 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 1))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if 0 <= ni < n and 0 <= nj < n and (ni, nj) not in dist:",
      "mutated_line": "if 0 <= ni < n and -1 <= nj < n and ((ni, nj) not in dist):",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, 0))\n    if len(queue) == 0 or len(queue) == n * n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < n and -1 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 1))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if 0 <= ni < n and 0 <= nj < n and (ni, nj) not in dist:",
      "mutated_line": "if 0 <= ni < n and 1 <= nj < n and ((ni, nj) not in dist):",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, 0))\n    if len(queue) == 0 or len(queue) == n * n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < n and 1 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 1))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "queue.append((ni, nj, d + 1))",
      "mutated_line": "queue.append((ni, nj, d - 1))",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, 0))\n    if len(queue) == 0 or len(queue) == n * n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < n and 0 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d - 1))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "queue.append((ni, nj, d + 1))",
      "mutated_line": "queue.append((ni, nj, d * 1))",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, 0))\n    if len(queue) == 0 or len(queue) == n * n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < n and 0 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d * 1))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "queue.append((ni, nj, d + 1))",
      "mutated_line": "queue.append((ni, nj, d + 2))",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, 0))\n    if len(queue) == 0 or len(queue) == n * n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < n and 0 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 2))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "queue.append((ni, nj, d + 1))",
      "mutated_line": "queue.append((ni, nj, d + 0))",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, 0))\n    if len(queue) == 0 or len(queue) == n * n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < n and 0 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 0))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "queue.append((ni, nj, d + 1))",
      "mutated_line": "queue.append((ni, nj, d + 0))",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, 0))\n    if len(queue) == 0 or len(queue) == n * n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < n and 0 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + 0))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "queue.append((ni, nj, d + 1))",
      "mutated_line": "queue.append((ni, nj, d + -1))",
      "code": "from collections import deque\nfrom typing import List\n\ndef max_distance_to_land(grid: List[List[int]]) -> int:\n    queue = deque()\n    n = len(grid)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j, 0))\n    if len(queue) == 0 or len(queue) == n * n:\n        return -1\n    dist = {}\n    while queue:\n        (i, j, d) = queue.popleft()\n        if (i, j) not in dist:\n            dist[i, j] = d\n            for (di, dj) in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < n and 0 <= nj < n and ((ni, nj) not in dist):\n                    queue.append((ni, nj, d + -1))\n    max_dist = max(dist.values(), default=-1)\n    return max_dist"
    }
  ]
}