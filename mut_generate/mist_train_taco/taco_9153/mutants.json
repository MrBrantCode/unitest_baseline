{
  "task_id": "taco_9153",
  "entry_point": "calculate_minimum_radius",
  "mutant_count": 30,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 20,
      "original_line": "current_population += population",
      "mutated_line": "current_population -= population",
      "code": "import math\n\ndef calculate_minimum_radius(n, s, locations):\n    distances = []\n    for i in range(n):\n        (x, y, k) = locations[i]\n        distance = math.sqrt(x ** 2 + y ** 2)\n        distances.append((distance, k))\n    distances.sort()\n    current_population = s\n    for i in range(n):\n        (radius, population) = distances[i]\n        current_population -= population\n        if current_population >= 1000000:\n            return radius\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 25,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "import math\n\ndef calculate_minimum_radius(n, s, locations):\n    distances = []\n    for i in range(n):\n        (x, y, k) = locations[i]\n        distance = math.sqrt(x ** 2 + y ** 2)\n        distances.append((distance, k))\n    distances.sort()\n    current_population = s\n    for i in range(n):\n        (radius, population) = distances[i]\n        current_population += population\n        if current_population >= 1000000:\n            return radius\n    return +1"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if current_population >= 1000000:",
      "mutated_line": "if current_population > 1000000:",
      "code": "import math\n\ndef calculate_minimum_radius(n, s, locations):\n    distances = []\n    for i in range(n):\n        (x, y, k) = locations[i]\n        distance = math.sqrt(x ** 2 + y ** 2)\n        distances.append((distance, k))\n    distances.sort()\n    current_population = s\n    for i in range(n):\n        (radius, population) = distances[i]\n        current_population += population\n        if current_population > 1000000:\n            return radius\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if current_population >= 1000000:",
      "mutated_line": "if current_population < 1000000:",
      "code": "import math\n\ndef calculate_minimum_radius(n, s, locations):\n    distances = []\n    for i in range(n):\n        (x, y, k) = locations[i]\n        distance = math.sqrt(x ** 2 + y ** 2)\n        distances.append((distance, k))\n    distances.sort()\n    current_population = s\n    for i in range(n):\n        (radius, population) = distances[i]\n        current_population += population\n        if current_population < 1000000:\n            return radius\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if current_population >= 1000000:",
      "mutated_line": "if current_population == 1000000:",
      "code": "import math\n\ndef calculate_minimum_radius(n, s, locations):\n    distances = []\n    for i in range(n):\n        (x, y, k) = locations[i]\n        distance = math.sqrt(x ** 2 + y ** 2)\n        distances.append((distance, k))\n    distances.sort()\n    current_population = s\n    for i in range(n):\n        (radius, population) = distances[i]\n        current_population += population\n        if current_population == 1000000:\n            return radius\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "import math\n\ndef calculate_minimum_radius(n, s, locations):\n    distances = []\n    for i in range(n):\n        (x, y, k) = locations[i]\n        distance = math.sqrt(x ** 2 + y ** 2)\n        distances.append((distance, k))\n    distances.sort()\n    current_population = s\n    for i in range(n):\n        (radius, population) = distances[i]\n        current_population += population\n        if current_population >= 1000000:\n            return radius\n    return -2"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import math\n\ndef calculate_minimum_radius(n, s, locations):\n    distances = []\n    for i in range(n):\n        (x, y, k) = locations[i]\n        distance = math.sqrt(x ** 2 + y ** 2)\n        distances.append((distance, k))\n    distances.sort()\n    current_population = s\n    for i in range(n):\n        (radius, population) = distances[i]\n        current_population += population\n        if current_population >= 1000000:\n            return radius\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import math\n\ndef calculate_minimum_radius(n, s, locations):\n    distances = []\n    for i in range(n):\n        (x, y, k) = locations[i]\n        distance = math.sqrt(x ** 2 + y ** 2)\n        distances.append((distance, k))\n    distances.sort()\n    current_population = s\n    for i in range(n):\n        (radius, population) = distances[i]\n        current_population += population\n        if current_population >= 1000000:\n            return radius\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "import math\n\ndef calculate_minimum_radius(n, s, locations):\n    distances = []\n    for i in range(n):\n        (x, y, k) = locations[i]\n        distance = math.sqrt(x ** 2 + y ** 2)\n        distances.append((distance, k))\n    distances.sort()\n    current_population = s\n    for i in range(n):\n        (radius, population) = distances[i]\n        current_population += population\n        if current_population >= 1000000:\n            return radius\n    return --1"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "distance = math.sqrt(x ** 2 + y ** 2)",
      "mutated_line": "distance = math.sqrt(x ** 2 - y ** 2)",
      "code": "import math\n\ndef calculate_minimum_radius(n, s, locations):\n    distances = []\n    for i in range(n):\n        (x, y, k) = locations[i]\n        distance = math.sqrt(x ** 2 - y ** 2)\n        distances.append((distance, k))\n    distances.sort()\n    current_population = s\n    for i in range(n):\n        (radius, population) = distances[i]\n        current_population += population\n        if current_population >= 1000000:\n            return radius\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "distance = math.sqrt(x ** 2 + y ** 2)",
      "mutated_line": "distance = math.sqrt(x ** 2 * y ** 2)",
      "code": "import math\n\ndef calculate_minimum_radius(n, s, locations):\n    distances = []\n    for i in range(n):\n        (x, y, k) = locations[i]\n        distance = math.sqrt(x ** 2 * y ** 2)\n        distances.append((distance, k))\n    distances.sort()\n    current_population = s\n    for i in range(n):\n        (radius, population) = distances[i]\n        current_population += population\n        if current_population >= 1000000:\n            return radius\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if current_population >= 1000000:",
      "mutated_line": "if current_population >= 1000001:",
      "code": "import math\n\ndef calculate_minimum_radius(n, s, locations):\n    distances = []\n    for i in range(n):\n        (x, y, k) = locations[i]\n        distance = math.sqrt(x ** 2 + y ** 2)\n        distances.append((distance, k))\n    distances.sort()\n    current_population = s\n    for i in range(n):\n        (radius, population) = distances[i]\n        current_population += population\n        if current_population >= 1000001:\n            return radius\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if current_population >= 1000000:",
      "mutated_line": "if current_population >= 999999:",
      "code": "import math\n\ndef calculate_minimum_radius(n, s, locations):\n    distances = []\n    for i in range(n):\n        (x, y, k) = locations[i]\n        distance = math.sqrt(x ** 2 + y ** 2)\n        distances.append((distance, k))\n    distances.sort()\n    current_population = s\n    for i in range(n):\n        (radius, population) = distances[i]\n        current_population += population\n        if current_population >= 999999:\n            return radius\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if current_population >= 1000000:",
      "mutated_line": "if current_population >= 0:",
      "code": "import math\n\ndef calculate_minimum_radius(n, s, locations):\n    distances = []\n    for i in range(n):\n        (x, y, k) = locations[i]\n        distance = math.sqrt(x ** 2 + y ** 2)\n        distances.append((distance, k))\n    distances.sort()\n    current_population = s\n    for i in range(n):\n        (radius, population) = distances[i]\n        current_population += population\n        if current_population >= 0:\n            return radius\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if current_population >= 1000000:",
      "mutated_line": "if current_population >= 1:",
      "code": "import math\n\ndef calculate_minimum_radius(n, s, locations):\n    distances = []\n    for i in range(n):\n        (x, y, k) = locations[i]\n        distance = math.sqrt(x ** 2 + y ** 2)\n        distances.append((distance, k))\n    distances.sort()\n    current_population = s\n    for i in range(n):\n        (radius, population) = distances[i]\n        current_population += population\n        if current_population >= 1:\n            return radius\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if current_population >= 1000000:",
      "mutated_line": "if current_population >= -1000000:",
      "code": "import math\n\ndef calculate_minimum_radius(n, s, locations):\n    distances = []\n    for i in range(n):\n        (x, y, k) = locations[i]\n        distance = math.sqrt(x ** 2 + y ** 2)\n        distances.append((distance, k))\n    distances.sort()\n    current_population = s\n    for i in range(n):\n        (radius, population) = distances[i]\n        current_population += population\n        if current_population >= -1000000:\n            return radius\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "distance = math.sqrt(x ** 2 + y ** 2)",
      "mutated_line": "distance = math.sqrt(x * 2 + y ** 2)",
      "code": "import math\n\ndef calculate_minimum_radius(n, s, locations):\n    distances = []\n    for i in range(n):\n        (x, y, k) = locations[i]\n        distance = math.sqrt(x * 2 + y ** 2)\n        distances.append((distance, k))\n    distances.sort()\n    current_population = s\n    for i in range(n):\n        (radius, population) = distances[i]\n        current_population += population\n        if current_population >= 1000000:\n            return radius\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "distance = math.sqrt(x ** 2 + y ** 2)",
      "mutated_line": "distance = math.sqrt(x + 2 + y ** 2)",
      "code": "import math\n\ndef calculate_minimum_radius(n, s, locations):\n    distances = []\n    for i in range(n):\n        (x, y, k) = locations[i]\n        distance = math.sqrt(x + 2 + y ** 2)\n        distances.append((distance, k))\n    distances.sort()\n    current_population = s\n    for i in range(n):\n        (radius, population) = distances[i]\n        current_population += population\n        if current_population >= 1000000:\n            return radius\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "distance = math.sqrt(x ** 2 + y ** 2)",
      "mutated_line": "distance = math.sqrt(x ** 2 + y * 2)",
      "code": "import math\n\ndef calculate_minimum_radius(n, s, locations):\n    distances = []\n    for i in range(n):\n        (x, y, k) = locations[i]\n        distance = math.sqrt(x ** 2 + y * 2)\n        distances.append((distance, k))\n    distances.sort()\n    current_population = s\n    for i in range(n):\n        (radius, population) = distances[i]\n        current_population += population\n        if current_population >= 1000000:\n            return radius\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "distance = math.sqrt(x ** 2 + y ** 2)",
      "mutated_line": "distance = math.sqrt(x ** 2 + (y + 2))",
      "code": "import math\n\ndef calculate_minimum_radius(n, s, locations):\n    distances = []\n    for i in range(n):\n        (x, y, k) = locations[i]\n        distance = math.sqrt(x ** 2 + (y + 2))\n        distances.append((distance, k))\n    distances.sort()\n    current_population = s\n    for i in range(n):\n        (radius, population) = distances[i]\n        current_population += population\n        if current_population >= 1000000:\n            return radius\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "distance = math.sqrt(x ** 2 + y ** 2)",
      "mutated_line": "distance = math.sqrt(x ** 3 + y ** 2)",
      "code": "import math\n\ndef calculate_minimum_radius(n, s, locations):\n    distances = []\n    for i in range(n):\n        (x, y, k) = locations[i]\n        distance = math.sqrt(x ** 3 + y ** 2)\n        distances.append((distance, k))\n    distances.sort()\n    current_population = s\n    for i in range(n):\n        (radius, population) = distances[i]\n        current_population += population\n        if current_population >= 1000000:\n            return radius\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "distance = math.sqrt(x ** 2 + y ** 2)",
      "mutated_line": "distance = math.sqrt(x ** 1 + y ** 2)",
      "code": "import math\n\ndef calculate_minimum_radius(n, s, locations):\n    distances = []\n    for i in range(n):\n        (x, y, k) = locations[i]\n        distance = math.sqrt(x ** 1 + y ** 2)\n        distances.append((distance, k))\n    distances.sort()\n    current_population = s\n    for i in range(n):\n        (radius, population) = distances[i]\n        current_population += population\n        if current_population >= 1000000:\n            return radius\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "distance = math.sqrt(x ** 2 + y ** 2)",
      "mutated_line": "distance = math.sqrt(x ** 0 + y ** 2)",
      "code": "import math\n\ndef calculate_minimum_radius(n, s, locations):\n    distances = []\n    for i in range(n):\n        (x, y, k) = locations[i]\n        distance = math.sqrt(x ** 0 + y ** 2)\n        distances.append((distance, k))\n    distances.sort()\n    current_population = s\n    for i in range(n):\n        (radius, population) = distances[i]\n        current_population += population\n        if current_population >= 1000000:\n            return radius\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "distance = math.sqrt(x ** 2 + y ** 2)",
      "mutated_line": "distance = math.sqrt(x ** 1 + y ** 2)",
      "code": "import math\n\ndef calculate_minimum_radius(n, s, locations):\n    distances = []\n    for i in range(n):\n        (x, y, k) = locations[i]\n        distance = math.sqrt(x ** 1 + y ** 2)\n        distances.append((distance, k))\n    distances.sort()\n    current_population = s\n    for i in range(n):\n        (radius, population) = distances[i]\n        current_population += population\n        if current_population >= 1000000:\n            return radius\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "distance = math.sqrt(x ** 2 + y ** 2)",
      "mutated_line": "distance = math.sqrt(x ** -2 + y ** 2)",
      "code": "import math\n\ndef calculate_minimum_radius(n, s, locations):\n    distances = []\n    for i in range(n):\n        (x, y, k) = locations[i]\n        distance = math.sqrt(x ** -2 + y ** 2)\n        distances.append((distance, k))\n    distances.sort()\n    current_population = s\n    for i in range(n):\n        (radius, population) = distances[i]\n        current_population += population\n        if current_population >= 1000000:\n            return radius\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "distance = math.sqrt(x ** 2 + y ** 2)",
      "mutated_line": "distance = math.sqrt(x ** 2 + y ** 3)",
      "code": "import math\n\ndef calculate_minimum_radius(n, s, locations):\n    distances = []\n    for i in range(n):\n        (x, y, k) = locations[i]\n        distance = math.sqrt(x ** 2 + y ** 3)\n        distances.append((distance, k))\n    distances.sort()\n    current_population = s\n    for i in range(n):\n        (radius, population) = distances[i]\n        current_population += population\n        if current_population >= 1000000:\n            return radius\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "distance = math.sqrt(x ** 2 + y ** 2)",
      "mutated_line": "distance = math.sqrt(x ** 2 + y ** 1)",
      "code": "import math\n\ndef calculate_minimum_radius(n, s, locations):\n    distances = []\n    for i in range(n):\n        (x, y, k) = locations[i]\n        distance = math.sqrt(x ** 2 + y ** 1)\n        distances.append((distance, k))\n    distances.sort()\n    current_population = s\n    for i in range(n):\n        (radius, population) = distances[i]\n        current_population += population\n        if current_population >= 1000000:\n            return radius\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "distance = math.sqrt(x ** 2 + y ** 2)",
      "mutated_line": "distance = math.sqrt(x ** 2 + y ** 0)",
      "code": "import math\n\ndef calculate_minimum_radius(n, s, locations):\n    distances = []\n    for i in range(n):\n        (x, y, k) = locations[i]\n        distance = math.sqrt(x ** 2 + y ** 0)\n        distances.append((distance, k))\n    distances.sort()\n    current_population = s\n    for i in range(n):\n        (radius, population) = distances[i]\n        current_population += population\n        if current_population >= 1000000:\n            return radius\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "distance = math.sqrt(x ** 2 + y ** 2)",
      "mutated_line": "distance = math.sqrt(x ** 2 + y ** 1)",
      "code": "import math\n\ndef calculate_minimum_radius(n, s, locations):\n    distances = []\n    for i in range(n):\n        (x, y, k) = locations[i]\n        distance = math.sqrt(x ** 2 + y ** 1)\n        distances.append((distance, k))\n    distances.sort()\n    current_population = s\n    for i in range(n):\n        (radius, population) = distances[i]\n        current_population += population\n        if current_population >= 1000000:\n            return radius\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "distance = math.sqrt(x ** 2 + y ** 2)",
      "mutated_line": "distance = math.sqrt(x ** 2 + y ** -2)",
      "code": "import math\n\ndef calculate_minimum_radius(n, s, locations):\n    distances = []\n    for i in range(n):\n        (x, y, k) = locations[i]\n        distance = math.sqrt(x ** 2 + y ** -2)\n        distances.append((distance, k))\n    distances.sort()\n    current_population = s\n    for i in range(n):\n        (radius, population) = distances[i]\n        current_population += population\n        if current_population >= 1000000:\n            return radius\n    return -1"
    }
  ]
}