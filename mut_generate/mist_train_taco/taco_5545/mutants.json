{
  "task_id": "taco_5545",
  "entry_point": "count_special_coprime_numbers",
  "mutant_count": 146,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "digits = [0] * 20",
      "mutated_line": "digits = [0] / 20",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] / 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "digits = [0] * 20",
      "mutated_line": "digits = [0] + 20",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] + 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "digits = [0] * 20",
      "mutated_line": "digits = [0] ** 20",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] ** 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if pos == -1:",
      "mutated_line": "if pos != -1:",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos != -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 8,
      "original_line": "if not check and dp[pos][sumD][sumSq] != -1:",
      "mutated_line": "if not check or dp[pos][sumD][sumSq] != -1:",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check or dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 15,
      "original_line": "ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)",
      "mutated_line": "ans -= solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans -= solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if N == 0:",
      "mutated_line": "if N != 0:",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N != 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "length = 0",
      "mutated_line": "length = 1",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 1\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "length = 0",
      "mutated_line": "length = -1",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = -1\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "length = 0",
      "mutated_line": "length = 1",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 1\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 28,
      "original_line": "length += 1",
      "mutated_line": "length -= 1",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length -= 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "digits = [0] * 20",
      "mutated_line": "digits = [0] * 21",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 21\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "digits = [0] * 20",
      "mutated_line": "digits = [0] * 19",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 19\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "digits = [0] * 20",
      "mutated_line": "digits = [0] * 0",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 0\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "digits = [0] * 20",
      "mutated_line": "digits = [0] * 1",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 1\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "digits = [0] * 20",
      "mutated_line": "digits = [0] * -20",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * -20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "if pos == -1:",
      "mutated_line": "if pos == +1:",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == +1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if not check and dp[pos][sumD][sumSq] != -1:",
      "mutated_line": "if not check and dp[pos][sumD][sumSq] == -1:",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] == -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ans, endDig = 0, 0",
      "mutated_line": "(ans, endDig) = (1, 0)",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (1, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ans, endDig = 0, 0",
      "mutated_line": "(ans, endDig) = (-1, 0)",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (-1, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ans, endDig = 0, 0",
      "mutated_line": "(ans, endDig) = (1, 0)",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (1, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ans, endDig = 0, 0",
      "mutated_line": "(ans, endDig) = (0, 1)",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 1)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ans, endDig = 0, 0",
      "mutated_line": "(ans, endDig) = (0, -1)",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, -1)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ans, endDig = 0, 0",
      "mutated_line": "(ans, endDig) = (0, 1)",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 1)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "endDig = digits[pos] if check else 9",
      "mutated_line": "endDig = digits[pos] if check else 10",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 10\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "endDig = digits[pos] if check else 9",
      "mutated_line": "endDig = digits[pos] if check else 8",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 8\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "endDig = digits[pos] if check else 9",
      "mutated_line": "endDig = digits[pos] if check else 0",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 0\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "endDig = digits[pos] if check else 9",
      "mutated_line": "endDig = digits[pos] if check else 1",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 1\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "endDig = digits[pos] if check else 9",
      "mutated_line": "endDig = digits[pos] if check else -9",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else -9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for curDig in range(0, endDig + 1):",
      "mutated_line": "for curDig in range(1, endDig + 1):",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(1, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for curDig in range(0, endDig + 1):",
      "mutated_line": "for curDig in range(-1, endDig + 1):",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(-1, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for curDig in range(0, endDig + 1):",
      "mutated_line": "for curDig in range(1, endDig + 1):",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(1, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "for curDig in range(0, endDig + 1):",
      "mutated_line": "for curDig in range(0, endDig - 1):",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig - 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "for curDig in range(0, endDig + 1):",
      "mutated_line": "for curDig in range(0, endDig * 1):",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig * 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if N == 0:",
      "mutated_line": "if N == 1:",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 1:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if N == 0:",
      "mutated_line": "if N == -1:",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == -1:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if N == 0:",
      "mutated_line": "if N == 1:",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 1:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 1\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return -1\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 1\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "digits[length] = N % 10",
      "mutated_line": "digits[length] = N * 10",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N * 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "digits[length] = N % 10",
      "mutated_line": "digits[length] = N + 10",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N + 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "N //= 10",
      "mutated_line": "N //= 11",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 11\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "N //= 10",
      "mutated_line": "N //= 9",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 9\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "N //= 10",
      "mutated_line": "N //= 0",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 0\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "N //= 10",
      "mutated_line": "N //= 1",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 1\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "N //= 10",
      "mutated_line": "N //= -10",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= -10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "length += 1",
      "mutated_line": "length += 2",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 2\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "length += 1",
      "mutated_line": "length += 0",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 0\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "length += 1",
      "mutated_line": "length += 0",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 0\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "length += 1",
      "mutated_line": "length += -1",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += -1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return solveDP(length - 1, 0, 0, 1)",
      "mutated_line": "return solveDP(length + 1, 0, 0, 1)",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length + 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return solveDP(length - 1, 0, 0, 1)",
      "mutated_line": "return solveDP(length * 1, 0, 0, 1)",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length * 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return solveDP(length - 1, 0, 0, 1)",
      "mutated_line": "return solveDP(length - 1, 1, 0, 1)",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 1, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return solveDP(length - 1, 0, 0, 1)",
      "mutated_line": "return solveDP(length - 1, -1, 0, 1)",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, -1, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return solveDP(length - 1, 0, 0, 1)",
      "mutated_line": "return solveDP(length - 1, 1, 0, 1)",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 1, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return solveDP(length - 1, 0, 0, 1)",
      "mutated_line": "return solveDP(length - 1, 0, 1, 1)",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 1, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return solveDP(length - 1, 0, 0, 1)",
      "mutated_line": "return solveDP(length - 1, 0, -1, 1)",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, -1, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return solveDP(length - 1, 0, 0, 1)",
      "mutated_line": "return solveDP(length - 1, 0, 1, 1)",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 1, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return solveDP(length - 1, 0, 0, 1)",
      "mutated_line": "return solveDP(length - 1, 0, 0, 2)",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 2)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return solveDP(length - 1, 0, 0, 1)",
      "mutated_line": "return solveDP(length - 1, 0, 0, 0)",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 0)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return solveDP(length - 1, 0, 0, 1)",
      "mutated_line": "return solveDP(length - 1, 0, 0, 0)",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 0)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return solveDP(length - 1, 0, 0, 1)",
      "mutated_line": "return solveDP(length - 1, 0, 0, -1)",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, -1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]",
      "mutated_line": "dp = [[[-1] / 1500 for i in range(200)] for j in range(20)]",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] / 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]",
      "mutated_line": "dp = [[[-1] + 1500 for i in range(200)] for j in range(20)]",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] + 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]",
      "mutated_line": "dp = [[[-1] ** 1500 for i in range(200)] for j in range(20)]",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] ** 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "digits = [0] * 20",
      "mutated_line": "digits = [1] * 20",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [1] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "digits = [0] * 20",
      "mutated_line": "digits = [-1] * 20",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [-1] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "digits = [0] * 20",
      "mutated_line": "digits = [1] * 20",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [1] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "results.append(solve(r) - solve(l - 1))",
      "mutated_line": "results.append(solve(r) + solve(l - 1))",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) + solve(l - 1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "results.append(solve(r) - solve(l - 1))",
      "mutated_line": "results.append(solve(r) * solve(l - 1))",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) * solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if pos == -1:",
      "mutated_line": "if pos == -2:",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -2:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if pos == -1:",
      "mutated_line": "if pos == -0:",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -0:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if pos == -1:",
      "mutated_line": "if pos == -0:",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -0:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if pos == -1:",
      "mutated_line": "if pos == --1:",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == --1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "return 1 if gcd(sumD, sumSq) == 1 else 0",
      "mutated_line": "return 1 if gcd(sumD, sumSq) != 1 else 0",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) != 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return 1 if gcd(sumD, sumSq) == 1 else 0",
      "mutated_line": "return 2 if gcd(sumD, sumSq) == 1 else 0",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 2 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return 1 if gcd(sumD, sumSq) == 1 else 0",
      "mutated_line": "return 0 if gcd(sumD, sumSq) == 1 else 0",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 0 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return 1 if gcd(sumD, sumSq) == 1 else 0",
      "mutated_line": "return 0 if gcd(sumD, sumSq) == 1 else 0",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 0 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return 1 if gcd(sumD, sumSq) == 1 else 0",
      "mutated_line": "return -1 if gcd(sumD, sumSq) == 1 else 0",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return -1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return 1 if gcd(sumD, sumSq) == 1 else 0",
      "mutated_line": "return 1 if gcd(sumD, sumSq) == 1 else 1",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 1\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return 1 if gcd(sumD, sumSq) == 1 else 0",
      "mutated_line": "return 1 if gcd(sumD, sumSq) == 1 else -1",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else -1\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return 1 if gcd(sumD, sumSq) == 1 else 0",
      "mutated_line": "return 1 if gcd(sumD, sumSq) == 1 else 1",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 1\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 8,
      "original_line": "if not check and dp[pos][sumD][sumSq] != -1:",
      "mutated_line": "if not check and dp[pos][sumD][sumSq] != +1:",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != +1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for curDig in range(0, endDig + 1):",
      "mutated_line": "for curDig in range(0, endDig + 2):",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 2):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for curDig in range(0, endDig + 1):",
      "mutated_line": "for curDig in range(0, endDig + 0):",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 0):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for curDig in range(0, endDig + 1):",
      "mutated_line": "for curDig in range(0, endDig + 0):",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 0):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for curDig in range(0, endDig + 1):",
      "mutated_line": "for curDig in range(0, endDig + -1):",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + -1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)",
      "mutated_line": "ans += solveDP(pos + 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos + 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)",
      "mutated_line": "ans += solveDP(pos * 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos * 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)",
      "mutated_line": "ans += solveDP(pos - 1, sumD - curDig, sumSq + curDig * curDig, check and curDig == endDig)",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD - curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)",
      "mutated_line": "ans += solveDP(pos - 1, sumD * curDig, sumSq + curDig * curDig, check and curDig == endDig)",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD * curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)",
      "mutated_line": "ans += solveDP(pos - 1, sumD + curDig, sumSq - curDig * curDig, check and curDig == endDig)",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq - curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)",
      "mutated_line": "ans += solveDP(pos - 1, sumD + curDig, sumSq * (curDig * curDig), check and curDig == endDig)",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq * (curDig * curDig), check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 15,
      "original_line": "ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)",
      "mutated_line": "ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check or curDig == endDig)",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check or curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "digits[length] = N % 10",
      "mutated_line": "digits[length] = N % 11",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 11\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "digits[length] = N % 10",
      "mutated_line": "digits[length] = N % 9",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 9\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "digits[length] = N % 10",
      "mutated_line": "digits[length] = N % 0",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 0\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "digits[length] = N % 10",
      "mutated_line": "digits[length] = N % 1",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 1\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "digits[length] = N % 10",
      "mutated_line": "digits[length] = N % -10",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % -10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return solveDP(length - 1, 0, 0, 1)",
      "mutated_line": "return solveDP(length - 2, 0, 0, 1)",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 2, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return solveDP(length - 1, 0, 0, 1)",
      "mutated_line": "return solveDP(length - 0, 0, 0, 1)",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 0, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return solveDP(length - 1, 0, 0, 1)",
      "mutated_line": "return solveDP(length - 0, 0, 0, 1)",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 0, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return solveDP(length - 1, 0, 0, 1)",
      "mutated_line": "return solveDP(length - -1, 0, 0, 1)",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - -1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]",
      "mutated_line": "dp = [[[-1] * 1501 for i in range(200)] for j in range(20)]",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1501 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]",
      "mutated_line": "dp = [[[-1] * 1499 for i in range(200)] for j in range(20)]",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1499 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]",
      "mutated_line": "dp = [[[-1] * 0 for i in range(200)] for j in range(20)]",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 0 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]",
      "mutated_line": "dp = [[[-1] * 1 for i in range(200)] for j in range(20)]",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]",
      "mutated_line": "dp = [[[-1] * -1500 for i in range(200)] for j in range(20)]",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * -1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]",
      "mutated_line": "dp = [[[-1] * 1500 for i in range(200)] for j in range(21)]",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(21)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]",
      "mutated_line": "dp = [[[-1] * 1500 for i in range(200)] for j in range(19)]",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(19)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]",
      "mutated_line": "dp = [[[-1] * 1500 for i in range(200)] for j in range(0)]",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(0)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]",
      "mutated_line": "dp = [[[-1] * 1500 for i in range(200)] for j in range(1)]",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(1)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]",
      "mutated_line": "dp = [[[-1] * 1500 for i in range(200)] for j in range(-20)]",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(-20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return 1 if gcd(sumD, sumSq) == 1 else 0",
      "mutated_line": "return 1 if gcd(sumD, sumSq) == 2 else 0",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 2 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return 1 if gcd(sumD, sumSq) == 1 else 0",
      "mutated_line": "return 1 if gcd(sumD, sumSq) == 0 else 0",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 0 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return 1 if gcd(sumD, sumSq) == 1 else 0",
      "mutated_line": "return 1 if gcd(sumD, sumSq) == 0 else 0",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 0 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return 1 if gcd(sumD, sumSq) == 1 else 0",
      "mutated_line": "return 1 if gcd(sumD, sumSq) == -1 else 0",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == -1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if not check and dp[pos][sumD][sumSq] != -1:",
      "mutated_line": "if not check and dp[pos][sumD][sumSq] != -2:",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -2:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if not check and dp[pos][sumD][sumSq] != -1:",
      "mutated_line": "if not check and dp[pos][sumD][sumSq] != -0:",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -0:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if not check and dp[pos][sumD][sumSq] != -1:",
      "mutated_line": "if not check and dp[pos][sumD][sumSq] != -0:",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -0:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if not check and dp[pos][sumD][sumSq] != -1:",
      "mutated_line": "if not check and dp[pos][sumD][sumSq] != --1:",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != --1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)",
      "mutated_line": "ans += solveDP(pos - 2, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 2, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)",
      "mutated_line": "ans += solveDP(pos - 0, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 0, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)",
      "mutated_line": "ans += solveDP(pos - 0, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 0, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)",
      "mutated_line": "ans += solveDP(pos - -1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - -1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)",
      "mutated_line": "ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig / curDig, check and curDig == endDig)",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig / curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)",
      "mutated_line": "ans += solveDP(pos - 1, sumD + curDig, sumSq + (curDig + curDig), check and curDig == endDig)",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + (curDig + curDig), check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)",
      "mutated_line": "ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig ** curDig, check and curDig == endDig)",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig ** curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)",
      "mutated_line": "ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig != endDig)",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig != endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 32,
      "original_line": "dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]",
      "mutated_line": "dp = [[[+1] * 1500 for i in range(200)] for j in range(20)]",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[+1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]",
      "mutated_line": "dp = [[[-1] * 1500 for i in range(201)] for j in range(20)]",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(201)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]",
      "mutated_line": "dp = [[[-1] * 1500 for i in range(199)] for j in range(20)]",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(199)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]",
      "mutated_line": "dp = [[[-1] * 1500 for i in range(0)] for j in range(20)]",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(0)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]",
      "mutated_line": "dp = [[[-1] * 1500 for i in range(1)] for j in range(20)]",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(1)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]",
      "mutated_line": "dp = [[[-1] * 1500 for i in range(-200)] for j in range(20)]",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(-200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "results.append(solve(r) - solve(l - 1))",
      "mutated_line": "results.append(solve(r) - solve(l + 1))",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l + 1))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "results.append(solve(r) - solve(l - 1))",
      "mutated_line": "results.append(solve(r) - solve(l * 1))",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l * 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]",
      "mutated_line": "dp = [[[-2] * 1500 for i in range(200)] for j in range(20)]",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-2] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]",
      "mutated_line": "dp = [[[-0] * 1500 for i in range(200)] for j in range(20)]",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-0] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]",
      "mutated_line": "dp = [[[-0] * 1500 for i in range(200)] for j in range(20)]",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-0] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]",
      "mutated_line": "dp = [[[--1] * 1500 for i in range(200)] for j in range(20)]",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[--1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 1))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "results.append(solve(r) - solve(l - 1))",
      "mutated_line": "results.append(solve(r) - solve(l - 2))",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 2))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "results.append(solve(r) - solve(l - 1))",
      "mutated_line": "results.append(solve(r) - solve(l - 0))",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 0))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "results.append(solve(r) - solve(l - 1))",
      "mutated_line": "results.append(solve(r) - solve(l - 0))",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - 0))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "results.append(solve(r) - solve(l - 1))",
      "mutated_line": "results.append(solve(r) - solve(l - -1))",
      "code": "from math import gcd\n\ndef count_special_coprime_numbers(test_cases):\n\n    def solveDP(pos, sumD, sumSq, check):\n        if pos == -1:\n            return 1 if gcd(sumD, sumSq) == 1 else 0\n        if not check and dp[pos][sumD][sumSq] != -1:\n            return dp[pos][sumD][sumSq]\n        (ans, endDig) = (0, 0)\n        endDig = digits[pos] if check else 9\n        for curDig in range(0, endDig + 1):\n            ans += solveDP(pos - 1, sumD + curDig, sumSq + curDig * curDig, check and curDig == endDig)\n        if not check:\n            dp[pos][sumD][sumSq] = ans\n        return ans\n\n    def solve(N):\n        if N == 0:\n            return 0\n        length = 0\n        while N:\n            digits[length] = N % 10\n            N //= 10\n            length += 1\n        return solveDP(length - 1, 0, 0, 1)\n    results = []\n    dp = [[[-1] * 1500 for i in range(200)] for j in range(20)]\n    digits = [0] * 20\n    for (l, r) in test_cases:\n        results.append(solve(r) - solve(l - -1))\n    return results"
    }
  ]
}