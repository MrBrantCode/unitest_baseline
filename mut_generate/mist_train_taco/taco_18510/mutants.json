{
  "task_id": "taco_18510",
  "entry_point": "find_optimal_path_and_affected_roads",
  "mutant_count": 111,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "while q != -1:",
      "mutated_line": "while q == -1:",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q == -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "k = 0",
      "mutated_line": "k = 1",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 1\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "k = 0",
      "mutated_line": "k = -1",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = -1\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "k = 0",
      "mutated_line": "k = 1",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 1\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "pre = dijkstra(1, n)",
      "mutated_line": "pre = dijkstra(2, n)",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(2, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "pre = dijkstra(1, n)",
      "mutated_line": "pre = dijkstra(0, n)",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(0, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "pre = dijkstra(1, n)",
      "mutated_line": "pre = dijkstra(0, n)",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(0, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "pre = dijkstra(1, n)",
      "mutated_line": "pre = dijkstra(-1, n)",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(-1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "UOI",
      "lineno": 31,
      "original_line": "while q != -1:",
      "mutated_line": "while q != +1:",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != +1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "for i in range(len(path) - 1):",
      "mutated_line": "for i in range(len(path) + 1):",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) + 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "for i in range(len(path) - 1):",
      "mutated_line": "for i in range(len(path) * 1):",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) * 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "LCR",
      "lineno": 43,
      "original_line": "if ((s, e) in pairs or (e, s) in pairs) and f == 0:",
      "mutated_line": "if ((s, e) in pairs or (e, s) in pairs) or f == 0:",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) or f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "ASR",
      "lineno": 44,
      "original_line": "k += 1",
      "mutated_line": "k -= 1",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k -= 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "UOI",
      "lineno": 12,
      "original_line": "pre = [-1 for _ in range(n + 1)]",
      "mutated_line": "pre = [+1 for _ in range(n + 1)]",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [+1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "d[s] = (0, 0)",
      "mutated_line": "d[s] = (1, 0)",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (1, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "d[s] = (0, 0)",
      "mutated_line": "d[s] = (-1, 0)",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (-1, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "d[s] = (0, 0)",
      "mutated_line": "d[s] = (1, 0)",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (1, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "d[s] = (0, 0)",
      "mutated_line": "d[s] = (0, 1)",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 1)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "d[s] = (0, 0)",
      "mutated_line": "d[s] = (0, -1)",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, -1)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "d[s] = (0, 0)",
      "mutated_line": "d[s] = (0, 1)",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 1)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if d[p] < (dis, cost):",
      "mutated_line": "if d[p] <= (dis, cost):",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] <= (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if d[p] < (dis, cost):",
      "mutated_line": "if d[p] >= (dis, cost):",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] >= (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if d[p] < (dis, cost):",
      "mutated_line": "if d[p] != (dis, cost):",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] != (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "while q != -1:",
      "mutated_line": "while q != -2:",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -2:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "while q != -1:",
      "mutated_line": "while q != -0:",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -0:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "while q != -1:",
      "mutated_line": "while q != -0:",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -0:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "while q != -1:",
      "mutated_line": "while q != --1:",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != --1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for i in range(len(path) - 1):",
      "mutated_line": "for i in range(len(path) - 2):",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 2):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for i in range(len(path) - 1):",
      "mutated_line": "for i in range(len(path) - 0):",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 0):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for i in range(len(path) - 1):",
      "mutated_line": "for i in range(len(path) - 0):",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 0):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for i in range(len(path) - 1):",
      "mutated_line": "for i in range(len(path) - -1):",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - -1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "LCR",
      "lineno": 43,
      "original_line": "if ((s, e) in pairs or (e, s) in pairs) and f == 0:",
      "mutated_line": "if ((s, e) in pairs and (e, s) in pairs) and f == 0:",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs and (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if ((s, e) in pairs or (e, s) in pairs) and f == 0:",
      "mutated_line": "if ((s, e) in pairs or (e, s) in pairs) and f != 0:",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f != 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "k += 1",
      "mutated_line": "k += 2",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 2\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "k += 1",
      "mutated_line": "k += 0",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 0\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "k += 1",
      "mutated_line": "k += 0",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 0\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "k += 1",
      "mutated_line": "k += -1",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += -1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "LCR",
      "lineno": 46,
      "original_line": "elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:",
      "mutated_line": "elif (s, e) not in pairs and (e, s) not in pairs or f == 1:",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif (s, e) not in pairs and (e, s) not in pairs or f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "ASR",
      "lineno": 47,
      "original_line": "k += 1",
      "mutated_line": "k -= 1",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k -= 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "pre = [-1 for _ in range(n + 1)]",
      "mutated_line": "pre = [-2 for _ in range(n + 1)]",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-2 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "pre = [-1 for _ in range(n + 1)]",
      "mutated_line": "pre = [-0 for _ in range(n + 1)]",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-0 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "pre = [-1 for _ in range(n + 1)]",
      "mutated_line": "pre = [-0 for _ in range(n + 1)]",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-0 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "pre = [-1 for _ in range(n + 1)]",
      "mutated_line": "pre = [--1 for _ in range(n + 1)]",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [--1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "hq = [(0, 0, s)]",
      "mutated_line": "hq = [(1, 0, s)]",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(1, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "hq = [(0, 0, s)]",
      "mutated_line": "hq = [(-1, 0, s)]",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(-1, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "hq = [(0, 0, s)]",
      "mutated_line": "hq = [(1, 0, s)]",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(1, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "hq = [(0, 0, s)]",
      "mutated_line": "hq = [(0, 1, s)]",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 1, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "hq = [(0, 0, s)]",
      "mutated_line": "hq = [(0, -1, s)]",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, -1, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "hq = [(0, 0, s)]",
      "mutated_line": "hq = [(0, 1, s)]",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 1, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "cost_e = cost + (1 if not f else 0)",
      "mutated_line": "cost_e = cost - (1 if not f else 0)",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost - (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "cost_e = cost + (1 if not f else 0)",
      "mutated_line": "cost_e = cost * (1 if not f else 0)",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost * (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "dis_e = dis + 1",
      "mutated_line": "dis_e = dis - 1",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis - 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "dis_e = dis + 1",
      "mutated_line": "dis_e = dis * 1",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis * 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if (dis_e, cost_e) < d[e]:",
      "mutated_line": "if (dis_e, cost_e) <= d[e]:",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) <= d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if (dis_e, cost_e) < d[e]:",
      "mutated_line": "if (dis_e, cost_e) >= d[e]:",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) >= d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if (dis_e, cost_e) < d[e]:",
      "mutated_line": "if (dis_e, cost_e) != d[e]:",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) != d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if ((s, e) in pairs or (e, s) in pairs) and f == 0:",
      "mutated_line": "if ((s, e) not in pairs or (e, s) in pairs) and f == 0:",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) not in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if ((s, e) in pairs or (e, s) in pairs) and f == 0:",
      "mutated_line": "if ((s, e) in pairs or (e, s) not in pairs) and f == 0:",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) not in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if ((s, e) in pairs or (e, s) in pairs) and f == 0:",
      "mutated_line": "if ((s, e) in pairs or (e, s) in pairs) and f == 1:",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if ((s, e) in pairs or (e, s) in pairs) and f == 0:",
      "mutated_line": "if ((s, e) in pairs or (e, s) in pairs) and f == -1:",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == -1:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if ((s, e) in pairs or (e, s) in pairs) and f == 0:",
      "mutated_line": "if ((s, e) in pairs or (e, s) in pairs) and f == 1:",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "LCR",
      "lineno": 46,
      "original_line": "elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:",
      "mutated_line": "elif ((s, e) not in pairs or (e, s) not in pairs) and f == 1:",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs or (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:",
      "mutated_line": "elif ((s, e) not in pairs and (e, s) not in pairs) and f != 1:",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f != 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "k += 1",
      "mutated_line": "k += 2",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 2\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "k += 1",
      "mutated_line": "k += 0",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 0\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "k += 1",
      "mutated_line": "k += 0",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 0\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "k += 1",
      "mutated_line": "k += -1",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += -1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "d = [(float('inf'), float('inf')) for _ in range(n + 1)]",
      "mutated_line": "d = [(float(''), float('inf')) for _ in range(n + 1)]",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float(''), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "d = [(float('inf'), float('inf')) for _ in range(n + 1)]",
      "mutated_line": "d = [(float('inf'), float('')) for _ in range(n + 1)]",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "d = [(float('inf'), float('inf')) for _ in range(n + 1)]",
      "mutated_line": "d = [(float('inf'), float('inf')) for _ in range(n - 1)]",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n - 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "d = [(float('inf'), float('inf')) for _ in range(n + 1)]",
      "mutated_line": "d = [(float('inf'), float('inf')) for _ in range(n * 1)]",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n * 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "pre = [-1 for _ in range(n + 1)]",
      "mutated_line": "pre = [-1 for _ in range(n - 1)]",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n - 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "pre = [-1 for _ in range(n + 1)]",
      "mutated_line": "pre = [-1 for _ in range(n * 1)]",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n * 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dis_e = dis + 1",
      "mutated_line": "dis_e = dis + 2",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 2\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dis_e = dis + 1",
      "mutated_line": "dis_e = dis + 0",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 0\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dis_e = dis + 1",
      "mutated_line": "dis_e = dis + 0",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 0\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dis_e = dis + 1",
      "mutated_line": "dis_e = dis + -1",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + -1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "pairs.add((path[i], path[i + 1]))",
      "mutated_line": "pairs.add((path[i], path[i - 1]))",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i - 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "pairs.add((path[i], path[i + 1]))",
      "mutated_line": "pairs.add((path[i], path[i * 1]))",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i * 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "affected_roads.append((s, e, 1))",
      "mutated_line": "affected_roads.append((s, e, 2))",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 2))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "affected_roads.append((s, e, 1))",
      "mutated_line": "affected_roads.append((s, e, 0))",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 0))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "affected_roads.append((s, e, 1))",
      "mutated_line": "affected_roads.append((s, e, 0))",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 0))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "affected_roads.append((s, e, 1))",
      "mutated_line": "affected_roads.append((s, e, -1))",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, -1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:",
      "mutated_line": "elif ((s, e) in pairs and (e, s) not in pairs) and f == 1:",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:",
      "mutated_line": "elif ((s, e) not in pairs and (e, s) in pairs) and f == 1:",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:",
      "mutated_line": "elif ((s, e) not in pairs and (e, s) not in pairs) and f == 2:",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 2:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:",
      "mutated_line": "elif ((s, e) not in pairs and (e, s) not in pairs) and f == 0:",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:",
      "mutated_line": "elif ((s, e) not in pairs and (e, s) not in pairs) and f == 0:",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:",
      "mutated_line": "elif ((s, e) not in pairs and (e, s) not in pairs) and f == -1:",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == -1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "d = [(float('inf'), float('inf')) for _ in range(n + 1)]",
      "mutated_line": "d = [(float('inf'), float('inf')) for _ in range(n + 2)]",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 2)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "d = [(float('inf'), float('inf')) for _ in range(n + 1)]",
      "mutated_line": "d = [(float('inf'), float('inf')) for _ in range(n + 0)]",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 0)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "d = [(float('inf'), float('inf')) for _ in range(n + 1)]",
      "mutated_line": "d = [(float('inf'), float('inf')) for _ in range(n + 0)]",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 0)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "d = [(float('inf'), float('inf')) for _ in range(n + 1)]",
      "mutated_line": "d = [(float('inf'), float('inf')) for _ in range(n + -1)]",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + -1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "pre = [-1 for _ in range(n + 1)]",
      "mutated_line": "pre = [-1 for _ in range(n + 2)]",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 2)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "pre = [-1 for _ in range(n + 1)]",
      "mutated_line": "pre = [-1 for _ in range(n + 0)]",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 0)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "pre = [-1 for _ in range(n + 1)]",
      "mutated_line": "pre = [-1 for _ in range(n + 0)]",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 0)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "pre = [-1 for _ in range(n + 1)]",
      "mutated_line": "pre = [-1 for _ in range(n + -1)]",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + -1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "cost_e = cost + (1 if not f else 0)",
      "mutated_line": "cost_e = cost + (2 if not f else 0)",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (2 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "cost_e = cost + (1 if not f else 0)",
      "mutated_line": "cost_e = cost + (0 if not f else 0)",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (0 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "cost_e = cost + (1 if not f else 0)",
      "mutated_line": "cost_e = cost + (0 if not f else 0)",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (0 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "cost_e = cost + (1 if not f else 0)",
      "mutated_line": "cost_e = cost + (-1 if not f else 0)",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (-1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "cost_e = cost + (1 if not f else 0)",
      "mutated_line": "cost_e = cost + (1 if not f else 1)",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 1)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "cost_e = cost + (1 if not f else 0)",
      "mutated_line": "cost_e = cost + (1 if not f else -1)",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else -1)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "cost_e = cost + (1 if not f else 0)",
      "mutated_line": "cost_e = cost + (1 if not f else 1)",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 1)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "pairs.add((path[i], path[i + 1]))",
      "mutated_line": "pairs.add((path[i], path[i + 2]))",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 2]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "pairs.add((path[i], path[i + 1]))",
      "mutated_line": "pairs.add((path[i], path[i + 0]))",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 0]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "pairs.add((path[i], path[i + 1]))",
      "mutated_line": "pairs.add((path[i], path[i + 0]))",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 0]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "pairs.add((path[i], path[i + 1]))",
      "mutated_line": "pairs.add((path[i], path[i + -1]))",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + -1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 0))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "affected_roads.append((s, e, 0))",
      "mutated_line": "affected_roads.append((s, e, 1))",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 1))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "affected_roads.append((s, e, 0))",
      "mutated_line": "affected_roads.append((s, e, -1))",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, -1))\n    return (k, affected_roads)"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "affected_roads.append((s, e, 0))",
      "mutated_line": "affected_roads.append((s, e, 1))",
      "code": "import collections\nimport heapq\n\ndef find_optimal_path_and_affected_roads(n, m, roads):\n    G = collections.defaultdict(list)\n    for (s, e, f) in roads:\n        G[s].append((e, f))\n        G[e].append((s, f))\n\n    def dijkstra(s, e):\n        d = [(float('inf'), float('inf')) for _ in range(n + 1)]\n        pre = [-1 for _ in range(n + 1)]\n        d[s] = (0, 0)\n        hq = [(0, 0, s)]\n        while hq:\n            (dis, cost, p) = heapq.heappop(hq)\n            if d[p] < (dis, cost):\n                continue\n            for (e, f) in G[p]:\n                cost_e = cost + (1 if not f else 0)\n                dis_e = dis + 1\n                if (dis_e, cost_e) < d[e]:\n                    d[e] = (dis_e, cost_e)\n                    pre[e] = p\n                    heapq.heappush(hq, (dis_e, cost_e, e))\n        return pre\n    pre = dijkstra(1, n)\n    q = n\n    path = []\n    while q != -1:\n        path.append(q)\n        q = pre[q]\n    path.reverse()\n    pairs = set()\n    for i in range(len(path) - 1):\n        pairs.add((path[i], path[i + 1]))\n    k = 0\n    affected_roads = []\n    for (s, e, f) in roads:\n        if ((s, e) in pairs or (e, s) in pairs) and f == 0:\n            k += 1\n            affected_roads.append((s, e, 1))\n        elif ((s, e) not in pairs and (e, s) not in pairs) and f == 1:\n            k += 1\n            affected_roads.append((s, e, 1))\n    return (k, affected_roads)"
    }
  ]
}