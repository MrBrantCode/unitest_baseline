{
  "task_id": "taco_12351",
  "entry_point": "max_candies",
  "mutant_count": 36,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "reachable = [False] * len(status)",
      "mutated_line": "reachable = [False] / len(status)",
      "code": "def max_candies(status, candies, keys, containedBoxes, initialBoxes):\n    reachable = [False] / len(status)\n    visited = [False] * len(status)\n    for box in initialBoxes:\n        reachable[box] = True\n    for i in range(len(containedBoxes)):\n        for inside in containedBoxes[i]:\n            reachable[inside] = False\n    queue = initialBoxes\n    target = []\n    ret = 0\n    while queue:\n        for box in queue:\n            if status[box] == 1 and reachable[box] and (not visited[box]):\n                ret += candies[box]\n                visited[box] = True\n                for key in keys[box]:\n                    if status[key] == 0:\n                        status[key] = 1\n                        if reachable[key]:\n                            target.append(key)\n                for inside in containedBoxes[box]:\n                    reachable[inside] = True\n                    if status[inside] == 1:\n                        target.append(inside)\n            else:\n                target.append(box)\n        if target == queue:\n            break\n        queue = target\n        target = []\n    return ret"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "reachable = [False] * len(status)",
      "mutated_line": "reachable = [False] + len(status)",
      "code": "def max_candies(status, candies, keys, containedBoxes, initialBoxes):\n    reachable = [False] + len(status)\n    visited = [False] * len(status)\n    for box in initialBoxes:\n        reachable[box] = True\n    for i in range(len(containedBoxes)):\n        for inside in containedBoxes[i]:\n            reachable[inside] = False\n    queue = initialBoxes\n    target = []\n    ret = 0\n    while queue:\n        for box in queue:\n            if status[box] == 1 and reachable[box] and (not visited[box]):\n                ret += candies[box]\n                visited[box] = True\n                for key in keys[box]:\n                    if status[key] == 0:\n                        status[key] = 1\n                        if reachable[key]:\n                            target.append(key)\n                for inside in containedBoxes[box]:\n                    reachable[inside] = True\n                    if status[inside] == 1:\n                        target.append(inside)\n            else:\n                target.append(box)\n        if target == queue:\n            break\n        queue = target\n        target = []\n    return ret"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "reachable = [False] * len(status)",
      "mutated_line": "reachable = [False] ** len(status)",
      "code": "def max_candies(status, candies, keys, containedBoxes, initialBoxes):\n    reachable = [False] ** len(status)\n    visited = [False] * len(status)\n    for box in initialBoxes:\n        reachable[box] = True\n    for i in range(len(containedBoxes)):\n        for inside in containedBoxes[i]:\n            reachable[inside] = False\n    queue = initialBoxes\n    target = []\n    ret = 0\n    while queue:\n        for box in queue:\n            if status[box] == 1 and reachable[box] and (not visited[box]):\n                ret += candies[box]\n                visited[box] = True\n                for key in keys[box]:\n                    if status[key] == 0:\n                        status[key] = 1\n                        if reachable[key]:\n                            target.append(key)\n                for inside in containedBoxes[box]:\n                    reachable[inside] = True\n                    if status[inside] == 1:\n                        target.append(inside)\n            else:\n                target.append(box)\n        if target == queue:\n            break\n        queue = target\n        target = []\n    return ret"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "visited = [False] * len(status)",
      "mutated_line": "visited = [False] / len(status)",
      "code": "def max_candies(status, candies, keys, containedBoxes, initialBoxes):\n    reachable = [False] * len(status)\n    visited = [False] / len(status)\n    for box in initialBoxes:\n        reachable[box] = True\n    for i in range(len(containedBoxes)):\n        for inside in containedBoxes[i]:\n            reachable[inside] = False\n    queue = initialBoxes\n    target = []\n    ret = 0\n    while queue:\n        for box in queue:\n            if status[box] == 1 and reachable[box] and (not visited[box]):\n                ret += candies[box]\n                visited[box] = True\n                for key in keys[box]:\n                    if status[key] == 0:\n                        status[key] = 1\n                        if reachable[key]:\n                            target.append(key)\n                for inside in containedBoxes[box]:\n                    reachable[inside] = True\n                    if status[inside] == 1:\n                        target.append(inside)\n            else:\n                target.append(box)\n        if target == queue:\n            break\n        queue = target\n        target = []\n    return ret"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "visited = [False] * len(status)",
      "mutated_line": "visited = [False] + len(status)",
      "code": "def max_candies(status, candies, keys, containedBoxes, initialBoxes):\n    reachable = [False] * len(status)\n    visited = [False] + len(status)\n    for box in initialBoxes:\n        reachable[box] = True\n    for i in range(len(containedBoxes)):\n        for inside in containedBoxes[i]:\n            reachable[inside] = False\n    queue = initialBoxes\n    target = []\n    ret = 0\n    while queue:\n        for box in queue:\n            if status[box] == 1 and reachable[box] and (not visited[box]):\n                ret += candies[box]\n                visited[box] = True\n                for key in keys[box]:\n                    if status[key] == 0:\n                        status[key] = 1\n                        if reachable[key]:\n                            target.append(key)\n                for inside in containedBoxes[box]:\n                    reachable[inside] = True\n                    if status[inside] == 1:\n                        target.append(inside)\n            else:\n                target.append(box)\n        if target == queue:\n            break\n        queue = target\n        target = []\n    return ret"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "visited = [False] * len(status)",
      "mutated_line": "visited = [False] ** len(status)",
      "code": "def max_candies(status, candies, keys, containedBoxes, initialBoxes):\n    reachable = [False] * len(status)\n    visited = [False] ** len(status)\n    for box in initialBoxes:\n        reachable[box] = True\n    for i in range(len(containedBoxes)):\n        for inside in containedBoxes[i]:\n            reachable[inside] = False\n    queue = initialBoxes\n    target = []\n    ret = 0\n    while queue:\n        for box in queue:\n            if status[box] == 1 and reachable[box] and (not visited[box]):\n                ret += candies[box]\n                visited[box] = True\n                for key in keys[box]:\n                    if status[key] == 0:\n                        status[key] = 1\n                        if reachable[key]:\n                            target.append(key)\n                for inside in containedBoxes[box]:\n                    reachable[inside] = True\n                    if status[inside] == 1:\n                        target.append(inside)\n            else:\n                target.append(box)\n        if target == queue:\n            break\n        queue = target\n        target = []\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ret = 0",
      "mutated_line": "ret = 1",
      "code": "def max_candies(status, candies, keys, containedBoxes, initialBoxes):\n    reachable = [False] * len(status)\n    visited = [False] * len(status)\n    for box in initialBoxes:\n        reachable[box] = True\n    for i in range(len(containedBoxes)):\n        for inside in containedBoxes[i]:\n            reachable[inside] = False\n    queue = initialBoxes\n    target = []\n    ret = 1\n    while queue:\n        for box in queue:\n            if status[box] == 1 and reachable[box] and (not visited[box]):\n                ret += candies[box]\n                visited[box] = True\n                for key in keys[box]:\n                    if status[key] == 0:\n                        status[key] = 1\n                        if reachable[key]:\n                            target.append(key)\n                for inside in containedBoxes[box]:\n                    reachable[inside] = True\n                    if status[inside] == 1:\n                        target.append(inside)\n            else:\n                target.append(box)\n        if target == queue:\n            break\n        queue = target\n        target = []\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ret = 0",
      "mutated_line": "ret = -1",
      "code": "def max_candies(status, candies, keys, containedBoxes, initialBoxes):\n    reachable = [False] * len(status)\n    visited = [False] * len(status)\n    for box in initialBoxes:\n        reachable[box] = True\n    for i in range(len(containedBoxes)):\n        for inside in containedBoxes[i]:\n            reachable[inside] = False\n    queue = initialBoxes\n    target = []\n    ret = -1\n    while queue:\n        for box in queue:\n            if status[box] == 1 and reachable[box] and (not visited[box]):\n                ret += candies[box]\n                visited[box] = True\n                for key in keys[box]:\n                    if status[key] == 0:\n                        status[key] = 1\n                        if reachable[key]:\n                            target.append(key)\n                for inside in containedBoxes[box]:\n                    reachable[inside] = True\n                    if status[inside] == 1:\n                        target.append(inside)\n            else:\n                target.append(box)\n        if target == queue:\n            break\n        queue = target\n        target = []\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ret = 0",
      "mutated_line": "ret = 1",
      "code": "def max_candies(status, candies, keys, containedBoxes, initialBoxes):\n    reachable = [False] * len(status)\n    visited = [False] * len(status)\n    for box in initialBoxes:\n        reachable[box] = True\n    for i in range(len(containedBoxes)):\n        for inside in containedBoxes[i]:\n            reachable[inside] = False\n    queue = initialBoxes\n    target = []\n    ret = 1\n    while queue:\n        for box in queue:\n            if status[box] == 1 and reachable[box] and (not visited[box]):\n                ret += candies[box]\n                visited[box] = True\n                for key in keys[box]:\n                    if status[key] == 0:\n                        status[key] = 1\n                        if reachable[key]:\n                            target.append(key)\n                for inside in containedBoxes[box]:\n                    reachable[inside] = True\n                    if status[inside] == 1:\n                        target.append(inside)\n            else:\n                target.append(box)\n        if target == queue:\n            break\n        queue = target\n        target = []\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "reachable[box] = True",
      "mutated_line": "reachable[box] = False",
      "code": "def max_candies(status, candies, keys, containedBoxes, initialBoxes):\n    reachable = [False] * len(status)\n    visited = [False] * len(status)\n    for box in initialBoxes:\n        reachable[box] = False\n    for i in range(len(containedBoxes)):\n        for inside in containedBoxes[i]:\n            reachable[inside] = False\n    queue = initialBoxes\n    target = []\n    ret = 0\n    while queue:\n        for box in queue:\n            if status[box] == 1 and reachable[box] and (not visited[box]):\n                ret += candies[box]\n                visited[box] = True\n                for key in keys[box]:\n                    if status[key] == 0:\n                        status[key] = 1\n                        if reachable[key]:\n                            target.append(key)\n                for inside in containedBoxes[box]:\n                    reachable[inside] = True\n                    if status[inside] == 1:\n                        target.append(inside)\n            else:\n                target.append(box)\n        if target == queue:\n            break\n        queue = target\n        target = []\n    return ret"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if target == queue:",
      "mutated_line": "if target != queue:",
      "code": "def max_candies(status, candies, keys, containedBoxes, initialBoxes):\n    reachable = [False] * len(status)\n    visited = [False] * len(status)\n    for box in initialBoxes:\n        reachable[box] = True\n    for i in range(len(containedBoxes)):\n        for inside in containedBoxes[i]:\n            reachable[inside] = False\n    queue = initialBoxes\n    target = []\n    ret = 0\n    while queue:\n        for box in queue:\n            if status[box] == 1 and reachable[box] and (not visited[box]):\n                ret += candies[box]\n                visited[box] = True\n                for key in keys[box]:\n                    if status[key] == 0:\n                        status[key] = 1\n                        if reachable[key]:\n                            target.append(key)\n                for inside in containedBoxes[box]:\n                    reachable[inside] = True\n                    if status[inside] == 1:\n                        target.append(inside)\n            else:\n                target.append(box)\n        if target != queue:\n            break\n        queue = target\n        target = []\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "reachable = [False] * len(status)",
      "mutated_line": "reachable = [True] * len(status)",
      "code": "def max_candies(status, candies, keys, containedBoxes, initialBoxes):\n    reachable = [True] * len(status)\n    visited = [False] * len(status)\n    for box in initialBoxes:\n        reachable[box] = True\n    for i in range(len(containedBoxes)):\n        for inside in containedBoxes[i]:\n            reachable[inside] = False\n    queue = initialBoxes\n    target = []\n    ret = 0\n    while queue:\n        for box in queue:\n            if status[box] == 1 and reachable[box] and (not visited[box]):\n                ret += candies[box]\n                visited[box] = True\n                for key in keys[box]:\n                    if status[key] == 0:\n                        status[key] = 1\n                        if reachable[key]:\n                            target.append(key)\n                for inside in containedBoxes[box]:\n                    reachable[inside] = True\n                    if status[inside] == 1:\n                        target.append(inside)\n            else:\n                target.append(box)\n        if target == queue:\n            break\n        queue = target\n        target = []\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "visited = [False] * len(status)",
      "mutated_line": "visited = [True] * len(status)",
      "code": "def max_candies(status, candies, keys, containedBoxes, initialBoxes):\n    reachable = [False] * len(status)\n    visited = [True] * len(status)\n    for box in initialBoxes:\n        reachable[box] = True\n    for i in range(len(containedBoxes)):\n        for inside in containedBoxes[i]:\n            reachable[inside] = False\n    queue = initialBoxes\n    target = []\n    ret = 0\n    while queue:\n        for box in queue:\n            if status[box] == 1 and reachable[box] and (not visited[box]):\n                ret += candies[box]\n                visited[box] = True\n                for key in keys[box]:\n                    if status[key] == 0:\n                        status[key] = 1\n                        if reachable[key]:\n                            target.append(key)\n                for inside in containedBoxes[box]:\n                    reachable[inside] = True\n                    if status[inside] == 1:\n                        target.append(inside)\n            else:\n                target.append(box)\n        if target == queue:\n            break\n        queue = target\n        target = []\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "reachable[inside] = False",
      "mutated_line": "reachable[inside] = True",
      "code": "def max_candies(status, candies, keys, containedBoxes, initialBoxes):\n    reachable = [False] * len(status)\n    visited = [False] * len(status)\n    for box in initialBoxes:\n        reachable[box] = True\n    for i in range(len(containedBoxes)):\n        for inside in containedBoxes[i]:\n            reachable[inside] = True\n    queue = initialBoxes\n    target = []\n    ret = 0\n    while queue:\n        for box in queue:\n            if status[box] == 1 and reachable[box] and (not visited[box]):\n                ret += candies[box]\n                visited[box] = True\n                for key in keys[box]:\n                    if status[key] == 0:\n                        status[key] = 1\n                        if reachable[key]:\n                            target.append(key)\n                for inside in containedBoxes[box]:\n                    reachable[inside] = True\n                    if status[inside] == 1:\n                        target.append(inside)\n            else:\n                target.append(box)\n        if target == queue:\n            break\n        queue = target\n        target = []\n    return ret"
    },
    {
      "operator": "LCR",
      "lineno": 18,
      "original_line": "if status[box] == 1 and reachable[box] and (not visited[box]):",
      "mutated_line": "if status[box] == 1 or reachable[box] or (not visited[box]):",
      "code": "def max_candies(status, candies, keys, containedBoxes, initialBoxes):\n    reachable = [False] * len(status)\n    visited = [False] * len(status)\n    for box in initialBoxes:\n        reachable[box] = True\n    for i in range(len(containedBoxes)):\n        for inside in containedBoxes[i]:\n            reachable[inside] = False\n    queue = initialBoxes\n    target = []\n    ret = 0\n    while queue:\n        for box in queue:\n            if status[box] == 1 or reachable[box] or (not visited[box]):\n                ret += candies[box]\n                visited[box] = True\n                for key in keys[box]:\n                    if status[key] == 0:\n                        status[key] = 1\n                        if reachable[key]:\n                            target.append(key)\n                for inside in containedBoxes[box]:\n                    reachable[inside] = True\n                    if status[inside] == 1:\n                        target.append(inside)\n            else:\n                target.append(box)\n        if target == queue:\n            break\n        queue = target\n        target = []\n    return ret"
    },
    {
      "operator": "ASR",
      "lineno": 19,
      "original_line": "ret += candies[box]",
      "mutated_line": "ret -= candies[box]",
      "code": "def max_candies(status, candies, keys, containedBoxes, initialBoxes):\n    reachable = [False] * len(status)\n    visited = [False] * len(status)\n    for box in initialBoxes:\n        reachable[box] = True\n    for i in range(len(containedBoxes)):\n        for inside in containedBoxes[i]:\n            reachable[inside] = False\n    queue = initialBoxes\n    target = []\n    ret = 0\n    while queue:\n        for box in queue:\n            if status[box] == 1 and reachable[box] and (not visited[box]):\n                ret -= candies[box]\n                visited[box] = True\n                for key in keys[box]:\n                    if status[key] == 0:\n                        status[key] = 1\n                        if reachable[key]:\n                            target.append(key)\n                for inside in containedBoxes[box]:\n                    reachable[inside] = True\n                    if status[inside] == 1:\n                        target.append(inside)\n            else:\n                target.append(box)\n        if target == queue:\n            break\n        queue = target\n        target = []\n    return ret"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if status[box] == 1 and reachable[box] and (not visited[box]):",
      "mutated_line": "if status[box] != 1 and reachable[box] and (not visited[box]):",
      "code": "def max_candies(status, candies, keys, containedBoxes, initialBoxes):\n    reachable = [False] * len(status)\n    visited = [False] * len(status)\n    for box in initialBoxes:\n        reachable[box] = True\n    for i in range(len(containedBoxes)):\n        for inside in containedBoxes[i]:\n            reachable[inside] = False\n    queue = initialBoxes\n    target = []\n    ret = 0\n    while queue:\n        for box in queue:\n            if status[box] != 1 and reachable[box] and (not visited[box]):\n                ret += candies[box]\n                visited[box] = True\n                for key in keys[box]:\n                    if status[key] == 0:\n                        status[key] = 1\n                        if reachable[key]:\n                            target.append(key)\n                for inside in containedBoxes[box]:\n                    reachable[inside] = True\n                    if status[inside] == 1:\n                        target.append(inside)\n            else:\n                target.append(box)\n        if target == queue:\n            break\n        queue = target\n        target = []\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "visited[box] = True",
      "mutated_line": "visited[box] = False",
      "code": "def max_candies(status, candies, keys, containedBoxes, initialBoxes):\n    reachable = [False] * len(status)\n    visited = [False] * len(status)\n    for box in initialBoxes:\n        reachable[box] = True\n    for i in range(len(containedBoxes)):\n        for inside in containedBoxes[i]:\n            reachable[inside] = False\n    queue = initialBoxes\n    target = []\n    ret = 0\n    while queue:\n        for box in queue:\n            if status[box] == 1 and reachable[box] and (not visited[box]):\n                ret += candies[box]\n                visited[box] = False\n                for key in keys[box]:\n                    if status[key] == 0:\n                        status[key] = 1\n                        if reachable[key]:\n                            target.append(key)\n                for inside in containedBoxes[box]:\n                    reachable[inside] = True\n                    if status[inside] == 1:\n                        target.append(inside)\n            else:\n                target.append(box)\n        if target == queue:\n            break\n        queue = target\n        target = []\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if status[box] == 1 and reachable[box] and (not visited[box]):",
      "mutated_line": "if status[box] == 2 and reachable[box] and (not visited[box]):",
      "code": "def max_candies(status, candies, keys, containedBoxes, initialBoxes):\n    reachable = [False] * len(status)\n    visited = [False] * len(status)\n    for box in initialBoxes:\n        reachable[box] = True\n    for i in range(len(containedBoxes)):\n        for inside in containedBoxes[i]:\n            reachable[inside] = False\n    queue = initialBoxes\n    target = []\n    ret = 0\n    while queue:\n        for box in queue:\n            if status[box] == 2 and reachable[box] and (not visited[box]):\n                ret += candies[box]\n                visited[box] = True\n                for key in keys[box]:\n                    if status[key] == 0:\n                        status[key] = 1\n                        if reachable[key]:\n                            target.append(key)\n                for inside in containedBoxes[box]:\n                    reachable[inside] = True\n                    if status[inside] == 1:\n                        target.append(inside)\n            else:\n                target.append(box)\n        if target == queue:\n            break\n        queue = target\n        target = []\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if status[box] == 1 and reachable[box] and (not visited[box]):",
      "mutated_line": "if status[box] == 0 and reachable[box] and (not visited[box]):",
      "code": "def max_candies(status, candies, keys, containedBoxes, initialBoxes):\n    reachable = [False] * len(status)\n    visited = [False] * len(status)\n    for box in initialBoxes:\n        reachable[box] = True\n    for i in range(len(containedBoxes)):\n        for inside in containedBoxes[i]:\n            reachable[inside] = False\n    queue = initialBoxes\n    target = []\n    ret = 0\n    while queue:\n        for box in queue:\n            if status[box] == 0 and reachable[box] and (not visited[box]):\n                ret += candies[box]\n                visited[box] = True\n                for key in keys[box]:\n                    if status[key] == 0:\n                        status[key] = 1\n                        if reachable[key]:\n                            target.append(key)\n                for inside in containedBoxes[box]:\n                    reachable[inside] = True\n                    if status[inside] == 1:\n                        target.append(inside)\n            else:\n                target.append(box)\n        if target == queue:\n            break\n        queue = target\n        target = []\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if status[box] == 1 and reachable[box] and (not visited[box]):",
      "mutated_line": "if status[box] == 0 and reachable[box] and (not visited[box]):",
      "code": "def max_candies(status, candies, keys, containedBoxes, initialBoxes):\n    reachable = [False] * len(status)\n    visited = [False] * len(status)\n    for box in initialBoxes:\n        reachable[box] = True\n    for i in range(len(containedBoxes)):\n        for inside in containedBoxes[i]:\n            reachable[inside] = False\n    queue = initialBoxes\n    target = []\n    ret = 0\n    while queue:\n        for box in queue:\n            if status[box] == 0 and reachable[box] and (not visited[box]):\n                ret += candies[box]\n                visited[box] = True\n                for key in keys[box]:\n                    if status[key] == 0:\n                        status[key] = 1\n                        if reachable[key]:\n                            target.append(key)\n                for inside in containedBoxes[box]:\n                    reachable[inside] = True\n                    if status[inside] == 1:\n                        target.append(inside)\n            else:\n                target.append(box)\n        if target == queue:\n            break\n        queue = target\n        target = []\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if status[box] == 1 and reachable[box] and (not visited[box]):",
      "mutated_line": "if status[box] == -1 and reachable[box] and (not visited[box]):",
      "code": "def max_candies(status, candies, keys, containedBoxes, initialBoxes):\n    reachable = [False] * len(status)\n    visited = [False] * len(status)\n    for box in initialBoxes:\n        reachable[box] = True\n    for i in range(len(containedBoxes)):\n        for inside in containedBoxes[i]:\n            reachable[inside] = False\n    queue = initialBoxes\n    target = []\n    ret = 0\n    while queue:\n        for box in queue:\n            if status[box] == -1 and reachable[box] and (not visited[box]):\n                ret += candies[box]\n                visited[box] = True\n                for key in keys[box]:\n                    if status[key] == 0:\n                        status[key] = 1\n                        if reachable[key]:\n                            target.append(key)\n                for inside in containedBoxes[box]:\n                    reachable[inside] = True\n                    if status[inside] == 1:\n                        target.append(inside)\n            else:\n                target.append(box)\n        if target == queue:\n            break\n        queue = target\n        target = []\n    return ret"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if status[key] == 0:",
      "mutated_line": "if status[key] != 0:",
      "code": "def max_candies(status, candies, keys, containedBoxes, initialBoxes):\n    reachable = [False] * len(status)\n    visited = [False] * len(status)\n    for box in initialBoxes:\n        reachable[box] = True\n    for i in range(len(containedBoxes)):\n        for inside in containedBoxes[i]:\n            reachable[inside] = False\n    queue = initialBoxes\n    target = []\n    ret = 0\n    while queue:\n        for box in queue:\n            if status[box] == 1 and reachable[box] and (not visited[box]):\n                ret += candies[box]\n                visited[box] = True\n                for key in keys[box]:\n                    if status[key] != 0:\n                        status[key] = 1\n                        if reachable[key]:\n                            target.append(key)\n                for inside in containedBoxes[box]:\n                    reachable[inside] = True\n                    if status[inside] == 1:\n                        target.append(inside)\n            else:\n                target.append(box)\n        if target == queue:\n            break\n        queue = target\n        target = []\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "reachable[inside] = True",
      "mutated_line": "reachable[inside] = False",
      "code": "def max_candies(status, candies, keys, containedBoxes, initialBoxes):\n    reachable = [False] * len(status)\n    visited = [False] * len(status)\n    for box in initialBoxes:\n        reachable[box] = True\n    for i in range(len(containedBoxes)):\n        for inside in containedBoxes[i]:\n            reachable[inside] = False\n    queue = initialBoxes\n    target = []\n    ret = 0\n    while queue:\n        for box in queue:\n            if status[box] == 1 and reachable[box] and (not visited[box]):\n                ret += candies[box]\n                visited[box] = True\n                for key in keys[box]:\n                    if status[key] == 0:\n                        status[key] = 1\n                        if reachable[key]:\n                            target.append(key)\n                for inside in containedBoxes[box]:\n                    reachable[inside] = False\n                    if status[inside] == 1:\n                        target.append(inside)\n            else:\n                target.append(box)\n        if target == queue:\n            break\n        queue = target\n        target = []\n    return ret"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if status[inside] == 1:",
      "mutated_line": "if status[inside] != 1:",
      "code": "def max_candies(status, candies, keys, containedBoxes, initialBoxes):\n    reachable = [False] * len(status)\n    visited = [False] * len(status)\n    for box in initialBoxes:\n        reachable[box] = True\n    for i in range(len(containedBoxes)):\n        for inside in containedBoxes[i]:\n            reachable[inside] = False\n    queue = initialBoxes\n    target = []\n    ret = 0\n    while queue:\n        for box in queue:\n            if status[box] == 1 and reachable[box] and (not visited[box]):\n                ret += candies[box]\n                visited[box] = True\n                for key in keys[box]:\n                    if status[key] == 0:\n                        status[key] = 1\n                        if reachable[key]:\n                            target.append(key)\n                for inside in containedBoxes[box]:\n                    reachable[inside] = True\n                    if status[inside] != 1:\n                        target.append(inside)\n            else:\n                target.append(box)\n        if target == queue:\n            break\n        queue = target\n        target = []\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if status[key] == 0:",
      "mutated_line": "if status[key] == 1:",
      "code": "def max_candies(status, candies, keys, containedBoxes, initialBoxes):\n    reachable = [False] * len(status)\n    visited = [False] * len(status)\n    for box in initialBoxes:\n        reachable[box] = True\n    for i in range(len(containedBoxes)):\n        for inside in containedBoxes[i]:\n            reachable[inside] = False\n    queue = initialBoxes\n    target = []\n    ret = 0\n    while queue:\n        for box in queue:\n            if status[box] == 1 and reachable[box] and (not visited[box]):\n                ret += candies[box]\n                visited[box] = True\n                for key in keys[box]:\n                    if status[key] == 1:\n                        status[key] = 1\n                        if reachable[key]:\n                            target.append(key)\n                for inside in containedBoxes[box]:\n                    reachable[inside] = True\n                    if status[inside] == 1:\n                        target.append(inside)\n            else:\n                target.append(box)\n        if target == queue:\n            break\n        queue = target\n        target = []\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if status[key] == 0:",
      "mutated_line": "if status[key] == -1:",
      "code": "def max_candies(status, candies, keys, containedBoxes, initialBoxes):\n    reachable = [False] * len(status)\n    visited = [False] * len(status)\n    for box in initialBoxes:\n        reachable[box] = True\n    for i in range(len(containedBoxes)):\n        for inside in containedBoxes[i]:\n            reachable[inside] = False\n    queue = initialBoxes\n    target = []\n    ret = 0\n    while queue:\n        for box in queue:\n            if status[box] == 1 and reachable[box] and (not visited[box]):\n                ret += candies[box]\n                visited[box] = True\n                for key in keys[box]:\n                    if status[key] == -1:\n                        status[key] = 1\n                        if reachable[key]:\n                            target.append(key)\n                for inside in containedBoxes[box]:\n                    reachable[inside] = True\n                    if status[inside] == 1:\n                        target.append(inside)\n            else:\n                target.append(box)\n        if target == queue:\n            break\n        queue = target\n        target = []\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if status[key] == 0:",
      "mutated_line": "if status[key] == 1:",
      "code": "def max_candies(status, candies, keys, containedBoxes, initialBoxes):\n    reachable = [False] * len(status)\n    visited = [False] * len(status)\n    for box in initialBoxes:\n        reachable[box] = True\n    for i in range(len(containedBoxes)):\n        for inside in containedBoxes[i]:\n            reachable[inside] = False\n    queue = initialBoxes\n    target = []\n    ret = 0\n    while queue:\n        for box in queue:\n            if status[box] == 1 and reachable[box] and (not visited[box]):\n                ret += candies[box]\n                visited[box] = True\n                for key in keys[box]:\n                    if status[key] == 1:\n                        status[key] = 1\n                        if reachable[key]:\n                            target.append(key)\n                for inside in containedBoxes[box]:\n                    reachable[inside] = True\n                    if status[inside] == 1:\n                        target.append(inside)\n            else:\n                target.append(box)\n        if target == queue:\n            break\n        queue = target\n        target = []\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "status[key] = 1",
      "mutated_line": "status[key] = 2",
      "code": "def max_candies(status, candies, keys, containedBoxes, initialBoxes):\n    reachable = [False] * len(status)\n    visited = [False] * len(status)\n    for box in initialBoxes:\n        reachable[box] = True\n    for i in range(len(containedBoxes)):\n        for inside in containedBoxes[i]:\n            reachable[inside] = False\n    queue = initialBoxes\n    target = []\n    ret = 0\n    while queue:\n        for box in queue:\n            if status[box] == 1 and reachable[box] and (not visited[box]):\n                ret += candies[box]\n                visited[box] = True\n                for key in keys[box]:\n                    if status[key] == 0:\n                        status[key] = 2\n                        if reachable[key]:\n                            target.append(key)\n                for inside in containedBoxes[box]:\n                    reachable[inside] = True\n                    if status[inside] == 1:\n                        target.append(inside)\n            else:\n                target.append(box)\n        if target == queue:\n            break\n        queue = target\n        target = []\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "status[key] = 1",
      "mutated_line": "status[key] = 0",
      "code": "def max_candies(status, candies, keys, containedBoxes, initialBoxes):\n    reachable = [False] * len(status)\n    visited = [False] * len(status)\n    for box in initialBoxes:\n        reachable[box] = True\n    for i in range(len(containedBoxes)):\n        for inside in containedBoxes[i]:\n            reachable[inside] = False\n    queue = initialBoxes\n    target = []\n    ret = 0\n    while queue:\n        for box in queue:\n            if status[box] == 1 and reachable[box] and (not visited[box]):\n                ret += candies[box]\n                visited[box] = True\n                for key in keys[box]:\n                    if status[key] == 0:\n                        status[key] = 0\n                        if reachable[key]:\n                            target.append(key)\n                for inside in containedBoxes[box]:\n                    reachable[inside] = True\n                    if status[inside] == 1:\n                        target.append(inside)\n            else:\n                target.append(box)\n        if target == queue:\n            break\n        queue = target\n        target = []\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "status[key] = 1",
      "mutated_line": "status[key] = 0",
      "code": "def max_candies(status, candies, keys, containedBoxes, initialBoxes):\n    reachable = [False] * len(status)\n    visited = [False] * len(status)\n    for box in initialBoxes:\n        reachable[box] = True\n    for i in range(len(containedBoxes)):\n        for inside in containedBoxes[i]:\n            reachable[inside] = False\n    queue = initialBoxes\n    target = []\n    ret = 0\n    while queue:\n        for box in queue:\n            if status[box] == 1 and reachable[box] and (not visited[box]):\n                ret += candies[box]\n                visited[box] = True\n                for key in keys[box]:\n                    if status[key] == 0:\n                        status[key] = 0\n                        if reachable[key]:\n                            target.append(key)\n                for inside in containedBoxes[box]:\n                    reachable[inside] = True\n                    if status[inside] == 1:\n                        target.append(inside)\n            else:\n                target.append(box)\n        if target == queue:\n            break\n        queue = target\n        target = []\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "status[key] = 1",
      "mutated_line": "status[key] = -1",
      "code": "def max_candies(status, candies, keys, containedBoxes, initialBoxes):\n    reachable = [False] * len(status)\n    visited = [False] * len(status)\n    for box in initialBoxes:\n        reachable[box] = True\n    for i in range(len(containedBoxes)):\n        for inside in containedBoxes[i]:\n            reachable[inside] = False\n    queue = initialBoxes\n    target = []\n    ret = 0\n    while queue:\n        for box in queue:\n            if status[box] == 1 and reachable[box] and (not visited[box]):\n                ret += candies[box]\n                visited[box] = True\n                for key in keys[box]:\n                    if status[key] == 0:\n                        status[key] = -1\n                        if reachable[key]:\n                            target.append(key)\n                for inside in containedBoxes[box]:\n                    reachable[inside] = True\n                    if status[inside] == 1:\n                        target.append(inside)\n            else:\n                target.append(box)\n        if target == queue:\n            break\n        queue = target\n        target = []\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if status[inside] == 1:",
      "mutated_line": "if status[inside] == 2:",
      "code": "def max_candies(status, candies, keys, containedBoxes, initialBoxes):\n    reachable = [False] * len(status)\n    visited = [False] * len(status)\n    for box in initialBoxes:\n        reachable[box] = True\n    for i in range(len(containedBoxes)):\n        for inside in containedBoxes[i]:\n            reachable[inside] = False\n    queue = initialBoxes\n    target = []\n    ret = 0\n    while queue:\n        for box in queue:\n            if status[box] == 1 and reachable[box] and (not visited[box]):\n                ret += candies[box]\n                visited[box] = True\n                for key in keys[box]:\n                    if status[key] == 0:\n                        status[key] = 1\n                        if reachable[key]:\n                            target.append(key)\n                for inside in containedBoxes[box]:\n                    reachable[inside] = True\n                    if status[inside] == 2:\n                        target.append(inside)\n            else:\n                target.append(box)\n        if target == queue:\n            break\n        queue = target\n        target = []\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if status[inside] == 1:",
      "mutated_line": "if status[inside] == 0:",
      "code": "def max_candies(status, candies, keys, containedBoxes, initialBoxes):\n    reachable = [False] * len(status)\n    visited = [False] * len(status)\n    for box in initialBoxes:\n        reachable[box] = True\n    for i in range(len(containedBoxes)):\n        for inside in containedBoxes[i]:\n            reachable[inside] = False\n    queue = initialBoxes\n    target = []\n    ret = 0\n    while queue:\n        for box in queue:\n            if status[box] == 1 and reachable[box] and (not visited[box]):\n                ret += candies[box]\n                visited[box] = True\n                for key in keys[box]:\n                    if status[key] == 0:\n                        status[key] = 1\n                        if reachable[key]:\n                            target.append(key)\n                for inside in containedBoxes[box]:\n                    reachable[inside] = True\n                    if status[inside] == 0:\n                        target.append(inside)\n            else:\n                target.append(box)\n        if target == queue:\n            break\n        queue = target\n        target = []\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if status[inside] == 1:",
      "mutated_line": "if status[inside] == 0:",
      "code": "def max_candies(status, candies, keys, containedBoxes, initialBoxes):\n    reachable = [False] * len(status)\n    visited = [False] * len(status)\n    for box in initialBoxes:\n        reachable[box] = True\n    for i in range(len(containedBoxes)):\n        for inside in containedBoxes[i]:\n            reachable[inside] = False\n    queue = initialBoxes\n    target = []\n    ret = 0\n    while queue:\n        for box in queue:\n            if status[box] == 1 and reachable[box] and (not visited[box]):\n                ret += candies[box]\n                visited[box] = True\n                for key in keys[box]:\n                    if status[key] == 0:\n                        status[key] = 1\n                        if reachable[key]:\n                            target.append(key)\n                for inside in containedBoxes[box]:\n                    reachable[inside] = True\n                    if status[inside] == 0:\n                        target.append(inside)\n            else:\n                target.append(box)\n        if target == queue:\n            break\n        queue = target\n        target = []\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if status[inside] == 1:",
      "mutated_line": "if status[inside] == -1:",
      "code": "def max_candies(status, candies, keys, containedBoxes, initialBoxes):\n    reachable = [False] * len(status)\n    visited = [False] * len(status)\n    for box in initialBoxes:\n        reachable[box] = True\n    for i in range(len(containedBoxes)):\n        for inside in containedBoxes[i]:\n            reachable[inside] = False\n    queue = initialBoxes\n    target = []\n    ret = 0\n    while queue:\n        for box in queue:\n            if status[box] == 1 and reachable[box] and (not visited[box]):\n                ret += candies[box]\n                visited[box] = True\n                for key in keys[box]:\n                    if status[key] == 0:\n                        status[key] = 1\n                        if reachable[key]:\n                            target.append(key)\n                for inside in containedBoxes[box]:\n                    reachable[inside] = True\n                    if status[inside] == -1:\n                        target.append(inside)\n            else:\n                target.append(box)\n        if target == queue:\n            break\n        queue = target\n        target = []\n    return ret"
    }
  ]
}