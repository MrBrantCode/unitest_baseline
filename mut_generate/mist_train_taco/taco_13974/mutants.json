{
  "task_id": "taco_13974",
  "entry_point": "count_sequences_with_one_at_k",
  "mutant_count": 198,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 1000000007",
      "mutated_line": "mod = 1000000008",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000008\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 1000000007",
      "mutated_line": "mod = 1000000006",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000006\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 1000000007",
      "mutated_line": "mod = 0",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 0\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 1000000007",
      "mutated_line": "mod = 1",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 1000000007",
      "mutated_line": "mod = -1000000007",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = -1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if K == 1:",
      "mutated_line": "if K != 1:",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K != 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 1\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = -1\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 1\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if K != N:",
      "mutated_line": "if K == N:",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K == N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if K == 1:",
      "mutated_line": "if K == 2:",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 2:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if K == 1:",
      "mutated_line": "if K == 0:",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 0:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if K == 1:",
      "mutated_line": "if K == 0:",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 0:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if K == 1:",
      "mutated_line": "if K == -1:",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == -1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if N == 1:",
      "mutated_line": "if N != 1:",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N != 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "dp = [[0] * (N + 1) for _ in range(K - 1)]",
      "mutated_line": "dp = [[0] / (N + 1) for _ in range(K - 1)]",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] / (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "dp = [[0] * (N + 1) for _ in range(K - 1)]",
      "mutated_line": "dp = [[0] + (N + 1) for _ in range(K - 1)]",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] + (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "dp = [[0] * (N + 1) for _ in range(K - 1)]",
      "mutated_line": "dp = [[0] ** (N + 1) for _ in range(K - 1)]",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] ** (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for j in range(2, N + 1):",
      "mutated_line": "for j in range(3, N + 1):",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(3, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for j in range(2, N + 1):",
      "mutated_line": "for j in range(1, N + 1):",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(1, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for j in range(2, N + 1):",
      "mutated_line": "for j in range(0, N + 1):",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(0, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for j in range(2, N + 1):",
      "mutated_line": "for j in range(1, N + 1):",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(1, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for j in range(2, N + 1):",
      "mutated_line": "for j in range(-2, N + 1):",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(-2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "for j in range(2, N + 1):",
      "mutated_line": "for j in range(2, N - 1):",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N - 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "for j in range(2, N + 1):",
      "mutated_line": "for j in range(2, N * 1):",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N * 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[0][j] = 1",
      "mutated_line": "dp[0][j] = 2",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 2\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[0][j] = 1",
      "mutated_line": "dp[0][j] = 0",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 0\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[0][j] = 1",
      "mutated_line": "dp[0][j] = 0",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 0\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[0][j] = 1",
      "mutated_line": "dp[0][j] = -1",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = -1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(1, K - 1):",
      "mutated_line": "for i in range(2, K - 1):",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(2, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(1, K - 1):",
      "mutated_line": "for i in range(0, K - 1):",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(0, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(1, K - 1):",
      "mutated_line": "for i in range(0, K - 1):",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(0, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(1, K - 1):",
      "mutated_line": "for i in range(-1, K - 1):",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(-1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "for i in range(1, K - 1):",
      "mutated_line": "for i in range(1, K + 1):",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K + 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "for i in range(1, K - 1):",
      "mutated_line": "for i in range(1, K * 1):",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K * 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "cs = [0] * (N + 1)",
      "mutated_line": "cs = [0] / (N + 1)",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] / (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "cs = [0] * (N + 1)",
      "mutated_line": "cs = [0] + (N + 1)",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] + (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "cs = [0] * (N + 1)",
      "mutated_line": "cs = [0] ** (N + 1)",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] ** (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range(2, N + 1):",
      "mutated_line": "for j in range(3, N + 1):",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(3, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range(2, N + 1):",
      "mutated_line": "for j in range(1, N + 1):",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(1, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range(2, N + 1):",
      "mutated_line": "for j in range(0, N + 1):",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(0, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range(2, N + 1):",
      "mutated_line": "for j in range(1, N + 1):",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(1, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range(2, N + 1):",
      "mutated_line": "for j in range(-2, N + 1):",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(-2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "for j in range(2, N + 1):",
      "mutated_line": "for j in range(2, N - 1):",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N - 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "for j in range(2, N + 1):",
      "mutated_line": "for j in range(2, N * 1):",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N * 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "ans = (ans + dp[-1][j]) % mod",
      "mutated_line": "ans = (ans + dp[-1][j]) * mod",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) * mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "ans = (ans + dp[-1][j]) % mod",
      "mutated_line": "ans = ans + dp[-1][j] + mod",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = ans + dp[-1][j] + mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "ans = ans * pow(2, N - K - 1, mod) % mod",
      "mutated_line": "ans = ans * pow(2, N - K - 1, mod) * mod",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) * mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "ans = ans * pow(2, N - K - 1, mod) % mod",
      "mutated_line": "ans = ans * pow(2, N - K - 1, mod) + mod",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) + mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if N == 1:",
      "mutated_line": "if N == 2:",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 2:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if N == 1:",
      "mutated_line": "if N == 0:",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 0:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if N == 1:",
      "mutated_line": "if N == 0:",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 0:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if N == 1:",
      "mutated_line": "if N == -1:",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == -1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return 1",
      "mutated_line": "return 2",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 2\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 0\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 0\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return 1",
      "mutated_line": "return -1",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return -1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "dp = [[0] * (N + 1) for _ in range(K - 1)]",
      "mutated_line": "dp = [[0] * (N - 1) for _ in range(K - 1)]",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N - 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "dp = [[0] * (N + 1) for _ in range(K - 1)]",
      "mutated_line": "dp = [[0] * (N * 1) for _ in range(K - 1)]",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N * 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for j in range(2, N + 1):",
      "mutated_line": "for j in range(2, N + 2):",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 2):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for j in range(2, N + 1):",
      "mutated_line": "for j in range(2, N + 0):",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 0):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for j in range(2, N + 1):",
      "mutated_line": "for j in range(2, N + 0):",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 0):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for j in range(2, N + 1):",
      "mutated_line": "for j in range(2, N + -1):",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + -1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(1, K - 1):",
      "mutated_line": "for i in range(1, K - 2):",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 2):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(1, K - 1):",
      "mutated_line": "for i in range(1, K - 0):",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 0):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(1, K - 1):",
      "mutated_line": "for i in range(1, K - 0):",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 0):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(1, K - 1):",
      "mutated_line": "for i in range(1, K - -1):",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - -1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "cs = [0] * (N + 1)",
      "mutated_line": "cs = [0] * (N - 1)",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N - 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "cs = [0] * (N + 1)",
      "mutated_line": "cs = [0] * (N * 1)",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N * 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for j in range(1, N + 1):",
      "mutated_line": "for j in range(2, N + 1):",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(2, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for j in range(1, N + 1):",
      "mutated_line": "for j in range(0, N + 1):",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(0, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for j in range(1, N + 1):",
      "mutated_line": "for j in range(0, N + 1):",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(0, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for j in range(1, N + 1):",
      "mutated_line": "for j in range(-1, N + 1):",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(-1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for j in range(1, N + 1):",
      "mutated_line": "for j in range(1, N - 1):",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N - 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for j in range(1, N + 1):",
      "mutated_line": "for j in range(1, N * 1):",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N * 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod",
      "mutated_line": "cs[j] = (cs[j - 1] + dp[i - 1][j]) * mod",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) * mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod",
      "mutated_line": "cs[j] = cs[j - 1] + dp[i - 1][j] + mod",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = cs[j - 1] + dp[i - 1][j] + mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for j in range(2, N + 1):",
      "mutated_line": "for j in range(3, N + 1):",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(3, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for j in range(2, N + 1):",
      "mutated_line": "for j in range(1, N + 1):",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(1, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for j in range(2, N + 1):",
      "mutated_line": "for j in range(0, N + 1):",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(0, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for j in range(2, N + 1):",
      "mutated_line": "for j in range(1, N + 1):",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(1, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for j in range(2, N + 1):",
      "mutated_line": "for j in range(-2, N + 1):",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(-2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "for j in range(2, N + 1):",
      "mutated_line": "for j in range(2, N - 1):",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N - 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "for j in range(2, N + 1):",
      "mutated_line": "for j in range(2, N * 1):",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N * 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if j != N - i + 1:",
      "mutated_line": "if j == N - i + 1:",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j == N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod",
      "mutated_line": "dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) * mod",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) * mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod",
      "mutated_line": "dp[i][j] = dp[i][j] + cs[-1] - cs[j] + mod",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = dp[i][j] + cs[-1] - cs[j] + mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range(2, N + 1):",
      "mutated_line": "for j in range(2, N + 2):",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 2):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range(2, N + 1):",
      "mutated_line": "for j in range(2, N + 0):",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 0):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range(2, N + 1):",
      "mutated_line": "for j in range(2, N + 0):",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 0):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range(2, N + 1):",
      "mutated_line": "for j in range(2, N + -1):",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + -1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "ans = (ans + dp[-1][j]) % mod",
      "mutated_line": "ans = (ans - dp[-1][j]) % mod",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans - dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "ans = (ans + dp[-1][j]) % mod",
      "mutated_line": "ans = ans * dp[-1][j] % mod",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = ans * dp[-1][j] % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "ans = ans * pow(2, N - K - 1, mod) % mod",
      "mutated_line": "ans = ans / pow(2, N - K - 1, mod) % mod",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans / pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "ans = ans * pow(2, N - K - 1, mod) % mod",
      "mutated_line": "ans = (ans + pow(2, N - K - 1, mod)) % mod",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = (ans + pow(2, N - K - 1, mod)) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "ans = ans * pow(2, N - K - 1, mod) % mod",
      "mutated_line": "ans = ans ** pow(2, N - K - 1, mod) % mod",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans ** pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return pow(2, N - 2, mod)",
      "mutated_line": "return pow(3, N - 2, mod)",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(3, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return pow(2, N - 2, mod)",
      "mutated_line": "return pow(1, N - 2, mod)",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(1, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return pow(2, N - 2, mod)",
      "mutated_line": "return pow(0, N - 2, mod)",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(0, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return pow(2, N - 2, mod)",
      "mutated_line": "return pow(1, N - 2, mod)",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(1, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return pow(2, N - 2, mod)",
      "mutated_line": "return pow(-2, N - 2, mod)",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(-2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return pow(2, N - 2, mod)",
      "mutated_line": "return pow(2, N + 2, mod)",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N + 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return pow(2, N - 2, mod)",
      "mutated_line": "return pow(2, N * 2, mod)",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N * 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp = [[0] * (N + 1) for _ in range(K - 1)]",
      "mutated_line": "dp = [[1] * (N + 1) for _ in range(K - 1)]",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[1] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp = [[0] * (N + 1) for _ in range(K - 1)]",
      "mutated_line": "dp = [[-1] * (N + 1) for _ in range(K - 1)]",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[-1] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp = [[0] * (N + 1) for _ in range(K - 1)]",
      "mutated_line": "dp = [[1] * (N + 1) for _ in range(K - 1)]",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[1] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp = [[0] * (N + 1) for _ in range(K - 1)]",
      "mutated_line": "dp = [[0] * (N + 2) for _ in range(K - 1)]",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 2) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp = [[0] * (N + 1) for _ in range(K - 1)]",
      "mutated_line": "dp = [[0] * (N + 0) for _ in range(K - 1)]",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 0) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp = [[0] * (N + 1) for _ in range(K - 1)]",
      "mutated_line": "dp = [[0] * (N + 0) for _ in range(K - 1)]",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 0) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp = [[0] * (N + 1) for _ in range(K - 1)]",
      "mutated_line": "dp = [[0] * (N + -1) for _ in range(K - 1)]",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + -1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "dp = [[0] * (N + 1) for _ in range(K - 1)]",
      "mutated_line": "dp = [[0] * (N + 1) for _ in range(K + 1)]",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K + 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "dp = [[0] * (N + 1) for _ in range(K - 1)]",
      "mutated_line": "dp = [[0] * (N + 1) for _ in range(K * 1)]",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K * 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[0][j] = 1",
      "mutated_line": "dp[1][j] = 1",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[1][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[0][j] = 1",
      "mutated_line": "dp[-1][j] = 1",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[-1][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[0][j] = 1",
      "mutated_line": "dp[1][j] = 1",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[1][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "cs = [0] * (N + 1)",
      "mutated_line": "cs = [1] * (N + 1)",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [1] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "cs = [0] * (N + 1)",
      "mutated_line": "cs = [-1] * (N + 1)",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [-1] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "cs = [0] * (N + 1)",
      "mutated_line": "cs = [1] * (N + 1)",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [1] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "cs = [0] * (N + 1)",
      "mutated_line": "cs = [0] * (N + 2)",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 2)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "cs = [0] * (N + 1)",
      "mutated_line": "cs = [0] * (N + 0)",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 0)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "cs = [0] * (N + 1)",
      "mutated_line": "cs = [0] * (N + 0)",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 0)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "cs = [0] * (N + 1)",
      "mutated_line": "cs = [0] * (N + -1)",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + -1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for j in range(1, N + 1):",
      "mutated_line": "for j in range(1, N + 2):",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 2):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for j in range(1, N + 1):",
      "mutated_line": "for j in range(1, N + 0):",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 0):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for j in range(1, N + 1):",
      "mutated_line": "for j in range(1, N + 0):",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 0):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for j in range(1, N + 1):",
      "mutated_line": "for j in range(1, N + -1):",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + -1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod",
      "mutated_line": "cs[j] = (cs[j - 1] - dp[i - 1][j]) % mod",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] - dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod",
      "mutated_line": "cs[j] = cs[j - 1] * dp[i - 1][j] % mod",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = cs[j - 1] * dp[i - 1][j] % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for j in range(2, N + 1):",
      "mutated_line": "for j in range(2, N + 2):",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 2):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for j in range(2, N + 1):",
      "mutated_line": "for j in range(2, N + 0):",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 0):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for j in range(2, N + 1):",
      "mutated_line": "for j in range(2, N + 0):",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 0):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for j in range(2, N + 1):",
      "mutated_line": "for j in range(2, N + -1):",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + -1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if j != N - i + 1:",
      "mutated_line": "if j != N - i - 1:",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i - 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if j != N - i + 1:",
      "mutated_line": "if j != (N - i) * 1:",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != (N - i) * 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod",
      "mutated_line": "dp[i][j] = (dp[i][j] + dp[i - 1][j]) * mod",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) * mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod",
      "mutated_line": "dp[i][j] = dp[i][j] + dp[i - 1][j] + mod",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = dp[i][j] + dp[i - 1][j] + mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod",
      "mutated_line": "dp[i][j] = (dp[i][j] + cs[-1] + cs[j]) % mod",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] + cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod",
      "mutated_line": "dp[i][j] = (dp[i][j] + cs[-1]) * cs[j] % mod",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1]) * cs[j] % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return pow(2, N - 2, mod)",
      "mutated_line": "return pow(2, N - 3, mod)",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 3, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return pow(2, N - 2, mod)",
      "mutated_line": "return pow(2, N - 1, mod)",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 1, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return pow(2, N - 2, mod)",
      "mutated_line": "return pow(2, N - 0, mod)",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 0, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return pow(2, N - 2, mod)",
      "mutated_line": "return pow(2, N - 1, mod)",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 1, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return pow(2, N - 2, mod)",
      "mutated_line": "return pow(2, N - -2, mod)",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - -2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp = [[0] * (N + 1) for _ in range(K - 1)]",
      "mutated_line": "dp = [[0] * (N + 1) for _ in range(K - 2)]",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 2)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp = [[0] * (N + 1) for _ in range(K - 1)]",
      "mutated_line": "dp = [[0] * (N + 1) for _ in range(K - 0)]",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 0)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp = [[0] * (N + 1) for _ in range(K - 1)]",
      "mutated_line": "dp = [[0] * (N + 1) for _ in range(K - 0)]",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 0)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp = [[0] * (N + 1) for _ in range(K - 1)]",
      "mutated_line": "dp = [[0] * (N + 1) for _ in range(K - -1)]",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - -1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if j != N - i + 1:",
      "mutated_line": "if j != N + i + 1:",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N + i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if j != N - i + 1:",
      "mutated_line": "if j != N * i + 1:",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N * i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if j != N - i + 1:",
      "mutated_line": "if j != N - i + 2:",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 2:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if j != N - i + 1:",
      "mutated_line": "if j != N - i + 0:",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 0:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if j != N - i + 1:",
      "mutated_line": "if j != N - i + 0:",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 0:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if j != N - i + 1:",
      "mutated_line": "if j != N - i + -1:",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + -1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod",
      "mutated_line": "dp[i][j] = (dp[i][j] - dp[i - 1][j]) % mod",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] - dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod",
      "mutated_line": "dp[i][j] = dp[i][j] * dp[i - 1][j] % mod",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = dp[i][j] * dp[i - 1][j] % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod",
      "mutated_line": "dp[i][j] = (dp[i][j] - cs[-1] - cs[j]) % mod",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] - cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod",
      "mutated_line": "dp[i][j] = (dp[i][j] * cs[-1] - cs[j]) % mod",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] * cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ans = ans * pow(2, N - K - 1, mod) % mod",
      "mutated_line": "ans = ans * pow(3, N - K - 1, mod) % mod",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(3, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ans = ans * pow(2, N - K - 1, mod) % mod",
      "mutated_line": "ans = ans * pow(1, N - K - 1, mod) % mod",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(1, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ans = ans * pow(2, N - K - 1, mod) % mod",
      "mutated_line": "ans = ans * pow(0, N - K - 1, mod) % mod",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(0, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ans = ans * pow(2, N - K - 1, mod) % mod",
      "mutated_line": "ans = ans * pow(1, N - K - 1, mod) % mod",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(1, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ans = ans * pow(2, N - K - 1, mod) % mod",
      "mutated_line": "ans = ans * pow(-2, N - K - 1, mod) % mod",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(-2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "ans = ans * pow(2, N - K - 1, mod) % mod",
      "mutated_line": "ans = ans * pow(2, N - K + 1, mod) % mod",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K + 1, mod) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "ans = ans * pow(2, N - K - 1, mod) % mod",
      "mutated_line": "ans = ans * pow(2, (N - K) * 1, mod) % mod",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, (N - K) * 1, mod) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod",
      "mutated_line": "cs[j] = (cs[j + 1] + dp[i - 1][j]) % mod",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j + 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod",
      "mutated_line": "cs[j] = (cs[j * 1] + dp[i - 1][j]) % mod",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j * 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 26,
      "original_line": "ans = (ans + dp[-1][j]) % mod",
      "mutated_line": "ans = (ans + dp[+1][j]) % mod",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[+1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "ans = ans * pow(2, N - K - 1, mod) % mod",
      "mutated_line": "ans = ans * pow(2, N + K - 1, mod) % mod",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N + K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "ans = ans * pow(2, N - K - 1, mod) % mod",
      "mutated_line": "ans = ans * pow(2, N * K - 1, mod) % mod",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N * K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ans = ans * pow(2, N - K - 1, mod) % mod",
      "mutated_line": "ans = ans * pow(2, N - K - 2, mod) % mod",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 2, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ans = ans * pow(2, N - K - 1, mod) % mod",
      "mutated_line": "ans = ans * pow(2, N - K - 0, mod) % mod",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 0, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ans = ans * pow(2, N - K - 1, mod) % mod",
      "mutated_line": "ans = ans * pow(2, N - K - 0, mod) % mod",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 0, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ans = ans * pow(2, N - K - 1, mod) % mod",
      "mutated_line": "ans = ans * pow(2, N - K - -1, mod) % mod",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - -1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod",
      "mutated_line": "cs[j] = (cs[j - 2] + dp[i - 1][j]) % mod",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 2] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod",
      "mutated_line": "cs[j] = (cs[j - 0] + dp[i - 1][j]) % mod",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 0] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod",
      "mutated_line": "cs[j] = (cs[j - 0] + dp[i - 1][j]) % mod",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 0] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod",
      "mutated_line": "cs[j] = (cs[j - -1] + dp[i - 1][j]) % mod",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - -1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod",
      "mutated_line": "cs[j] = (cs[j - 1] + dp[i + 1][j]) % mod",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i + 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod",
      "mutated_line": "cs[j] = (cs[j - 1] + dp[i * 1][j]) % mod",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i * 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 22,
      "original_line": "dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod",
      "mutated_line": "dp[i][j] = (dp[i][j] + cs[+1] - cs[j]) % mod",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[+1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ans = (ans + dp[-1][j]) % mod",
      "mutated_line": "ans = (ans + dp[-2][j]) % mod",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-2][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ans = (ans + dp[-1][j]) % mod",
      "mutated_line": "ans = (ans + dp[-0][j]) % mod",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-0][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ans = (ans + dp[-1][j]) % mod",
      "mutated_line": "ans = (ans + dp[-0][j]) % mod",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-0][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ans = (ans + dp[-1][j]) % mod",
      "mutated_line": "ans = (ans + dp[--1][j]) % mod",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[--1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod",
      "mutated_line": "cs[j] = (cs[j - 1] + dp[i - 2][j]) % mod",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 2][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod",
      "mutated_line": "cs[j] = (cs[j - 1] + dp[i - 0][j]) % mod",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 0][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod",
      "mutated_line": "cs[j] = (cs[j - 1] + dp[i - 0][j]) % mod",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 0][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod",
      "mutated_line": "cs[j] = (cs[j - 1] + dp[i - -1][j]) % mod",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - -1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod",
      "mutated_line": "dp[i][j] = (dp[i][j] + dp[i + 1][j]) % mod",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i + 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod",
      "mutated_line": "dp[i][j] = (dp[i][j] + dp[i * 1][j]) % mod",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i * 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod",
      "mutated_line": "dp[i][j] = (dp[i][j] + cs[-2] - cs[j]) % mod",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-2] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod",
      "mutated_line": "dp[i][j] = (dp[i][j] + cs[-0] - cs[j]) % mod",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-0] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod",
      "mutated_line": "dp[i][j] = (dp[i][j] + cs[-0] - cs[j]) % mod",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-0] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod",
      "mutated_line": "dp[i][j] = (dp[i][j] + cs[--1] - cs[j]) % mod",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[--1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod",
      "mutated_line": "dp[i][j] = (dp[i][j] + dp[i - 2][j]) % mod",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 2][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod",
      "mutated_line": "dp[i][j] = (dp[i][j] + dp[i - 0][j]) % mod",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 0][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod",
      "mutated_line": "dp[i][j] = (dp[i][j] + dp[i - 0][j]) % mod",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - 0][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod",
      "mutated_line": "dp[i][j] = (dp[i][j] + dp[i - -1][j]) % mod",
      "code": "def count_sequences_with_one_at_k(N: int, K: int) -> int:\n    mod = 1000000007\n    if K == 1:\n        if N == 1:\n            return 1\n        else:\n            return pow(2, N - 2, mod)\n    dp = [[0] * (N + 1) for _ in range(K - 1)]\n    for j in range(2, N + 1):\n        dp[0][j] = 1\n    for i in range(1, K - 1):\n        cs = [0] * (N + 1)\n        for j in range(1, N + 1):\n            cs[j] = (cs[j - 1] + dp[i - 1][j]) % mod\n        for j in range(2, N + 1):\n            if j != N - i + 1:\n                dp[i][j] = (dp[i][j] + dp[i - -1][j]) % mod\n            dp[i][j] = (dp[i][j] + cs[-1] - cs[j]) % mod\n    ans = 0\n    for j in range(2, N + 1):\n        ans = (ans + dp[-1][j]) % mod\n    if K != N:\n        ans = ans * pow(2, N - K - 1, mod) % mod\n    return ans"
    }
  ]
}