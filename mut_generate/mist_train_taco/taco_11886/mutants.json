{
  "task_id": "taco_11886",
  "entry_point": "find_good_points",
  "mutant_count": 49,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return sum(x ** 2 for x in v) ** 0.5",
      "mutated_line": "return sum((x ** 2 for x in v)) * 0.5",
      "code": "def find_good_points(points):\n\n    def dot_product(v1, v2):\n        return sum((x * y for (x, y) in zip(v1, v2)))\n\n    def vector_length(v):\n        return sum((x ** 2 for x in v)) * 0.5\n\n    def is_acute_angle(v1, v2):\n        return dot_product(v1, v2) > 0\n    n = len(points)\n    good_indices = []\n    for k in range(n):\n        is_good = True\n        for i in range(n):\n            for j in range(n):\n                if i != k and j != k and (i != j):\n                    v1 = [points[i][d] - points[k][d] for d in range(5)]\n                    v2 = [points[j][d] - points[k][d] for d in range(5)]\n                    if is_acute_angle(v1, v2):\n                        is_good = False\n                        break\n            if not is_good:\n                break\n        if is_good:\n            good_indices.append(k + 1)\n    return (len(good_indices), good_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return sum(x ** 2 for x in v) ** 0.5",
      "mutated_line": "return sum((x ** 2 for x in v)) + 0.5",
      "code": "def find_good_points(points):\n\n    def dot_product(v1, v2):\n        return sum((x * y for (x, y) in zip(v1, v2)))\n\n    def vector_length(v):\n        return sum((x ** 2 for x in v)) + 0.5\n\n    def is_acute_angle(v1, v2):\n        return dot_product(v1, v2) > 0\n    n = len(points)\n    good_indices = []\n    for k in range(n):\n        is_good = True\n        for i in range(n):\n            for j in range(n):\n                if i != k and j != k and (i != j):\n                    v1 = [points[i][d] - points[k][d] for d in range(5)]\n                    v2 = [points[j][d] - points[k][d] for d in range(5)]\n                    if is_acute_angle(v1, v2):\n                        is_good = False\n                        break\n            if not is_good:\n                break\n        if is_good:\n            good_indices.append(k + 1)\n    return (len(good_indices), good_indices)"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "return dot_product(v1, v2) > 0",
      "mutated_line": "return dot_product(v1, v2) >= 0",
      "code": "def find_good_points(points):\n\n    def dot_product(v1, v2):\n        return sum((x * y for (x, y) in zip(v1, v2)))\n\n    def vector_length(v):\n        return sum((x ** 2 for x in v)) ** 0.5\n\n    def is_acute_angle(v1, v2):\n        return dot_product(v1, v2) >= 0\n    n = len(points)\n    good_indices = []\n    for k in range(n):\n        is_good = True\n        for i in range(n):\n            for j in range(n):\n                if i != k and j != k and (i != j):\n                    v1 = [points[i][d] - points[k][d] for d in range(5)]\n                    v2 = [points[j][d] - points[k][d] for d in range(5)]\n                    if is_acute_angle(v1, v2):\n                        is_good = False\n                        break\n            if not is_good:\n                break\n        if is_good:\n            good_indices.append(k + 1)\n    return (len(good_indices), good_indices)"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "return dot_product(v1, v2) > 0",
      "mutated_line": "return dot_product(v1, v2) <= 0",
      "code": "def find_good_points(points):\n\n    def dot_product(v1, v2):\n        return sum((x * y for (x, y) in zip(v1, v2)))\n\n    def vector_length(v):\n        return sum((x ** 2 for x in v)) ** 0.5\n\n    def is_acute_angle(v1, v2):\n        return dot_product(v1, v2) <= 0\n    n = len(points)\n    good_indices = []\n    for k in range(n):\n        is_good = True\n        for i in range(n):\n            for j in range(n):\n                if i != k and j != k and (i != j):\n                    v1 = [points[i][d] - points[k][d] for d in range(5)]\n                    v2 = [points[j][d] - points[k][d] for d in range(5)]\n                    if is_acute_angle(v1, v2):\n                        is_good = False\n                        break\n            if not is_good:\n                break\n        if is_good:\n            good_indices.append(k + 1)\n    return (len(good_indices), good_indices)"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "return dot_product(v1, v2) > 0",
      "mutated_line": "return dot_product(v1, v2) != 0",
      "code": "def find_good_points(points):\n\n    def dot_product(v1, v2):\n        return sum((x * y for (x, y) in zip(v1, v2)))\n\n    def vector_length(v):\n        return sum((x ** 2 for x in v)) ** 0.5\n\n    def is_acute_angle(v1, v2):\n        return dot_product(v1, v2) != 0\n    n = len(points)\n    good_indices = []\n    for k in range(n):\n        is_good = True\n        for i in range(n):\n            for j in range(n):\n                if i != k and j != k and (i != j):\n                    v1 = [points[i][d] - points[k][d] for d in range(5)]\n                    v2 = [points[j][d] - points[k][d] for d in range(5)]\n                    if is_acute_angle(v1, v2):\n                        is_good = False\n                        break\n            if not is_good:\n                break\n        if is_good:\n            good_indices.append(k + 1)\n    return (len(good_indices), good_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "is_good = True",
      "mutated_line": "is_good = False",
      "code": "def find_good_points(points):\n\n    def dot_product(v1, v2):\n        return sum((x * y for (x, y) in zip(v1, v2)))\n\n    def vector_length(v):\n        return sum((x ** 2 for x in v)) ** 0.5\n\n    def is_acute_angle(v1, v2):\n        return dot_product(v1, v2) > 0\n    n = len(points)\n    good_indices = []\n    for k in range(n):\n        is_good = False\n        for i in range(n):\n            for j in range(n):\n                if i != k and j != k and (i != j):\n                    v1 = [points[i][d] - points[k][d] for d in range(5)]\n                    v2 = [points[j][d] - points[k][d] for d in range(5)]\n                    if is_acute_angle(v1, v2):\n                        is_good = False\n                        break\n            if not is_good:\n                break\n        if is_good:\n            good_indices.append(k + 1)\n    return (len(good_indices), good_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return sum(x ** 2 for x in v) ** 0.5",
      "mutated_line": "return sum((x ** 2 for x in v)) ** 1.5",
      "code": "def find_good_points(points):\n\n    def dot_product(v1, v2):\n        return sum((x * y for (x, y) in zip(v1, v2)))\n\n    def vector_length(v):\n        return sum((x ** 2 for x in v)) ** 1.5\n\n    def is_acute_angle(v1, v2):\n        return dot_product(v1, v2) > 0\n    n = len(points)\n    good_indices = []\n    for k in range(n):\n        is_good = True\n        for i in range(n):\n            for j in range(n):\n                if i != k and j != k and (i != j):\n                    v1 = [points[i][d] - points[k][d] for d in range(5)]\n                    v2 = [points[j][d] - points[k][d] for d in range(5)]\n                    if is_acute_angle(v1, v2):\n                        is_good = False\n                        break\n            if not is_good:\n                break\n        if is_good:\n            good_indices.append(k + 1)\n    return (len(good_indices), good_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return sum(x ** 2 for x in v) ** 0.5",
      "mutated_line": "return sum((x ** 2 for x in v)) ** -0.5",
      "code": "def find_good_points(points):\n\n    def dot_product(v1, v2):\n        return sum((x * y for (x, y) in zip(v1, v2)))\n\n    def vector_length(v):\n        return sum((x ** 2 for x in v)) ** -0.5\n\n    def is_acute_angle(v1, v2):\n        return dot_product(v1, v2) > 0\n    n = len(points)\n    good_indices = []\n    for k in range(n):\n        is_good = True\n        for i in range(n):\n            for j in range(n):\n                if i != k and j != k and (i != j):\n                    v1 = [points[i][d] - points[k][d] for d in range(5)]\n                    v2 = [points[j][d] - points[k][d] for d in range(5)]\n                    if is_acute_angle(v1, v2):\n                        is_good = False\n                        break\n            if not is_good:\n                break\n        if is_good:\n            good_indices.append(k + 1)\n    return (len(good_indices), good_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return sum(x ** 2 for x in v) ** 0.5",
      "mutated_line": "return sum((x ** 2 for x in v)) ** 0",
      "code": "def find_good_points(points):\n\n    def dot_product(v1, v2):\n        return sum((x * y for (x, y) in zip(v1, v2)))\n\n    def vector_length(v):\n        return sum((x ** 2 for x in v)) ** 0\n\n    def is_acute_angle(v1, v2):\n        return dot_product(v1, v2) > 0\n    n = len(points)\n    good_indices = []\n    for k in range(n):\n        is_good = True\n        for i in range(n):\n            for j in range(n):\n                if i != k and j != k and (i != j):\n                    v1 = [points[i][d] - points[k][d] for d in range(5)]\n                    v2 = [points[j][d] - points[k][d] for d in range(5)]\n                    if is_acute_angle(v1, v2):\n                        is_good = False\n                        break\n            if not is_good:\n                break\n        if is_good:\n            good_indices.append(k + 1)\n    return (len(good_indices), good_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return sum(x ** 2 for x in v) ** 0.5",
      "mutated_line": "return sum((x ** 2 for x in v)) ** 1",
      "code": "def find_good_points(points):\n\n    def dot_product(v1, v2):\n        return sum((x * y for (x, y) in zip(v1, v2)))\n\n    def vector_length(v):\n        return sum((x ** 2 for x in v)) ** 1\n\n    def is_acute_angle(v1, v2):\n        return dot_product(v1, v2) > 0\n    n = len(points)\n    good_indices = []\n    for k in range(n):\n        is_good = True\n        for i in range(n):\n            for j in range(n):\n                if i != k and j != k and (i != j):\n                    v1 = [points[i][d] - points[k][d] for d in range(5)]\n                    v2 = [points[j][d] - points[k][d] for d in range(5)]\n                    if is_acute_angle(v1, v2):\n                        is_good = False\n                        break\n            if not is_good:\n                break\n        if is_good:\n            good_indices.append(k + 1)\n    return (len(good_indices), good_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return sum(x ** 2 for x in v) ** 0.5",
      "mutated_line": "return sum((x ** 2 for x in v)) ** -0.5",
      "code": "def find_good_points(points):\n\n    def dot_product(v1, v2):\n        return sum((x * y for (x, y) in zip(v1, v2)))\n\n    def vector_length(v):\n        return sum((x ** 2 for x in v)) ** -0.5\n\n    def is_acute_angle(v1, v2):\n        return dot_product(v1, v2) > 0\n    n = len(points)\n    good_indices = []\n    for k in range(n):\n        is_good = True\n        for i in range(n):\n            for j in range(n):\n                if i != k and j != k and (i != j):\n                    v1 = [points[i][d] - points[k][d] for d in range(5)]\n                    v2 = [points[j][d] - points[k][d] for d in range(5)]\n                    if is_acute_angle(v1, v2):\n                        is_good = False\n                        break\n            if not is_good:\n                break\n        if is_good:\n            good_indices.append(k + 1)\n    return (len(good_indices), good_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return dot_product(v1, v2) > 0",
      "mutated_line": "return dot_product(v1, v2) > 1",
      "code": "def find_good_points(points):\n\n    def dot_product(v1, v2):\n        return sum((x * y for (x, y) in zip(v1, v2)))\n\n    def vector_length(v):\n        return sum((x ** 2 for x in v)) ** 0.5\n\n    def is_acute_angle(v1, v2):\n        return dot_product(v1, v2) > 1\n    n = len(points)\n    good_indices = []\n    for k in range(n):\n        is_good = True\n        for i in range(n):\n            for j in range(n):\n                if i != k and j != k and (i != j):\n                    v1 = [points[i][d] - points[k][d] for d in range(5)]\n                    v2 = [points[j][d] - points[k][d] for d in range(5)]\n                    if is_acute_angle(v1, v2):\n                        is_good = False\n                        break\n            if not is_good:\n                break\n        if is_good:\n            good_indices.append(k + 1)\n    return (len(good_indices), good_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return dot_product(v1, v2) > 0",
      "mutated_line": "return dot_product(v1, v2) > -1",
      "code": "def find_good_points(points):\n\n    def dot_product(v1, v2):\n        return sum((x * y for (x, y) in zip(v1, v2)))\n\n    def vector_length(v):\n        return sum((x ** 2 for x in v)) ** 0.5\n\n    def is_acute_angle(v1, v2):\n        return dot_product(v1, v2) > -1\n    n = len(points)\n    good_indices = []\n    for k in range(n):\n        is_good = True\n        for i in range(n):\n            for j in range(n):\n                if i != k and j != k and (i != j):\n                    v1 = [points[i][d] - points[k][d] for d in range(5)]\n                    v2 = [points[j][d] - points[k][d] for d in range(5)]\n                    if is_acute_angle(v1, v2):\n                        is_good = False\n                        break\n            if not is_good:\n                break\n        if is_good:\n            good_indices.append(k + 1)\n    return (len(good_indices), good_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return dot_product(v1, v2) > 0",
      "mutated_line": "return dot_product(v1, v2) > 1",
      "code": "def find_good_points(points):\n\n    def dot_product(v1, v2):\n        return sum((x * y for (x, y) in zip(v1, v2)))\n\n    def vector_length(v):\n        return sum((x ** 2 for x in v)) ** 0.5\n\n    def is_acute_angle(v1, v2):\n        return dot_product(v1, v2) > 1\n    n = len(points)\n    good_indices = []\n    for k in range(n):\n        is_good = True\n        for i in range(n):\n            for j in range(n):\n                if i != k and j != k and (i != j):\n                    v1 = [points[i][d] - points[k][d] for d in range(5)]\n                    v2 = [points[j][d] - points[k][d] for d in range(5)]\n                    if is_acute_angle(v1, v2):\n                        is_good = False\n                        break\n            if not is_good:\n                break\n        if is_good:\n            good_indices.append(k + 1)\n    return (len(good_indices), good_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return sum(x * y for x, y in zip(v1, v2))",
      "mutated_line": "return sum((x / y for (x, y) in zip(v1, v2)))",
      "code": "def find_good_points(points):\n\n    def dot_product(v1, v2):\n        return sum((x / y for (x, y) in zip(v1, v2)))\n\n    def vector_length(v):\n        return sum((x ** 2 for x in v)) ** 0.5\n\n    def is_acute_angle(v1, v2):\n        return dot_product(v1, v2) > 0\n    n = len(points)\n    good_indices = []\n    for k in range(n):\n        is_good = True\n        for i in range(n):\n            for j in range(n):\n                if i != k and j != k and (i != j):\n                    v1 = [points[i][d] - points[k][d] for d in range(5)]\n                    v2 = [points[j][d] - points[k][d] for d in range(5)]\n                    if is_acute_angle(v1, v2):\n                        is_good = False\n                        break\n            if not is_good:\n                break\n        if is_good:\n            good_indices.append(k + 1)\n    return (len(good_indices), good_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return sum(x * y for x, y in zip(v1, v2))",
      "mutated_line": "return sum((x + y for (x, y) in zip(v1, v2)))",
      "code": "def find_good_points(points):\n\n    def dot_product(v1, v2):\n        return sum((x + y for (x, y) in zip(v1, v2)))\n\n    def vector_length(v):\n        return sum((x ** 2 for x in v)) ** 0.5\n\n    def is_acute_angle(v1, v2):\n        return dot_product(v1, v2) > 0\n    n = len(points)\n    good_indices = []\n    for k in range(n):\n        is_good = True\n        for i in range(n):\n            for j in range(n):\n                if i != k and j != k and (i != j):\n                    v1 = [points[i][d] - points[k][d] for d in range(5)]\n                    v2 = [points[j][d] - points[k][d] for d in range(5)]\n                    if is_acute_angle(v1, v2):\n                        is_good = False\n                        break\n            if not is_good:\n                break\n        if is_good:\n            good_indices.append(k + 1)\n    return (len(good_indices), good_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return sum(x * y for x, y in zip(v1, v2))",
      "mutated_line": "return sum((x ** y for (x, y) in zip(v1, v2)))",
      "code": "def find_good_points(points):\n\n    def dot_product(v1, v2):\n        return sum((x ** y for (x, y) in zip(v1, v2)))\n\n    def vector_length(v):\n        return sum((x ** 2 for x in v)) ** 0.5\n\n    def is_acute_angle(v1, v2):\n        return dot_product(v1, v2) > 0\n    n = len(points)\n    good_indices = []\n    for k in range(n):\n        is_good = True\n        for i in range(n):\n            for j in range(n):\n                if i != k and j != k and (i != j):\n                    v1 = [points[i][d] - points[k][d] for d in range(5)]\n                    v2 = [points[j][d] - points[k][d] for d in range(5)]\n                    if is_acute_angle(v1, v2):\n                        is_good = False\n                        break\n            if not is_good:\n                break\n        if is_good:\n            good_indices.append(k + 1)\n    return (len(good_indices), good_indices)"
    },
    {
      "operator": "LCR",
      "lineno": 18,
      "original_line": "if i != k and j != k and i != j:",
      "mutated_line": "if i != k or j != k or i != j:",
      "code": "def find_good_points(points):\n\n    def dot_product(v1, v2):\n        return sum((x * y for (x, y) in zip(v1, v2)))\n\n    def vector_length(v):\n        return sum((x ** 2 for x in v)) ** 0.5\n\n    def is_acute_angle(v1, v2):\n        return dot_product(v1, v2) > 0\n    n = len(points)\n    good_indices = []\n    for k in range(n):\n        is_good = True\n        for i in range(n):\n            for j in range(n):\n                if i != k or j != k or i != j:\n                    v1 = [points[i][d] - points[k][d] for d in range(5)]\n                    v2 = [points[j][d] - points[k][d] for d in range(5)]\n                    if is_acute_angle(v1, v2):\n                        is_good = False\n                        break\n            if not is_good:\n                break\n        if is_good:\n            good_indices.append(k + 1)\n    return (len(good_indices), good_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "good_indices.append(k + 1)",
      "mutated_line": "good_indices.append(k - 1)",
      "code": "def find_good_points(points):\n\n    def dot_product(v1, v2):\n        return sum((x * y for (x, y) in zip(v1, v2)))\n\n    def vector_length(v):\n        return sum((x ** 2 for x in v)) ** 0.5\n\n    def is_acute_angle(v1, v2):\n        return dot_product(v1, v2) > 0\n    n = len(points)\n    good_indices = []\n    for k in range(n):\n        is_good = True\n        for i in range(n):\n            for j in range(n):\n                if i != k and j != k and (i != j):\n                    v1 = [points[i][d] - points[k][d] for d in range(5)]\n                    v2 = [points[j][d] - points[k][d] for d in range(5)]\n                    if is_acute_angle(v1, v2):\n                        is_good = False\n                        break\n            if not is_good:\n                break\n        if is_good:\n            good_indices.append(k - 1)\n    return (len(good_indices), good_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "good_indices.append(k + 1)",
      "mutated_line": "good_indices.append(k * 1)",
      "code": "def find_good_points(points):\n\n    def dot_product(v1, v2):\n        return sum((x * y for (x, y) in zip(v1, v2)))\n\n    def vector_length(v):\n        return sum((x ** 2 for x in v)) ** 0.5\n\n    def is_acute_angle(v1, v2):\n        return dot_product(v1, v2) > 0\n    n = len(points)\n    good_indices = []\n    for k in range(n):\n        is_good = True\n        for i in range(n):\n            for j in range(n):\n                if i != k and j != k and (i != j):\n                    v1 = [points[i][d] - points[k][d] for d in range(5)]\n                    v2 = [points[j][d] - points[k][d] for d in range(5)]\n                    if is_acute_angle(v1, v2):\n                        is_good = False\n                        break\n            if not is_good:\n                break\n        if is_good:\n            good_indices.append(k * 1)\n    return (len(good_indices), good_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return sum(x ** 2 for x in v) ** 0.5",
      "mutated_line": "return sum((x * 2 for x in v)) ** 0.5",
      "code": "def find_good_points(points):\n\n    def dot_product(v1, v2):\n        return sum((x * y for (x, y) in zip(v1, v2)))\n\n    def vector_length(v):\n        return sum((x * 2 for x in v)) ** 0.5\n\n    def is_acute_angle(v1, v2):\n        return dot_product(v1, v2) > 0\n    n = len(points)\n    good_indices = []\n    for k in range(n):\n        is_good = True\n        for i in range(n):\n            for j in range(n):\n                if i != k and j != k and (i != j):\n                    v1 = [points[i][d] - points[k][d] for d in range(5)]\n                    v2 = [points[j][d] - points[k][d] for d in range(5)]\n                    if is_acute_angle(v1, v2):\n                        is_good = False\n                        break\n            if not is_good:\n                break\n        if is_good:\n            good_indices.append(k + 1)\n    return (len(good_indices), good_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return sum(x ** 2 for x in v) ** 0.5",
      "mutated_line": "return sum((x + 2 for x in v)) ** 0.5",
      "code": "def find_good_points(points):\n\n    def dot_product(v1, v2):\n        return sum((x * y for (x, y) in zip(v1, v2)))\n\n    def vector_length(v):\n        return sum((x + 2 for x in v)) ** 0.5\n\n    def is_acute_angle(v1, v2):\n        return dot_product(v1, v2) > 0\n    n = len(points)\n    good_indices = []\n    for k in range(n):\n        is_good = True\n        for i in range(n):\n            for j in range(n):\n                if i != k and j != k and (i != j):\n                    v1 = [points[i][d] - points[k][d] for d in range(5)]\n                    v2 = [points[j][d] - points[k][d] for d in range(5)]\n                    if is_acute_angle(v1, v2):\n                        is_good = False\n                        break\n            if not is_good:\n                break\n        if is_good:\n            good_indices.append(k + 1)\n    return (len(good_indices), good_indices)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if i != k and j != k and i != j:",
      "mutated_line": "if i == k and j != k and (i != j):",
      "code": "def find_good_points(points):\n\n    def dot_product(v1, v2):\n        return sum((x * y for (x, y) in zip(v1, v2)))\n\n    def vector_length(v):\n        return sum((x ** 2 for x in v)) ** 0.5\n\n    def is_acute_angle(v1, v2):\n        return dot_product(v1, v2) > 0\n    n = len(points)\n    good_indices = []\n    for k in range(n):\n        is_good = True\n        for i in range(n):\n            for j in range(n):\n                if i == k and j != k and (i != j):\n                    v1 = [points[i][d] - points[k][d] for d in range(5)]\n                    v2 = [points[j][d] - points[k][d] for d in range(5)]\n                    if is_acute_angle(v1, v2):\n                        is_good = False\n                        break\n            if not is_good:\n                break\n        if is_good:\n            good_indices.append(k + 1)\n    return (len(good_indices), good_indices)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if i != k and j != k and i != j:",
      "mutated_line": "if i != k and j == k and (i != j):",
      "code": "def find_good_points(points):\n\n    def dot_product(v1, v2):\n        return sum((x * y for (x, y) in zip(v1, v2)))\n\n    def vector_length(v):\n        return sum((x ** 2 for x in v)) ** 0.5\n\n    def is_acute_angle(v1, v2):\n        return dot_product(v1, v2) > 0\n    n = len(points)\n    good_indices = []\n    for k in range(n):\n        is_good = True\n        for i in range(n):\n            for j in range(n):\n                if i != k and j == k and (i != j):\n                    v1 = [points[i][d] - points[k][d] for d in range(5)]\n                    v2 = [points[j][d] - points[k][d] for d in range(5)]\n                    if is_acute_angle(v1, v2):\n                        is_good = False\n                        break\n            if not is_good:\n                break\n        if is_good:\n            good_indices.append(k + 1)\n    return (len(good_indices), good_indices)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if i != k and j != k and i != j:",
      "mutated_line": "if i != k and j != k and (i == j):",
      "code": "def find_good_points(points):\n\n    def dot_product(v1, v2):\n        return sum((x * y for (x, y) in zip(v1, v2)))\n\n    def vector_length(v):\n        return sum((x ** 2 for x in v)) ** 0.5\n\n    def is_acute_angle(v1, v2):\n        return dot_product(v1, v2) > 0\n    n = len(points)\n    good_indices = []\n    for k in range(n):\n        is_good = True\n        for i in range(n):\n            for j in range(n):\n                if i != k and j != k and (i == j):\n                    v1 = [points[i][d] - points[k][d] for d in range(5)]\n                    v2 = [points[j][d] - points[k][d] for d in range(5)]\n                    if is_acute_angle(v1, v2):\n                        is_good = False\n                        break\n            if not is_good:\n                break\n        if is_good:\n            good_indices.append(k + 1)\n    return (len(good_indices), good_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "good_indices.append(k + 1)",
      "mutated_line": "good_indices.append(k + 2)",
      "code": "def find_good_points(points):\n\n    def dot_product(v1, v2):\n        return sum((x * y for (x, y) in zip(v1, v2)))\n\n    def vector_length(v):\n        return sum((x ** 2 for x in v)) ** 0.5\n\n    def is_acute_angle(v1, v2):\n        return dot_product(v1, v2) > 0\n    n = len(points)\n    good_indices = []\n    for k in range(n):\n        is_good = True\n        for i in range(n):\n            for j in range(n):\n                if i != k and j != k and (i != j):\n                    v1 = [points[i][d] - points[k][d] for d in range(5)]\n                    v2 = [points[j][d] - points[k][d] for d in range(5)]\n                    if is_acute_angle(v1, v2):\n                        is_good = False\n                        break\n            if not is_good:\n                break\n        if is_good:\n            good_indices.append(k + 2)\n    return (len(good_indices), good_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "good_indices.append(k + 1)",
      "mutated_line": "good_indices.append(k + 0)",
      "code": "def find_good_points(points):\n\n    def dot_product(v1, v2):\n        return sum((x * y for (x, y) in zip(v1, v2)))\n\n    def vector_length(v):\n        return sum((x ** 2 for x in v)) ** 0.5\n\n    def is_acute_angle(v1, v2):\n        return dot_product(v1, v2) > 0\n    n = len(points)\n    good_indices = []\n    for k in range(n):\n        is_good = True\n        for i in range(n):\n            for j in range(n):\n                if i != k and j != k and (i != j):\n                    v1 = [points[i][d] - points[k][d] for d in range(5)]\n                    v2 = [points[j][d] - points[k][d] for d in range(5)]\n                    if is_acute_angle(v1, v2):\n                        is_good = False\n                        break\n            if not is_good:\n                break\n        if is_good:\n            good_indices.append(k + 0)\n    return (len(good_indices), good_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "good_indices.append(k + 1)",
      "mutated_line": "good_indices.append(k + 0)",
      "code": "def find_good_points(points):\n\n    def dot_product(v1, v2):\n        return sum((x * y for (x, y) in zip(v1, v2)))\n\n    def vector_length(v):\n        return sum((x ** 2 for x in v)) ** 0.5\n\n    def is_acute_angle(v1, v2):\n        return dot_product(v1, v2) > 0\n    n = len(points)\n    good_indices = []\n    for k in range(n):\n        is_good = True\n        for i in range(n):\n            for j in range(n):\n                if i != k and j != k and (i != j):\n                    v1 = [points[i][d] - points[k][d] for d in range(5)]\n                    v2 = [points[j][d] - points[k][d] for d in range(5)]\n                    if is_acute_angle(v1, v2):\n                        is_good = False\n                        break\n            if not is_good:\n                break\n        if is_good:\n            good_indices.append(k + 0)\n    return (len(good_indices), good_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "good_indices.append(k + 1)",
      "mutated_line": "good_indices.append(k + -1)",
      "code": "def find_good_points(points):\n\n    def dot_product(v1, v2):\n        return sum((x * y for (x, y) in zip(v1, v2)))\n\n    def vector_length(v):\n        return sum((x ** 2 for x in v)) ** 0.5\n\n    def is_acute_angle(v1, v2):\n        return dot_product(v1, v2) > 0\n    n = len(points)\n    good_indices = []\n    for k in range(n):\n        is_good = True\n        for i in range(n):\n            for j in range(n):\n                if i != k and j != k and (i != j):\n                    v1 = [points[i][d] - points[k][d] for d in range(5)]\n                    v2 = [points[j][d] - points[k][d] for d in range(5)]\n                    if is_acute_angle(v1, v2):\n                        is_good = False\n                        break\n            if not is_good:\n                break\n        if is_good:\n            good_indices.append(k + -1)\n    return (len(good_indices), good_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return sum(x ** 2 for x in v) ** 0.5",
      "mutated_line": "return sum((x ** 3 for x in v)) ** 0.5",
      "code": "def find_good_points(points):\n\n    def dot_product(v1, v2):\n        return sum((x * y for (x, y) in zip(v1, v2)))\n\n    def vector_length(v):\n        return sum((x ** 3 for x in v)) ** 0.5\n\n    def is_acute_angle(v1, v2):\n        return dot_product(v1, v2) > 0\n    n = len(points)\n    good_indices = []\n    for k in range(n):\n        is_good = True\n        for i in range(n):\n            for j in range(n):\n                if i != k and j != k and (i != j):\n                    v1 = [points[i][d] - points[k][d] for d in range(5)]\n                    v2 = [points[j][d] - points[k][d] for d in range(5)]\n                    if is_acute_angle(v1, v2):\n                        is_good = False\n                        break\n            if not is_good:\n                break\n        if is_good:\n            good_indices.append(k + 1)\n    return (len(good_indices), good_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return sum(x ** 2 for x in v) ** 0.5",
      "mutated_line": "return sum((x ** 1 for x in v)) ** 0.5",
      "code": "def find_good_points(points):\n\n    def dot_product(v1, v2):\n        return sum((x * y for (x, y) in zip(v1, v2)))\n\n    def vector_length(v):\n        return sum((x ** 1 for x in v)) ** 0.5\n\n    def is_acute_angle(v1, v2):\n        return dot_product(v1, v2) > 0\n    n = len(points)\n    good_indices = []\n    for k in range(n):\n        is_good = True\n        for i in range(n):\n            for j in range(n):\n                if i != k and j != k and (i != j):\n                    v1 = [points[i][d] - points[k][d] for d in range(5)]\n                    v2 = [points[j][d] - points[k][d] for d in range(5)]\n                    if is_acute_angle(v1, v2):\n                        is_good = False\n                        break\n            if not is_good:\n                break\n        if is_good:\n            good_indices.append(k + 1)\n    return (len(good_indices), good_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return sum(x ** 2 for x in v) ** 0.5",
      "mutated_line": "return sum((x ** 0 for x in v)) ** 0.5",
      "code": "def find_good_points(points):\n\n    def dot_product(v1, v2):\n        return sum((x * y for (x, y) in zip(v1, v2)))\n\n    def vector_length(v):\n        return sum((x ** 0 for x in v)) ** 0.5\n\n    def is_acute_angle(v1, v2):\n        return dot_product(v1, v2) > 0\n    n = len(points)\n    good_indices = []\n    for k in range(n):\n        is_good = True\n        for i in range(n):\n            for j in range(n):\n                if i != k and j != k and (i != j):\n                    v1 = [points[i][d] - points[k][d] for d in range(5)]\n                    v2 = [points[j][d] - points[k][d] for d in range(5)]\n                    if is_acute_angle(v1, v2):\n                        is_good = False\n                        break\n            if not is_good:\n                break\n        if is_good:\n            good_indices.append(k + 1)\n    return (len(good_indices), good_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return sum(x ** 2 for x in v) ** 0.5",
      "mutated_line": "return sum((x ** 1 for x in v)) ** 0.5",
      "code": "def find_good_points(points):\n\n    def dot_product(v1, v2):\n        return sum((x * y for (x, y) in zip(v1, v2)))\n\n    def vector_length(v):\n        return sum((x ** 1 for x in v)) ** 0.5\n\n    def is_acute_angle(v1, v2):\n        return dot_product(v1, v2) > 0\n    n = len(points)\n    good_indices = []\n    for k in range(n):\n        is_good = True\n        for i in range(n):\n            for j in range(n):\n                if i != k and j != k and (i != j):\n                    v1 = [points[i][d] - points[k][d] for d in range(5)]\n                    v2 = [points[j][d] - points[k][d] for d in range(5)]\n                    if is_acute_angle(v1, v2):\n                        is_good = False\n                        break\n            if not is_good:\n                break\n        if is_good:\n            good_indices.append(k + 1)\n    return (len(good_indices), good_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return sum(x ** 2 for x in v) ** 0.5",
      "mutated_line": "return sum((x ** -2 for x in v)) ** 0.5",
      "code": "def find_good_points(points):\n\n    def dot_product(v1, v2):\n        return sum((x * y for (x, y) in zip(v1, v2)))\n\n    def vector_length(v):\n        return sum((x ** -2 for x in v)) ** 0.5\n\n    def is_acute_angle(v1, v2):\n        return dot_product(v1, v2) > 0\n    n = len(points)\n    good_indices = []\n    for k in range(n):\n        is_good = True\n        for i in range(n):\n            for j in range(n):\n                if i != k and j != k and (i != j):\n                    v1 = [points[i][d] - points[k][d] for d in range(5)]\n                    v2 = [points[j][d] - points[k][d] for d in range(5)]\n                    if is_acute_angle(v1, v2):\n                        is_good = False\n                        break\n            if not is_good:\n                break\n        if is_good:\n            good_indices.append(k + 1)\n    return (len(good_indices), good_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "v1 = [points[i][d] - points[k][d] for d in range(5)]",
      "mutated_line": "v1 = [points[i][d] + points[k][d] for d in range(5)]",
      "code": "def find_good_points(points):\n\n    def dot_product(v1, v2):\n        return sum((x * y for (x, y) in zip(v1, v2)))\n\n    def vector_length(v):\n        return sum((x ** 2 for x in v)) ** 0.5\n\n    def is_acute_angle(v1, v2):\n        return dot_product(v1, v2) > 0\n    n = len(points)\n    good_indices = []\n    for k in range(n):\n        is_good = True\n        for i in range(n):\n            for j in range(n):\n                if i != k and j != k and (i != j):\n                    v1 = [points[i][d] + points[k][d] for d in range(5)]\n                    v2 = [points[j][d] - points[k][d] for d in range(5)]\n                    if is_acute_angle(v1, v2):\n                        is_good = False\n                        break\n            if not is_good:\n                break\n        if is_good:\n            good_indices.append(k + 1)\n    return (len(good_indices), good_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "v1 = [points[i][d] - points[k][d] for d in range(5)]",
      "mutated_line": "v1 = [points[i][d] * points[k][d] for d in range(5)]",
      "code": "def find_good_points(points):\n\n    def dot_product(v1, v2):\n        return sum((x * y for (x, y) in zip(v1, v2)))\n\n    def vector_length(v):\n        return sum((x ** 2 for x in v)) ** 0.5\n\n    def is_acute_angle(v1, v2):\n        return dot_product(v1, v2) > 0\n    n = len(points)\n    good_indices = []\n    for k in range(n):\n        is_good = True\n        for i in range(n):\n            for j in range(n):\n                if i != k and j != k and (i != j):\n                    v1 = [points[i][d] * points[k][d] for d in range(5)]\n                    v2 = [points[j][d] - points[k][d] for d in range(5)]\n                    if is_acute_angle(v1, v2):\n                        is_good = False\n                        break\n            if not is_good:\n                break\n        if is_good:\n            good_indices.append(k + 1)\n    return (len(good_indices), good_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "v2 = [points[j][d] - points[k][d] for d in range(5)]",
      "mutated_line": "v2 = [points[j][d] + points[k][d] for d in range(5)]",
      "code": "def find_good_points(points):\n\n    def dot_product(v1, v2):\n        return sum((x * y for (x, y) in zip(v1, v2)))\n\n    def vector_length(v):\n        return sum((x ** 2 for x in v)) ** 0.5\n\n    def is_acute_angle(v1, v2):\n        return dot_product(v1, v2) > 0\n    n = len(points)\n    good_indices = []\n    for k in range(n):\n        is_good = True\n        for i in range(n):\n            for j in range(n):\n                if i != k and j != k and (i != j):\n                    v1 = [points[i][d] - points[k][d] for d in range(5)]\n                    v2 = [points[j][d] + points[k][d] for d in range(5)]\n                    if is_acute_angle(v1, v2):\n                        is_good = False\n                        break\n            if not is_good:\n                break\n        if is_good:\n            good_indices.append(k + 1)\n    return (len(good_indices), good_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "v2 = [points[j][d] - points[k][d] for d in range(5)]",
      "mutated_line": "v2 = [points[j][d] * points[k][d] for d in range(5)]",
      "code": "def find_good_points(points):\n\n    def dot_product(v1, v2):\n        return sum((x * y for (x, y) in zip(v1, v2)))\n\n    def vector_length(v):\n        return sum((x ** 2 for x in v)) ** 0.5\n\n    def is_acute_angle(v1, v2):\n        return dot_product(v1, v2) > 0\n    n = len(points)\n    good_indices = []\n    for k in range(n):\n        is_good = True\n        for i in range(n):\n            for j in range(n):\n                if i != k and j != k and (i != j):\n                    v1 = [points[i][d] - points[k][d] for d in range(5)]\n                    v2 = [points[j][d] * points[k][d] for d in range(5)]\n                    if is_acute_angle(v1, v2):\n                        is_good = False\n                        break\n            if not is_good:\n                break\n        if is_good:\n            good_indices.append(k + 1)\n    return (len(good_indices), good_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "is_good = False",
      "mutated_line": "is_good = True",
      "code": "def find_good_points(points):\n\n    def dot_product(v1, v2):\n        return sum((x * y for (x, y) in zip(v1, v2)))\n\n    def vector_length(v):\n        return sum((x ** 2 for x in v)) ** 0.5\n\n    def is_acute_angle(v1, v2):\n        return dot_product(v1, v2) > 0\n    n = len(points)\n    good_indices = []\n    for k in range(n):\n        is_good = True\n        for i in range(n):\n            for j in range(n):\n                if i != k and j != k and (i != j):\n                    v1 = [points[i][d] - points[k][d] for d in range(5)]\n                    v2 = [points[j][d] - points[k][d] for d in range(5)]\n                    if is_acute_angle(v1, v2):\n                        is_good = True\n                        break\n            if not is_good:\n                break\n        if is_good:\n            good_indices.append(k + 1)\n    return (len(good_indices), good_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "v1 = [points[i][d] - points[k][d] for d in range(5)]",
      "mutated_line": "v1 = [points[i][d] - points[k][d] for d in range(6)]",
      "code": "def find_good_points(points):\n\n    def dot_product(v1, v2):\n        return sum((x * y for (x, y) in zip(v1, v2)))\n\n    def vector_length(v):\n        return sum((x ** 2 for x in v)) ** 0.5\n\n    def is_acute_angle(v1, v2):\n        return dot_product(v1, v2) > 0\n    n = len(points)\n    good_indices = []\n    for k in range(n):\n        is_good = True\n        for i in range(n):\n            for j in range(n):\n                if i != k and j != k and (i != j):\n                    v1 = [points[i][d] - points[k][d] for d in range(6)]\n                    v2 = [points[j][d] - points[k][d] for d in range(5)]\n                    if is_acute_angle(v1, v2):\n                        is_good = False\n                        break\n            if not is_good:\n                break\n        if is_good:\n            good_indices.append(k + 1)\n    return (len(good_indices), good_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "v1 = [points[i][d] - points[k][d] for d in range(5)]",
      "mutated_line": "v1 = [points[i][d] - points[k][d] for d in range(4)]",
      "code": "def find_good_points(points):\n\n    def dot_product(v1, v2):\n        return sum((x * y for (x, y) in zip(v1, v2)))\n\n    def vector_length(v):\n        return sum((x ** 2 for x in v)) ** 0.5\n\n    def is_acute_angle(v1, v2):\n        return dot_product(v1, v2) > 0\n    n = len(points)\n    good_indices = []\n    for k in range(n):\n        is_good = True\n        for i in range(n):\n            for j in range(n):\n                if i != k and j != k and (i != j):\n                    v1 = [points[i][d] - points[k][d] for d in range(4)]\n                    v2 = [points[j][d] - points[k][d] for d in range(5)]\n                    if is_acute_angle(v1, v2):\n                        is_good = False\n                        break\n            if not is_good:\n                break\n        if is_good:\n            good_indices.append(k + 1)\n    return (len(good_indices), good_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "v1 = [points[i][d] - points[k][d] for d in range(5)]",
      "mutated_line": "v1 = [points[i][d] - points[k][d] for d in range(0)]",
      "code": "def find_good_points(points):\n\n    def dot_product(v1, v2):\n        return sum((x * y for (x, y) in zip(v1, v2)))\n\n    def vector_length(v):\n        return sum((x ** 2 for x in v)) ** 0.5\n\n    def is_acute_angle(v1, v2):\n        return dot_product(v1, v2) > 0\n    n = len(points)\n    good_indices = []\n    for k in range(n):\n        is_good = True\n        for i in range(n):\n            for j in range(n):\n                if i != k and j != k and (i != j):\n                    v1 = [points[i][d] - points[k][d] for d in range(0)]\n                    v2 = [points[j][d] - points[k][d] for d in range(5)]\n                    if is_acute_angle(v1, v2):\n                        is_good = False\n                        break\n            if not is_good:\n                break\n        if is_good:\n            good_indices.append(k + 1)\n    return (len(good_indices), good_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "v1 = [points[i][d] - points[k][d] for d in range(5)]",
      "mutated_line": "v1 = [points[i][d] - points[k][d] for d in range(1)]",
      "code": "def find_good_points(points):\n\n    def dot_product(v1, v2):\n        return sum((x * y for (x, y) in zip(v1, v2)))\n\n    def vector_length(v):\n        return sum((x ** 2 for x in v)) ** 0.5\n\n    def is_acute_angle(v1, v2):\n        return dot_product(v1, v2) > 0\n    n = len(points)\n    good_indices = []\n    for k in range(n):\n        is_good = True\n        for i in range(n):\n            for j in range(n):\n                if i != k and j != k and (i != j):\n                    v1 = [points[i][d] - points[k][d] for d in range(1)]\n                    v2 = [points[j][d] - points[k][d] for d in range(5)]\n                    if is_acute_angle(v1, v2):\n                        is_good = False\n                        break\n            if not is_good:\n                break\n        if is_good:\n            good_indices.append(k + 1)\n    return (len(good_indices), good_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "v1 = [points[i][d] - points[k][d] for d in range(5)]",
      "mutated_line": "v1 = [points[i][d] - points[k][d] for d in range(-5)]",
      "code": "def find_good_points(points):\n\n    def dot_product(v1, v2):\n        return sum((x * y for (x, y) in zip(v1, v2)))\n\n    def vector_length(v):\n        return sum((x ** 2 for x in v)) ** 0.5\n\n    def is_acute_angle(v1, v2):\n        return dot_product(v1, v2) > 0\n    n = len(points)\n    good_indices = []\n    for k in range(n):\n        is_good = True\n        for i in range(n):\n            for j in range(n):\n                if i != k and j != k and (i != j):\n                    v1 = [points[i][d] - points[k][d] for d in range(-5)]\n                    v2 = [points[j][d] - points[k][d] for d in range(5)]\n                    if is_acute_angle(v1, v2):\n                        is_good = False\n                        break\n            if not is_good:\n                break\n        if is_good:\n            good_indices.append(k + 1)\n    return (len(good_indices), good_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "v2 = [points[j][d] - points[k][d] for d in range(5)]",
      "mutated_line": "v2 = [points[j][d] - points[k][d] for d in range(6)]",
      "code": "def find_good_points(points):\n\n    def dot_product(v1, v2):\n        return sum((x * y for (x, y) in zip(v1, v2)))\n\n    def vector_length(v):\n        return sum((x ** 2 for x in v)) ** 0.5\n\n    def is_acute_angle(v1, v2):\n        return dot_product(v1, v2) > 0\n    n = len(points)\n    good_indices = []\n    for k in range(n):\n        is_good = True\n        for i in range(n):\n            for j in range(n):\n                if i != k and j != k and (i != j):\n                    v1 = [points[i][d] - points[k][d] for d in range(5)]\n                    v2 = [points[j][d] - points[k][d] for d in range(6)]\n                    if is_acute_angle(v1, v2):\n                        is_good = False\n                        break\n            if not is_good:\n                break\n        if is_good:\n            good_indices.append(k + 1)\n    return (len(good_indices), good_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "v2 = [points[j][d] - points[k][d] for d in range(5)]",
      "mutated_line": "v2 = [points[j][d] - points[k][d] for d in range(4)]",
      "code": "def find_good_points(points):\n\n    def dot_product(v1, v2):\n        return sum((x * y for (x, y) in zip(v1, v2)))\n\n    def vector_length(v):\n        return sum((x ** 2 for x in v)) ** 0.5\n\n    def is_acute_angle(v1, v2):\n        return dot_product(v1, v2) > 0\n    n = len(points)\n    good_indices = []\n    for k in range(n):\n        is_good = True\n        for i in range(n):\n            for j in range(n):\n                if i != k and j != k and (i != j):\n                    v1 = [points[i][d] - points[k][d] for d in range(5)]\n                    v2 = [points[j][d] - points[k][d] for d in range(4)]\n                    if is_acute_angle(v1, v2):\n                        is_good = False\n                        break\n            if not is_good:\n                break\n        if is_good:\n            good_indices.append(k + 1)\n    return (len(good_indices), good_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "v2 = [points[j][d] - points[k][d] for d in range(5)]",
      "mutated_line": "v2 = [points[j][d] - points[k][d] for d in range(0)]",
      "code": "def find_good_points(points):\n\n    def dot_product(v1, v2):\n        return sum((x * y for (x, y) in zip(v1, v2)))\n\n    def vector_length(v):\n        return sum((x ** 2 for x in v)) ** 0.5\n\n    def is_acute_angle(v1, v2):\n        return dot_product(v1, v2) > 0\n    n = len(points)\n    good_indices = []\n    for k in range(n):\n        is_good = True\n        for i in range(n):\n            for j in range(n):\n                if i != k and j != k and (i != j):\n                    v1 = [points[i][d] - points[k][d] for d in range(5)]\n                    v2 = [points[j][d] - points[k][d] for d in range(0)]\n                    if is_acute_angle(v1, v2):\n                        is_good = False\n                        break\n            if not is_good:\n                break\n        if is_good:\n            good_indices.append(k + 1)\n    return (len(good_indices), good_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "v2 = [points[j][d] - points[k][d] for d in range(5)]",
      "mutated_line": "v2 = [points[j][d] - points[k][d] for d in range(1)]",
      "code": "def find_good_points(points):\n\n    def dot_product(v1, v2):\n        return sum((x * y for (x, y) in zip(v1, v2)))\n\n    def vector_length(v):\n        return sum((x ** 2 for x in v)) ** 0.5\n\n    def is_acute_angle(v1, v2):\n        return dot_product(v1, v2) > 0\n    n = len(points)\n    good_indices = []\n    for k in range(n):\n        is_good = True\n        for i in range(n):\n            for j in range(n):\n                if i != k and j != k and (i != j):\n                    v1 = [points[i][d] - points[k][d] for d in range(5)]\n                    v2 = [points[j][d] - points[k][d] for d in range(1)]\n                    if is_acute_angle(v1, v2):\n                        is_good = False\n                        break\n            if not is_good:\n                break\n        if is_good:\n            good_indices.append(k + 1)\n    return (len(good_indices), good_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "v2 = [points[j][d] - points[k][d] for d in range(5)]",
      "mutated_line": "v2 = [points[j][d] - points[k][d] for d in range(-5)]",
      "code": "def find_good_points(points):\n\n    def dot_product(v1, v2):\n        return sum((x * y for (x, y) in zip(v1, v2)))\n\n    def vector_length(v):\n        return sum((x ** 2 for x in v)) ** 0.5\n\n    def is_acute_angle(v1, v2):\n        return dot_product(v1, v2) > 0\n    n = len(points)\n    good_indices = []\n    for k in range(n):\n        is_good = True\n        for i in range(n):\n            for j in range(n):\n                if i != k and j != k and (i != j):\n                    v1 = [points[i][d] - points[k][d] for d in range(5)]\n                    v2 = [points[j][d] - points[k][d] for d in range(-5)]\n                    if is_acute_angle(v1, v2):\n                        is_good = False\n                        break\n            if not is_good:\n                break\n        if is_good:\n            good_indices.append(k + 1)\n    return (len(good_indices), good_indices)"
    }
  ]
}