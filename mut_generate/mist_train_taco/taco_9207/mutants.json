{
  "task_id": "taco_9207",
  "entry_point": "find_max_number_on_scoreboard",
  "mutant_count": 187,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "possible[-1][0] = True",
      "mutated_line": "possible[-1][0] = False",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = False\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "i = i - (i >> 1 & 1431655765)",
      "mutated_line": "i = i + (i >> 1 & 1431655765)",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i + (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "i = i - (i >> 1 & 1431655765)",
      "mutated_line": "i = i * (i >> 1 & 1431655765)",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i * (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "i = (i & 858993459) + (i >> 2 & 858993459)",
      "mutated_line": "i = (i & 858993459) - (i >> 2 & 858993459)",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) - (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "i = (i & 858993459) + (i >> 2 & 858993459)",
      "mutated_line": "i = (i & 858993459) * (i >> 2 & 858993459)",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) * (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "possible[-1][0] = True",
      "mutated_line": "possible[-1][1] = True",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][1] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "possible[-1][0] = True",
      "mutated_line": "possible[-1][-1] = True",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][-1] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "possible[-1][0] = True",
      "mutated_line": "possible[-1][1] = True",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][1] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "UOI",
      "lineno": 33,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return +1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n + 1, -1, -1):",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n + 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n * 1, -1, -1):",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n * 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "UOI",
      "lineno": 36,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, +1, -1):",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, +1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "UOI",
      "lineno": 36,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -1, +1):",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, +1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return ''.join(ans).rjust(n, '0')",
      "mutated_line": "return ''.join(ans).rjust(n, '')",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '')"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "i = i - (i >> 1 & 1431655765)",
      "mutated_line": "i = i - (i >> 1 | 1431655765)",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 | 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "i = (i & 858993459) + (i >> 2 & 858993459)",
      "mutated_line": "i = (i | 858993459) + (i >> 2 & 858993459)",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i | 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "i = (i & 858993459) + (i >> 2 & 858993459)",
      "mutated_line": "i = (i & 858993459) + (i >> 2 | 858993459)",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 | 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24",
      "mutated_line": "return ((i + (i >> 4) & 252645135) * 16843009 | 4294967295) >> 24",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 | 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24",
      "mutated_line": "return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 25",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 25\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24",
      "mutated_line": "return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 23",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 23\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24",
      "mutated_line": "return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 0",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 0\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24",
      "mutated_line": "return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 1",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 1\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24",
      "mutated_line": "return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> -24",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> -24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "UOI",
      "lineno": 8,
      "original_line": "for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:",
      "mutated_line": "for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::+1]:",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::+1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "digits = [int(d, 2) for d in digits[::-1]]",
      "mutated_line": "digits = [int(d, 3) for d in digits[::-1]]",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 3) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "digits = [int(d, 2) for d in digits[::-1]]",
      "mutated_line": "digits = [int(d, 1) for d in digits[::-1]]",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 1) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "digits = [int(d, 2) for d in digits[::-1]]",
      "mutated_line": "digits = [int(d, 0) for d in digits[::-1]]",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 0) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "digits = [int(d, 2) for d in digits[::-1]]",
      "mutated_line": "digits = [int(d, 1) for d in digits[::-1]]",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 1) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "digits = [int(d, 2) for d in digits[::-1]]",
      "mutated_line": "digits = [int(d, -2) for d in digits[::-1]]",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, -2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if d & b == d:",
      "mutated_line": "if d & b != d:",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b != d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "possible = [[False for i in range(k + 1)]]",
      "mutated_line": "possible = [[True for i in range(k + 1)]]",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[True for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "UOI",
      "lineno": 22,
      "original_line": "possible[-1][0] = True",
      "mutated_line": "possible[+1][0] = True",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[+1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "nextPossible = [False for i in range(k + 1)]",
      "mutated_line": "nextPossible = [True for i in range(k + 1)]",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [True for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "for k_ in range(k + 1):",
      "mutated_line": "for k_ in range(k - 1):",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k - 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "for k_ in range(k + 1):",
      "mutated_line": "for k_ in range(k * 1):",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k * 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -2\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -0\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -0\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return --1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 2, -1, -1):",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 2, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 0, -1, -1):",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 0, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 0, -1, -1):",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 0, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - -1, -1, -1):",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - -1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -2, -1):",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -2, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -0, -1):",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -0, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -0, -1):",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -0, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, --1, -1):",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, --1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -1, -2):",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -2):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -1, -0):",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -0):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -1, -0):",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -0):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -1, --1):",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, --1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if d & b == d:",
      "mutated_line": "if d & b != d:",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b != d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "i = i - (i >> 1 & 1431655765)",
      "mutated_line": "i = i - (i >> 1 & 1431655766)",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655766)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "i = i - (i >> 1 & 1431655765)",
      "mutated_line": "i = i - (i >> 1 & 1431655764)",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655764)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "i = i - (i >> 1 & 1431655765)",
      "mutated_line": "i = i - (i >> 1 & 0)",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 0)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "i = i - (i >> 1 & 1431655765)",
      "mutated_line": "i = i - (i >> 1 & 1)",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "i = i - (i >> 1 & 1431655765)",
      "mutated_line": "i = i - (i >> 1 & -1431655765)",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & -1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "i = (i & 858993459) + (i >> 2 & 858993459)",
      "mutated_line": "i = (i & 858993460) + (i >> 2 & 858993459)",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993460) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "i = (i & 858993459) + (i >> 2 & 858993459)",
      "mutated_line": "i = (i & 858993458) + (i >> 2 & 858993459)",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993458) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "i = (i & 858993459) + (i >> 2 & 858993459)",
      "mutated_line": "i = (i & 0) + (i >> 2 & 858993459)",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 0) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "i = (i & 858993459) + (i >> 2 & 858993459)",
      "mutated_line": "i = (i & 1) + (i >> 2 & 858993459)",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 1) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "i = (i & 858993459) + (i >> 2 & 858993459)",
      "mutated_line": "i = (i & -858993459) + (i >> 2 & 858993459)",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & -858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "i = (i & 858993459) + (i >> 2 & 858993459)",
      "mutated_line": "i = (i & 858993459) + (i >> 2 & 858993460)",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993460)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "i = (i & 858993459) + (i >> 2 & 858993459)",
      "mutated_line": "i = (i & 858993459) + (i >> 2 & 858993458)",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993458)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "i = (i & 858993459) + (i >> 2 & 858993459)",
      "mutated_line": "i = (i & 858993459) + (i >> 2 & 0)",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 0)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "i = (i & 858993459) + (i >> 2 & 858993459)",
      "mutated_line": "i = (i & 858993459) + (i >> 2 & 1)",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 1)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "i = (i & 858993459) + (i >> 2 & 858993459)",
      "mutated_line": "i = (i & 858993459) + (i >> 2 & -858993459)",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & -858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24",
      "mutated_line": "return ((i + (i >> 4) & 252645135) / 16843009 & 4294967295) >> 24",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) / 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24",
      "mutated_line": "return ((i + (i >> 4) & 252645135) + 16843009 & 4294967295) >> 24",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) + 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24",
      "mutated_line": "return ((i + (i >> 4) & 252645135) ** 16843009 & 4294967295) >> 24",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) ** 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24",
      "mutated_line": "return ((i + (i >> 4) & 252645135) * 16843009 & 4294967296) >> 24",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967296) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24",
      "mutated_line": "return ((i + (i >> 4) & 252645135) * 16843009 & 4294967294) >> 24",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967294) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24",
      "mutated_line": "return ((i + (i >> 4) & 252645135) * 16843009 & 0) >> 24",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 0) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24",
      "mutated_line": "return ((i + (i >> 4) & 252645135) * 16843009 & 1) >> 24",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 1) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24",
      "mutated_line": "return ((i + (i >> 4) & 252645135) * 16843009 & -4294967295) >> 24",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & -4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:",
      "mutated_line": "for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-2]:",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-2]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:",
      "mutated_line": "for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-0]:",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-0]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:",
      "mutated_line": "for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-0]:",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-0]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:",
      "mutated_line": "for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::--1]:",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::--1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "binaryToDecimal[int(x, 2)] = i",
      "mutated_line": "binaryToDecimal[int(x, 3)] = i",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 3)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "binaryToDecimal[int(x, 2)] = i",
      "mutated_line": "binaryToDecimal[int(x, 1)] = i",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 1)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "binaryToDecimal[int(x, 2)] = i",
      "mutated_line": "binaryToDecimal[int(x, 0)] = i",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 0)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "binaryToDecimal[int(x, 2)] = i",
      "mutated_line": "binaryToDecimal[int(x, 1)] = i",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 1)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "binaryToDecimal[int(x, 2)] = i",
      "mutated_line": "binaryToDecimal[int(x, -2)] = i",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, -2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if d & b == d:",
      "mutated_line": "if d | b == d:",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d | b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "possible[-1][0] = True",
      "mutated_line": "possible[-2][0] = True",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-2][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "possible[-1][0] = True",
      "mutated_line": "possible[-0][0] = True",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-0][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "possible[-1][0] = True",
      "mutated_line": "possible[-0][0] = True",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-0][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "possible[-1][0] = True",
      "mutated_line": "possible[--1][0] = True",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[--1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for k_ in range(k + 1):",
      "mutated_line": "for k_ in range(k + 2):",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 2):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for k_ in range(k + 1):",
      "mutated_line": "for k_ in range(k + 0):",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 0):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for k_ in range(k + 1):",
      "mutated_line": "for k_ in range(k + 0):",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 0):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for k_ in range(k + 1):",
      "mutated_line": "for k_ in range(k + -1):",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + -1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "if d & b == d:",
      "mutated_line": "if d | b == d:",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d | b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "LCR",
      "lineno": 41,
      "original_line": "if k - cost >= 0 and possible[i][k - cost]:",
      "mutated_line": "if k - cost >= 0 or possible[i][k - cost]:",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 or possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "ASR",
      "lineno": 43,
      "original_line": "k -= cost",
      "mutated_line": "k += cost",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k += cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "i = i - (i >> 1 & 1431655765)",
      "mutated_line": "i = i - (i >> 2 & 1431655765)",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 2 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "i = i - (i >> 1 & 1431655765)",
      "mutated_line": "i = i - (i >> 0 & 1431655765)",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 0 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "i = i - (i >> 1 & 1431655765)",
      "mutated_line": "i = i - (i >> 0 & 1431655765)",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 0 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "i = i - (i >> 1 & 1431655765)",
      "mutated_line": "i = i - (i >> -1 & 1431655765)",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> -1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "i = (i & 858993459) + (i >> 2 & 858993459)",
      "mutated_line": "i = (i & 858993459) + (i >> 3 & 858993459)",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 3 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "i = (i & 858993459) + (i >> 2 & 858993459)",
      "mutated_line": "i = (i & 858993459) + (i >> 1 & 858993459)",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 1 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "i = (i & 858993459) + (i >> 2 & 858993459)",
      "mutated_line": "i = (i & 858993459) + (i >> 0 & 858993459)",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 0 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "i = (i & 858993459) + (i >> 2 & 858993459)",
      "mutated_line": "i = (i & 858993459) + (i >> 1 & 858993459)",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 1 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "i = (i & 858993459) + (i >> 2 & 858993459)",
      "mutated_line": "i = (i & 858993459) + (i >> -2 & 858993459)",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> -2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24",
      "mutated_line": "return ((i + (i >> 4) | 252645135) * 16843009 & 4294967295) >> 24",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) | 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24",
      "mutated_line": "return ((i + (i >> 4) & 252645135) * 16843010 & 4294967295) >> 24",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843010 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24",
      "mutated_line": "return ((i + (i >> 4) & 252645135) * 16843008 & 4294967295) >> 24",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843008 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24",
      "mutated_line": "return ((i + (i >> 4) & 252645135) * 0 & 4294967295) >> 24",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 0 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24",
      "mutated_line": "return ((i + (i >> 4) & 252645135) * 1 & 4294967295) >> 24",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 1 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24",
      "mutated_line": "return ((i + (i >> 4) & 252645135) * -16843009 & 4294967295) >> 24",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * -16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:",
      "mutated_line": "for (i, x) in list(enumerate(['', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:",
      "mutated_line": "for (i, x) in list(enumerate(['1110111', '', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:",
      "mutated_line": "for (i, x) in list(enumerate(['1110111', '0010010', '', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:",
      "mutated_line": "for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:",
      "mutated_line": "for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:",
      "mutated_line": "for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '', '1101111', '1010010', '1111111', '1111011']))[::-1]:",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:",
      "mutated_line": "for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '', '1010010', '1111111', '1111011']))[::-1]:",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:",
      "mutated_line": "for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '', '1111111', '1111011']))[::-1]:",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:",
      "mutated_line": "for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '', '1111011']))[::-1]:",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:",
      "mutated_line": "for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '']))[::-1]:",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "UOI",
      "lineno": 11,
      "original_line": "digits = [int(d, 2) for d in digits[::-1]]",
      "mutated_line": "digits = [int(d, 2) for d in digits[::+1]]",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::+1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "costs = [[] for i in range(1 << 7)]",
      "mutated_line": "costs = [[] for i in range(2 << 7)]",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(2 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "costs = [[] for i in range(1 << 7)]",
      "mutated_line": "costs = [[] for i in range(0 << 7)]",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(0 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "costs = [[] for i in range(1 << 7)]",
      "mutated_line": "costs = [[] for i in range(0 << 7)]",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(0 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "costs = [[] for i in range(1 << 7)]",
      "mutated_line": "costs = [[] for i in range(-1 << 7)]",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(-1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "costs = [[] for i in range(1 << 7)]",
      "mutated_line": "costs = [[] for i in range(1 << 8)]",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 8)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "costs = [[] for i in range(1 << 7)]",
      "mutated_line": "costs = [[] for i in range(1 << 6)]",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 6)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "costs = [[] for i in range(1 << 7)]",
      "mutated_line": "costs = [[] for i in range(1 << 0)]",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 0)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "costs = [[] for i in range(1 << 7)]",
      "mutated_line": "costs = [[] for i in range(1 << 1)]",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 1)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "costs = [[] for i in range(1 << 7)]",
      "mutated_line": "costs = [[] for i in range(1 << -7)]",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << -7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "cost = popcount(b - d)",
      "mutated_line": "cost = popcount(b + d)",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b + d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "cost = popcount(b - d)",
      "mutated_line": "cost = popcount(b * d)",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b * d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "possible = [[False for i in range(k + 1)]]",
      "mutated_line": "possible = [[False for i in range(k - 1)]]",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k - 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "possible = [[False for i in range(k + 1)]]",
      "mutated_line": "possible = [[False for i in range(k * 1)]]",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k * 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "nextPossible = [False for i in range(k + 1)]",
      "mutated_line": "nextPossible = [False for i in range(k - 1)]",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k - 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "nextPossible = [False for i in range(k + 1)]",
      "mutated_line": "nextPossible = [False for i in range(k * 1)]",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k * 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "UOI",
      "lineno": 26,
      "original_line": "if possible[-1][k_]:",
      "mutated_line": "if possible[+1][k_]:",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[+1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if k_ + cost <= k:",
      "mutated_line": "if k_ + cost < k:",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost < k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if k_ + cost <= k:",
      "mutated_line": "if k_ + cost > k:",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost > k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if k_ + cost <= k:",
      "mutated_line": "if k_ + cost == k:",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost == k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "cost = popcount(b - d)",
      "mutated_line": "cost = popcount(b + d)",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b + d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "cost = popcount(b - d)",
      "mutated_line": "cost = popcount(b * d)",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b * d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if k - cost >= 0 and possible[i][k - cost]:",
      "mutated_line": "if k - cost > 0 and possible[i][k - cost]:",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost > 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if k - cost >= 0 and possible[i][k - cost]:",
      "mutated_line": "if k - cost < 0 and possible[i][k - cost]:",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost < 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if k - cost >= 0 and possible[i][k - cost]:",
      "mutated_line": "if k - cost == 0 and possible[i][k - cost]:",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost == 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return ''.join(ans).rjust(n, '0')",
      "mutated_line": "return 'MUTATED'.join(ans).rjust(n, '0')",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return 'MUTATED'.join(ans).rjust(n, '0')"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24",
      "mutated_line": "return ((i - (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i - (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24",
      "mutated_line": "return ((i * (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i * (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24",
      "mutated_line": "return ((i + (i >> 4) & 252645136) * 16843009 & 4294967295) >> 24",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645136) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24",
      "mutated_line": "return ((i + (i >> 4) & 252645134) * 16843009 & 4294967295) >> 24",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645134) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24",
      "mutated_line": "return ((i + (i >> 4) & 0) * 16843009 & 4294967295) >> 24",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 0) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24",
      "mutated_line": "return ((i + (i >> 4) & 1) * 16843009 & 4294967295) >> 24",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 1) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24",
      "mutated_line": "return ((i + (i >> 4) & -252645135) * 16843009 & 4294967295) >> 24",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & -252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "digits = [int(d, 2) for d in digits[::-1]]",
      "mutated_line": "digits = [int(d, 2) for d in digits[::-2]]",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-2]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "digits = [int(d, 2) for d in digits[::-1]]",
      "mutated_line": "digits = [int(d, 2) for d in digits[::-0]]",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-0]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "digits = [int(d, 2) for d in digits[::-1]]",
      "mutated_line": "digits = [int(d, 2) for d in digits[::-0]]",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-0]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "digits = [int(d, 2) for d in digits[::-1]]",
      "mutated_line": "digits = [int(d, 2) for d in digits[::--1]]",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::--1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "possible = [[False for i in range(k + 1)]]",
      "mutated_line": "possible = [[False for i in range(k + 2)]]",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 2)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "possible = [[False for i in range(k + 1)]]",
      "mutated_line": "possible = [[False for i in range(k + 0)]]",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 0)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "possible = [[False for i in range(k + 1)]]",
      "mutated_line": "possible = [[False for i in range(k + 0)]]",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 0)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "possible = [[False for i in range(k + 1)]]",
      "mutated_line": "possible = [[False for i in range(k + -1)]]",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + -1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "nextPossible = [False for i in range(k + 1)]",
      "mutated_line": "nextPossible = [False for i in range(k + 2)]",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 2)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "nextPossible = [False for i in range(k + 1)]",
      "mutated_line": "nextPossible = [False for i in range(k + 0)]",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 0)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "nextPossible = [False for i in range(k + 1)]",
      "mutated_line": "nextPossible = [False for i in range(k + 0)]",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 0)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "nextPossible = [False for i in range(k + 1)]",
      "mutated_line": "nextPossible = [False for i in range(k + -1)]",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + -1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if possible[-1][k_]:",
      "mutated_line": "if possible[-2][k_]:",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-2][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if possible[-1][k_]:",
      "mutated_line": "if possible[-0][k_]:",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-0][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if possible[-1][k_]:",
      "mutated_line": "if possible[-0][k_]:",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-0][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if possible[-1][k_]:",
      "mutated_line": "if possible[--1][k_]:",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[--1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if k_ + cost <= k:",
      "mutated_line": "if k_ - cost <= k:",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ - cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if k_ + cost <= k:",
      "mutated_line": "if k_ * cost <= k:",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ * cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "nextPossible[k_ + cost] = True",
      "mutated_line": "nextPossible[k_ + cost] = False",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = False\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "if k - cost >= 0 and possible[i][k - cost]:",
      "mutated_line": "if k + cost >= 0 and possible[i][k - cost]:",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k + cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "if k - cost >= 0 and possible[i][k - cost]:",
      "mutated_line": "if k * cost >= 0 and possible[i][k - cost]:",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k * cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if k - cost >= 0 and possible[i][k - cost]:",
      "mutated_line": "if k - cost >= 1 and possible[i][k - cost]:",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 1 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if k - cost >= 0 and possible[i][k - cost]:",
      "mutated_line": "if k - cost >= -1 and possible[i][k - cost]:",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= -1 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if k - cost >= 0 and possible[i][k - cost]:",
      "mutated_line": "if k - cost >= 1 and possible[i][k - cost]:",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 1 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "if k - cost >= 0 and possible[i][k - cost]:",
      "mutated_line": "if k - cost >= 0 and possible[i][k + cost]:",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k + cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "if k - cost >= 0 and possible[i][k - cost]:",
      "mutated_line": "if k - cost >= 0 and possible[i][k * cost]:",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k * cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "nextPossible[k_ + cost] = True",
      "mutated_line": "nextPossible[k_ - cost] = True",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ - cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "nextPossible[k_ + cost] = True",
      "mutated_line": "nextPossible[k_ * cost] = True",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ * cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24",
      "mutated_line": "return ((i + (i >> 5) & 252645135) * 16843009 & 4294967295) >> 24",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 5) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24",
      "mutated_line": "return ((i + (i >> 3) & 252645135) * 16843009 & 4294967295) >> 24",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 3) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24",
      "mutated_line": "return ((i + (i >> 0) & 252645135) * 16843009 & 4294967295) >> 24",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 0) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24",
      "mutated_line": "return ((i + (i >> 1) & 252645135) * 16843009 & 4294967295) >> 24",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> 1) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return ((i + (i >> 4) & 252645135) * 16843009 & 4294967295) >> 24",
      "mutated_line": "return ((i + (i >> -4) & 252645135) * 16843009 & 4294967295) >> 24",
      "code": "def find_max_number_on_scoreboard(n, k, digits):\n\n    def popcount(i):\n        i = i - (i >> 1 & 1431655765)\n        i = (i & 858993459) + (i >> 2 & 858993459)\n        return ((i + (i >> -4) & 252645135) * 16843009 & 4294967295) >> 24\n    binaryToDecimal = {}\n    for (i, x) in list(enumerate(['1110111', '0010010', '1011101', '1011011', '0111010', '1101011', '1101111', '1010010', '1111111', '1111011']))[::-1]:\n        binaryToDecimal[int(x, 2)] = i\n    digits = [int(d, 2) for d in digits[::-1]]\n    costs = [[] for i in range(1 << 7)]\n    for d in digits:\n        temp = []\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                temp.append(cost)\n        costs[d] = temp\n    possible = [[False for i in range(k + 1)]]\n    possible[-1][0] = True\n    for d in digits:\n        nextPossible = [False for i in range(k + 1)]\n        for k_ in range(k + 1):\n            if possible[-1][k_]:\n                for cost in costs[d]:\n                    if k_ + cost <= k:\n                        nextPossible[k_ + cost] = True\n        possible.append(nextPossible)\n    if not possible[n][k]:\n        return -1\n    ans = []\n    for i in range(n - 1, -1, -1):\n        d = digits[i]\n        for (b, v) in binaryToDecimal.items():\n            if d & b == d:\n                cost = popcount(b - d)\n                if k - cost >= 0 and possible[i][k - cost]:\n                    ans.append(str(v))\n                    k -= cost\n                    break\n    return ''.join(ans).rjust(n, '0')"
    }
  ]
}