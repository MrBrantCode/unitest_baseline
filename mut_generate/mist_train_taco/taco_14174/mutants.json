{
  "task_id": "taco_14174",
  "entry_point": "is_bicolorable",
  "mutant_count": 41,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "color = [-1] * n",
      "mutated_line": "",
      "code": "def is_bicolorable(test_cases):\n    results = []\n    for case in test_cases:\n        n = case['n']\n        edges = case['edges']\n        graph = [[] for _ in range(n)]\n        for (u, v) in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        color = [-1] / n\n\n        def bfs(start):\n            queue = [start]\n            color[start] = 0\n            while queue:\n                node = queue.pop(0)\n                current_color = color[node]\n                for neighbor in graph[node]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = 1 - current_color\n                        queue.append(neighbor)\n                    elif color[neighbor] == current_color:\n                        return False\n            return True\n        bicolorable = True\n        for node in range(n):\n            if color[node] == -1:\n                if not bfs(node):\n                    bicolorable = False\n                    break\n        if bicolorable:\n            results.append('BICOLORABLE.')\n        else:\n            results.append('NOT BICOLORABLE.')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "color = [-1] * n",
      "mutated_line": "",
      "code": "def is_bicolorable(test_cases):\n    results = []\n    for case in test_cases:\n        n = case['n']\n        edges = case['edges']\n        graph = [[] for _ in range(n)]\n        for (u, v) in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        color = [-1] + n\n\n        def bfs(start):\n            queue = [start]\n            color[start] = 0\n            while queue:\n                node = queue.pop(0)\n                current_color = color[node]\n                for neighbor in graph[node]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = 1 - current_color\n                        queue.append(neighbor)\n                    elif color[neighbor] == current_color:\n                        return False\n            return True\n        bicolorable = True\n        for node in range(n):\n            if color[node] == -1:\n                if not bfs(node):\n                    bicolorable = False\n                    break\n        if bicolorable:\n            results.append('BICOLORABLE.')\n        else:\n            results.append('NOT BICOLORABLE.')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "color = [-1] * n",
      "mutated_line": "",
      "code": "def is_bicolorable(test_cases):\n    results = []\n    for case in test_cases:\n        n = case['n']\n        edges = case['edges']\n        graph = [[] for _ in range(n)]\n        for (u, v) in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        color = [-1] ** n\n\n        def bfs(start):\n            queue = [start]\n            color[start] = 0\n            while queue:\n                node = queue.pop(0)\n                current_color = color[node]\n                for neighbor in graph[node]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = 1 - current_color\n                        queue.append(neighbor)\n                    elif color[neighbor] == current_color:\n                        return False\n            return True\n        bicolorable = True\n        for node in range(n):\n            if color[node] == -1:\n                if not bfs(node):\n                    bicolorable = False\n                    break\n        if bicolorable:\n            results.append('BICOLORABLE.')\n        else:\n            results.append('NOT BICOLORABLE.')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "bicolorable = True",
      "mutated_line": "bicolorable = False",
      "code": "def is_bicolorable(test_cases):\n    results = []\n    for case in test_cases:\n        n = case['n']\n        edges = case['edges']\n        graph = [[] for _ in range(n)]\n        for (u, v) in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        color = [-1] * n\n\n        def bfs(start):\n            queue = [start]\n            color[start] = 0\n            while queue:\n                node = queue.pop(0)\n                current_color = color[node]\n                for neighbor in graph[node]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = 1 - current_color\n                        queue.append(neighbor)\n                    elif color[neighbor] == current_color:\n                        return False\n            return True\n        bicolorable = False\n        for node in range(n):\n            if color[node] == -1:\n                if not bfs(node):\n                    bicolorable = False\n                    break\n        if bicolorable:\n            results.append('BICOLORABLE.')\n        else:\n            results.append('NOT BICOLORABLE.')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "n = case['n']",
      "mutated_line": "n = case['']",
      "code": "def is_bicolorable(test_cases):\n    results = []\n    for case in test_cases:\n        n = case['']\n        edges = case['edges']\n        graph = [[] for _ in range(n)]\n        for (u, v) in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        color = [-1] * n\n\n        def bfs(start):\n            queue = [start]\n            color[start] = 0\n            while queue:\n                node = queue.pop(0)\n                current_color = color[node]\n                for neighbor in graph[node]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = 1 - current_color\n                        queue.append(neighbor)\n                    elif color[neighbor] == current_color:\n                        return False\n            return True\n        bicolorable = True\n        for node in range(n):\n            if color[node] == -1:\n                if not bfs(node):\n                    bicolorable = False\n                    break\n        if bicolorable:\n            results.append('BICOLORABLE.')\n        else:\n            results.append('NOT BICOLORABLE.')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "edges = case['edges']",
      "mutated_line": "edges = case['']",
      "code": "def is_bicolorable(test_cases):\n    results = []\n    for case in test_cases:\n        n = case['n']\n        edges = case['']\n        graph = [[] for _ in range(n)]\n        for (u, v) in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        color = [-1] * n\n\n        def bfs(start):\n            queue = [start]\n            color[start] = 0\n            while queue:\n                node = queue.pop(0)\n                current_color = color[node]\n                for neighbor in graph[node]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = 1 - current_color\n                        queue.append(neighbor)\n                    elif color[neighbor] == current_color:\n                        return False\n            return True\n        bicolorable = True\n        for node in range(n):\n            if color[node] == -1:\n                if not bfs(node):\n                    bicolorable = False\n                    break\n        if bicolorable:\n            results.append('BICOLORABLE.')\n        else:\n            results.append('NOT BICOLORABLE.')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "color[start] = 0  # Start with color 0",
      "mutated_line": "color[start] = 1",
      "code": "def is_bicolorable(test_cases):\n    results = []\n    for case in test_cases:\n        n = case['n']\n        edges = case['edges']\n        graph = [[] for _ in range(n)]\n        for (u, v) in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        color = [-1] * n\n\n        def bfs(start):\n            queue = [start]\n            color[start] = 1\n            while queue:\n                node = queue.pop(0)\n                current_color = color[node]\n                for neighbor in graph[node]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = 1 - current_color\n                        queue.append(neighbor)\n                    elif color[neighbor] == current_color:\n                        return False\n            return True\n        bicolorable = True\n        for node in range(n):\n            if color[node] == -1:\n                if not bfs(node):\n                    bicolorable = False\n                    break\n        if bicolorable:\n            results.append('BICOLORABLE.')\n        else:\n            results.append('NOT BICOLORABLE.')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "color[start] = 0  # Start with color 0",
      "mutated_line": "color[start] = -1",
      "code": "def is_bicolorable(test_cases):\n    results = []\n    for case in test_cases:\n        n = case['n']\n        edges = case['edges']\n        graph = [[] for _ in range(n)]\n        for (u, v) in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        color = [-1] * n\n\n        def bfs(start):\n            queue = [start]\n            color[start] = -1\n            while queue:\n                node = queue.pop(0)\n                current_color = color[node]\n                for neighbor in graph[node]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = 1 - current_color\n                        queue.append(neighbor)\n                    elif color[neighbor] == current_color:\n                        return False\n            return True\n        bicolorable = True\n        for node in range(n):\n            if color[node] == -1:\n                if not bfs(node):\n                    bicolorable = False\n                    break\n        if bicolorable:\n            results.append('BICOLORABLE.')\n        else:\n            results.append('NOT BICOLORABLE.')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "color[start] = 0  # Start with color 0",
      "mutated_line": "color[start] = 1",
      "code": "def is_bicolorable(test_cases):\n    results = []\n    for case in test_cases:\n        n = case['n']\n        edges = case['edges']\n        graph = [[] for _ in range(n)]\n        for (u, v) in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        color = [-1] * n\n\n        def bfs(start):\n            queue = [start]\n            color[start] = 1\n            while queue:\n                node = queue.pop(0)\n                current_color = color[node]\n                for neighbor in graph[node]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = 1 - current_color\n                        queue.append(neighbor)\n                    elif color[neighbor] == current_color:\n                        return False\n            return True\n        bicolorable = True\n        for node in range(n):\n            if color[node] == -1:\n                if not bfs(node):\n                    bicolorable = False\n                    break\n        if bicolorable:\n            results.append('BICOLORABLE.')\n        else:\n            results.append('NOT BICOLORABLE.')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def is_bicolorable(test_cases):\n    results = []\n    for case in test_cases:\n        n = case['n']\n        edges = case['edges']\n        graph = [[] for _ in range(n)]\n        for (u, v) in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        color = [-1] * n\n\n        def bfs(start):\n            queue = [start]\n            color[start] = 0\n            while queue:\n                node = queue.pop(0)\n                current_color = color[node]\n                for neighbor in graph[node]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = 1 - current_color\n                        queue.append(neighbor)\n                    elif color[neighbor] == current_color:\n                        return False\n            return False\n        bicolorable = True\n        for node in range(n):\n            if color[node] == -1:\n                if not bfs(node):\n                    bicolorable = False\n                    break\n        if bicolorable:\n            results.append('BICOLORABLE.')\n        else:\n            results.append('NOT BICOLORABLE.')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if color[node] == -1:  # Not visited",
      "mutated_line": "if color[node] != -1:",
      "code": "def is_bicolorable(test_cases):\n    results = []\n    for case in test_cases:\n        n = case['n']\n        edges = case['edges']\n        graph = [[] for _ in range(n)]\n        for (u, v) in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        color = [-1] * n\n\n        def bfs(start):\n            queue = [start]\n            color[start] = 0\n            while queue:\n                node = queue.pop(0)\n                current_color = color[node]\n                for neighbor in graph[node]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = 1 - current_color\n                        queue.append(neighbor)\n                    elif color[neighbor] == current_color:\n                        return False\n            return True\n        bicolorable = True\n        for node in range(n):\n            if color[node] != -1:\n                if not bfs(node):\n                    bicolorable = False\n                    break\n        if bicolorable:\n            results.append('BICOLORABLE.')\n        else:\n            results.append('NOT BICOLORABLE.')\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "color = [-1] * n",
      "mutated_line": "",
      "code": "def is_bicolorable(test_cases):\n    results = []\n    for case in test_cases:\n        n = case['n']\n        edges = case['edges']\n        graph = [[] for _ in range(n)]\n        for (u, v) in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        color = [+1] * n\n\n        def bfs(start):\n            queue = [start]\n            color[start] = 0\n            while queue:\n                node = queue.pop(0)\n                current_color = color[node]\n                for neighbor in graph[node]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = 1 - current_color\n                        queue.append(neighbor)\n                    elif color[neighbor] == current_color:\n                        return False\n            return True\n        bicolorable = True\n        for node in range(n):\n            if color[node] == -1:\n                if not bfs(node):\n                    bicolorable = False\n                    break\n        if bicolorable:\n            results.append('BICOLORABLE.')\n        else:\n            results.append('NOT BICOLORABLE.')\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 39,
      "original_line": "if color[node] == -1:  # Not visited",
      "mutated_line": "if color[node] == +1:",
      "code": "def is_bicolorable(test_cases):\n    results = []\n    for case in test_cases:\n        n = case['n']\n        edges = case['edges']\n        graph = [[] for _ in range(n)]\n        for (u, v) in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        color = [-1] * n\n\n        def bfs(start):\n            queue = [start]\n            color[start] = 0\n            while queue:\n                node = queue.pop(0)\n                current_color = color[node]\n                for neighbor in graph[node]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = 1 - current_color\n                        queue.append(neighbor)\n                    elif color[neighbor] == current_color:\n                        return False\n            return True\n        bicolorable = True\n        for node in range(n):\n            if color[node] == +1:\n                if not bfs(node):\n                    bicolorable = False\n                    break\n        if bicolorable:\n            results.append('BICOLORABLE.')\n        else:\n            results.append('NOT BICOLORABLE.')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "results.append(\"BICOLORABLE.\")",
      "mutated_line": "results.append('')",
      "code": "def is_bicolorable(test_cases):\n    results = []\n    for case in test_cases:\n        n = case['n']\n        edges = case['edges']\n        graph = [[] for _ in range(n)]\n        for (u, v) in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        color = [-1] * n\n\n        def bfs(start):\n            queue = [start]\n            color[start] = 0\n            while queue:\n                node = queue.pop(0)\n                current_color = color[node]\n                for neighbor in graph[node]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = 1 - current_color\n                        queue.append(neighbor)\n                    elif color[neighbor] == current_color:\n                        return False\n            return True\n        bicolorable = True\n        for node in range(n):\n            if color[node] == -1:\n                if not bfs(node):\n                    bicolorable = False\n                    break\n        if bicolorable:\n            results.append('')\n        else:\n            results.append('NOT BICOLORABLE.')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "results.append(\"NOT BICOLORABLE.\")",
      "mutated_line": "results.append('')",
      "code": "def is_bicolorable(test_cases):\n    results = []\n    for case in test_cases:\n        n = case['n']\n        edges = case['edges']\n        graph = [[] for _ in range(n)]\n        for (u, v) in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        color = [-1] * n\n\n        def bfs(start):\n            queue = [start]\n            color[start] = 0\n            while queue:\n                node = queue.pop(0)\n                current_color = color[node]\n                for neighbor in graph[node]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = 1 - current_color\n                        queue.append(neighbor)\n                    elif color[neighbor] == current_color:\n                        return False\n            return True\n        bicolorable = True\n        for node in range(n):\n            if color[node] == -1:\n                if not bfs(node):\n                    bicolorable = False\n                    break\n        if bicolorable:\n            results.append('BICOLORABLE.')\n        else:\n            results.append('')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "color = [-1] * n",
      "mutated_line": "",
      "code": "def is_bicolorable(test_cases):\n    results = []\n    for case in test_cases:\n        n = case['n']\n        edges = case['edges']\n        graph = [[] for _ in range(n)]\n        for (u, v) in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        color = [-2] * n\n\n        def bfs(start):\n            queue = [start]\n            color[start] = 0\n            while queue:\n                node = queue.pop(0)\n                current_color = color[node]\n                for neighbor in graph[node]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = 1 - current_color\n                        queue.append(neighbor)\n                    elif color[neighbor] == current_color:\n                        return False\n            return True\n        bicolorable = True\n        for node in range(n):\n            if color[node] == -1:\n                if not bfs(node):\n                    bicolorable = False\n                    break\n        if bicolorable:\n            results.append('BICOLORABLE.')\n        else:\n            results.append('NOT BICOLORABLE.')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "color = [-1] * n",
      "mutated_line": "",
      "code": "def is_bicolorable(test_cases):\n    results = []\n    for case in test_cases:\n        n = case['n']\n        edges = case['edges']\n        graph = [[] for _ in range(n)]\n        for (u, v) in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        color = [-0] * n\n\n        def bfs(start):\n            queue = [start]\n            color[start] = 0\n            while queue:\n                node = queue.pop(0)\n                current_color = color[node]\n                for neighbor in graph[node]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = 1 - current_color\n                        queue.append(neighbor)\n                    elif color[neighbor] == current_color:\n                        return False\n            return True\n        bicolorable = True\n        for node in range(n):\n            if color[node] == -1:\n                if not bfs(node):\n                    bicolorable = False\n                    break\n        if bicolorable:\n            results.append('BICOLORABLE.')\n        else:\n            results.append('NOT BICOLORABLE.')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "color = [-1] * n",
      "mutated_line": "",
      "code": "def is_bicolorable(test_cases):\n    results = []\n    for case in test_cases:\n        n = case['n']\n        edges = case['edges']\n        graph = [[] for _ in range(n)]\n        for (u, v) in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        color = [-0] * n\n\n        def bfs(start):\n            queue = [start]\n            color[start] = 0\n            while queue:\n                node = queue.pop(0)\n                current_color = color[node]\n                for neighbor in graph[node]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = 1 - current_color\n                        queue.append(neighbor)\n                    elif color[neighbor] == current_color:\n                        return False\n            return True\n        bicolorable = True\n        for node in range(n):\n            if color[node] == -1:\n                if not bfs(node):\n                    bicolorable = False\n                    break\n        if bicolorable:\n            results.append('BICOLORABLE.')\n        else:\n            results.append('NOT BICOLORABLE.')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "color = [-1] * n",
      "mutated_line": "",
      "code": "def is_bicolorable(test_cases):\n    results = []\n    for case in test_cases:\n        n = case['n']\n        edges = case['edges']\n        graph = [[] for _ in range(n)]\n        for (u, v) in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        color = [--1] * n\n\n        def bfs(start):\n            queue = [start]\n            color[start] = 0\n            while queue:\n                node = queue.pop(0)\n                current_color = color[node]\n                for neighbor in graph[node]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = 1 - current_color\n                        queue.append(neighbor)\n                    elif color[neighbor] == current_color:\n                        return False\n            return True\n        bicolorable = True\n        for node in range(n):\n            if color[node] == -1:\n                if not bfs(node):\n                    bicolorable = False\n                    break\n        if bicolorable:\n            results.append('BICOLORABLE.')\n        else:\n            results.append('NOT BICOLORABLE.')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "node = queue.pop(0)",
      "mutated_line": "node = queue.pop(1)",
      "code": "def is_bicolorable(test_cases):\n    results = []\n    for case in test_cases:\n        n = case['n']\n        edges = case['edges']\n        graph = [[] for _ in range(n)]\n        for (u, v) in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        color = [-1] * n\n\n        def bfs(start):\n            queue = [start]\n            color[start] = 0\n            while queue:\n                node = queue.pop(1)\n                current_color = color[node]\n                for neighbor in graph[node]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = 1 - current_color\n                        queue.append(neighbor)\n                    elif color[neighbor] == current_color:\n                        return False\n            return True\n        bicolorable = True\n        for node in range(n):\n            if color[node] == -1:\n                if not bfs(node):\n                    bicolorable = False\n                    break\n        if bicolorable:\n            results.append('BICOLORABLE.')\n        else:\n            results.append('NOT BICOLORABLE.')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "node = queue.pop(0)",
      "mutated_line": "node = queue.pop(-1)",
      "code": "def is_bicolorable(test_cases):\n    results = []\n    for case in test_cases:\n        n = case['n']\n        edges = case['edges']\n        graph = [[] for _ in range(n)]\n        for (u, v) in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        color = [-1] * n\n\n        def bfs(start):\n            queue = [start]\n            color[start] = 0\n            while queue:\n                node = queue.pop(-1)\n                current_color = color[node]\n                for neighbor in graph[node]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = 1 - current_color\n                        queue.append(neighbor)\n                    elif color[neighbor] == current_color:\n                        return False\n            return True\n        bicolorable = True\n        for node in range(n):\n            if color[node] == -1:\n                if not bfs(node):\n                    bicolorable = False\n                    break\n        if bicolorable:\n            results.append('BICOLORABLE.')\n        else:\n            results.append('NOT BICOLORABLE.')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "node = queue.pop(0)",
      "mutated_line": "node = queue.pop(1)",
      "code": "def is_bicolorable(test_cases):\n    results = []\n    for case in test_cases:\n        n = case['n']\n        edges = case['edges']\n        graph = [[] for _ in range(n)]\n        for (u, v) in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        color = [-1] * n\n\n        def bfs(start):\n            queue = [start]\n            color[start] = 0\n            while queue:\n                node = queue.pop(1)\n                current_color = color[node]\n                for neighbor in graph[node]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = 1 - current_color\n                        queue.append(neighbor)\n                    elif color[neighbor] == current_color:\n                        return False\n            return True\n        bicolorable = True\n        for node in range(n):\n            if color[node] == -1:\n                if not bfs(node):\n                    bicolorable = False\n                    break\n        if bicolorable:\n            results.append('BICOLORABLE.')\n        else:\n            results.append('NOT BICOLORABLE.')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if color[neighbor] == -1:",
      "mutated_line": "if color[neighbor] != -1:",
      "code": "def is_bicolorable(test_cases):\n    results = []\n    for case in test_cases:\n        n = case['n']\n        edges = case['edges']\n        graph = [[] for _ in range(n)]\n        for (u, v) in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        color = [-1] * n\n\n        def bfs(start):\n            queue = [start]\n            color[start] = 0\n            while queue:\n                node = queue.pop(0)\n                current_color = color[node]\n                for neighbor in graph[node]:\n                    if color[neighbor] != -1:\n                        color[neighbor] = 1 - current_color\n                        queue.append(neighbor)\n                    elif color[neighbor] == current_color:\n                        return False\n            return True\n        bicolorable = True\n        for node in range(n):\n            if color[node] == -1:\n                if not bfs(node):\n                    bicolorable = False\n                    break\n        if bicolorable:\n            results.append('BICOLORABLE.')\n        else:\n            results.append('NOT BICOLORABLE.')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if color[node] == -1:  # Not visited",
      "mutated_line": "if color[node] == -2:",
      "code": "def is_bicolorable(test_cases):\n    results = []\n    for case in test_cases:\n        n = case['n']\n        edges = case['edges']\n        graph = [[] for _ in range(n)]\n        for (u, v) in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        color = [-1] * n\n\n        def bfs(start):\n            queue = [start]\n            color[start] = 0\n            while queue:\n                node = queue.pop(0)\n                current_color = color[node]\n                for neighbor in graph[node]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = 1 - current_color\n                        queue.append(neighbor)\n                    elif color[neighbor] == current_color:\n                        return False\n            return True\n        bicolorable = True\n        for node in range(n):\n            if color[node] == -2:\n                if not bfs(node):\n                    bicolorable = False\n                    break\n        if bicolorable:\n            results.append('BICOLORABLE.')\n        else:\n            results.append('NOT BICOLORABLE.')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if color[node] == -1:  # Not visited",
      "mutated_line": "if color[node] == -0:",
      "code": "def is_bicolorable(test_cases):\n    results = []\n    for case in test_cases:\n        n = case['n']\n        edges = case['edges']\n        graph = [[] for _ in range(n)]\n        for (u, v) in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        color = [-1] * n\n\n        def bfs(start):\n            queue = [start]\n            color[start] = 0\n            while queue:\n                node = queue.pop(0)\n                current_color = color[node]\n                for neighbor in graph[node]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = 1 - current_color\n                        queue.append(neighbor)\n                    elif color[neighbor] == current_color:\n                        return False\n            return True\n        bicolorable = True\n        for node in range(n):\n            if color[node] == -0:\n                if not bfs(node):\n                    bicolorable = False\n                    break\n        if bicolorable:\n            results.append('BICOLORABLE.')\n        else:\n            results.append('NOT BICOLORABLE.')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if color[node] == -1:  # Not visited",
      "mutated_line": "if color[node] == -0:",
      "code": "def is_bicolorable(test_cases):\n    results = []\n    for case in test_cases:\n        n = case['n']\n        edges = case['edges']\n        graph = [[] for _ in range(n)]\n        for (u, v) in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        color = [-1] * n\n\n        def bfs(start):\n            queue = [start]\n            color[start] = 0\n            while queue:\n                node = queue.pop(0)\n                current_color = color[node]\n                for neighbor in graph[node]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = 1 - current_color\n                        queue.append(neighbor)\n                    elif color[neighbor] == current_color:\n                        return False\n            return True\n        bicolorable = True\n        for node in range(n):\n            if color[node] == -0:\n                if not bfs(node):\n                    bicolorable = False\n                    break\n        if bicolorable:\n            results.append('BICOLORABLE.')\n        else:\n            results.append('NOT BICOLORABLE.')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if color[node] == -1:  # Not visited",
      "mutated_line": "if color[node] == --1:",
      "code": "def is_bicolorable(test_cases):\n    results = []\n    for case in test_cases:\n        n = case['n']\n        edges = case['edges']\n        graph = [[] for _ in range(n)]\n        for (u, v) in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        color = [-1] * n\n\n        def bfs(start):\n            queue = [start]\n            color[start] = 0\n            while queue:\n                node = queue.pop(0)\n                current_color = color[node]\n                for neighbor in graph[node]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = 1 - current_color\n                        queue.append(neighbor)\n                    elif color[neighbor] == current_color:\n                        return False\n            return True\n        bicolorable = True\n        for node in range(n):\n            if color[node] == --1:\n                if not bfs(node):\n                    bicolorable = False\n                    break\n        if bicolorable:\n            results.append('BICOLORABLE.')\n        else:\n            results.append('NOT BICOLORABLE.')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "bicolorable = False",
      "mutated_line": "bicolorable = True",
      "code": "def is_bicolorable(test_cases):\n    results = []\n    for case in test_cases:\n        n = case['n']\n        edges = case['edges']\n        graph = [[] for _ in range(n)]\n        for (u, v) in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        color = [-1] * n\n\n        def bfs(start):\n            queue = [start]\n            color[start] = 0\n            while queue:\n                node = queue.pop(0)\n                current_color = color[node]\n                for neighbor in graph[node]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = 1 - current_color\n                        queue.append(neighbor)\n                    elif color[neighbor] == current_color:\n                        return False\n            return True\n        bicolorable = True\n        for node in range(n):\n            if color[node] == -1:\n                if not bfs(node):\n                    bicolorable = True\n                    break\n        if bicolorable:\n            results.append('BICOLORABLE.')\n        else:\n            results.append('NOT BICOLORABLE.')\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 28,
      "original_line": "if color[neighbor] == -1:",
      "mutated_line": "if color[neighbor] == +1:",
      "code": "def is_bicolorable(test_cases):\n    results = []\n    for case in test_cases:\n        n = case['n']\n        edges = case['edges']\n        graph = [[] for _ in range(n)]\n        for (u, v) in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        color = [-1] * n\n\n        def bfs(start):\n            queue = [start]\n            color[start] = 0\n            while queue:\n                node = queue.pop(0)\n                current_color = color[node]\n                for neighbor in graph[node]:\n                    if color[neighbor] == +1:\n                        color[neighbor] = 1 - current_color\n                        queue.append(neighbor)\n                    elif color[neighbor] == current_color:\n                        return False\n            return True\n        bicolorable = True\n        for node in range(n):\n            if color[node] == -1:\n                if not bfs(node):\n                    bicolorable = False\n                    break\n        if bicolorable:\n            results.append('BICOLORABLE.')\n        else:\n            results.append('NOT BICOLORABLE.')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "color[neighbor] = 1 - current_color",
      "mutated_line": "color[neighbor] = 1 + current_color",
      "code": "def is_bicolorable(test_cases):\n    results = []\n    for case in test_cases:\n        n = case['n']\n        edges = case['edges']\n        graph = [[] for _ in range(n)]\n        for (u, v) in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        color = [-1] * n\n\n        def bfs(start):\n            queue = [start]\n            color[start] = 0\n            while queue:\n                node = queue.pop(0)\n                current_color = color[node]\n                for neighbor in graph[node]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = 1 + current_color\n                        queue.append(neighbor)\n                    elif color[neighbor] == current_color:\n                        return False\n            return True\n        bicolorable = True\n        for node in range(n):\n            if color[node] == -1:\n                if not bfs(node):\n                    bicolorable = False\n                    break\n        if bicolorable:\n            results.append('BICOLORABLE.')\n        else:\n            results.append('NOT BICOLORABLE.')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "color[neighbor] = 1 - current_color",
      "mutated_line": "color[neighbor] = 1 * current_color",
      "code": "def is_bicolorable(test_cases):\n    results = []\n    for case in test_cases:\n        n = case['n']\n        edges = case['edges']\n        graph = [[] for _ in range(n)]\n        for (u, v) in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        color = [-1] * n\n\n        def bfs(start):\n            queue = [start]\n            color[start] = 0\n            while queue:\n                node = queue.pop(0)\n                current_color = color[node]\n                for neighbor in graph[node]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = 1 * current_color\n                        queue.append(neighbor)\n                    elif color[neighbor] == current_color:\n                        return False\n            return True\n        bicolorable = True\n        for node in range(n):\n            if color[node] == -1:\n                if not bfs(node):\n                    bicolorable = False\n                    break\n        if bicolorable:\n            results.append('BICOLORABLE.')\n        else:\n            results.append('NOT BICOLORABLE.')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "elif color[neighbor] == current_color:",
      "mutated_line": "elif color[neighbor] != current_color:",
      "code": "def is_bicolorable(test_cases):\n    results = []\n    for case in test_cases:\n        n = case['n']\n        edges = case['edges']\n        graph = [[] for _ in range(n)]\n        for (u, v) in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        color = [-1] * n\n\n        def bfs(start):\n            queue = [start]\n            color[start] = 0\n            while queue:\n                node = queue.pop(0)\n                current_color = color[node]\n                for neighbor in graph[node]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = 1 - current_color\n                        queue.append(neighbor)\n                    elif color[neighbor] != current_color:\n                        return False\n            return True\n        bicolorable = True\n        for node in range(n):\n            if color[node] == -1:\n                if not bfs(node):\n                    bicolorable = False\n                    break\n        if bicolorable:\n            results.append('BICOLORABLE.')\n        else:\n            results.append('NOT BICOLORABLE.')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if color[neighbor] == -1:",
      "mutated_line": "if color[neighbor] == -2:",
      "code": "def is_bicolorable(test_cases):\n    results = []\n    for case in test_cases:\n        n = case['n']\n        edges = case['edges']\n        graph = [[] for _ in range(n)]\n        for (u, v) in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        color = [-1] * n\n\n        def bfs(start):\n            queue = [start]\n            color[start] = 0\n            while queue:\n                node = queue.pop(0)\n                current_color = color[node]\n                for neighbor in graph[node]:\n                    if color[neighbor] == -2:\n                        color[neighbor] = 1 - current_color\n                        queue.append(neighbor)\n                    elif color[neighbor] == current_color:\n                        return False\n            return True\n        bicolorable = True\n        for node in range(n):\n            if color[node] == -1:\n                if not bfs(node):\n                    bicolorable = False\n                    break\n        if bicolorable:\n            results.append('BICOLORABLE.')\n        else:\n            results.append('NOT BICOLORABLE.')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if color[neighbor] == -1:",
      "mutated_line": "if color[neighbor] == -0:",
      "code": "def is_bicolorable(test_cases):\n    results = []\n    for case in test_cases:\n        n = case['n']\n        edges = case['edges']\n        graph = [[] for _ in range(n)]\n        for (u, v) in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        color = [-1] * n\n\n        def bfs(start):\n            queue = [start]\n            color[start] = 0\n            while queue:\n                node = queue.pop(0)\n                current_color = color[node]\n                for neighbor in graph[node]:\n                    if color[neighbor] == -0:\n                        color[neighbor] = 1 - current_color\n                        queue.append(neighbor)\n                    elif color[neighbor] == current_color:\n                        return False\n            return True\n        bicolorable = True\n        for node in range(n):\n            if color[node] == -1:\n                if not bfs(node):\n                    bicolorable = False\n                    break\n        if bicolorable:\n            results.append('BICOLORABLE.')\n        else:\n            results.append('NOT BICOLORABLE.')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if color[neighbor] == -1:",
      "mutated_line": "if color[neighbor] == -0:",
      "code": "def is_bicolorable(test_cases):\n    results = []\n    for case in test_cases:\n        n = case['n']\n        edges = case['edges']\n        graph = [[] for _ in range(n)]\n        for (u, v) in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        color = [-1] * n\n\n        def bfs(start):\n            queue = [start]\n            color[start] = 0\n            while queue:\n                node = queue.pop(0)\n                current_color = color[node]\n                for neighbor in graph[node]:\n                    if color[neighbor] == -0:\n                        color[neighbor] = 1 - current_color\n                        queue.append(neighbor)\n                    elif color[neighbor] == current_color:\n                        return False\n            return True\n        bicolorable = True\n        for node in range(n):\n            if color[node] == -1:\n                if not bfs(node):\n                    bicolorable = False\n                    break\n        if bicolorable:\n            results.append('BICOLORABLE.')\n        else:\n            results.append('NOT BICOLORABLE.')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if color[neighbor] == -1:",
      "mutated_line": "if color[neighbor] == --1:",
      "code": "def is_bicolorable(test_cases):\n    results = []\n    for case in test_cases:\n        n = case['n']\n        edges = case['edges']\n        graph = [[] for _ in range(n)]\n        for (u, v) in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        color = [-1] * n\n\n        def bfs(start):\n            queue = [start]\n            color[start] = 0\n            while queue:\n                node = queue.pop(0)\n                current_color = color[node]\n                for neighbor in graph[node]:\n                    if color[neighbor] == --1:\n                        color[neighbor] = 1 - current_color\n                        queue.append(neighbor)\n                    elif color[neighbor] == current_color:\n                        return False\n            return True\n        bicolorable = True\n        for node in range(n):\n            if color[node] == -1:\n                if not bfs(node):\n                    bicolorable = False\n                    break\n        if bicolorable:\n            results.append('BICOLORABLE.')\n        else:\n            results.append('NOT BICOLORABLE.')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "color[neighbor] = 1 - current_color",
      "mutated_line": "color[neighbor] = 2 - current_color",
      "code": "def is_bicolorable(test_cases):\n    results = []\n    for case in test_cases:\n        n = case['n']\n        edges = case['edges']\n        graph = [[] for _ in range(n)]\n        for (u, v) in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        color = [-1] * n\n\n        def bfs(start):\n            queue = [start]\n            color[start] = 0\n            while queue:\n                node = queue.pop(0)\n                current_color = color[node]\n                for neighbor in graph[node]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = 2 - current_color\n                        queue.append(neighbor)\n                    elif color[neighbor] == current_color:\n                        return False\n            return True\n        bicolorable = True\n        for node in range(n):\n            if color[node] == -1:\n                if not bfs(node):\n                    bicolorable = False\n                    break\n        if bicolorable:\n            results.append('BICOLORABLE.')\n        else:\n            results.append('NOT BICOLORABLE.')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "color[neighbor] = 1 - current_color",
      "mutated_line": "color[neighbor] = 0 - current_color",
      "code": "def is_bicolorable(test_cases):\n    results = []\n    for case in test_cases:\n        n = case['n']\n        edges = case['edges']\n        graph = [[] for _ in range(n)]\n        for (u, v) in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        color = [-1] * n\n\n        def bfs(start):\n            queue = [start]\n            color[start] = 0\n            while queue:\n                node = queue.pop(0)\n                current_color = color[node]\n                for neighbor in graph[node]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = 0 - current_color\n                        queue.append(neighbor)\n                    elif color[neighbor] == current_color:\n                        return False\n            return True\n        bicolorable = True\n        for node in range(n):\n            if color[node] == -1:\n                if not bfs(node):\n                    bicolorable = False\n                    break\n        if bicolorable:\n            results.append('BICOLORABLE.')\n        else:\n            results.append('NOT BICOLORABLE.')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "color[neighbor] = 1 - current_color",
      "mutated_line": "color[neighbor] = 0 - current_color",
      "code": "def is_bicolorable(test_cases):\n    results = []\n    for case in test_cases:\n        n = case['n']\n        edges = case['edges']\n        graph = [[] for _ in range(n)]\n        for (u, v) in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        color = [-1] * n\n\n        def bfs(start):\n            queue = [start]\n            color[start] = 0\n            while queue:\n                node = queue.pop(0)\n                current_color = color[node]\n                for neighbor in graph[node]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = 0 - current_color\n                        queue.append(neighbor)\n                    elif color[neighbor] == current_color:\n                        return False\n            return True\n        bicolorable = True\n        for node in range(n):\n            if color[node] == -1:\n                if not bfs(node):\n                    bicolorable = False\n                    break\n        if bicolorable:\n            results.append('BICOLORABLE.')\n        else:\n            results.append('NOT BICOLORABLE.')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "color[neighbor] = 1 - current_color",
      "mutated_line": "color[neighbor] = -1 - current_color",
      "code": "def is_bicolorable(test_cases):\n    results = []\n    for case in test_cases:\n        n = case['n']\n        edges = case['edges']\n        graph = [[] for _ in range(n)]\n        for (u, v) in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        color = [-1] * n\n\n        def bfs(start):\n            queue = [start]\n            color[start] = 0\n            while queue:\n                node = queue.pop(0)\n                current_color = color[node]\n                for neighbor in graph[node]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = -1 - current_color\n                        queue.append(neighbor)\n                    elif color[neighbor] == current_color:\n                        return False\n            return True\n        bicolorable = True\n        for node in range(n):\n            if color[node] == -1:\n                if not bfs(node):\n                    bicolorable = False\n                    break\n        if bicolorable:\n            results.append('BICOLORABLE.')\n        else:\n            results.append('NOT BICOLORABLE.')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def is_bicolorable(test_cases):\n    results = []\n    for case in test_cases:\n        n = case['n']\n        edges = case['edges']\n        graph = [[] for _ in range(n)]\n        for (u, v) in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        color = [-1] * n\n\n        def bfs(start):\n            queue = [start]\n            color[start] = 0\n            while queue:\n                node = queue.pop(0)\n                current_color = color[node]\n                for neighbor in graph[node]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = 1 - current_color\n                        queue.append(neighbor)\n                    elif color[neighbor] == current_color:\n                        return True\n            return True\n        bicolorable = True\n        for node in range(n):\n            if color[node] == -1:\n                if not bfs(node):\n                    bicolorable = False\n                    break\n        if bicolorable:\n            results.append('BICOLORABLE.')\n        else:\n            results.append('NOT BICOLORABLE.')\n    return results"
    }
  ]
}