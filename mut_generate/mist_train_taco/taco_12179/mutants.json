{
  "task_id": "taco_12179",
  "entry_point": "calculate_minimal_station_power",
  "mutant_count": 146,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if len(houses) <= 3:",
      "mutated_line": "if len(houses) < 3:",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) < 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if len(houses) <= 3:",
      "mutated_line": "if len(houses) > 3:",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) > 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if len(houses) <= 3:",
      "mutated_line": "if len(houses) == 3:",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) == 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "span = 0",
      "mutated_line": "span = 1",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 1\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "span = 0",
      "mutated_line": "span = -1",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = -1\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "span = 0",
      "mutated_line": "span = 1",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 1\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "left = 1",
      "mutated_line": "left = 2",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 2\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "left = 1",
      "mutated_line": "left = 0",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 0\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "left = 1",
      "mutated_line": "left = 0",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 0\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "left = 1",
      "mutated_line": "left = -1",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = -1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "right = len(houses) - 2",
      "mutated_line": "right = len(houses) + 2",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) + 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "right = len(houses) - 2",
      "mutated_line": "right = len(houses) * 2",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) * 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "while houses[right] - houses[left] > span:",
      "mutated_line": "while houses[right] - houses[left] >= span:",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] >= span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "while houses[right] - houses[left] > span:",
      "mutated_line": "while houses[right] - houses[left] <= span:",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] <= span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "while houses[right] - houses[left] > span:",
      "mutated_line": "while houses[right] - houses[left] != span:",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] != span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "minimal_power = span / 2",
      "mutated_line": "station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span * 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "minimal_power = span / 2",
      "mutated_line": "station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span // 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if len(houses) <= 3:",
      "mutated_line": "if len(houses) <= 4:",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 4:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if len(houses) <= 3:",
      "mutated_line": "if len(houses) <= 2:",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 2:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if len(houses) <= 3:",
      "mutated_line": "if len(houses) <= 0:",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 0:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if len(houses) <= 3:",
      "mutated_line": "if len(houses) <= 1:",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 1:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if len(houses) <= 3:",
      "mutated_line": "if len(houses) <= -3:",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= -3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "minimal_power = 0",
      "mutated_line": "minimal_power = 1",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 1\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "minimal_power = 0",
      "mutated_line": "minimal_power = -1",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = -1\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "minimal_power = 0",
      "mutated_line": "minimal_power = 1",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 1\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "while len(result) < 3:",
      "mutated_line": "while len(result) <= 3:",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) <= 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "while len(result) < 3:",
      "mutated_line": "while len(result) >= 3:",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) >= 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "while len(result) < 3:",
      "mutated_line": "while len(result) != 3:",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) != 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "right = len(houses) - 2",
      "mutated_line": "right = len(houses) - 3",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 3\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "right = len(houses) - 2",
      "mutated_line": "right = len(houses) - 1",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 1\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "right = len(houses) - 2",
      "mutated_line": "right = len(houses) - 0",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 0\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "right = len(houses) - 2",
      "mutated_line": "right = len(houses) - 1",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 1\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "right = len(houses) - 2",
      "mutated_line": "right = len(houses) - -2",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - -2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "while houses[right] - houses[left] > span:",
      "mutated_line": "while houses[right] + houses[left] > span:",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] + houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "while houses[right] - houses[left] > span:",
      "mutated_line": "while houses[right] * houses[left] > span:",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] * houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "left_gap = houses[left] - houses[0] - span",
      "mutated_line": "left_gap = houses[left] - houses[0] + span",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] + span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "left_gap = houses[left] - houses[0] - span",
      "mutated_line": "left_gap = (houses[left] - houses[0]) * span",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = (houses[left] - houses[0]) * span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "right_gap = houses[-1] - houses[right] - span",
      "mutated_line": "right_gap = houses[-1] - houses[right] + span",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] + span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "right_gap = houses[-1] - houses[right] - span",
      "mutated_line": "right_gap = (houses[-1] - houses[right]) * span",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = (houses[-1] - houses[right]) * span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "middle = houses[right] - houses[left]",
      "mutated_line": "middle = houses[right] + houses[left]",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] + houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "middle = houses[right] - houses[left]",
      "mutated_line": "middle = houses[right] * houses[left]",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] * houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if left_gap <= right_gap:",
      "mutated_line": "if left_gap < right_gap:",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap < right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if left_gap <= right_gap:",
      "mutated_line": "if left_gap > right_gap:",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap > right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if left_gap <= right_gap:",
      "mutated_line": "if left_gap == right_gap:",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap == right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "ASR",
      "lineno": 25,
      "original_line": "left += 1",
      "mutated_line": "left -= 1",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left -= 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "ASR",
      "lineno": 28,
      "original_line": "span += left_gap",
      "mutated_line": "span -= left_gap",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span -= left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "ASR",
      "lineno": 33,
      "original_line": "right -= 1",
      "mutated_line": "right += 1",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right += 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "ASR",
      "lineno": 34,
      "original_line": "span += right_gap",
      "mutated_line": "span -= right_gap",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span -= right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "minimal_power = span / 2",
      "mutated_line": "station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 3\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "minimal_power = span / 2",
      "mutated_line": "station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 1\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "minimal_power = span / 2",
      "mutated_line": "station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 0\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "minimal_power = span / 2",
      "mutated_line": "station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 1\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "minimal_power = span / 2",
      "mutated_line": "station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / -2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "(houses[0] + houses[left - 1]) / 2,",
      "mutated_line": "return (minimal_power, station_locations)",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) * 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "(houses[0] + houses[left - 1]) / 2,",
      "mutated_line": "return (minimal_power, station_locations)",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) // 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "(houses[left] + houses[right]) / 2,",
      "mutated_line": "return (minimal_power, station_locations)",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) * 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "(houses[left] + houses[right]) / 2,",
      "mutated_line": "return (minimal_power, station_locations)",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) // 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "(houses[right + 1] + houses[-1]) / 2",
      "mutated_line": "return (minimal_power, station_locations)",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) * 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "(houses[right + 1] + houses[-1]) / 2",
      "mutated_line": "return (minimal_power, station_locations)",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) // 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "while len(result) < 3:",
      "mutated_line": "while len(result) < 4:",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 4:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "while len(result) < 3:",
      "mutated_line": "while len(result) < 2:",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 2:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "while len(result) < 3:",
      "mutated_line": "while len(result) < 0:",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 0:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "while len(result) < 3:",
      "mutated_line": "while len(result) < 1:",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 1:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "while len(result) < 3:",
      "mutated_line": "while len(result) < -3:",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < -3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "left_gap = houses[left] - houses[0] - span",
      "mutated_line": "left_gap = houses[left] + houses[0] - span",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] + houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "left_gap = houses[left] - houses[0] - span",
      "mutated_line": "left_gap = houses[left] * houses[0] - span",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] * houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "right_gap = houses[-1] - houses[right] - span",
      "mutated_line": "right_gap = houses[-1] + houses[right] - span",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] + houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "right_gap = houses[-1] - houses[right] - span",
      "mutated_line": "right_gap = houses[-1] * houses[right] - span",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] * houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if span + left_gap > middle:",
      "mutated_line": "if span + left_gap >= middle:",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap >= middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if span + left_gap > middle:",
      "mutated_line": "if span + left_gap <= middle:",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap <= middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if span + left_gap > middle:",
      "mutated_line": "if span + left_gap != middle:",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap != middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "left += 1",
      "mutated_line": "left += 2",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 2\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "left += 1",
      "mutated_line": "left += 0",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 0\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "left += 1",
      "mutated_line": "left += 0",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 0\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "left += 1",
      "mutated_line": "left += -1",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += -1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if left_gap == right_gap:",
      "mutated_line": "if left_gap != right_gap:",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap != right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "ASR",
      "lineno": 27,
      "original_line": "right -= 1",
      "mutated_line": "right += 1",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right += 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if span + right_gap > middle:",
      "mutated_line": "if span + right_gap >= middle:",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap >= middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if span + right_gap > middle:",
      "mutated_line": "if span + right_gap <= middle:",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap <= middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if span + right_gap > middle:",
      "mutated_line": "if span + right_gap != middle:",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap != middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "right -= 1",
      "mutated_line": "right -= 2",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 2\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "right -= 1",
      "mutated_line": "right -= 0",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 0\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "right -= 1",
      "mutated_line": "right -= 0",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 0\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "right -= 1",
      "mutated_line": "right -= -1",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= -1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "(houses[0] + houses[left - 1]) / 2,",
      "mutated_line": "return (minimal_power, station_locations)",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] - houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "(houses[0] + houses[left - 1]) / 2,",
      "mutated_line": "return (minimal_power, station_locations)",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = (houses[0] * houses[left - 1] / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "(houses[0] + houses[left - 1]) / 2,",
      "mutated_line": "return (minimal_power, station_locations)",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 3, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "(houses[0] + houses[left - 1]) / 2,",
      "mutated_line": "return (minimal_power, station_locations)",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 1, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "(houses[0] + houses[left - 1]) / 2,",
      "mutated_line": "return (minimal_power, station_locations)",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 0, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "(houses[0] + houses[left - 1]) / 2,",
      "mutated_line": "return (minimal_power, station_locations)",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 1, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "(houses[0] + houses[left - 1]) / 2,",
      "mutated_line": "return (minimal_power, station_locations)",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / -2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "(houses[left] + houses[right]) / 2,",
      "mutated_line": "return (minimal_power, station_locations)",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] - houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "(houses[left] + houses[right]) / 2,",
      "mutated_line": "return (minimal_power, station_locations)",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, houses[left] * houses[right] / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "(houses[left] + houses[right]) / 2,",
      "mutated_line": "return (minimal_power, station_locations)",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 3, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "(houses[left] + houses[right]) / 2,",
      "mutated_line": "return (minimal_power, station_locations)",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 1, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "(houses[left] + houses[right]) / 2,",
      "mutated_line": "return (minimal_power, station_locations)",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 0, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "(houses[left] + houses[right]) / 2,",
      "mutated_line": "return (minimal_power, station_locations)",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 1, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "(houses[left] + houses[right]) / 2,",
      "mutated_line": "return (minimal_power, station_locations)",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / -2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "(houses[right + 1] + houses[-1]) / 2",
      "mutated_line": "return (minimal_power, station_locations)",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] - houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "(houses[right + 1] + houses[-1]) / 2",
      "mutated_line": "return (minimal_power, station_locations)",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, houses[right + 1] * houses[-1] / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "(houses[right + 1] + houses[-1]) / 2",
      "mutated_line": "return (minimal_power, station_locations)",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 3)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "(houses[right + 1] + houses[-1]) / 2",
      "mutated_line": "return (minimal_power, station_locations)",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 1)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "(houses[right + 1] + houses[-1]) / 2",
      "mutated_line": "return (minimal_power, station_locations)",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 0)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "(houses[right + 1] + houses[-1]) / 2",
      "mutated_line": "return (minimal_power, station_locations)",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 1)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "(houses[right + 1] + houses[-1]) / 2",
      "mutated_line": "return (minimal_power, station_locations)",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / -2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if span + left_gap > middle:",
      "mutated_line": "if span - left_gap > middle:",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span - left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if span + left_gap > middle:",
      "mutated_line": "if span * left_gap > middle:",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span * left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "right -= 1",
      "mutated_line": "right -= 2",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 2\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "right -= 1",
      "mutated_line": "right -= 0",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 0\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "right -= 1",
      "mutated_line": "right -= 0",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 0\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "right -= 1",
      "mutated_line": "right -= -1",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= -1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "if span + right_gap > middle:",
      "mutated_line": "if span - right_gap > middle:",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span - right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "if span + right_gap > middle:",
      "mutated_line": "if span * right_gap > middle:",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span * right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "UOI",
      "lineno": 8,
      "original_line": "result.append(result[-1])",
      "mutated_line": "result.append(result[+1])",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[+1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "left_gap = houses[left] - houses[0] - span",
      "mutated_line": "left_gap = houses[left] - houses[1] - span",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[1] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "left_gap = houses[left] - houses[0] - span",
      "mutated_line": "left_gap = houses[left] - houses[-1] - span",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[-1] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "left_gap = houses[left] - houses[0] - span",
      "mutated_line": "left_gap = houses[left] - houses[1] - span",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[1] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "right_gap = houses[-1] - houses[right] - span",
      "mutated_line": "right_gap = houses[+1] - houses[right] - span",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[+1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "(houses[0] + houses[left - 1]) / 2,",
      "mutated_line": "return (minimal_power, station_locations)",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[1] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "(houses[0] + houses[left - 1]) / 2,",
      "mutated_line": "return (minimal_power, station_locations)",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[-1] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "(houses[0] + houses[left - 1]) / 2,",
      "mutated_line": "return (minimal_power, station_locations)",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[1] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "(houses[0] + houses[left - 1]) / 2,",
      "mutated_line": "return (minimal_power, station_locations)",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left + 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "(houses[0] + houses[left - 1]) / 2,",
      "mutated_line": "return (minimal_power, station_locations)",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left * 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "(houses[right + 1] + houses[-1]) / 2",
      "mutated_line": "return (minimal_power, station_locations)",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right - 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "(houses[right + 1] + houses[-1]) / 2",
      "mutated_line": "return (minimal_power, station_locations)",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right * 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "UOI",
      "lineno": 40,
      "original_line": "(houses[right + 1] + houses[-1]) / 2",
      "mutated_line": "return (minimal_power, station_locations)",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[+1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "result.append(result[-1])",
      "mutated_line": "result.append(result[-2])",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-2])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "result.append(result[-1])",
      "mutated_line": "result.append(result[-0])",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-0])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "result.append(result[-1])",
      "mutated_line": "result.append(result[-0])",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-0])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "result.append(result[-1])",
      "mutated_line": "result.append(result[--1])",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[--1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "right_gap = houses[-1] - houses[right] - span",
      "mutated_line": "right_gap = houses[-2] - houses[right] - span",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-2] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "right_gap = houses[-1] - houses[right] - span",
      "mutated_line": "right_gap = houses[-0] - houses[right] - span",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-0] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "right_gap = houses[-1] - houses[right] - span",
      "mutated_line": "right_gap = houses[-0] - houses[right] - span",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-0] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "right_gap = houses[-1] - houses[right] - span",
      "mutated_line": "right_gap = houses[--1] - houses[right] - span",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[--1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "(houses[0] + houses[left - 1]) / 2,",
      "mutated_line": "return (minimal_power, station_locations)",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 2]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "(houses[0] + houses[left - 1]) / 2,",
      "mutated_line": "return (minimal_power, station_locations)",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 0]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "(houses[0] + houses[left - 1]) / 2,",
      "mutated_line": "return (minimal_power, station_locations)",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 0]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "(houses[0] + houses[left - 1]) / 2,",
      "mutated_line": "return (minimal_power, station_locations)",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - -1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "(houses[right + 1] + houses[-1]) / 2",
      "mutated_line": "return (minimal_power, station_locations)",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 2] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "(houses[right + 1] + houses[-1]) / 2",
      "mutated_line": "return (minimal_power, station_locations)",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 0] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "(houses[right + 1] + houses[-1]) / 2",
      "mutated_line": "return (minimal_power, station_locations)",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 0] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "(houses[right + 1] + houses[-1]) / 2",
      "mutated_line": "return (minimal_power, station_locations)",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + -1] + houses[-1]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "(houses[right + 1] + houses[-1]) / 2",
      "mutated_line": "return (minimal_power, station_locations)",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-2]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "(houses[right + 1] + houses[-1]) / 2",
      "mutated_line": "return (minimal_power, station_locations)",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-0]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "(houses[right + 1] + houses[-1]) / 2",
      "mutated_line": "return (minimal_power, station_locations)",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[-0]) / 2)\n    return (minimal_power, station_locations)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "(houses[right + 1] + houses[-1]) / 2",
      "mutated_line": "return (minimal_power, station_locations)",
      "code": "def calculate_minimal_station_power(n, houses):\n    houses = sorted(set(houses))\n    if len(houses) <= 3:\n        minimal_power = 0\n        result = houses[:]\n        while len(result) < 3:\n            result.append(result[-1])\n        station_locations = tuple(result)\n        return (minimal_power, station_locations)\n    span = 0\n    left = 1\n    right = len(houses) - 2\n    while houses[right] - houses[left] > span:\n        left_gap = houses[left] - houses[0] - span\n        right_gap = houses[-1] - houses[right] - span\n        middle = houses[right] - houses[left]\n        if left_gap <= right_gap:\n            if span + left_gap > middle:\n                span = middle\n                break\n            left += 1\n            if left_gap == right_gap:\n                right -= 1\n            span += left_gap\n        else:\n            if span + right_gap > middle:\n                span = middle\n                break\n            right -= 1\n            span += right_gap\n    minimal_power = span / 2\n    station_locations = ((houses[0] + houses[left - 1]) / 2, (houses[left] + houses[right]) / 2, (houses[right + 1] + houses[--1]) / 2)\n    return (minimal_power, station_locations)"
    }
  ]
}