{
  "task_id": "taco_5535",
  "entry_point": "min_flips_to_xorgon",
  "mutant_count": 144,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "l = 0",
      "mutated_line": "l = 1",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 1\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "l = 0",
      "mutated_line": "l = -1",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = -1\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "l = 0",
      "mutated_line": "l = 1",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 1\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "while l != u:",
      "mutated_line": "while l == u:",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l == u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 1\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = -1\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 1\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ctr = 0",
      "mutated_line": "ctr = 1",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 1\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ctr = 0",
      "mutated_line": "ctr = -1",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = -1\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ctr = 0",
      "mutated_line": "ctr = 1",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 1\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if ctr % 2 == 0:",
      "mutated_line": "if ctr % 2 != 0:",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 != 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 37,
      "original_line": "ans += minflip[0]",
      "mutated_line": "ans -= minflip[0]",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans -= minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 38,
      "original_line": "ans -= minflip[1]",
      "mutated_line": "ans += minflip[1]",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans += minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "titi = 0",
      "mutated_line": "titi = 1",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 1\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "titi = 0",
      "mutated_line": "titi = -1",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = -1\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "titi = 0",
      "mutated_line": "titi = 1",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 1\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "gao = 0",
      "mutated_line": "gao = 1",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 1\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "gao = 0",
      "mutated_line": "gao = -1",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = -1\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "gao = 0",
      "mutated_line": "gao = 1",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 1\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 22,
      "original_line": "minflip = (-1, -1)",
      "mutated_line": "minflip = (+1, -1)",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (+1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 22,
      "original_line": "minflip = (-1, -1)",
      "mutated_line": "minflip = (-1, +1)",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, +1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if i[0] < i[1]:",
      "mutated_line": "if i[0] <= i[1]:",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] <= i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if i[0] < i[1]:",
      "mutated_line": "if i[0] >= i[1]:",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] >= i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if i[0] < i[1]:",
      "mutated_line": "if i[0] != i[1]:",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] != i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 27,
      "original_line": "ans += i[0]",
      "mutated_line": "ans -= i[0]",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans -= i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 28,
      "original_line": "ctr += 1",
      "mutated_line": "ctr -= 1",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr -= 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 32,
      "original_line": "ans += i[1]",
      "mutated_line": "ans -= i[1]",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans -= i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "if ctr % 2 == 0:",
      "mutated_line": "if ctr * 2 == 0:",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr * 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "if ctr % 2 == 0:",
      "mutated_line": "if ctr + 2 == 0:",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr + 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if ctr % 2 == 0:",
      "mutated_line": "if ctr % 2 == 1:",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 1:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if ctr % 2 == 0:",
      "mutated_line": "if ctr % 2 == -1:",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == -1:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if ctr % 2 == 0:",
      "mutated_line": "if ctr % 2 == 1:",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 1:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "l = min(l + k, len(arr))",
      "mutated_line": "l = min(l - k, len(arr))",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l - k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "l = min(l + k, len(arr))",
      "mutated_line": "l = min(l * k, len(arr))",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l * k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "u = min(u + k, len(arr))",
      "mutated_line": "u = min(u - k, len(arr))",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u - k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "u = min(u + k, len(arr))",
      "mutated_line": "u = min(u * k, len(arr))",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u * k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if len(sol[j]) > i:",
      "mutated_line": "if len(sol[j]) >= i:",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) >= i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if len(sol[j]) > i:",
      "mutated_line": "if len(sol[j]) <= i:",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) <= i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if len(sol[j]) > i:",
      "mutated_line": "if len(sol[j]) != i:",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) != i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "minflip = (-1, -1)",
      "mutated_line": "minflip = (-2, -1)",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-2, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "minflip = (-1, -1)",
      "mutated_line": "minflip = (-0, -1)",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-0, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "minflip = (-1, -1)",
      "mutated_line": "minflip = (-0, -1)",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-0, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "minflip = (-1, -1)",
      "mutated_line": "minflip = (--1, -1)",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (--1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "minflip = (-1, -1)",
      "mutated_line": "minflip = (-1, -2)",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -2)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "minflip = (-1, -1)",
      "mutated_line": "minflip = (-1, -0)",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -0)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "minflip = (-1, -1)",
      "mutated_line": "minflip = (-1, -0)",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -0)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "minflip = (-1, -1)",
      "mutated_line": "minflip = (-1, --1)",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, --1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ctr += 1",
      "mutated_line": "ctr += 2",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 2\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ctr += 1",
      "mutated_line": "ctr += 0",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 0\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ctr += 1",
      "mutated_line": "ctr += 0",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 0\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ctr += 1",
      "mutated_line": "ctr += -1",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += -1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 29,
      "original_line": "if i[1] < minflip[0] or minflip[0] == -1:",
      "mutated_line": "if i[1] < minflip[0] and minflip[0] == -1:",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] and minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 33,
      "original_line": "if i[0] < minflip[0] or minflip[0] == -1:",
      "mutated_line": "if i[0] < minflip[0] and minflip[0] == -1:",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] and minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if ctr % 2 == 0:",
      "mutated_line": "if ctr % 3 == 0:",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 3 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if ctr % 2 == 0:",
      "mutated_line": "if ctr % 1 == 0:",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 1 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if ctr % 2 == 0:",
      "mutated_line": "if ctr % 0 == 0:",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 0 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if ctr % 2 == 0:",
      "mutated_line": "if ctr % 1 == 0:",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 1 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if ctr % 2 == 0:",
      "mutated_line": "if ctr % -2 == 0:",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % -2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ans += minflip[0]",
      "mutated_line": "ans += minflip[1]",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[1]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ans += minflip[0]",
      "mutated_line": "ans += minflip[-1]",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[-1]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ans += minflip[0]",
      "mutated_line": "ans += minflip[1]",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[1]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "ans -= minflip[1]",
      "mutated_line": "ans -= minflip[2]",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[2]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "ans -= minflip[1]",
      "mutated_line": "ans -= minflip[0]",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[0]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "ans -= minflip[1]",
      "mutated_line": "ans -= minflip[0]",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[0]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "ans -= minflip[1]",
      "mutated_line": "ans -= minflip[-1]",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[-1]\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if sol[j][i] == 0:",
      "mutated_line": "if sol[j][i] != 0:",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] != 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 17,
      "original_line": "titi += 1",
      "mutated_line": "titi -= 1",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi -= 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 19,
      "original_line": "gao += 1",
      "mutated_line": "gao -= 1",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao -= 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if i[0] < i[1]:",
      "mutated_line": "if i[1] < i[1]:",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[1] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if i[0] < i[1]:",
      "mutated_line": "if i[-1] < i[1]:",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[-1] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if i[0] < i[1]:",
      "mutated_line": "if i[1] < i[1]:",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[1] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if i[0] < i[1]:",
      "mutated_line": "if i[0] < i[2]:",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[2]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if i[0] < i[1]:",
      "mutated_line": "if i[0] < i[0]:",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[0]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if i[0] < i[1]:",
      "mutated_line": "if i[0] < i[0]:",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[0]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if i[0] < i[1]:",
      "mutated_line": "if i[0] < i[-1]:",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[-1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "ans += i[0]",
      "mutated_line": "ans += i[1]",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[1]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "ans += i[0]",
      "mutated_line": "ans += i[-1]",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[-1]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "ans += i[0]",
      "mutated_line": "ans += i[1]",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[1]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if i[1] < minflip[0] or minflip[0] == -1:",
      "mutated_line": "if i[1] <= minflip[0] or minflip[0] == -1:",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] <= minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if i[1] < minflip[0] or minflip[0] == -1:",
      "mutated_line": "if i[1] >= minflip[0] or minflip[0] == -1:",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] >= minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if i[1] < minflip[0] or minflip[0] == -1:",
      "mutated_line": "if i[1] != minflip[0] or minflip[0] == -1:",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] != minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if i[1] < minflip[0] or minflip[0] == -1:",
      "mutated_line": "if i[1] < minflip[0] or minflip[0] != -1:",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] != -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "ans += i[1]",
      "mutated_line": "ans += i[2]",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[2]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "ans += i[1]",
      "mutated_line": "ans += i[0]",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[0]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "ans += i[1]",
      "mutated_line": "ans += i[0]",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[0]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "ans += i[1]",
      "mutated_line": "ans += i[-1]",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[-1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if i[0] < minflip[0] or minflip[0] == -1:",
      "mutated_line": "if i[0] <= minflip[0] or minflip[0] == -1:",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] <= minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if i[0] < minflip[0] or minflip[0] == -1:",
      "mutated_line": "if i[0] >= minflip[0] or minflip[0] == -1:",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] >= minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if i[0] < minflip[0] or minflip[0] == -1:",
      "mutated_line": "if i[0] != minflip[0] or minflip[0] == -1:",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] != minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if i[0] < minflip[0] or minflip[0] == -1:",
      "mutated_line": "if i[0] < minflip[0] or minflip[0] != -1:",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] != -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if sol[j][i] == 0:",
      "mutated_line": "if sol[j][i] == 1:",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 1:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if sol[j][i] == 0:",
      "mutated_line": "if sol[j][i] == -1:",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == -1:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if sol[j][i] == 0:",
      "mutated_line": "if sol[j][i] == 1:",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 1:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "titi += 1",
      "mutated_line": "titi += 2",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 2\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "titi += 1",
      "mutated_line": "titi += 0",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 0\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "titi += 1",
      "mutated_line": "titi += 0",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 0\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "titi += 1",
      "mutated_line": "titi += -1",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += -1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "gao += 1",
      "mutated_line": "gao += 2",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 2\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "gao += 1",
      "mutated_line": "gao += 0",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 0\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "gao += 1",
      "mutated_line": "gao += 0",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 0\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "gao += 1",
      "mutated_line": "gao += -1",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += -1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 29,
      "original_line": "if i[1] < minflip[0] or minflip[0] == -1:",
      "mutated_line": "if i[1] < minflip[0] or minflip[0] == +1:",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == +1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 33,
      "original_line": "if i[0] < minflip[0] or minflip[0] == -1:",
      "mutated_line": "if i[0] < minflip[0] or minflip[0] == +1:",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == +1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if i[1] < minflip[0] or minflip[0] == -1:",
      "mutated_line": "if i[2] < minflip[0] or minflip[0] == -1:",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[2] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if i[1] < minflip[0] or minflip[0] == -1:",
      "mutated_line": "if i[0] < minflip[0] or minflip[0] == -1:",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if i[1] < minflip[0] or minflip[0] == -1:",
      "mutated_line": "if i[0] < minflip[0] or minflip[0] == -1:",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if i[1] < minflip[0] or minflip[0] == -1:",
      "mutated_line": "if i[-1] < minflip[0] or minflip[0] == -1:",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[-1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if i[1] < minflip[0] or minflip[0] == -1:",
      "mutated_line": "if i[1] < minflip[1] or minflip[0] == -1:",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[1] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if i[1] < minflip[0] or minflip[0] == -1:",
      "mutated_line": "if i[1] < minflip[-1] or minflip[0] == -1:",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[-1] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if i[1] < minflip[0] or minflip[0] == -1:",
      "mutated_line": "if i[1] < minflip[1] or minflip[0] == -1:",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[1] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if i[1] < minflip[0] or minflip[0] == -1:",
      "mutated_line": "if i[1] < minflip[0] or minflip[1] == -1:",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[1] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if i[1] < minflip[0] or minflip[0] == -1:",
      "mutated_line": "if i[1] < minflip[0] or minflip[-1] == -1:",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[-1] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if i[1] < minflip[0] or minflip[0] == -1:",
      "mutated_line": "if i[1] < minflip[0] or minflip[1] == -1:",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[1] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if i[1] < minflip[0] or minflip[0] == -1:",
      "mutated_line": "if i[1] < minflip[0] or minflip[0] == -2:",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -2:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if i[1] < minflip[0] or minflip[0] == -1:",
      "mutated_line": "if i[1] < minflip[0] or minflip[0] == -0:",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -0:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if i[1] < minflip[0] or minflip[0] == -1:",
      "mutated_line": "if i[1] < minflip[0] or minflip[0] == -0:",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -0:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if i[1] < minflip[0] or minflip[0] == -1:",
      "mutated_line": "if i[1] < minflip[0] or minflip[0] == --1:",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == --1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "minflip = (i[1], i[0])",
      "mutated_line": "minflip = (i[2], i[0])",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[2], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "minflip = (i[1], i[0])",
      "mutated_line": "minflip = (i[0], i[0])",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "minflip = (i[1], i[0])",
      "mutated_line": "minflip = (i[0], i[0])",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "minflip = (i[1], i[0])",
      "mutated_line": "minflip = (i[-1], i[0])",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[-1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "minflip = (i[1], i[0])",
      "mutated_line": "minflip = (i[1], i[1])",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[1])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "minflip = (i[1], i[0])",
      "mutated_line": "minflip = (i[1], i[-1])",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[-1])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "minflip = (i[1], i[0])",
      "mutated_line": "minflip = (i[1], i[1])",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[1])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if i[0] < minflip[0] or minflip[0] == -1:",
      "mutated_line": "if i[1] < minflip[0] or minflip[0] == -1:",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if i[0] < minflip[0] or minflip[0] == -1:",
      "mutated_line": "if i[-1] < minflip[0] or minflip[0] == -1:",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[-1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if i[0] < minflip[0] or minflip[0] == -1:",
      "mutated_line": "if i[1] < minflip[0] or minflip[0] == -1:",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if i[0] < minflip[0] or minflip[0] == -1:",
      "mutated_line": "if i[0] < minflip[1] or minflip[0] == -1:",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[1] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if i[0] < minflip[0] or minflip[0] == -1:",
      "mutated_line": "if i[0] < minflip[-1] or minflip[0] == -1:",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[-1] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if i[0] < minflip[0] or minflip[0] == -1:",
      "mutated_line": "if i[0] < minflip[1] or minflip[0] == -1:",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[1] or minflip[0] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if i[0] < minflip[0] or minflip[0] == -1:",
      "mutated_line": "if i[0] < minflip[0] or minflip[1] == -1:",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[1] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if i[0] < minflip[0] or minflip[0] == -1:",
      "mutated_line": "if i[0] < minflip[0] or minflip[-1] == -1:",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[-1] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if i[0] < minflip[0] or minflip[0] == -1:",
      "mutated_line": "if i[0] < minflip[0] or minflip[1] == -1:",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[1] == -1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if i[0] < minflip[0] or minflip[0] == -1:",
      "mutated_line": "if i[0] < minflip[0] or minflip[0] == -2:",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -2:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if i[0] < minflip[0] or minflip[0] == -1:",
      "mutated_line": "if i[0] < minflip[0] or minflip[0] == -0:",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -0:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if i[0] < minflip[0] or minflip[0] == -1:",
      "mutated_line": "if i[0] < minflip[0] or minflip[0] == -0:",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -0:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if i[0] < minflip[0] or minflip[0] == -1:",
      "mutated_line": "if i[0] < minflip[0] or minflip[0] == --1:",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == --1:\n                minflip = (i[0], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "minflip = (i[0], i[1])",
      "mutated_line": "minflip = (i[1], i[1])",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "minflip = (i[0], i[1])",
      "mutated_line": "minflip = (i[-1], i[1])",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[-1], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "minflip = (i[0], i[1])",
      "mutated_line": "minflip = (i[1], i[1])",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "minflip = (i[0], i[1])",
      "mutated_line": "minflip = (i[0], i[2])",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[2])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "minflip = (i[0], i[1])",
      "mutated_line": "minflip = (i[0], i[0])",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[0])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "minflip = (i[0], i[1])",
      "mutated_line": "minflip = (i[0], i[0])",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[0])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "minflip = (i[0], i[1])",
      "mutated_line": "minflip = (i[0], i[-1])",
      "code": "def min_flips_to_xorgon(n, k, arr):\n    sol = []\n    l = 0\n    u = k\n    while l != u:\n        sol.append(arr[l:min(len(arr), u)])\n        l = min(l + k, len(arr))\n        u = min(u + k, len(arr))\n    tiwari = []\n    for i in range(k):\n        titi = 0\n        gao = 0\n        for j in range(len(sol)):\n            if len(sol[j]) > i:\n                if sol[j][i] == 0:\n                    titi += 1\n                else:\n                    gao += 1\n        tiwari.append((titi, gao))\n    minflip = (-1, -1)\n    ans = 0\n    ctr = 0\n    for i in tiwari:\n        if i[0] < i[1]:\n            ans += i[0]\n            ctr += 1\n            if i[1] < minflip[0] or minflip[0] == -1:\n                minflip = (i[1], i[0])\n        else:\n            ans += i[1]\n            if i[0] < minflip[0] or minflip[0] == -1:\n                minflip = (i[0], i[-1])\n    if ctr % 2 == 0:\n        ans += minflip[0]\n        ans -= minflip[1]\n    return ans"
    }
  ]
}